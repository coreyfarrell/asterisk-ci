<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Asterisk GIT-16-d8ac5bf1a5 - channels/sip/include/sip.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">channels/sip/include</a> - sip.h<span style="font-size: 80%;"> (source / <a href="sip.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Asterisk GIT-16-d8ac5bf1a5</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-07-23 21:48:22</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Asterisk -- An open source telephony toolkit.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (C) 2010, Digium, Inc.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * See http://www.asterisk.org for more information about
<span class="lineNum">       7 </span>            :  * the Asterisk project. Please do not directly contact
<span class="lineNum">       8 </span>            :  * any of the maintainers of this project for assistance;
<span class="lineNum">       9 </span>            :  * the project provides a web site, mailing lists and IRC
<span class="lineNum">      10 </span>            :  * channels for your use.
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  * This program is free software, distributed under the terms of
<span class="lineNum">      13 </span>            :  * the GNU General Public License Version 2. See the LICENSE file
<span class="lineNum">      14 </span>            :  * at the top of the source tree.
<span class="lineNum">      15 </span>            :  */
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : /*!
<span class="lineNum">      18 </span>            :  * \file
<span class="lineNum">      19 </span>            :  * \brief chan_sip header file
<span class="lineNum">      20 </span>            :  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #ifndef _SIP_H
<span class="lineNum">      23 </span>            : #define _SIP_H
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : #include &quot;asterisk.h&quot;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #include &quot;asterisk/stringfields.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;asterisk/linkedlists.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;asterisk/strings.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;asterisk/tcptls.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;asterisk/test.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;asterisk/channel.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;asterisk/app.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;asterisk/indications.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;asterisk/security_events.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;asterisk/features.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;asterisk/rtp_engine.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;asterisk/netsock2.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;asterisk/features_config.h&quot;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : #include &quot;route.h&quot;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : #ifndef FALSE
<span class="lineNum">      44 </span>            : #define FALSE    0
<span class="lineNum">      45 </span>            : #endif
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #ifndef TRUE
<span class="lineNum">      48 </span>            : #define TRUE     1
<span class="lineNum">      49 </span>            : #endif
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : /* Arguments for sip_find_peer */
<span class="lineNum">      52 </span>            : #define FINDUSERS (1 &lt;&lt; 0)
<span class="lineNum">      53 </span>            : #define FINDPEERS (1 &lt;&lt; 1)
<span class="lineNum">      54 </span>            : #define FINDALLDEVICES (FINDUSERS | FINDPEERS)
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : #define SIPBUFSIZE      512             /*!&lt; Buffer size for many operations */
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : #define XMIT_ERROR      -2
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : #define SIP_RESERVED    &quot;;/?:@&amp;=+$,# &quot;  /*!&lt; Reserved characters in the username part of the URI */
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : #define DEFAULT_DEFAULT_EXPIRY       120
<span class="lineNum">      63 </span>            : #define DEFAULT_MIN_EXPIRY           60
<span class="lineNum">      64 </span>            : #define DEFAULT_MAX_EXPIRY           3600
<span class="lineNum">      65 </span>            : #define DEFAULT_MWI_EXPIRY           3600
<span class="lineNum">      66 </span>            : #define DEFAULT_REGISTRATION_TIMEOUT 20
<span class="lineNum">      67 </span>            : #define DEFAULT_MAX_FORWARDS         70
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : #define DEFAULT_AUTHLIMIT            100
<span class="lineNum">      70 </span>            : #define DEFAULT_AUTHTIMEOUT          30
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : /* guard limit must be larger than guard secs */
<span class="lineNum">      73 </span>            : /* guard min must be &lt; 1000, and should be &gt;= 250 */
<span class="lineNum">      74 </span>            : #define EXPIRY_GUARD_SECS    15   /*!&lt; How long before expiry do we reregister */
<span class="lineNum">      75 </span>            : #define EXPIRY_GUARD_LIMIT   30   /*!&lt; Below here, we use EXPIRY_GUARD_PCT instead of EXPIRY_GUARD_SECS */
<span class="lineNum">      76 </span>            : #define EXPIRY_GUARD_MIN     500  /*!&lt; This is the minimum guard time applied. If
<span class="lineNum">      77 </span>            :                                    *   GUARD_PCT turns out to be lower than this, it
<span class="lineNum">      78 </span>            :                                    *   will use this time instead.
<span class="lineNum">      79 </span>            :                                    *   This is in milliseconds.
<span class="lineNum">      80 </span>            :                                                                    */
<span class="lineNum">      81 </span>            : #define EXPIRY_GUARD_PCT     0.20 /*!&lt; Percentage of expires timeout to use when
<span class="lineNum">      82 </span>            :                                    *   below EXPIRY_GUARD_LIMIT */
<span class="lineNum">      83 </span>            : #define DEFAULT_EXPIRY       900  /*!&lt; Expire slowly */
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : #define DEFAULT_QUALIFY_GAP   100
<span class="lineNum">      86 </span>            : #define DEFAULT_QUALIFY_PEERS 1
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : #define CALLERID_UNKNOWN          &quot;Anonymous&quot;
<span class="lineNum">      89 </span>            : #define FROMDOMAIN_INVALID        &quot;anonymous.invalid&quot;
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : #define DEFAULT_MAXMS             2000        /*!&lt; Qualification: Must be faster than 2 seconds by default */
<span class="lineNum">      92 </span>            : #define DEFAULT_QUALIFYFREQ       60 * 1000   /*!&lt; Qualification: How often to check for the host to be up */
<span class="lineNum">      93 </span>            : #define DEFAULT_FREQ_NOTOK        10 * 1000   /*!&lt; Qualification: How often to check, if the host is down... */
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : #define DEFAULT_RETRANS           1000        /*!&lt; How frequently to retransmit Default: 2 * 500 ms in RFC 3261 */
<span class="lineNum">      96 </span>            : #define DEFAULT_TIMER_T1          500         /*!&lt; SIP timer T1 (according to RFC 3261) */
<span class="lineNum">      97 </span>            : #define SIP_TRANS_TIMEOUT         64 * DEFAULT_TIMER_T1 /*!&lt; SIP request timeout (rfc 3261) 64*T1
<span class="lineNum">      98 </span>            :                                                          *  \todo Use known T1 for timeout (peerpoke)
<span class="lineNum">      99 </span>            :                                                          */
<span class="lineNum">     100 </span>            : #define DEFAULT_TRANS_TIMEOUT     -1     /*!&lt; Use default SIP transaction timeout */
<span class="lineNum">     101 </span>            : #define PROVIS_KEEPALIVE_TIMEOUT  60000  /*!&lt; How long to wait before retransmitting a provisional response (rfc 3261 13.3.1.1) */
<span class="lineNum">     102 </span>            : #define MAX_AUTHTRIES             3      /*!&lt; Try authentication three times, then fail */
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : #define SIP_MAX_HEADERS           64     /*!&lt; Max amount of SIP headers to read */
<span class="lineNum">     105 </span>            : #define SIP_MAX_LINES             256    /*!&lt; Max amount of lines in SIP attachment (like SDP) */
<span class="lineNum">     106 </span>            : #define SIP_MAX_PACKET_SIZE       20480  /*!&lt; Max SIP packet size */
<span class="lineNum">     107 </span>            : #define SIP_MIN_PACKET            4096   /*!&lt; Initialize size of memory to allocate for packets */
<span class="lineNum">     108 </span>            : #define MAX_HISTORY_ENTRIES               50     /*!&lt; Max entires in the history list for a sip_pvt */
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : #define INITIAL_CSEQ              101    /*!&lt; Our initial sip sequence number */
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : #define DEFAULT_MAX_SE            1800   /*!&lt; Session-Timer Default Session-Expires period (RFC 4028) */
<span class="lineNum">     113 </span>            : #define DEFAULT_MIN_SE            90     /*!&lt; Session-Timer Default Min-SE period (RFC 4028) */
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : #define SDP_MAX_RTPMAP_CODECS     32     /*!&lt; Maximum number of codecs allowed in received SDP */
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : #define RTP     1
<span class="lineNum">     118 </span>            : #define NO_RTP  0
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : #define DEC_CALL_LIMIT   0
<span class="lineNum">     121 </span>            : #define INC_CALL_LIMIT   1
<span class="lineNum">     122 </span>            : #define DEC_CALL_RINGING 2
<span class="lineNum">     123 </span>            : #define INC_CALL_RINGING 3
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : /*! Define SIP option tags, used in Require: and Supported: headers
<span class="lineNum">     126 </span>            :  *  We need to be aware of these properties in the phones to use
<span class="lineNum">     127 </span>            :  *  the replace: header. We should not do that without knowing
<span class="lineNum">     128 </span>            :  *  that the other end supports it...
<span class="lineNum">     129 </span>            :  *  This is nothing we can configure, we learn by the dialog
<span class="lineNum">     130 </span>            :  *  Supported: header on the REGISTER (peer) or the INVITE
<span class="lineNum">     131 </span>            :  *  (other devices)
<span class="lineNum">     132 </span>            :  *  We are not using many of these today, but will in the future.
<span class="lineNum">     133 </span>            :  *  This is documented in RFC 3261
<span class="lineNum">     134 </span>            :  */
<span class="lineNum">     135 </span>            : #define SUPPORTED       1
<span class="lineNum">     136 </span>            : #define NOT_SUPPORTED   0
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : /* SIP options */
<span class="lineNum">     139 </span>            : #define SIP_OPT_REPLACES      (1 &lt;&lt; 0)
<span class="lineNum">     140 </span>            : #define SIP_OPT_100REL        (1 &lt;&lt; 1)
<span class="lineNum">     141 </span>            : #define SIP_OPT_TIMER         (1 &lt;&lt; 2)
<span class="lineNum">     142 </span>            : #define SIP_OPT_EARLY_SESSION (1 &lt;&lt; 3)
<span class="lineNum">     143 </span>            : #define SIP_OPT_JOIN          (1 &lt;&lt; 4)
<span class="lineNum">     144 </span>            : #define SIP_OPT_PATH          (1 &lt;&lt; 5)
<span class="lineNum">     145 </span>            : #define SIP_OPT_PREF          (1 &lt;&lt; 6)
<span class="lineNum">     146 </span>            : #define SIP_OPT_PRECONDITION  (1 &lt;&lt; 7)
<span class="lineNum">     147 </span>            : #define SIP_OPT_PRIVACY       (1 &lt;&lt; 8)
<span class="lineNum">     148 </span>            : #define SIP_OPT_SDP_ANAT      (1 &lt;&lt; 9)
<span class="lineNum">     149 </span>            : #define SIP_OPT_SEC_AGREE     (1 &lt;&lt; 10)
<span class="lineNum">     150 </span>            : #define SIP_OPT_EVENTLIST     (1 &lt;&lt; 11)
<span class="lineNum">     151 </span>            : #define SIP_OPT_GRUU          (1 &lt;&lt; 12)
<span class="lineNum">     152 </span>            : #define SIP_OPT_TARGET_DIALOG (1 &lt;&lt; 13)
<span class="lineNum">     153 </span>            : #define SIP_OPT_NOREFERSUB    (1 &lt;&lt; 14)
<span class="lineNum">     154 </span>            : #define SIP_OPT_HISTINFO      (1 &lt;&lt; 15)
<span class="lineNum">     155 </span>            : #define SIP_OPT_RESPRIORITY   (1 &lt;&lt; 16)
<span class="lineNum">     156 </span>            : #define SIP_OPT_FROMCHANGE    (1 &lt;&lt; 17)
<span class="lineNum">     157 </span>            : #define SIP_OPT_RECLISTINV    (1 &lt;&lt; 18)
<span class="lineNum">     158 </span>            : #define SIP_OPT_RECLISTSUB    (1 &lt;&lt; 19)
<span class="lineNum">     159 </span>            : #define SIP_OPT_OUTBOUND      (1 &lt;&lt; 20)
<span class="lineNum">     160 </span>            : #define SIP_OPT_UNKNOWN       (1 &lt;&lt; 21)
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            : /*! \brief SIP Methods we support
<span class="lineNum">     163 </span>            :  *  \todo This string should be set dynamically. We only support REFER and SUBSCRIBE if we have
<span class="lineNum">     164 </span>            :  *  allowsubscribe and allowrefer on in sip.conf.
<span class="lineNum">     165 </span>            :  */
<span class="lineNum">     166 </span>            : #define ALLOWED_METHODS &quot;INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, SUBSCRIBE, NOTIFY, INFO, PUBLISH, MESSAGE&quot;
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : /*! \brief Standard SIP unsecure port for UDP and TCP from RFC 3261. DO NOT CHANGE THIS */
<span class="lineNum">     169 </span>            : #define STANDARD_SIP_PORT       5060
<span class="lineNum">     170 </span>            : /*! \brief Standard SIP TLS port from RFC 3261. DO NOT CHANGE THIS */
<span class="lineNum">     171 </span>            : #define STANDARD_TLS_PORT       5061
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            : /*! \note in many SIP headers, absence of a port number implies port 5060,
<span class="lineNum">     174 </span>            :  * and this is why we cannot change the above constant.
<span class="lineNum">     175 </span>            :  * There is a limited number of places in asterisk where we could,
<span class="lineNum">     176 </span>            :  * in principle, use a different &quot;default&quot; port number, but
<span class="lineNum">     177 </span>            :  * we do not support this feature at the moment.
<span class="lineNum">     178 </span>            :  * You can run Asterisk with SIP on a different port with a configuration
<span class="lineNum">     179 </span>            :  * option. If you change this value in the source code, the signalling will be incorrect.
<span class="lineNum">     180 </span>            :  *
<span class="lineNum">     181 </span>            :  */
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : /*! \name DefaultValues Default values, set and reset in reload_config before reading configuration
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :    These are default values in the source. There are other recommended values in the
<span class="lineNum">     186 </span>            :    sip.conf.sample for new installations. These may differ to keep backwards compatibility,
<span class="lineNum">     187 </span>            :    yet encouraging new behaviour on new installations
<span class="lineNum">     188 </span>            :  */
<span class="lineNum">     189 </span>            : /*@{*/
<span class="lineNum">     190 </span>            : #define DEFAULT_CONTEXT        &quot;default&quot;  /*!&lt; The default context for [general] section as well as devices */
<span class="lineNum">     191 </span>            : #define DEFAULT_RECORD_FEATURE   &quot;automon&quot;  /*!&lt; The default feature specified for use with INFO */
<span class="lineNum">     192 </span>            : #define DEFAULT_MOHINTERPRET   &quot;default&quot;  /*!&lt; The default music class */
<span class="lineNum">     193 </span>            : #define DEFAULT_MOHSUGGEST     &quot;&quot;
<span class="lineNum">     194 </span>            : #define DEFAULT_VMEXTEN        &quot;asterisk&quot; /*!&lt; Default voicemail extension */
<span class="lineNum">     195 </span>            : #define DEFAULT_CALLERID       &quot;asterisk&quot; /*!&lt; Default caller ID */
<span class="lineNum">     196 </span>            : #define DEFAULT_MWI_FROM       &quot;&quot;
<span class="lineNum">     197 </span>            : #define DEFAULT_NOTIFYMIME     &quot;application/simple-message-summary&quot;
<span class="lineNum">     198 </span>            : #define DEFAULT_ALLOWGUEST     TRUE
<span class="lineNum">     199 </span>            : #define DEFAULT_RTPKEEPALIVE   0      /*!&lt; Default RTPkeepalive setting */
<span class="lineNum">     200 </span>            : #define DEFAULT_CALLCOUNTER    FALSE   /*!&lt; Do not enable call counters by default */
<span class="lineNum">     201 </span>            : #define DEFAULT_SRVLOOKUP      TRUE    /*!&lt; Recommended setting is ON */
<span class="lineNum">     202 </span>            : #define DEFAULT_COMPACTHEADERS FALSE  /*!&lt; Send compact (one-character) SIP headers. Default off */
<span class="lineNum">     203 </span>            : #define DEFAULT_TOS_SIP        0      /*!&lt; Call signalling packets should be marked as DSCP CS3, but the default is 0 to be compatible with previous versions. */
<span class="lineNum">     204 </span>            : #define DEFAULT_TOS_AUDIO      0      /*!&lt; Audio packets should be marked as DSCP EF (Expedited Forwarding), but the default is 0 to be compatible with previous versions. */
<span class="lineNum">     205 </span>            : #define DEFAULT_TOS_VIDEO      0      /*!&lt; Video packets should be marked as DSCP AF41, but the default is 0 to be compatible with previous versions. */
<span class="lineNum">     206 </span>            : #define DEFAULT_TOS_TEXT       0      /*!&lt; Text packets should be marked as XXXX XXXX, but the default is 0 to be compatible with previous versions. */
<span class="lineNum">     207 </span>            : #define DEFAULT_COS_SIP        4      /*!&lt; Level 2 class of service for SIP signalling */
<span class="lineNum">     208 </span>            : #define DEFAULT_COS_AUDIO      5      /*!&lt; Level 2 class of service for audio media  */
<span class="lineNum">     209 </span>            : #define DEFAULT_COS_VIDEO      6      /*!&lt; Level 2 class of service for video media */
<span class="lineNum">     210 </span>            : #define DEFAULT_COS_TEXT       5      /*!&lt; Level 2 class of service for text media (T.140) */
<span class="lineNum">     211 </span>            : #define DEFAULT_ALLOW_EXT_DOM  TRUE    /*!&lt; Allow external domains */
<span class="lineNum">     212 </span>            : #define DEFAULT_REALM          &quot;asterisk&quot; /*!&lt; Realm for HTTP digest authentication */
<span class="lineNum">     213 </span>            : #define DEFAULT_DOMAINSASREALM FALSE    /*!&lt; Use the domain option to guess the realm for registration and invite requests */
<span class="lineNum">     214 </span>            : #define DEFAULT_NOTIFYRINGING  NOTIFYRINGING_ENABLED /*!&lt; Notify devicestate system on ringing state */
<span class="lineNum">     215 </span>            : #define DEFAULT_NOTIFYCID      DISABLED /*!&lt; Include CID with ringing notifications */
<span class="lineNum">     216 </span>            : #define DEFAULT_PEDANTIC       TRUE     /*!&lt; Follow SIP standards for dialog matching */
<span class="lineNum">     217 </span>            : #define DEFAULT_AUTOCREATEPEER AUTOPEERS_DISABLED    /*!&lt; Don't create peers automagically */
<span class="lineNum">     218 </span>            : #define DEFAULT_MATCHEXTERNADDRLOCALLY FALSE /*!&lt; Match extern IP locally default setting */
<span class="lineNum">     219 </span>            : #define DEFAULT_QUALIFY        FALSE    /*!&lt; Don't monitor devices */
<span class="lineNum">     220 </span>            : #define DEFAULT_KEEPALIVE      0        /*!&lt; Don't send keep alive packets */
<span class="lineNum">     221 </span>            : #define DEFAULT_KEEPALIVE_INTERVAL 60   /*!&lt; Send keep alive packets at 60 second intervals */
<span class="lineNum">     222 </span>            : #define DEFAULT_ALWAYSAUTHREJECT  TRUE  /*!&lt; Don't reject authentication requests always */
<span class="lineNum">     223 </span>            : #define DEFAULT_AUTH_OPTIONS  FALSE
<span class="lineNum">     224 </span>            : #define DEFAULT_AUTH_MESSAGE  TRUE
<span class="lineNum">     225 </span>            : #define DEFAULT_ACCEPT_OUTOFCALL_MESSAGE TRUE
<span class="lineNum">     226 </span>            : #define DEFAULT_REGEXTENONQUALIFY FALSE
<span class="lineNum">     227 </span>            : #define DEFAULT_LEGACY_USEROPTION_PARSING FALSE
<span class="lineNum">     228 </span>            : #define DEFAULT_SEND_DIVERSION TRUE
<span class="lineNum">     229 </span>            : #define DEFAULT_T1MIN             100   /*!&lt; 100 MS for minimal roundtrip time */
<span class="lineNum">     230 </span>            : #define DEFAULT_MAX_CALL_BITRATE (384)  /*!&lt; Max bitrate for video */
<span class="lineNum">     231 </span>            : #ifndef DEFAULT_USERAGENT
<span class="lineNum">     232 </span>            : #define DEFAULT_USERAGENT  &quot;Asterisk PBX&quot;  /*!&lt; Default Useragent: header unless re-defined in sip.conf */
<span class="lineNum">     233 </span>            : #define DEFAULT_SDPSESSION &quot;Asterisk PBX&quot;  /*!&lt; Default SDP session name, (s=) header unless re-defined in sip.conf */
<span class="lineNum">     234 </span>            : #define DEFAULT_SDPOWNER   &quot;root&quot;          /*!&lt; Default SDP username field in (o=) header unless re-defined in sip.conf */
<span class="lineNum">     235 </span>            : #define DEFAULT_ENGINE     &quot;asterisk&quot;      /*!&lt; Default RTP engine to use for sessions */
<span class="lineNum">     236 </span>            : #define DEFAULT_STORE_SIP_CAUSE FALSE      /*!&lt; Don't store HASH(SIP_CAUSE,&lt;channel name&gt;) for channels by default */
<span class="lineNum">     237 </span>            : #endif
<span class="lineNum">     238 </span>            : /*@}*/
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : /*! \name SIPflags
<span class="lineNum">     241 </span>            :         Various flags for the flags field in the pvt structure
<span class="lineNum">     242 </span>            :         Trying to sort these up (one or more of the following):
<span class="lineNum">     243 </span>            :         D: Dialog
<span class="lineNum">     244 </span>            :         P: Peer/user
<span class="lineNum">     245 </span>            :         G: Global flag
<span class="lineNum">     246 </span>            :         When flags are used by multiple structures, it is important that
<span class="lineNum">     247 </span>            :         they have a common layout so it is easy to copy them.
<span class="lineNum">     248 </span>            : */
<span class="lineNum">     249 </span>            : /*@{*/
<span class="lineNum">     250 </span>            : #define SIP_OUTGOING        (1 &lt;&lt; 0) /*!&lt; D: Direction of the last transaction in this dialog */
<span class="lineNum">     251 </span>            : #define SIP_OFFER_CC        (1 &lt;&lt; 1) /*!&lt; D: Offer CC on subsequent responses */
<span class="lineNum">     252 </span>            : #define SIP_RINGING         (1 &lt;&lt; 2) /*!&lt; D: Have sent 180 ringing */
<span class="lineNum">     253 </span>            : #define SIP_PROGRESS_SENT   (1 &lt;&lt; 3) /*!&lt; D: Have sent 183 message progress */
<span class="lineNum">     254 </span>            : #define SIP_NEEDREINVITE    (1 &lt;&lt; 4) /*!&lt; D: Do we need to send another reinvite? */
<span class="lineNum">     255 </span>            : #define SIP_PENDINGBYE      (1 &lt;&lt; 5) /*!&lt; D: Need to send bye after we ack? */
<span class="lineNum">     256 </span>            : #define SIP_GOTREFER        (1 &lt;&lt; 6) /*!&lt; D: Got a refer? */
<span class="lineNum">     257 </span>            : #define SIP_CALL_LIMIT      (1 &lt;&lt; 7) /*!&lt; D: Call limit enforced for this call */
<span class="lineNum">     258 </span>            : #define SIP_INC_COUNT       (1 &lt;&lt; 8) /*!&lt; D: Did this dialog increment the counter of in-use calls? */
<span class="lineNum">     259 </span>            : #define SIP_INC_RINGING     (1 &lt;&lt; 9) /*!&lt; D: Did this connection increment the counter of in-use calls? */
<span class="lineNum">     260 </span>            : #define SIP_DEFER_BYE_ON_TRANSFER       (1 &lt;&lt; 10) /*!&lt; D: Do not hangup at first ast_hangup */
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : #define SIP_PROMISCREDIR    (1 &lt;&lt; 11) /*!&lt; DP: Promiscuous redirection */
<span class="lineNum">     263 </span>            : #define SIP_TRUSTRPID       (1 &lt;&lt; 12) /*!&lt; DP: Trust RPID headers? */
<span class="lineNum">     264 </span>            : #define SIP_USEREQPHONE     (1 &lt;&lt; 13) /*!&lt; DP: Add user=phone to numeric URI. Default off */
<span class="lineNum">     265 </span>            : #define SIP_USECLIENTCODE   (1 &lt;&lt; 14) /*!&lt; DP: Trust X-ClientCode info message */
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            : /* DTMF flags - see str2dtmfmode() and dtmfmode2str() */
<span class="lineNum">     268 </span>            : #define SIP_DTMF            (7 &lt;&lt; 15) /*!&lt; DP: DTMF Support: five settings, uses three bits */
<span class="lineNum">     269 </span>            : #define SIP_DTMF_RFC2833    (0 &lt;&lt; 15) /*!&lt; DP: DTMF Support: RTP DTMF - &quot;rfc2833&quot; */
<span class="lineNum">     270 </span>            : #define SIP_DTMF_INBAND     (1 &lt;&lt; 15) /*!&lt; DP: DTMF Support: Inband audio, only for ULAW/ALAW - &quot;inband&quot; */
<span class="lineNum">     271 </span>            : #define SIP_DTMF_INFO       (2 &lt;&lt; 15) /*!&lt; DP: DTMF Support: SIP Info messages - &quot;info&quot; */
<span class="lineNum">     272 </span>            : #define SIP_DTMF_AUTO       (3 &lt;&lt; 15) /*!&lt; DP: DTMF Support: AUTO switch between rfc2833 and in-band DTMF */
<span class="lineNum">     273 </span>            : #define SIP_DTMF_SHORTINFO  (4 &lt;&lt; 15) /*!&lt; DP: DTMF Support: SIP Info messages - &quot;info&quot; - short variant */
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : /* NAT settings */
<span class="lineNum">     276 </span>            : #define SIP_NAT_FORCE_RPORT     (1 &lt;&lt; 18) /*!&lt; DP: Force rport even if not present in the request */
<span class="lineNum">     277 </span>            : #define SIP_NAT_RPORT_PRESENT   (1 &lt;&lt; 19) /*!&lt; DP: rport was present in the request */
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            : /* re-INVITE related settings */
<span class="lineNum">     280 </span>            : #define SIP_REINVITE         (7 &lt;&lt; 20) /*!&lt; DP: four settings, uses three bits */
<span class="lineNum">     281 </span>            : #define SIP_REINVITE_NONE    (0 &lt;&lt; 20) /*!&lt; DP: no reinvite allowed */
<span class="lineNum">     282 </span>            : #define SIP_DIRECT_MEDIA     (1 &lt;&lt; 20) /*!&lt; DP: allow peers to be reinvited to send media directly p2p */
<span class="lineNum">     283 </span>            : #define SIP_DIRECT_MEDIA_NAT (2 &lt;&lt; 20) /*!&lt; DP: allow media reinvite when new peer is behind NAT */
<span class="lineNum">     284 </span>            : #define SIP_REINVITE_UPDATE  (4 &lt;&lt; 20) /*!&lt; DP: use UPDATE (RFC3311) when reinviting this peer */
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : /* &quot;insecure&quot; settings - see insecure2str() */
<span class="lineNum">     287 </span>            : #define SIP_INSECURE         (3 &lt;&lt; 23)    /*!&lt; DP: three settings, uses two bits */
<span class="lineNum">     288 </span>            : #define SIP_INSECURE_NONE    (0 &lt;&lt; 23)    /*!&lt; DP: secure mode */
<span class="lineNum">     289 </span>            : #define SIP_INSECURE_PORT    (1 &lt;&lt; 23)    /*!&lt; DP: don't require matching port for incoming requests */
<span class="lineNum">     290 </span>            : #define SIP_INSECURE_INVITE  (1 &lt;&lt; 24)    /*!&lt; DP: don't require authentication for incoming INVITEs */
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            : /* Sending PROGRESS in-band settings */
<span class="lineNum">     293 </span>            : #define SIP_PROG_INBAND        (3 &lt;&lt; 25) /*!&lt; DP: three settings, uses two bits */
<span class="lineNum">     294 </span>            : #define SIP_PROG_INBAND_NO     (0 &lt;&lt; 25)
<span class="lineNum">     295 </span>            : #define SIP_PROG_INBAND_NEVER  (1 &lt;&lt; 25)
<span class="lineNum">     296 </span>            : #define SIP_PROG_INBAND_YES    (2 &lt;&lt; 25)
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : #define SIP_USEPATH          (1 &lt;&lt; 27) /*!&lt; GDP: Trust and use incoming Path headers? */
<span class="lineNum">     299 </span>            : #define SIP_SENDRPID         (3 &lt;&lt; 29) /*!&lt; DP: Remote Party-ID Support */
<span class="lineNum">     300 </span>            : #define SIP_SENDRPID_NO      (0 &lt;&lt; 29)
<span class="lineNum">     301 </span>            : #define SIP_SENDRPID_PAI     (1 &lt;&lt; 29) /*!&lt; Use &quot;P-Asserted-Identity&quot; for rpid */
<span class="lineNum">     302 </span>            : #define SIP_SENDRPID_RPID    (2 &lt;&lt; 29) /*!&lt; Use &quot;Remote-Party-ID&quot; for rpid */
<span class="lineNum">     303 </span>            : #define SIP_G726_NONSTANDARD (1 &lt;&lt; 31) /*!&lt; DP: Use non-standard packing for G726-32 data */
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : /*! \brief Flags to copy from peer/user to dialog */
<span class="lineNum">     306 </span>            : #define SIP_FLAGS_TO_COPY \
<span class="lineNum">     307 </span>            :         (SIP_PROMISCREDIR | SIP_TRUSTRPID | SIP_SENDRPID | SIP_DTMF | SIP_REINVITE | \
<span class="lineNum">     308 </span>            :          SIP_PROG_INBAND | SIP_USECLIENTCODE | SIP_NAT_FORCE_RPORT | SIP_G726_NONSTANDARD | \
<span class="lineNum">     309 </span>            :          SIP_USEREQPHONE | SIP_INSECURE | SIP_USEPATH)
<span class="lineNum">     310 </span>            : /*@}*/
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : /*! \name SIPflags2
<span class="lineNum">     313 </span>            :         a second page of flags (for flags[1] */
<span class="lineNum">     314 </span>            : /*@{*/
<span class="lineNum">     315 </span>            : /* realtime flags */
<span class="lineNum">     316 </span>            : #define SIP_PAGE2_RTCACHEFRIENDS            (1 &lt;&lt;  0)   /*!&lt; GP: Should we keep RT objects in memory for extended time? */
<span class="lineNum">     317 </span>            : #define SIP_PAGE2_RTAUTOCLEAR               (1 &lt;&lt;  1)   /*!&lt; GP: Should we clean memory from peers after expiry? */
<span class="lineNum">     318 </span>            : #define SIP_PAGE2_RPID_UPDATE               (1 &lt;&lt;  2)
<span class="lineNum">     319 </span>            : #define SIP_PAGE2_Q850_REASON               (1 &lt;&lt;  3)   /*!&lt; DP: Get/send cause code via Reason header */
<span class="lineNum">     320 </span>            : #define SIP_PAGE2_SYMMETRICRTP              (1 &lt;&lt;  4)   /*!&lt; GDP: Whether symmetric RTP is enabled or not */
<span class="lineNum">     321 </span>            : #define SIP_PAGE2_STATECHANGEQUEUE          (1 &lt;&lt;  5)   /*!&lt; D: Unsent state pending change exists */
<span class="lineNum">     322 </span>            : #define SIP_PAGE2_CONNECTLINEUPDATE_PEND    (1 &lt;&lt;  6)
<span class="lineNum">     323 </span>            : #define SIP_PAGE2_RPID_IMMEDIATE            (1 &lt;&lt;  7)
<span class="lineNum">     324 </span>            : #define SIP_PAGE2_RPORT_PRESENT             (1 &lt;&lt;  8)   /*!&lt; Was rport received in the Via header? */
<span class="lineNum">     325 </span>            : #define SIP_PAGE2_PREFERRED_CODEC           (1 &lt;&lt;  9)   /*!&lt; GDP: Only respond with single most preferred joint codec */
<span class="lineNum">     326 </span>            : #define SIP_PAGE2_VIDEOSUPPORT              (1 &lt;&lt; 10)   /*!&lt; DP: Video supported if offered? */
<span class="lineNum">     327 </span>            : #define SIP_PAGE2_TEXTSUPPORT               (1 &lt;&lt; 11)   /*!&lt; GDP: Global text enable */
<span class="lineNum">     328 </span>            : #define SIP_PAGE2_ALLOWSUBSCRIBE            (1 &lt;&lt; 12)   /*!&lt; GP: Allow subscriptions from this peer? */
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : #define SIP_PAGE2_ALLOWOVERLAP              (3 &lt;&lt; 13)   /*!&lt; DP: Allow overlap dialing ? */
<span class="lineNum">     331 </span>            : #define SIP_PAGE2_ALLOWOVERLAP_NO           (0 &lt;&lt; 13)   /*!&lt; No, terminate with 404 Not found */
<span class="lineNum">     332 </span>            : #define SIP_PAGE2_ALLOWOVERLAP_YES          (1 &lt;&lt; 13)   /*!&lt; Yes, using the 484 Address Incomplete response */
<span class="lineNum">     333 </span>            : #define SIP_PAGE2_ALLOWOVERLAP_DTMF         (2 &lt;&lt; 13)   /*!&lt; Yes, using the DTMF transmission through Early Media */
<span class="lineNum">     334 </span>            : #define SIP_PAGE2_ALLOWOVERLAP_SPARE        (3 &lt;&lt; 13)   /*!&lt; Spare (reserved for another dialling transmission mechanisms like KPML) */
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : #define SIP_PAGE2_SUBSCRIBEMWIONLY          (1 &lt;&lt; 15)   /*!&lt; GP: Only issue MWI notification if subscribed to */
<span class="lineNum">     337 </span>            : #define SIP_PAGE2_IGNORESDPVERSION          (1 &lt;&lt; 16)   /*!&lt; GDP: Ignore the SDP session version number we receive and treat all sessions as new */
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : #define SIP_PAGE2_T38SUPPORT                (3 &lt;&lt; 17)   /*!&lt; GDP: T.38 Fax Support */
<span class="lineNum">     340 </span>            : #define SIP_PAGE2_T38SUPPORT_UDPTL          (1 &lt;&lt; 17)   /*!&lt; GDP: T.38 Fax Support (no error correction) */
<span class="lineNum">     341 </span>            : #define SIP_PAGE2_T38SUPPORT_UDPTL_FEC      (2 &lt;&lt; 17)   /*!&lt; GDP: T.38 Fax Support (FEC error correction) */
<span class="lineNum">     342 </span>            : #define SIP_PAGE2_T38SUPPORT_UDPTL_REDUNDANCY   (3 &lt;&lt; 17)   /*!&lt; GDP: T.38 Fax Support (redundancy error correction) */
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : #define SIP_PAGE2_CALL_ONHOLD               (3 &lt;&lt; 19)   /*!&lt; D: Call hold states: */
<span class="lineNum">     345 </span>            : #define SIP_PAGE2_CALL_ONHOLD_ACTIVE        (1 &lt;&lt; 19)   /*!&lt; D: Active hold */
<span class="lineNum">     346 </span>            : #define SIP_PAGE2_CALL_ONHOLD_ONEDIR        (2 &lt;&lt; 19)   /*!&lt; D: One directional hold */
<span class="lineNum">     347 </span>            : #define SIP_PAGE2_CALL_ONHOLD_INACTIVE      (3 &lt;&lt; 19)   /*!&lt; D: Inactive hold */
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            : #define SIP_PAGE2_RFC2833_COMPENSATE        (1 &lt;&lt; 21)   /*!&lt; DP: Compensate for buggy RFC2833 implementations */
<span class="lineNum">     350 </span>            : #define SIP_PAGE2_BUGGY_MWI                 (1 &lt;&lt; 22)   /*!&lt; DP: Buggy CISCO MWI fix */
<span class="lineNum">     351 </span>            : #define SIP_PAGE2_DIALOG_ESTABLISHED        (1 &lt;&lt; 23)   /*!&lt; 29: Has a dialog been established? */
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            : #define SIP_PAGE2_FAX_DETECT                (3 &lt;&lt; 24)   /*!&lt; DP: Fax Detection support */
<span class="lineNum">     354 </span>            : #define SIP_PAGE2_FAX_DETECT_CNG            (1 &lt;&lt; 24)   /*!&lt; DP: Fax Detection support - detect CNG in audio */
<span class="lineNum">     355 </span>            : #define SIP_PAGE2_FAX_DETECT_T38            (2 &lt;&lt; 24)   /*!&lt; DP: Fax Detection support - detect T.38 reinvite from peer */
<span class="lineNum">     356 </span>            : #define SIP_PAGE2_FAX_DETECT_BOTH           (3 &lt;&lt; 24)   /*!&lt; DP: Fax Detection support - detect both */
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : #define SIP_PAGE2_UDPTL_DESTINATION         (1 &lt;&lt; 26)   /*!&lt; DP: Use source IP of RTP as destination if NAT is enabled */
<span class="lineNum">     359 </span>            : #define SIP_PAGE2_VIDEOSUPPORT_ALWAYS       (1 &lt;&lt; 27)   /*!&lt; DP: Always set up video, even if endpoints don't support it */
<span class="lineNum">     360 </span>            : #define SIP_PAGE2_HAVEPEERCONTEXT           (1 &lt;&lt; 28)   /*&lt; Are we associated with a configured peer context? */
<span class="lineNum">     361 </span>            : #define SIP_PAGE2_USE_SRTP                  (1 &lt;&lt; 29)   /*!&lt; DP: Whether we should offer (only)  SRTP */
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : #define SIP_PAGE2_TRUST_ID_OUTBOUND         (3 &lt;&lt; 30)   /*!&lt; DP: Do we trust the peer with private presence information? */
<span class="lineNum">     364 </span>            : #define SIP_PAGE2_TRUST_ID_OUTBOUND_LEGACY  (0 &lt;&lt; 30)   /*!&lt; Legacy, Do not provide private presence information, but include PAI/RPID when private */
<span class="lineNum">     365 </span>            : #define SIP_PAGE2_TRUST_ID_OUTBOUND_NO      (1 &lt;&lt; 30)   /*!&lt; No, Do not provide private presence information, do not include PAI/RPID when private */
<span class="lineNum">     366 </span>            : #define SIP_PAGE2_TRUST_ID_OUTBOUND_YES     (2 &lt;&lt; 30)   /*!&lt; Yes, provide private presence information in PAI/RPID headers */
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            : #define SIP_PAGE2_FLAGS_TO_COPY \
<span class="lineNum">     369 </span>            :         (SIP_PAGE2_ALLOWSUBSCRIBE | SIP_PAGE2_ALLOWOVERLAP | SIP_PAGE2_IGNORESDPVERSION | \
<span class="lineNum">     370 </span>            :         SIP_PAGE2_VIDEOSUPPORT | SIP_PAGE2_T38SUPPORT | SIP_PAGE2_RFC2833_COMPENSATE | \
<span class="lineNum">     371 </span>            :         SIP_PAGE2_BUGGY_MWI | SIP_PAGE2_TEXTSUPPORT | SIP_PAGE2_FAX_DETECT | \
<span class="lineNum">     372 </span>            :         SIP_PAGE2_UDPTL_DESTINATION | SIP_PAGE2_VIDEOSUPPORT_ALWAYS | SIP_PAGE2_PREFERRED_CODEC | \
<span class="lineNum">     373 </span>            :         SIP_PAGE2_RPID_IMMEDIATE | SIP_PAGE2_RPID_UPDATE | SIP_PAGE2_SYMMETRICRTP |\
<span class="lineNum">     374 </span>            :         SIP_PAGE2_Q850_REASON | SIP_PAGE2_HAVEPEERCONTEXT | SIP_PAGE2_USE_SRTP | SIP_PAGE2_TRUST_ID_OUTBOUND)
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            : #define SIP_PAGE3_SNOM_AOC               (1 &lt;&lt; 0)  /*!&lt; DPG: Allow snom aoc messages */
<span class="lineNum">     378 </span>            : #define SIP_PAGE3_SRTP_TAG_32            (1 &lt;&lt; 1)  /*!&lt; DP: Use a 32bit auth tag in INVITE not 80bit */
<span class="lineNum">     379 </span>            : #define SIP_PAGE3_NAT_AUTO_RPORT         (1 &lt;&lt; 2)  /*!&lt; DGP: Set SIP_NAT_FORCE_RPORT when NAT is detected */
<span class="lineNum">     380 </span>            : #define SIP_PAGE3_NAT_AUTO_COMEDIA       (1 &lt;&lt; 3)  /*!&lt; DGP: Set SIP_PAGE2_SYMMETRICRTP when NAT is detected */
<span class="lineNum">     381 </span>            : #define SIP_PAGE3_DIRECT_MEDIA_OUTGOING  (1 &lt;&lt; 4)  /*!&lt; DP: Only send direct media reinvites on outgoing calls */
<span class="lineNum">     382 </span>            : #define SIP_PAGE3_USE_AVPF               (1 &lt;&lt; 5)  /*!&lt; DGP: Support a minimal AVPF-compatible profile */
<span class="lineNum">     383 </span>            : #define SIP_PAGE3_ICE_SUPPORT            (1 &lt;&lt; 6)  /*!&lt; DGP: Enable ICE support */
<span class="lineNum">     384 </span>            : #define SIP_PAGE3_IGNORE_PREFCAPS        (1 &lt;&lt; 7)  /*!&lt; DP: Ignore prefcaps when setting up an outgoing call leg */
<span class="lineNum">     385 </span>            : #define SIP_PAGE3_DISCARD_REMOTE_HOLD_RETRIEVAL  (1 &lt;&lt; 8)  /*!&lt; DGP: Stop telling the peer to start music on hold */
<span class="lineNum">     386 </span>            : #define SIP_PAGE3_FORCE_AVP              (1 &lt;&lt; 9)  /*!&lt; DGP: Force 'RTP/AVP' for all streams, even DTLS */
<span class="lineNum">     387 </span>            : #define SIP_PAGE3_RTCP_MUX               (1 &lt;&lt; 10) /*!&lt; DGP: Attempt to negotiate RFC 5761 RTCP multiplexing */
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : #define SIP_PAGE3_FLAGS_TO_COPY \
<span class="lineNum">     390 </span>            :         (SIP_PAGE3_SNOM_AOC | SIP_PAGE3_SRTP_TAG_32 | SIP_PAGE3_NAT_AUTO_RPORT | SIP_PAGE3_NAT_AUTO_COMEDIA | \
<span class="lineNum">     391 </span>            :          SIP_PAGE3_DIRECT_MEDIA_OUTGOING | SIP_PAGE3_USE_AVPF | SIP_PAGE3_ICE_SUPPORT | SIP_PAGE3_IGNORE_PREFCAPS | \
<span class="lineNum">     392 </span>            :          SIP_PAGE3_DISCARD_REMOTE_HOLD_RETRIEVAL | SIP_PAGE3_FORCE_AVP | SIP_PAGE3_RTCP_MUX)
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            : #define CHECK_AUTH_BUF_INITLEN   256
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            : /*@}*/
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            : /*----------------------------------------------------------*/
<span class="lineNum">     399 </span>            : /*----                    ENUMS                         ----*/
<span class="lineNum">     400 </span>            : /*----------------------------------------------------------*/
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            : /*! \brief Authorization scheme for call transfers
<span class="lineNum">     403 </span>            :  *
<span class="lineNum">     404 </span>            :  * \note Not a bitfield flag, since there are plans for other modes,
<span class="lineNum">     405 </span>            :  * like &quot;only allow transfers for authenticated devices&quot;
<span class="lineNum">     406 </span>            :  */
<span class="lineNum">     407 </span>            : enum transfermodes {
<span class="lineNum">     408 </span>            :         TRANSFER_OPENFORALL,            /*!&lt; Allow all SIP transfers */
<span class="lineNum">     409 </span>            :         TRANSFER_CLOSED,                /*!&lt; Allow no SIP transfers */
<span class="lineNum">     410 </span>            : };
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : /*! \brief The result of a lot of functions */
<span class="lineNum">     413 </span>            : enum sip_result {
<span class="lineNum">     414 </span>            :         AST_SUCCESS = 0,                /*!&lt; FALSE means success, funny enough */
<span class="lineNum">     415 </span>            :         AST_FAILURE = -1,               /*!&lt; Failure code */
<span class="lineNum">     416 </span>            : };
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : /*! \brief The results from handling an invite request
<span class="lineNum">     419 </span>            :  *
<span class="lineNum">     420 </span>            :  * \note Start at these values so we do not conflict with
<span class="lineNum">     421 </span>            :  * check_auth_results values when returning from
<span class="lineNum">     422 </span>            :  * handle_request_invite.  check_auth_results only returned during
<span class="lineNum">     423 </span>            :  * authentication routines
<span class="lineNum">     424 </span>            :  * */
<span class="lineNum">     425 </span>            : enum inv_req_result {
<span class="lineNum">     426 </span>            :         INV_REQ_SUCCESS = 11,    /*!&lt; Success code */
<span class="lineNum">     427 </span>            :         INV_REQ_FAILED  = 10,    /*!&lt; Failure code */
<span class="lineNum">     428 </span>            :         INV_REQ_ERROR   = 9,     /*!&lt; Error code */
<span class="lineNum">     429 </span>            : };
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            : /*! \brief States for the INVITE transaction, not the dialog
<span class="lineNum">     432 </span>            :  *  \note this is for the INVITE that sets up the dialog
<span class="lineNum">     433 </span>            :  */
<span class="lineNum">     434 </span>            : enum invitestates {
<span class="lineNum">     435 </span>            :         INV_NONE = 0,         /*!&lt; No state at all, maybe not an INVITE dialog */
<span class="lineNum">     436 </span>            :         INV_CALLING = 1,      /*!&lt; Invite sent, no answer */
<span class="lineNum">     437 </span>            :         INV_PROCEEDING = 2,   /*!&lt; We got/sent 1xx message */
<span class="lineNum">     438 </span>            :         INV_EARLY_MEDIA = 3,  /*!&lt; We got 18x message with to-tag back */
<span class="lineNum">     439 </span>            :         INV_COMPLETED = 4,    /*!&lt; Got final response with error. Wait for ACK, then CONFIRMED */
<span class="lineNum">     440 </span>            :         INV_CONFIRMED = 5,    /*!&lt; Confirmed response - we've got an ack (Incoming calls only) */
<span class="lineNum">     441 </span>            :         INV_TERMINATED = 6,   /*!&lt; Transaction done - either successful (AST_STATE_UP) or failed, but done
<span class="lineNum">     442 </span>            :                                      The only way out of this is a BYE from one side */
<span class="lineNum">     443 </span>            :         INV_CANCELLED = 7,    /*!&lt; Transaction cancelled by client or server in non-terminated state */
<span class="lineNum">     444 </span>            : };
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : /*! \brief When sending a SIP message, we can send with a few options, depending on
<span class="lineNum">     447 </span>            :  * type of SIP request. UNRELIABLE is moslty used for responses to repeated requests,
<span class="lineNum">     448 </span>            :  * where the original response would be sent RELIABLE in an INVITE transaction
<span class="lineNum">     449 </span>            :  */
<span class="lineNum">     450 </span>            : enum xmittype {
<span class="lineNum">     451 </span>            :         XMIT_CRITICAL = 2,    /*!&lt; Transmit critical SIP message reliably, with re-transmits.
<span class="lineNum">     452 </span>            :                                *   If it fails, it's critical and will cause a teardown of the session */
<span class="lineNum">     453 </span>            :         XMIT_RELIABLE = 1,    /*!&lt; Transmit SIP message reliably, with re-transmits */
<span class="lineNum">     454 </span>            :         XMIT_UNRELIABLE = 0,  /*!&lt; Transmit SIP message without bothering with re-transmits */
<span class="lineNum">     455 </span>            : };
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : /*! \brief Results from the parse_register() function */
<span class="lineNum">     458 </span>            : enum parse_register_result {
<span class="lineNum">     459 </span>            :         PARSE_REGISTER_DENIED,
<span class="lineNum">     460 </span>            :         PARSE_REGISTER_FAILED,
<span class="lineNum">     461 </span>            :         PARSE_REGISTER_UPDATE,
<span class="lineNum">     462 </span>            :         PARSE_REGISTER_QUERY,
<span class="lineNum">     463 </span>            : };
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : /*! \brief Type of subscription, based on the packages we do support, see \ref subscription_types */
<span class="lineNum">     466 </span>            : enum subscriptiontype {
<span class="lineNum">     467 </span>            :         NONE = 0,
<span class="lineNum">     468 </span>            :         XPIDF_XML,
<span class="lineNum">     469 </span>            :         DIALOG_INFO_XML,
<span class="lineNum">     470 </span>            :         CPIM_PIDF_XML,
<span class="lineNum">     471 </span>            :         PIDF_XML,
<span class="lineNum">     472 </span>            :         MWI_NOTIFICATION,
<span class="lineNum">     473 </span>            :         CALL_COMPLETION,
<span class="lineNum">     474 </span>            : };
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            : /*! \brief The number of media types in enum \ref media_type below. */
<span class="lineNum">     477 </span>            : #define OFFERED_MEDIA_COUNT     4
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            : /*! \brief Media types generate different &quot;dummy answers&quot; for not accepting the offer of
<span class="lineNum">     480 </span>            :         a media stream. We need to add definitions for each RTP profile. Secure RTP is not
<span class="lineNum">     481 </span>            :         the same as normal RTP and will require a new definition */
<span class="lineNum">     482 </span>            : enum media_type {
<span class="lineNum">     483 </span>            :         SDP_AUDIO,   /*!&lt; RTP/AVP Audio */
<span class="lineNum">     484 </span>            :         SDP_VIDEO,   /*!&lt; RTP/AVP Video */
<span class="lineNum">     485 </span>            :         SDP_IMAGE,   /*!&lt; Image udptl, not TCP or RTP */
<span class="lineNum">     486 </span>            :         SDP_TEXT,    /*!&lt; RTP/AVP Realtime Text */
<span class="lineNum">     487 </span>            :         SDP_UNKNOWN, /*!&lt; Unknown media type */
<span class="lineNum">     488 </span>            : };
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            : /*! \brief Authentication types - proxy or www authentication
<span class="lineNum">     491 </span>            :  *  \note Endpoints, like Asterisk, should always use WWW authentication to
<span class="lineNum">     492 </span>            :  *  allow multiple authentications in the same call - to the proxy and
<span class="lineNum">     493 </span>            :  *  to the end point.
<span class="lineNum">     494 </span>            :  */
<span class="lineNum">     495 </span>            : enum sip_auth_type {
<span class="lineNum">     496 </span>            :         PROXY_AUTH = 407,
<span class="lineNum">     497 </span>            :         WWW_AUTH = 401,
<span class="lineNum">     498 </span>            : };
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : /*! \brief Result from get_destination function */
<span class="lineNum">     501 </span>            : enum sip_get_dest_result {
<span class="lineNum">     502 </span>            :         SIP_GET_DEST_EXTEN_MATCHMORE = 1,
<span class="lineNum">     503 </span>            :         SIP_GET_DEST_EXTEN_FOUND = 0,
<span class="lineNum">     504 </span>            :         SIP_GET_DEST_EXTEN_NOT_FOUND = -1,
<span class="lineNum">     505 </span>            :         SIP_GET_DEST_REFUSED = -2,
<span class="lineNum">     506 </span>            :         SIP_GET_DEST_INVALID_URI = -3,
<span class="lineNum">     507 </span>            : };
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : /*! \brief Authentication result from check_auth* functions */
<span class="lineNum">     510 </span>            : enum check_auth_result {
<span class="lineNum">     511 </span>            :         AUTH_DONT_KNOW = -100,  /*!&lt; no result, need to check further */
<span class="lineNum">     512 </span>            :                 /* XXX maybe this is the same as AUTH_NOT_FOUND */
<span class="lineNum">     513 </span>            :         AUTH_SUCCESSFUL = 0,
<span class="lineNum">     514 </span>            :         AUTH_CHALLENGE_SENT = 1,
<span class="lineNum">     515 </span>            :         AUTH_SECRET_FAILED = -1,
<span class="lineNum">     516 </span>            :         AUTH_USERNAME_MISMATCH = -2,
<span class="lineNum">     517 </span>            :         AUTH_NOT_FOUND = -3,    /*!&lt; returned by register_verify */
<span class="lineNum">     518 </span>            :         AUTH_UNKNOWN_DOMAIN = -5,
<span class="lineNum">     519 </span>            :         AUTH_PEER_NOT_DYNAMIC = -6,
<span class="lineNum">     520 </span>            :         AUTH_ACL_FAILED = -7,
<span class="lineNum">     521 </span>            :         AUTH_BAD_TRANSPORT = -8,
<span class="lineNum">     522 </span>            :         AUTH_RTP_FAILED = -9,
<span class="lineNum">     523 </span>            :         AUTH_SESSION_LIMIT = -10,
<span class="lineNum">     524 </span>            : };
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : /*! \brief States for outbound registrations (with register= lines in sip.conf */
<span class="lineNum">     527 </span>            : enum sipregistrystate {
<span class="lineNum">     528 </span>            :         REG_STATE_UNREGISTERED = 0,     /*!&lt; We are not registered
<span class="lineNum">     529 </span>            :                  *  \note Initial state. We should have a timeout scheduled for the initial
<span class="lineNum">     530 </span>            :                  * (or next) registration transmission, calling sip_reregister
<span class="lineNum">     531 </span>            :                  */
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :         REG_STATE_REGSENT,      /*!&lt; Registration request sent
<span class="lineNum">     534 </span>            :                  * \note sent initial request, waiting for an ack or a timeout to
<span class="lineNum">     535 </span>            :                  * retransmit the initial request.
<span class="lineNum">     536 </span>            :                 */
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            :         REG_STATE_AUTHSENT,     /*!&lt; We have tried to authenticate
<span class="lineNum">     539 </span>            :                  * \note entered after transmit_register with auth info,
<span class="lineNum">     540 </span>            :                  * waiting for an ack.
<span class="lineNum">     541 </span>            :                  */
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :         REG_STATE_REGISTERED,   /*!&lt; Registered and done */
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :         REG_STATE_REJECTED,     /*!&lt; Registration rejected
<span class="lineNum">     546 </span>            :                  * \note only used when the remote party has an expire larger than
<span class="lineNum">     547 </span>            :                  * our max-expire. This is a final state from which we do not
<span class="lineNum">     548 </span>            :                  * recover (not sure how correctly).
<span class="lineNum">     549 </span>            :                  */
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            :         REG_STATE_TIMEOUT,      /*!&lt; Registration about to expire, renewing registration */
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :         REG_STATE_NOAUTH,       /*!&lt; We have no accepted credentials
<span class="lineNum">     554 </span>            :                  * \note fatal - no chance to proceed */
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :         REG_STATE_FAILED,       /*!&lt; Registration failed after several tries
<span class="lineNum">     557 </span>            :                  * \note fatal - no chance to proceed */
<span class="lineNum">     558 </span>            : };
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            : /*! \brief Modes in which Asterisk can be configured to run SIP Session-Timers */
<span class="lineNum">     561 </span>            : enum st_mode {
<span class="lineNum">     562 </span>            :         SESSION_TIMER_MODE_INVALID = 0, /*!&lt; Invalid value */
<span class="lineNum">     563 </span>            :         SESSION_TIMER_MODE_ACCEPT,      /*!&lt; Honor inbound Session-Timer requests */
<span class="lineNum">     564 </span>            :         SESSION_TIMER_MODE_ORIGINATE,   /*!&lt; Originate outbound and honor inbound requests */
<span class="lineNum">     565 </span>            :         SESSION_TIMER_MODE_REFUSE       /*!&lt; Ignore inbound Session-Timers requests */
<span class="lineNum">     566 </span>            : };
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            : /*! \brief The entity playing the refresher role for Session-Timers */
<span class="lineNum">     569 </span>            : enum st_refresher {
<span class="lineNum">     570 </span>            :         SESSION_TIMER_REFRESHER_AUTO, /*!&lt; Negotiated                      */
<span class="lineNum">     571 </span>            :         SESSION_TIMER_REFRESHER_US,   /*!&lt; Initially prefer session refresh by Asterisk */
<span class="lineNum">     572 </span>            :         SESSION_TIMER_REFRESHER_THEM, /*!&lt; Initially prefer session refresh by the other side */
<span class="lineNum">     573 </span>            : };
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            : enum st_refresher_param {
<span class="lineNum">     576 </span>            :         SESSION_TIMER_REFRESHER_PARAM_UNKNOWN,
<span class="lineNum">     577 </span>            :         SESSION_TIMER_REFRESHER_PARAM_UAC,
<span class="lineNum">     578 </span>            :         SESSION_TIMER_REFRESHER_PARAM_UAS,
<span class="lineNum">     579 </span>            : };
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span>            : /*! \brief Automatic peer registration behavior
<span class="lineNum">     582 </span>            : */
<span class="lineNum">     583 </span>            : enum autocreatepeer_mode {
<span class="lineNum">     584 </span>            :         AUTOPEERS_DISABLED = 0,         /*!&lt; Automatic peer creation disabled */
<span class="lineNum">     585 </span>            :         AUTOPEERS_VOLATILE,                     /*!&lt; Automatic peers dropped on sip reload (pre-1.8 behavior) */
<span class="lineNum">     586 </span>            :         AUTOPEERS_PERSIST                       /*!&lt; Automatic peers survive sip configuration reload */
<span class="lineNum">     587 </span>            : };
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            : /*! \brief States whether a SIP message can create a dialog in Asterisk. */
<span class="lineNum">     590 </span>            : enum can_create_dialog {
<span class="lineNum">     591 </span>            :         CAN_NOT_CREATE_DIALOG,
<span class="lineNum">     592 </span>            :         CAN_CREATE_DIALOG,
<span class="lineNum">     593 </span>            :         CAN_CREATE_DIALOG_UNSUPPORTED_METHOD,
<span class="lineNum">     594 </span>            : };
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            : /*! \brief SIP Request methods known by Asterisk
<span class="lineNum">     597 </span>            :  *
<span class="lineNum">     598 </span>            :  * \note Do _NOT_ make any changes to this enum, or the array following it;
<span class="lineNum">     599 </span>            :  * if you think you are doing the right thing, you are probably
<span class="lineNum">     600 </span>            :  * not doing the right thing. If you think there are changes
<span class="lineNum">     601 </span>            :  * needed, get someone else to review them first _before_
<span class="lineNum">     602 </span>            :  * submitting a patch. If these two lists do not match properly
<span class="lineNum">     603 </span>            :  * bad things will happen.
<span class="lineNum">     604 </span>            :  */
<span class="lineNum">     605 </span>            : enum sipmethod {
<span class="lineNum">     606 </span>            :         SIP_UNKNOWN,    /*!&lt; Unknown response */
<span class="lineNum">     607 </span>            :         SIP_RESPONSE,   /*!&lt; Not request, response to outbound request */
<span class="lineNum">     608 </span>            :         SIP_REGISTER,   /*!&lt; Registration to the mothership, tell us where you are located */
<span class="lineNum">     609 </span>            :         SIP_OPTIONS,    /*!&lt; Check capabilities of a device, used for &quot;ping&quot; too */
<span class="lineNum">     610 </span>            :         SIP_NOTIFY,     /*!&lt; Status update, Part of the event package standard, result of a SUBSCRIBE or a REFER */
<span class="lineNum">     611 </span>            :         SIP_INVITE,     /*!&lt; Set up a session */
<span class="lineNum">     612 </span>            :         SIP_ACK,        /*!&lt; End of a three-way handshake started with INVITE. */
<span class="lineNum">     613 </span>            :         SIP_PRACK,      /*!&lt; Reliable pre-call signalling. Not supported in Asterisk. */
<span class="lineNum">     614 </span>            :         SIP_BYE,        /*!&lt; End of a session */
<span class="lineNum">     615 </span>            :         SIP_REFER,      /*!&lt; Refer to another URI (transfer) */
<span class="lineNum">     616 </span>            :         SIP_SUBSCRIBE,  /*!&lt; Subscribe for updates (voicemail, session status, device status, presence) */
<span class="lineNum">     617 </span>            :         SIP_MESSAGE,    /*!&lt; Text messaging */
<span class="lineNum">     618 </span>            :         SIP_UPDATE,     /*!&lt; Update a dialog. We can send UPDATE; but not accept it */
<span class="lineNum">     619 </span>            :         SIP_INFO,       /*!&lt; Information updates during a session */
<span class="lineNum">     620 </span>            :         SIP_CANCEL,     /*!&lt; Cancel an INVITE */
<span class="lineNum">     621 </span>            :         SIP_PUBLISH,    /*!&lt; Not supported in Asterisk */
<span class="lineNum">     622 </span>            :         SIP_PING,       /*!&lt; Not supported at all, no standard but still implemented out there */
<span class="lineNum">     623 </span>            : };
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span>            : /*! \brief Setting for the 'notifyringing' option, see sip.conf.sample for details. */
<span class="lineNum">     626 </span>            : enum notifyringing_setting {
<span class="lineNum">     627 </span>            :         NOTIFYRINGING_DISABLED = 0,
<span class="lineNum">     628 </span>            :         NOTIFYRINGING_ENABLED = 1,
<span class="lineNum">     629 </span>            :         NOTIFYRINGING_NOTINUSE = 2,
<span class="lineNum">     630 </span>            : };
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : /*! \brief Settings for the 'notifycid' option, see sip.conf.sample for details. */
<span class="lineNum">     633 </span>            : enum notifycid_setting {
<span class="lineNum">     634 </span>            :         DISABLED       = 0,
<span class="lineNum">     635 </span>            :         ENABLED        = 1,
<span class="lineNum">     636 </span>            :         IGNORE_CONTEXT = 2,
<span class="lineNum">     637 </span>            : };
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span>            : /*! \brief Modes for SIP domain handling in the PBX */
<span class="lineNum">     640 </span>            : enum domain_mode {
<span class="lineNum">     641 </span>            :         SIP_DOMAIN_AUTO,      /*!&lt; This domain is auto-configured */
<span class="lineNum">     642 </span>            :         SIP_DOMAIN_CONFIG,    /*!&lt; This domain is from configuration */
<span class="lineNum">     643 </span>            : };
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            : /*! \brief debugging state
<span class="lineNum">     646 </span>            :  * We store separately the debugging requests from the config file
<span class="lineNum">     647 </span>            :  * and requests from the CLI. Debugging is enabled if either is set
<span class="lineNum">     648 </span>            :  * (which means that if sipdebug is set in the config file, we can
<span class="lineNum">     649 </span>            :  * only turn it off by reloading the config).
<span class="lineNum">     650 </span>            :  */
<span class="lineNum">     651 </span>            : enum sip_debug_e {
<span class="lineNum">     652 </span>            :         sip_debug_none = 0,
<span class="lineNum">     653 </span>            :         sip_debug_config = 1,
<span class="lineNum">     654 </span>            :         sip_debug_console = 2,
<span class="lineNum">     655 </span>            : };
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span>            : /*! \brief T38 States for a call */
<span class="lineNum">     658 </span>            : enum t38state {
<span class="lineNum">     659 </span>            :         T38_DISABLED = 0,     /*!&lt; Not enabled */
<span class="lineNum">     660 </span>            :         T38_LOCAL_REINVITE,   /*!&lt; Offered from local - REINVITE */
<span class="lineNum">     661 </span>            :         T38_PEER_REINVITE,    /*!&lt; Offered from peer - REINVITE */
<span class="lineNum">     662 </span>            :         T38_ENABLED,          /*!&lt; Negotiated (enabled) */
<span class="lineNum">     663 </span>            :         T38_REJECTED          /*!&lt; Refused */
<span class="lineNum">     664 </span>            : };
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            : /*! \brief Parameters to know status of transfer */
<span class="lineNum">     667 </span>            : enum referstatus {
<span class="lineNum">     668 </span>            :         REFER_IDLE,           /*!&lt; No REFER is in progress */
<span class="lineNum">     669 </span>            :         REFER_SENT,           /*!&lt; Sent REFER to transferee */
<span class="lineNum">     670 </span>            :         REFER_RECEIVED,       /*!&lt; Received REFER from transferrer */
<span class="lineNum">     671 </span>            :         REFER_CONFIRMED,      /*!&lt; Refer confirmed with a 100 TRYING (unused) */
<span class="lineNum">     672 </span>            :         REFER_ACCEPTED,       /*!&lt; Accepted by transferee */
<span class="lineNum">     673 </span>            :         REFER_RINGING,        /*!&lt; Target Ringing */
<span class="lineNum">     674 </span>            :         REFER_200OK,          /*!&lt; Answered by transfer target */
<span class="lineNum">     675 </span>            :         REFER_FAILED,         /*!&lt; REFER declined - go on */
<span class="lineNum">     676 </span>            :         REFER_NOAUTH          /*!&lt; We had no auth for REFER */
<span class="lineNum">     677 </span>            : };
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            : enum sip_peer_type {
<span class="lineNum">     680 </span>            :         SIP_TYPE_PEER = (1 &lt;&lt; 0),
<span class="lineNum">     681 </span>            :         SIP_TYPE_USER = (1 &lt;&lt; 1),
<span class="lineNum">     682 </span>            : };
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : enum t38_action_flag {
<span class="lineNum">     685 </span>            :         SDP_T38_NONE = 0, /*!&lt; Do not modify T38 information at all */
<span class="lineNum">     686 </span>            :         SDP_T38_INITIATE, /*!&lt; Remote side has requested T38 with us */
<span class="lineNum">     687 </span>            :         SDP_T38_ACCEPT,   /*!&lt; Remote side accepted our T38 request */
<span class="lineNum">     688 </span>            : };
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            : enum sip_tcptls_alert {
<span class="lineNum">     691 </span>            :         TCPTLS_ALERT_DATA,  /*!&lt; \brief There is new data to be sent out */
<span class="lineNum">     692 </span>            :         TCPTLS_ALERT_STOP,  /*!&lt; \brief A request to stop the tcp_handler thread */
<span class="lineNum">     693 </span>            : };
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            : enum digest_keys {
<span class="lineNum">     696 </span>            :         K_RESP,
<span class="lineNum">     697 </span>            :         K_URI,
<span class="lineNum">     698 </span>            :         K_USER,
<span class="lineNum">     699 </span>            :         K_NONCE,
<span class="lineNum">     700 </span>            :         K_LAST
<span class="lineNum">     701 </span>            : };
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            : /*----------------------------------------------------------*/
<span class="lineNum">     704 </span>            : /*----                    STRUCTS                       ----*/
<span class="lineNum">     705 </span>            : /*----------------------------------------------------------*/
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            : /*! \brief definition of a sip proxy server
<span class="lineNum">     708 </span>            :  *
<span class="lineNum">     709 </span>            :  * For outbound proxies, a sip_peer will contain a reference to a
<span class="lineNum">     710 </span>            :  * dynamically allocated instance of a sip_proxy. A sip_pvt may also
<span class="lineNum">     711 </span>            :  * contain a reference to a peer's outboundproxy, or it may contain
<span class="lineNum">     712 </span>            :  * a reference to the sip_cfg.outboundproxy.
<span class="lineNum">     713 </span>            :  */
<span class="lineNum">     714 </span>            : struct sip_proxy {
<span class="lineNum">     715 </span>            :         char name[MAXHOSTNAMELEN];      /*!&lt; DNS name of domain/host or IP */
<span class="lineNum">     716 </span>            :         struct ast_sockaddr ip;          /*!&lt; Currently used IP address and port */
<span class="lineNum">     717 </span>            :         int port;
<span class="lineNum">     718 </span>            :         time_t last_dnsupdate;          /*!&lt; When this was resolved */
<span class="lineNum">     719 </span>            :         enum ast_transport transport;
<span class="lineNum">     720 </span>            :         int force;                      /*!&lt; If it's an outbound proxy, Force use of this outbound proxy for all outbound requests */
<span class="lineNum">     721 </span>            :         /* Room for a SRV record chain based on the name */
<span class="lineNum">     722 </span>            : };
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            : /*! \brief argument for the 'show channels|subscriptions' callback. */
<span class="lineNum">     725 </span>            : struct __show_chan_arg {
<span class="lineNum">     726 </span>            :         int fd;
<span class="lineNum">     727 </span>            :         int subscriptions;
<span class="lineNum">     728 </span>            :         int numchans;   /* return value */
<span class="lineNum">     729 </span>            : };
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            : /*! \name GlobalSettings
<span class="lineNum">     732 </span>            :         Global settings apply to the channel (often settings you can change in the general section
<span class="lineNum">     733 </span>            :         of sip.conf
<span class="lineNum">     734 </span>            : */
<span class="lineNum">     735 </span>            : /*@{*/
<span class="lineNum">     736 </span>            : /*! \brief a place to store all global settings for the sip channel driver
<span class="lineNum">     737 </span>            : 
<span class="lineNum">     738 </span>            :         These are settings that will be possibly to apply on a group level later on.
<span class="lineNum">     739 </span>            :         \note Do not add settings that only apply to the channel itself and can't
<span class="lineNum">     740 </span>            :               be applied to devices (trunks, services, phones)
<span class="lineNum">     741 </span>            : */
<span class="lineNum">     742 </span>            : struct sip_settings {
<span class="lineNum">     743 </span>            :         int peer_rtupdate;          /*!&lt; G: Update database with registration data for peer? */
<span class="lineNum">     744 </span>            :         int rtsave_sysname;         /*!&lt; G: Save system name at registration? */
<span class="lineNum">     745 </span>            :         int rtsave_path;            /*!&lt; G: Save path header on registration */
<span class="lineNum">     746 </span>            :         int ignore_regexpire;       /*!&lt; G: Ignore expiration of peer  */
<span class="lineNum">     747 </span>            :         int rtautoclear;            /*!&lt; Realtime ?? */
<span class="lineNum">     748 </span>            :         int directrtpsetup;         /*!&lt; Enable support for Direct RTP setup (no re-invites) */
<span class="lineNum">     749 </span>            :         int pedanticsipchecking;    /*!&lt; Extra checking ?  Default off */
<span class="lineNum">     750 </span>            :         enum autocreatepeer_mode autocreatepeer;  /*!&lt; Auto creation of peers at registration? Default off. */
<span class="lineNum">     751 </span>            :         int srvlookup;              /*!&lt; SRV Lookup on or off. Default is on */
<span class="lineNum">     752 </span>            :         int allowguest;             /*!&lt; allow unauthenticated peers to connect? */
<span class="lineNum">     753 </span>            :         int alwaysauthreject;       /*!&lt; Send 401 Unauthorized for all failing requests */
<span class="lineNum">     754 </span>            :         int auth_options_requests;  /*!&lt; Authenticate OPTIONS requests */
<span class="lineNum">     755 </span>            :         int auth_message_requests;  /*!&lt; Authenticate MESSAGE requests */
<span class="lineNum">     756 </span>            :         int accept_outofcall_message; /*!&lt; Accept MESSAGE outside of a call */
<span class="lineNum">     757 </span>            :         int compactheaders;         /*!&lt; send compact sip headers */
<span class="lineNum">     758 </span>            :         int allow_external_domains; /*!&lt; Accept calls to external SIP domains? */
<span class="lineNum">     759 </span>            :         int regextenonqualify;      /*!&lt; Whether to add/remove regexten when qualifying peers */
<span class="lineNum">     760 </span>            :         int legacy_useroption_parsing; /*!&lt; Whether to strip useroptions in URI via semicolons */
<span class="lineNum">     761 </span>            :         int send_diversion;             /*!&lt; Whether to Send SIP Diversion headers */
<span class="lineNum">     762 </span>            :         int matchexternaddrlocally;   /*!&lt; Match externaddr/externhost setting against localnet setting */
<span class="lineNum">     763 </span>            :         char regcontext[AST_MAX_CONTEXT];  /*!&lt; Context for auto-extensions */
<span class="lineNum">     764 </span>            :         char messagecontext[AST_MAX_CONTEXT];  /*!&lt; Default context for out of dialog msgs. */
<span class="lineNum">     765 </span>            :         unsigned int disallowed_methods;   /*!&lt; methods that we should never try to use */
<span class="lineNum">     766 </span>            :         int notifyringing;          /*!&lt; Send notifications on ringing */
<span class="lineNum">     767 </span>            :         int notifyhold;             /*!&lt; Send notifications on hold */
<span class="lineNum">     768 </span>            :         enum notifycid_setting notifycid;  /*!&lt; Send CID with ringing notifications */
<span class="lineNum">     769 </span>            :         enum transfermodes allowtransfer;  /*!&lt; SIP Refer restriction scheme */
<span class="lineNum">     770 </span>            :         int allowsubscribe;         /*!&lt; Flag for disabling ALL subscriptions, this is FALSE only if all peers are FALSE
<span class="lineNum">     771 </span>            :                                          the global setting is in globals_flags[1] */
<span class="lineNum">     772 </span>            :         char realm[MAXHOSTNAMELEN]; /*!&lt; Default realm */
<span class="lineNum">     773 </span>            :         int domainsasrealm;         /*!&lt; Use domains lists as realms */
<span class="lineNum">     774 </span>            :         struct sip_proxy outboundproxy; /*!&lt; Outbound proxy */
<span class="lineNum">     775 </span>            :         char default_context[AST_MAX_CONTEXT];
<span class="lineNum">     776 </span>            :         char default_subscribecontext[AST_MAX_CONTEXT];
<span class="lineNum">     777 </span>            :         char default_record_on_feature[AST_FEATURE_MAX_LEN];
<span class="lineNum">     778 </span>            :         char default_record_off_feature[AST_FEATURE_MAX_LEN];
<span class="lineNum">     779 </span>            :         struct ast_acl_list *contact_acl;  /*! \brief Global list of addresses dynamic peers are not allowed to use */
<span class="lineNum">     780 </span>            :         struct ast_format_cap *caps; /*!&lt; Supported codecs */
<span class="lineNum">     781 </span>            :         int tcp_enabled;
<span class="lineNum">     782 </span>            :         int default_max_forwards;    /*!&lt; Default max forwards (SIP Anti-loop) */
<span class="lineNum">     783 </span>            :         int websocket_write_timeout; /*!&lt; Socket write timeout for websocket transports, in ms */
<span class="lineNum">     784 </span>            :         int websocket_enabled;       /*!&lt; Are websockets enabled? */
<span class="lineNum">     785 </span>            : };
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            : struct ast_websocket;
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            : /*! \brief The SIP socket definition */
<span class="lineNum">     790 </span>            : struct sip_socket {
<span class="lineNum">     791 </span>            :         enum ast_transport type;  /*!&lt; UDP, TCP or TLS */
<span class="lineNum">     792 </span>            :         int fd;                   /*!&lt; Filed descriptor, the actual socket */
<span class="lineNum">     793 </span>            :         uint16_t port;
<span class="lineNum">     794 </span>            :         struct ast_tcptls_session_instance *tcptls_session;  /* If tcp or tls, a socket manager */
<span class="lineNum">     795 </span>            :         struct ast_websocket *ws_session; /*! If ws or wss, a WebSocket session */
<span class="lineNum">     796 </span>            : };
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : /*! \brief sip_request: The data grabbed from the UDP socket
<span class="lineNum">     799 </span>            :  *
<span class="lineNum">     800 </span>            :  * \verbatim
<span class="lineNum">     801 </span>            :  * Incoming messages: we first store the data from the socket in data[],
<span class="lineNum">     802 </span>            :  * adding a trailing \0 to make string parsing routines happy.
<span class="lineNum">     803 </span>            :  * Then call parse_request() and req.method = find_sip_method();
<span class="lineNum">     804 </span>            :  * to initialize the other fields. The \r\n at the end of each line is
<span class="lineNum">     805 </span>            :  * replaced by \0, so that data[] is not a conforming SIP message anymore.
<span class="lineNum">     806 </span>            :  * After this processing, rlpart1 is set to non-NULL to remember
<span class="lineNum">     807 </span>            :  * that we can run get_header() on this kind of packet.
<span class="lineNum">     808 </span>            :  *
<span class="lineNum">     809 </span>            :  * parse_request() splits the first line as follows:
<span class="lineNum">     810 </span>            :  * Requests have in the first line      method uri SIP/2.0
<span class="lineNum">     811 </span>            :  *      rlpart1 = method; rlpart2 = uri;
<span class="lineNum">     812 </span>            :  * Responses have in the first line     SIP/2.0 NNN description
<span class="lineNum">     813 </span>            :  *      rlpart1 = SIP/2.0; rlpart2 = NNN + description;
<span class="lineNum">     814 </span>            :  *
<span class="lineNum">     815 </span>            :  * For outgoing packets, we initialize the fields with init_req() or init_resp()
<span class="lineNum">     816 </span>            :  * (which fills the first line to &quot;METHOD uri SIP/2.0&quot; or &quot;SIP/2.0 code text&quot;),
<span class="lineNum">     817 </span>            :  * and then fill the rest with add_header() and add_line().
<span class="lineNum">     818 </span>            :  * The \r\n at the end of the line are still there, so the get_header()
<span class="lineNum">     819 </span>            :  * and similar functions don't work on these packets.
<span class="lineNum">     820 </span>            :  * \endverbatim
<span class="lineNum">     821 </span>            :  */
<span class="lineNum">     822 </span>            : struct sip_request {
<span class="lineNum">     823 </span>            :         ptrdiff_t rlpart1;      /*!&lt; Offset of the SIP Method Name or &quot;SIP/2.0&quot; protocol version */
<span class="lineNum">     824 </span>            :         ptrdiff_t rlpart2;      /*!&lt; Offset of the Request URI or Response Status */
<span class="lineNum">     825 </span>            :         int headers;            /*!&lt; # of SIP Headers */
<span class="lineNum">     826 </span>            :         int method;             /*!&lt; Method of this request */
<span class="lineNum">     827 </span>            :         int lines;              /*!&lt; Body Content */
<span class="lineNum">     828 </span>            :         unsigned int sdp_start; /*!&lt; the line number where the SDP begins */
<span class="lineNum">     829 </span>            :         unsigned int sdp_count; /*!&lt; the number of lines of SDP */
<span class="lineNum">     830 </span>            :         char debug;             /*!&lt; print extra debugging if non zero */
<span class="lineNum">     831 </span>            :         char has_to_tag;        /*!&lt; non-zero if packet has To: tag */
<span class="lineNum">     832 </span>            :         char ignore;            /*!&lt; if non-zero This is a re-transmit, ignore it */
<span class="lineNum">     833 </span>            :         char authenticated;     /*!&lt; non-zero if this request was authenticated */
<span class="lineNum">     834 </span>            :         ptrdiff_t header[SIP_MAX_HEADERS]; /*!&lt; Array of offsets into the request string of each SIP header*/
<span class="lineNum">     835 </span>            :         ptrdiff_t line[SIP_MAX_LINES];     /*!&lt; Array of offsets into the request string of each SDP line*/
<span class="lineNum">     836 </span>            :         struct ast_str *data;
<span class="lineNum">     837 </span>            :         struct ast_str *content;
<span class="lineNum">     838 </span>            :         /* XXX Do we need to unref socket.ser when the request goes away? */
<span class="lineNum">     839 </span>            :         struct sip_socket socket;          /*!&lt; The socket used for this request */
<span class="lineNum">     840 </span>            :         AST_LIST_ENTRY(sip_request) next;
<span class="lineNum">     841 </span>            :         unsigned int reqsipoptions; /*!&lt; Items needed for Required header in responses */
<span class="lineNum">     842 </span>            : };
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            : /* \brief given a sip_request and an offset, return the char * that resides there
<span class="lineNum">     845 </span>            :  *
<span class="lineNum">     846 </span>            :  * It used to be that rlpart1, rlpart2, and the header and line arrays were character
<span class="lineNum">     847 </span>            :  * pointers. They are now offsets into the ast_str portion of the sip_request structure.
<span class="lineNum">     848 </span>            :  * To avoid adding a bunch of redundant pointer arithmetic to the code, this macro is
<span class="lineNum">     849 </span>            :  * provided to retrieve the string at a particular offset within the request's buffer
<span class="lineNum">     850 </span>            :  */
<span class="lineNum">     851 </span>            : #define REQ_OFFSET_TO_STR(req,offset) (ast_str_buffer((req)-&gt;data) + ((req)-&gt;offset))
<span class="lineNum">     852 </span>            : 
<span class="lineNum">     853 </span>            : /*! \brief Parameters to the transmit_invite function */
<span class="lineNum">     854 </span>            : struct sip_invite_param {
<span class="lineNum">     855 </span>            :         int addsipheaders;          /*!&lt; Add extra SIP headers */
<span class="lineNum">     856 </span>            :         const char *uri_options;    /*!&lt; URI options to add to the URI */
<span class="lineNum">     857 </span>            :         const char *vxml_url;       /*!&lt; VXML url for Cisco phones */
<span class="lineNum">     858 </span>            :         char *auth;                 /*!&lt; Authentication */
<span class="lineNum">     859 </span>            :         char *authheader;           /*!&lt; Auth header */
<span class="lineNum">     860 </span>            :         enum sip_auth_type auth_type;  /*!&lt; Authentication type */
<span class="lineNum">     861 </span>            :         const char *replaces;       /*!&lt; Replaces header for call transfers */
<span class="lineNum">     862 </span>            :         int transfer;               /*!&lt; Flag - is this Invite part of a SIP transfer? (invite/replaces) */
<span class="lineNum">     863 </span>            :         struct sip_proxy *outboundproxy; /*!&lt; Outbound proxy URI */
<span class="lineNum">     864 </span>            : };
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            : /*! \brief Structure to store Via information */
<span class="lineNum">     867 </span>            : struct sip_via {
<span class="lineNum">     868 </span>            :         char *via;
<span class="lineNum">     869 </span>            :         const char *protocol;
<span class="lineNum">     870 </span>            :         const char *sent_by;
<span class="lineNum">     871 </span>            :         const char *branch;
<span class="lineNum">     872 </span>            :         const char *maddr;
<span class="lineNum">     873 </span>            :         unsigned int port;
<span class="lineNum">     874 </span>            :         unsigned char ttl;
<span class="lineNum">     875 </span>            : };
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            : /*! \brief Domain data structure.
<span class="lineNum">     878 </span>            :         \note In the future, we will connect this to a configuration tree specific
<span class="lineNum">     879 </span>            :         for this domain
<span class="lineNum">     880 </span>            : */
<span class="lineNum">     881 </span>            : struct domain {
<span class="lineNum">     882 </span>            :         char domain[MAXHOSTNAMELEN];       /*!&lt; SIP domain we are responsible for */
<span class="lineNum">     883 </span>            :         char context[AST_MAX_EXTENSION];   /*!&lt; Incoming context for this domain */
<span class="lineNum">     884 </span>            :         enum domain_mode mode;             /*!&lt; How did we find this domain? */
<span class="lineNum">     885 </span>            :         AST_LIST_ENTRY(domain) list;       /*!&lt; List mechanics */
<span class="lineNum">     886 </span>            : };
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            : /*! \brief sip_history: Structure for saving transactions within a SIP dialog */
<span class="lineNum">     889 </span>            : struct sip_history {
<span class="lineNum">     890 </span>            :         AST_LIST_ENTRY(sip_history) list;
<span class="lineNum">     891 </span>            :         char event[0];  /* actually more, depending on needs */
<span class="lineNum">     892 </span>            : };
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            : /*! \brief sip_auth: Credentials for authentication to other SIP services */
<span class="lineNum">     895 </span>            : struct sip_auth {
<span class="lineNum">     896 </span>            :         AST_LIST_ENTRY(sip_auth) node;
<span class="lineNum">     897 </span>            :         char realm[AST_MAX_EXTENSION];  /*!&lt; Realm in which these credentials are valid */
<span class="lineNum">     898 </span>            :         char username[256];             /*!&lt; Username */
<span class="lineNum">     899 </span>            :         char secret[256];               /*!&lt; Secret */
<span class="lineNum">     900 </span>            :         char md5secret[256];            /*!&lt; MD5Secret */
<span class="lineNum">     901 </span>            : };
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            : /*! \brief Container of SIP authentication credentials. */
<span class="lineNum">     904 </span>            : struct sip_auth_container {
<span class="lineNum">     905 </span>            :         AST_LIST_HEAD_NOLOCK(, sip_auth) list;
<span class="lineNum">     906 </span>            : };
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            : /*! \brief T.38 channel settings (at some point we need to make this alloc'ed */
<span class="lineNum">     909 </span>            : struct t38properties {
<span class="lineNum">     910 </span>            :         enum t38state state;            /*!&lt; T.38 state */
<span class="lineNum">     911 </span>            :         struct ast_control_t38_parameters our_parms;
<span class="lineNum">     912 </span>            :         struct ast_control_t38_parameters their_parms;
<span class="lineNum">     913 </span>            : };
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            : /*! \brief generic struct to map between strings and integers.
<span class="lineNum">     916 </span>            :  * Fill it with x-s pairs, terminate with an entry with s = NULL;
<span class="lineNum">     917 </span>            :  * Then you can call map_x_s(...) to map an integer to a string,
<span class="lineNum">     918 </span>            :  * and map_s_x() for the string -&gt; integer mapping.
<span class="lineNum">     919 </span>            :  */
<span class="lineNum">     920 </span>            : struct _map_x_s {
<span class="lineNum">     921 </span>            :         int x;
<span class="lineNum">     922 </span>            :         const char *s;
<span class="lineNum">     923 </span>            : };
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            : /*! \brief Structure to handle SIP transfers. Dynamically allocated when needed */
<span class="lineNum">     926 </span>            : struct sip_refer {
<span class="lineNum">     927 </span>            :         AST_DECLARE_STRING_FIELDS(
<span class="lineNum">     928 </span>            :                 AST_STRING_FIELD(refer_to);             /*!&lt; Place to store REFER-TO extension */
<span class="lineNum">     929 </span>            :                 AST_STRING_FIELD(refer_to_domain);      /*!&lt; Place to store REFER-TO domain */
<span class="lineNum">     930 </span>            :                 AST_STRING_FIELD(refer_to_urioption);   /*!&lt; Place to store REFER-TO uri options */
<span class="lineNum">     931 </span>            :                 AST_STRING_FIELD(refer_to_context);     /*!&lt; Place to store REFER-TO context */
<span class="lineNum">     932 </span>            :                 AST_STRING_FIELD(referred_by);          /*!&lt; Place to store REFERRED-BY extension */
<span class="lineNum">     933 </span>            :                 AST_STRING_FIELD(refer_contact);        /*!&lt; Place to store Contact info from a REFER extension */
<span class="lineNum">     934 </span>            :                 AST_STRING_FIELD(replaces_callid);      /*!&lt; Replace info: callid */
<span class="lineNum">     935 </span>            :                 AST_STRING_FIELD(replaces_callid_totag);   /*!&lt; Replace info: to-tag */
<span class="lineNum">     936 </span>            :                 AST_STRING_FIELD(replaces_callid_fromtag); /*!&lt; Replace info: from-tag */
<span class="lineNum">     937 </span>            :         );
<span class="lineNum">     938 </span>            :         int attendedtransfer;                           /*!&lt; Attended or blind transfer? */
<span class="lineNum">     939 </span>            :         int localtransfer;                              /*!&lt; Transfer to local domain? */
<span class="lineNum">     940 </span>            :         enum referstatus status;                        /*!&lt; REFER status */
<span class="lineNum">     941 </span>            : };
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span>            : /*! \brief Struct to handle custom SIP notify requests. Dynamically allocated when needed */
<span class="lineNum">     944 </span>            : struct sip_notify {
<span class="lineNum">     945 </span>            :         struct ast_variable *headers;
<span class="lineNum">     946 </span>            :         struct ast_str *content;
<span class="lineNum">     947 </span>            : };
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span>            : /*! \brief Structure that encapsulates all attributes related to running
<span class="lineNum">     950 </span>            :  *   SIP Session-Timers feature on a per dialog basis.
<span class="lineNum">     951 </span>            :  */
<span class="lineNum">     952 </span>            : struct sip_st_dlg {
<span class="lineNum">     953 </span>            :         int st_active;                     /*!&lt; Session-Timers on/off */
<span class="lineNum">     954 </span>            :         int st_interval;                   /*!&lt; Session-Timers negotiated session refresh interval */
<span class="lineNum">     955 </span>            :         enum st_refresher st_ref;          /*!&lt; Session-Timers cached refresher */
<span class="lineNum">     956 </span>            :         int st_schedid;                    /*!&lt; Session-Timers ast_sched scheduler id */
<span class="lineNum">     957 </span>            :         int st_active_peer_ua;             /*!&lt; Session-Timers on/off in peer UA */
<span class="lineNum">     958 </span>            :         int st_cached_min_se;              /*!&lt; Session-Timers cached Min-SE */
<span class="lineNum">     959 </span>            :         int st_cached_max_se;              /*!&lt; Session-Timers cached Session-Expires */
<span class="lineNum">     960 </span>            :         enum st_mode st_cached_mode;       /*!&lt; Session-Timers cached M.O. */
<span class="lineNum">     961 </span>            :         enum st_refresher st_cached_ref;   /*!&lt; Session-Timers session refresher */
<span class="lineNum">     962 </span>            : };
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            : /*! \brief Structure that encapsulates all attributes related to configuration
<span class="lineNum">     966 </span>            :  *   of SIP Session-Timers feature on a per user/peer basis.
<span class="lineNum">     967 </span>            :  */
<span class="lineNum">     968 </span>            : struct sip_st_cfg {
<span class="lineNum">     969 </span>            :         enum st_mode st_mode_oper;      /*!&lt; Mode of operation for Session-Timers           */
<span class="lineNum">     970 </span>            :         enum st_refresher_param st_ref; /*!&lt; Session-Timer refresher                        */
<span class="lineNum">     971 </span>            :         int st_min_se;                  /*!&lt; Lowest threshold for session refresh interval  */
<span class="lineNum">     972 </span>            :         int st_max_se;                  /*!&lt; Highest threshold for session refresh interval */
<span class="lineNum">     973 </span>            : };
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            : /*! \brief Structure for remembering offered media in an INVITE, to make sure we reply
<span class="lineNum">     976 </span>            :         to all media streams. */
<span class="lineNum">     977 </span>            : struct offered_media {
<span class="lineNum">     978 </span>            :         enum media_type type;           /*!&lt; The type of media that was offered */
<span class="lineNum">     979 </span>            :         char *decline_m_line;           /*!&lt; Used if the media type is unknown/unused or a media stream is declined */
<span class="lineNum">     980 </span>            :         AST_LIST_ENTRY(offered_media) next;
<span class="lineNum">     981 </span>            : };
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span>            : /*! Additional headers to send with MESSAGE method packet. */
<span class="lineNum">     984 </span>            : struct sip_msg_hdr {
<span class="lineNum">     985 </span>            :         AST_LIST_ENTRY(sip_msg_hdr) next;
<span class="lineNum">     986 </span>            :         /*! Name of header to stick in MESSAGE */
<span class="lineNum">     987 </span>            :         const char *name;
<span class="lineNum">     988 </span>            :         /*! Value of header to stick in MESSAGE */
<span class="lineNum">     989 </span>            :         const char *value;
<span class="lineNum">     990 </span>            :         /*! The name and value strings are stuffed here in that order. */
<span class="lineNum">     991 </span>            :         char stuff[0];
<span class="lineNum">     992 </span>            : };
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span>            : /*! \brief Structure used for each SIP dialog, ie. a call, a registration, a subscribe.
<span class="lineNum">     995 </span>            :  * Created and initialized by sip_alloc(), the descriptor goes into the list of
<span class="lineNum">     996 </span>            :  * descriptors (dialoglist).
<span class="lineNum">     997 </span>            :  */
<span class="lineNum">     998 </span>            : struct sip_pvt {
<span class="lineNum">     999 </span>            :         struct sip_pvt *next;                   /*!&lt; Next dialog in chain */
<span class="lineNum">    1000 </span>            :         enum invitestates invitestate;          /*!&lt; Track state of SIP_INVITEs */
<span class="lineNum">    1001 </span>            :         ast_callid logger_callid;               /*!&lt; Identifier for call used in log messages */
<span class="lineNum">    1002 </span>            :         int method;                             /*!&lt; SIP method that opened this dialog */
<span class="lineNum">    1003 </span>            :         AST_DECLARE_STRING_FIELDS(
<span class="lineNum">    1004 </span>            :                 AST_STRING_FIELD(callid);       /*!&lt; Global CallID */
<span class="lineNum">    1005 </span>            :                 AST_STRING_FIELD(initviabranch); /*!&lt; The branch ID from the topmost Via header in the initial request */
<span class="lineNum">    1006 </span>            :                 AST_STRING_FIELD(initviasentby); /*!&lt; The sent-by from the topmost Via header in the initial request */
<span class="lineNum">    1007 </span>            :                 AST_STRING_FIELD(accountcode);  /*!&lt; Account code */
<span class="lineNum">    1008 </span>            :                 AST_STRING_FIELD(realm);        /*!&lt; Authorization realm */
<span class="lineNum">    1009 </span>            :                 AST_STRING_FIELD(nonce);        /*!&lt; Authorization nonce */
<span class="lineNum">    1010 </span>            :                 AST_STRING_FIELD(opaque);       /*!&lt; Opaque nonsense */
<span class="lineNum">    1011 </span>            :                 AST_STRING_FIELD(qop);          /*!&lt; Quality of Protection, since SIP wasn't complicated enough yet. */
<span class="lineNum">    1012 </span>            :                 AST_STRING_FIELD(domain);       /*!&lt; Authorization domain */
<span class="lineNum">    1013 </span>            :                 AST_STRING_FIELD(from);         /*!&lt; The From: header */
<span class="lineNum">    1014 </span>            :                 AST_STRING_FIELD(useragent);    /*!&lt; User agent in SIP request */
<span class="lineNum">    1015 </span>            :                 AST_STRING_FIELD(exten);        /*!&lt; Extension where to start */
<span class="lineNum">    1016 </span>            :                 AST_STRING_FIELD(context);      /*!&lt; Context for this call */
<span class="lineNum">    1017 </span>            :                 AST_STRING_FIELD(messagecontext); /*!&lt; Default context for outofcall messages. */
<span class="lineNum">    1018 </span>            :                 AST_STRING_FIELD(subscribecontext); /*!&lt; Subscribecontext */
<span class="lineNum">    1019 </span>            :                 AST_STRING_FIELD(subscribeuri); /*!&lt; Subscribecontext */
<span class="lineNum">    1020 </span>            :                 AST_STRING_FIELD(fromdomain);   /*!&lt; Domain to show in the from field */
<span class="lineNum">    1021 </span>            :                 AST_STRING_FIELD(fromuser);     /*!&lt; User to show in the user field */
<span class="lineNum">    1022 </span>            :                 AST_STRING_FIELD(fromname);     /*!&lt; Name to show in the user field */
<span class="lineNum">    1023 </span>            :                 AST_STRING_FIELD(tohost);       /*!&lt; Host we should put in the &quot;to&quot; field */
<span class="lineNum">    1024 </span>            :                 AST_STRING_FIELD(todnid);       /*!&lt; DNID of this call (overrides host) */
<span class="lineNum">    1025 </span>            :                 AST_STRING_FIELD(language);     /*!&lt; Default language for this call */
<span class="lineNum">    1026 </span>            :                 AST_STRING_FIELD(mohinterpret); /*!&lt; MOH class to use when put on hold */
<span class="lineNum">    1027 </span>            :                 AST_STRING_FIELD(mohsuggest);   /*!&lt; MOH class to suggest when putting a peer on hold */
<span class="lineNum">    1028 </span>            :                 AST_STRING_FIELD(rdnis);        /*!&lt; Referring DNIS */
<span class="lineNum">    1029 </span>            :                 AST_STRING_FIELD(redircause);   /*!&lt; Referring cause */
<span class="lineNum">    1030 </span>            :                 AST_STRING_FIELD(theirtag);     /*!&lt; Their tag */
<span class="lineNum">    1031 </span>            :                 AST_STRING_FIELD(theirprovtag); /*!&lt; Provisional their tag, used when evaluating responses to invites */
<span class="lineNum">    1032 </span>            :                 AST_STRING_FIELD(tag);          /*!&lt; Our tag for this session */
<span class="lineNum">    1033 </span>            :                 AST_STRING_FIELD(username);     /*!&lt; [user] name */
<span class="lineNum">    1034 </span>            :                 AST_STRING_FIELD(peername);     /*!&lt; [peer] name, not set if [user] */
<span class="lineNum">    1035 </span>            :                 AST_STRING_FIELD(authname);     /*!&lt; Who we use for authentication */
<span class="lineNum">    1036 </span>            :                 AST_STRING_FIELD(uri);          /*!&lt; Original requested URI */
<span class="lineNum">    1037 </span>            :                 AST_STRING_FIELD(okcontacturi); /*!&lt; URI from the 200 OK on INVITE */
<span class="lineNum">    1038 </span>            :                 AST_STRING_FIELD(peersecret);   /*!&lt; Password */
<span class="lineNum">    1039 </span>            :                 AST_STRING_FIELD(peermd5secret);
<span class="lineNum">    1040 </span>            :                 AST_STRING_FIELD(cid_num);      /*!&lt; Caller*ID number */
<span class="lineNum">    1041 </span>            :                 AST_STRING_FIELD(cid_name);     /*!&lt; Caller*ID name */
<span class="lineNum">    1042 </span>            :                 AST_STRING_FIELD(cid_tag);      /*!&lt; Caller*ID tag */
<span class="lineNum">    1043 </span>            :                 AST_STRING_FIELD(mwi_from);     /*!&lt; Name to place in the From header in outgoing NOTIFY requests */
<span class="lineNum">    1044 </span>            :                 AST_STRING_FIELD(fullcontact);  /*!&lt; The Contact: that the UA registers with us */
<span class="lineNum">    1045 </span>            :                                                 /* we only store the part in &lt;brackets&gt; in this field. */
<span class="lineNum">    1046 </span>            :                 AST_STRING_FIELD(our_contact);  /*!&lt; Our contact header */
<span class="lineNum">    1047 </span>            :                 AST_STRING_FIELD(url);          /*!&lt; URL to be sent with next message to peer */
<span class="lineNum">    1048 </span>            :                 AST_STRING_FIELD(parkinglot);   /*!&lt; Parkinglot */
<span class="lineNum">    1049 </span>            :                 AST_STRING_FIELD(engine);       /*!&lt; RTP engine to use */
<span class="lineNum">    1050 </span>            :                 AST_STRING_FIELD(dialstring);   /*!&lt; The dialstring used to call this SIP endpoint */
<span class="lineNum">    1051 </span>            :                 AST_STRING_FIELD(last_presence_subtype);   /*!&lt; The last presence subtype sent for a subscription. */
<span class="lineNum">    1052 </span>            :                 AST_STRING_FIELD(last_presence_message);   /*!&lt; The last presence message for a subscription */
<span class="lineNum">    1053 </span>            :                 AST_STRING_FIELD(msg_body);     /*!&lt; Text for a MESSAGE body */
<span class="lineNum">    1054 </span>            :                 AST_STRING_FIELD(tel_phone_context);       /*!&lt; The phone-context portion of a TEL URI */
<span class="lineNum">    1055 </span>            :         );
<span class="lineNum">    1056 </span>            :         char via[128];                          /*!&lt; Via: header */
<span class="lineNum">    1057 </span>            :         int maxforwards;                        /*!&lt; SIP Loop prevention */
<span class="lineNum">    1058 </span>            :         struct sip_socket socket;               /*!&lt; The socket used for this dialog */
<span class="lineNum">    1059 </span>            :         uint32_t ocseq;                         /*!&lt; Current outgoing seqno */
<span class="lineNum">    1060 </span>            :         uint32_t icseq;                         /*!&lt; Current incoming seqno */
<span class="lineNum">    1061 </span>            :         uint32_t init_icseq;                    /*!&lt; Initial incoming seqno from first request */
<span class="lineNum">    1062 </span>            :         ast_group_t callgroup;                  /*!&lt; Call group */
<span class="lineNum">    1063 </span>            :         ast_group_t pickupgroup;                /*!&lt; Pickup group */
<span class="lineNum">    1064 </span>            :         struct ast_namedgroups *named_callgroups;   /*!&lt; Named call group */
<span class="lineNum">    1065 </span>            :         struct ast_namedgroups *named_pickupgroups; /*!&lt; Named pickup group */
<span class="lineNum">    1066 </span>            :         uint32_t lastinvite;                    /*!&lt; Last seqno of invite */
<span class="lineNum">    1067 </span>            :         struct ast_flags flags[3];              /*!&lt; SIP_ flags */
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span>            :         /* boolean flags that don't belong in flags */
<span class="lineNum">    1070 </span>            :         unsigned short do_history:1;          /*!&lt; Set if we want to record history */
<span class="lineNum">    1071 </span>            :         unsigned short alreadygone:1;         /*!&lt; the peer has sent a message indicating termination of the dialog */
<span class="lineNum">    1072 </span>            :         unsigned short needdestroy:1;         /*!&lt; this dialog needs to be destroyed by the monitor thread */
<span class="lineNum">    1073 </span>            :         unsigned short final_destruction_scheduled:1; /*!&lt; final dialog destruction is scheduled. Keep dialog
<span class="lineNum">    1074 </span>            :                                                        *   around until then to handle retransmits. */
<span class="lineNum">    1075 </span>            :         unsigned short outgoing_call:1;       /*!&lt; this is an outgoing call */
<span class="lineNum">    1076 </span>            :         unsigned short answered_elsewhere:1;  /*!&lt; This call is cancelled due to answer on another channel */
<span class="lineNum">    1077 </span>            :         unsigned short novideo:1;             /*!&lt; Didn't get video in invite, don't offer */
<span class="lineNum">    1078 </span>            :         unsigned short notext:1;              /*!&lt; Text not supported  (?) */
<span class="lineNum">    1079 </span>            :         unsigned short session_modify:1;      /*!&lt; Session modification request true/false  */
<span class="lineNum">    1080 </span>            :         unsigned short route_persistent:1;    /*!&lt; Is this the &quot;real&quot; route? */
<span class="lineNum">    1081 </span>            :         unsigned short autoframing:1;         /*!&lt; Whether to use our local configuration for frame sizes (off)
<span class="lineNum">    1082 </span>            :                                                *   or respect the other endpoint's request for frame sizes (on)
<span class="lineNum">    1083 </span>            :                                                *   for incoming calls
<span class="lineNum">    1084 </span>            :                                                */
<span class="lineNum">    1085 </span>            :         unsigned short req_secure_signaling:1;/*!&lt; Whether we are required to have secure signaling or not */
<span class="lineNum">    1086 </span>            :         unsigned short natdetected:1;         /*!&lt; Whether we detected a NAT when processing the Via */
<span class="lineNum">    1087 </span>            :         int timer_t1;                     /*!&lt; SIP timer T1, ms rtt */
<span class="lineNum">    1088 </span>            :         int timer_b;                      /*!&lt; SIP timer B, ms */
<span class="lineNum">    1089 </span>            :         unsigned int sipoptions;          /*!&lt; Supported SIP options on the other end */
<span class="lineNum">    1090 </span>            :         unsigned int reqsipoptions;       /*!&lt; Required SIP options on the other end */
<span class="lineNum">    1091 </span>            :         struct ast_format_cap *caps;             /*!&lt; Special capability (codec) */
<span class="lineNum">    1092 </span>            :         struct ast_format_cap *jointcaps;        /*!&lt; Supported capability at both ends (codecs) */
<span class="lineNum">    1093 </span>            :         struct ast_format_cap *peercaps;         /*!&lt; Supported peer capability */
<span class="lineNum">    1094 </span>            :         struct ast_format_cap *redircaps;        /*!&lt; Redirect codecs */
<span class="lineNum">    1095 </span>            :         struct ast_format_cap *prefcaps;         /*!&lt; Preferred codec (outbound only) */
<span class="lineNum">    1096 </span>            :         int noncodeccapability;           /*!&lt; DTMF RFC2833 telephony-event */
<span class="lineNum">    1097 </span>            :         int jointnoncodeccapability;      /*!&lt; Joint Non codec capability */
<span class="lineNum">    1098 </span>            :         int maxcallbitrate;               /*!&lt; Maximum Call Bitrate for Video Calls */
<span class="lineNum">    1099 </span>            :         int t38_maxdatagram;              /*!&lt; T.38 FaxMaxDatagram override */
<span class="lineNum">    1100 </span>            :         int request_queue_sched_id;       /*!&lt; Scheduler ID of any scheduled action to process queued requests */
<span class="lineNum">    1101 </span>            :         int provisional_keepalive_sched_id;   /*!&lt; Scheduler ID for provisional responses that need to be sent out to avoid cancellation */
<span class="lineNum">    1102 </span>            :         const char *last_provisional;         /*!&lt; The last successfully transmitted provisonal response message */
<span class="lineNum">    1103 </span>            :         int authtries;                        /*!&lt; Times we've tried to authenticate */
<span class="lineNum">    1104 </span>            :         struct sip_proxy *outboundproxy;      /*!&lt; Outbound proxy for this dialog. Use ref_proxy to set this instead of setting it directly*/
<span class="lineNum">    1105 </span>            :         struct t38properties t38;             /*!&lt; T38 settings */
<span class="lineNum">    1106 </span>            :         struct ast_sockaddr udptlredirip;     /*!&lt; Where our T.38 UDPTL should be going if not to us */
<span class="lineNum">    1107 </span>            :         struct ast_udptl *udptl;              /*!&lt; T.38 UDPTL session */
<span class="lineNum">    1108 </span>            :         char zone[MAX_TONEZONE_COUNTRY];      /*!&lt; Default tone zone for channels created by this dialog */
<span class="lineNum">    1109 </span>            :         int callingpres;                      /*!&lt; Calling presentation */
<span class="lineNum">    1110 </span>            :         int expiry;                         /*!&lt; How long we take to expire */
<span class="lineNum">    1111 </span>            :         int sessionversion;                 /*!&lt; SDP Session Version */
<span class="lineNum">    1112 </span>            :         int sessionid;                      /*!&lt; SDP Session ID */
<span class="lineNum">    1113 </span>            :         long branch;                        /*!&lt; The branch identifier of this session */
<span class="lineNum">    1114 </span>            :         long invite_branch;                 /*!&lt; The branch used when we sent the initial INVITE */
<span class="lineNum">    1115 </span>            :         int64_t sessionversion_remote;      /*!&lt; Remote UA's SDP Session Version */
<span class="lineNum">    1116 </span>            :         unsigned int portinuri:1;           /*!&lt; Non zero if a port has been specified, will also disable srv lookups */
<span class="lineNum">    1117 </span>            :         struct ast_sockaddr sa;              /*!&lt; Our peer */
<span class="lineNum">    1118 </span>            :         struct ast_sockaddr redirip;         /*!&lt; Where our RTP should be going if not to us */
<span class="lineNum">    1119 </span>            :         struct ast_sockaddr vredirip;        /*!&lt; Where our Video RTP should be going if not to us */
<span class="lineNum">    1120 </span>            :         struct ast_sockaddr tredirip;        /*!&lt; Where our Text RTP should be going if not to us */
<span class="lineNum">    1121 </span>            :         time_t lastrtprx;                   /*!&lt; Last RTP received */
<span class="lineNum">    1122 </span>            :         time_t lastrtptx;                   /*!&lt; Last RTP sent */
<span class="lineNum">    1123 </span>            :         int rtptimeout;                     /*!&lt; RTP timeout time */
<span class="lineNum">    1124 </span>            :         int rtpholdtimeout;                 /*!&lt; RTP timeout time on hold*/
<span class="lineNum">    1125 </span>            :         int rtpkeepalive;                   /*!&lt; RTP send packets for keepalive */
<span class="lineNum">    1126 </span>            :         struct ast_acl_list *directmediaacl; /*!&lt; Which IPs are allowed to interchange direct media with this peer - copied from sip_peer */
<span class="lineNum">    1127 </span>            :         struct ast_sockaddr recv;            /*!&lt; Received as */
<span class="lineNum">    1128 </span>            :         struct ast_sockaddr ourip;           /*!&lt; Our IP (as seen from the outside) */
<span class="lineNum">    1129 </span>            :         enum transfermodes allowtransfer;   /*!&lt; REFER: restriction scheme */
<span class="lineNum">    1130 </span>            :         struct ast_channel *owner;          /*!&lt; Who owns us (if we have an owner) */
<span class="lineNum">    1131 </span>            :         struct sip_route route;             /*!&lt; List of routing steps (fm Record-Route) */
<span class="lineNum">    1132 </span>            :         struct sip_notify *notify;          /*!&lt; Custom notify type */
<span class="lineNum">    1133 </span>            :         struct sip_auth_container *peerauth;/*!&lt; Realm authentication credentials */
<span class="lineNum">    1134 </span>            :         int noncecount;                     /*!&lt; Nonce-count */
<span class="lineNum">    1135 </span>            :         unsigned int stalenonce:1;          /*!&lt; Marks the current nonce as responded too */
<span class="lineNum">    1136 </span>            :         unsigned int ongoing_reinvite:1;    /*!&lt; There is a reinvite in progress that might need to be cleaned up */
<span class="lineNum">    1137 </span>            :         char lastmsg[256];                  /*!&lt; Last Message sent/received */
<span class="lineNum">    1138 </span>            :         int amaflags;                       /*!&lt; AMA Flags */
<span class="lineNum">    1139 </span>            :         uint32_t pendinginvite; /*!&lt; Any pending INVITE or state NOTIFY (in subscribe pvt's) ? (seqno of this) */
<span class="lineNum">    1140 </span>            :         uint32_t glareinvite;      /*!&lt; A invite received while a pending invite is already present is stored here.  Its seqno is the
<span class="lineNum">    1141 </span>            :                                    value. Since this glare invite's seqno is not the same as the pending invite's, it must be
<span class="lineNum">    1142 </span>            :                                    held in order to properly process acknowledgements for our 491 response. */
<span class="lineNum">    1143 </span>            :         struct sip_request initreq;         /*!&lt; Latest request that opened a new transaction
<span class="lineNum">    1144 </span>            :                                                  within this dialog.
<span class="lineNum">    1145 </span>            :                                                  NOT the request that opened the dialog */
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            :         int initid;                         /*!&lt; Auto-congest ID if appropriate (scheduler) */
<span class="lineNum">    1148 </span>            :         int waitid;                         /*!&lt; Wait ID for scheduler after 491 or other delays */
<span class="lineNum">    1149 </span>            :         int reinviteid;                     /*!&lt; Reinvite in case of provisional, but no final response */
<span class="lineNum">    1150 </span>            :         int autokillid;                     /*!&lt; Auto-kill ID (scheduler) */
<span class="lineNum">    1151 </span>            :         int t38id;                          /*!&lt; T.38 Response ID */
<span class="lineNum">    1152 </span>            :         struct sip_refer *refer;            /*!&lt; REFER: SIP transfer data structure */
<span class="lineNum">    1153 </span>            :         enum subscriptiontype subscribed;   /*!&lt; SUBSCRIBE: Is this dialog a subscription?  */
<span class="lineNum">    1154 </span>            :         int stateid;                        /*!&lt; SUBSCRIBE: ID for devicestate subscriptions */
<span class="lineNum">    1155 </span>            :         int laststate;                      /*!&lt; SUBSCRIBE: Last known extension state */
<span class="lineNum">    1156 </span>            :         struct ao2_container *last_device_state_info; /*!&lt; SUBSCRIBE: last known extended extension state (take care of refs)*/
<span class="lineNum">    1157 </span>            :         struct timeval last_ringing_channel_time; /*!&lt; SUBSCRIBE: channel timestamp of the channel which caused the last early-state notification */
<span class="lineNum">    1158 </span>            :         int last_presence_state;            /*!&lt; SUBSCRIBE: Last known presence state */
<span class="lineNum">    1159 </span>            :         uint32_t dialogver;                 /*!&lt; SUBSCRIBE: Version for subscription dialog-info */
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            :         struct ast_dsp *dsp;                /*!&lt; Inband DTMF or Fax CNG tone Detection dsp */
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            :         struct sip_peer *relatedpeer;       /*!&lt; If this dialog is related to a peer, which one
<span class="lineNum">    1164 </span>            :                                                  Used in peerpoke, mwi subscriptions */
<span class="lineNum">    1165 </span>            :         struct sip_registry *registry;      /*!&lt; If this is a REGISTER dialog, to which registry */
<span class="lineNum">    1166 </span>            :         struct ast_rtp_instance *rtp;       /*!&lt; RTP Session */
<span class="lineNum">    1167 </span>            :         struct ast_rtp_instance *vrtp;      /*!&lt; Video RTP session */
<span class="lineNum">    1168 </span>            :         struct ast_rtp_instance *trtp;      /*!&lt; Text RTP session */
<span class="lineNum">    1169 </span>            :         struct sip_pkt *packets;            /*!&lt; Packets scheduled for re-transmission */
<span class="lineNum">    1170 </span>            :         struct sip_history_head *history;   /*!&lt; History of this SIP dialog */
<span class="lineNum">    1171 </span>            :         size_t history_entries;             /*!&lt; Number of entires in the history */
<span class="lineNum">    1172 </span>            :         struct ast_variable *chanvars;      /*!&lt; Channel variables to set for inbound call */
<span class="lineNum">    1173 </span>            :         AST_LIST_HEAD_NOLOCK(, sip_msg_hdr) msg_headers; /*!&lt; Additional MESSAGE headers to send. */
<span class="lineNum">    1174 </span>            :         AST_LIST_HEAD_NOLOCK(request_queue, sip_request) request_queue; /*!&lt; Requests that arrived but could not be processed immediately */
<span class="lineNum">    1175 </span>            :         struct sip_invite_param *options;   /*!&lt; Options for INVITE */
<span class="lineNum">    1176 </span>            :         struct sip_st_dlg *stimer;          /*!&lt; SIP Session-Timers */
<span class="lineNum">    1177 </span>            :         struct ast_sdp_srtp *srtp;              /*!&lt; Structure to hold Secure RTP session data for audio */
<span class="lineNum">    1178 </span>            :         struct ast_sdp_srtp *vsrtp;             /*!&lt; Structure to hold Secure RTP session data for video */
<span class="lineNum">    1179 </span>            :         struct ast_sdp_srtp *tsrtp;             /*!&lt; Structure to hold Secure RTP session data for text */
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span>            :         int red;                            /*!&lt; T.140 RTP Redundancy */
<span class="lineNum">    1182 </span>            :         int hangupcause;                    /*!&lt; Storage of hangupcause copied from our owner before we disconnect from the AST channel (only used at hangup) */
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span>            :         struct sip_subscription_mwi *mwi;   /*!&lt; If this is a subscription MWI dialog, to which subscription */
<span class="lineNum">    1185 </span>            :         /*! The SIP methods supported by this peer. We get this information from the Allow header of the first
<span class="lineNum">    1186 </span>            :          * message we receive from an endpoint during a dialog.
<span class="lineNum">    1187 </span>            :          */
<span class="lineNum">    1188 </span>            :         unsigned int allowed_methods;
<span class="lineNum">    1189 </span>            :         /*! Some peers are not trustworthy with their Allow headers, and so we need to override their wicked
<span class="lineNum">    1190 </span>            :          * ways through configuration. This is a copy of the peer's disallowed_methods, so that we can apply them
<span class="lineNum">    1191 </span>            :          * to the sip_pvt at various stages of dialog establishment
<span class="lineNum">    1192 </span>            :          */
<span class="lineNum">    1193 </span>            :         unsigned int disallowed_methods;
<span class="lineNum">    1194 </span>            :         /*! When receiving an SDP offer, it is important to take note of what media types were offered.
<span class="lineNum">    1195 </span>            :          * By doing this, even if we don't want to answer a particular media stream with something meaningful, we can
<span class="lineNum">    1196 </span>            :          * still put an m= line in our answer with the port set to 0.
<span class="lineNum">    1197 </span>            :          *
<span class="lineNum">    1198 </span>            :          * The reason for the length being 4 (OFFERED_MEDIA_COUNT) is that in this branch of Asterisk, the only media types supported are
<span class="lineNum">    1199 </span>            :          * image, audio, text, and video. Therefore we need to keep track of which types of media were offered.
<span class="lineNum">    1200 </span>            :          * Note that secure RTP defines new types of SDP media.
<span class="lineNum">    1201 </span>            :          *
<span class="lineNum">    1202 </span>            :          * If we wanted to be 100% correct, we would keep a list of all media streams offered. That way we could respond
<span class="lineNum">    1203 </span>            :          * even to unknown media types, and we could respond to multiple streams of the same type. Such large-scale changes
<span class="lineNum">    1204 </span>            :          * are not a good idea for released branches, though, so we're compromising by just making sure that for the common cases:
<span class="lineNum">    1205 </span>            :          * audio and video, audio and T.38, and audio and text, we give the appropriate response to both media streams.
<span class="lineNum">    1206 </span>            :          *
<span class="lineNum">    1207 </span>            :          * The large-scale changes would be a good idea for implementing during an SDP rewrite.
<span class="lineNum">    1208 </span>            :          */
<span class="lineNum">    1209 </span>            :         AST_LIST_HEAD_NOLOCK(, offered_media) offered_media;
<span class="lineNum">    1210 </span>            :         struct ast_cc_config_params *cc_params;
<span class="lineNum">    1211 </span>            :         struct sip_epa_entry *epa_entry;
<span class="lineNum">    1212 </span>            :         int fromdomainport;                 /*!&lt; Domain port to show in from field */
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span>            :         struct ast_rtp_dtls_cfg dtls_cfg;
<span class="lineNum">    1215 </span>            : };
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span>            : /*! \brief sip packet - raw format for outbound packets that are sent or scheduled for transmission
<span class="lineNum">    1218 </span>            :  * Packets are linked in a list, whose head is in the struct sip_pvt they belong to.
<span class="lineNum">    1219 </span>            :  * Each packet holds a reference to the parent struct sip_pvt.
<span class="lineNum">    1220 </span>            :  * This structure is allocated in __sip_reliable_xmit() and only for packets that
<span class="lineNum">    1221 </span>            :  * require retransmissions.
<span class="lineNum">    1222 </span>            :  */
<span class="lineNum">    1223 </span>            : struct sip_pkt {
<span class="lineNum">    1224 </span>            :         struct sip_pkt *next;     /*!&lt; Next packet in linked list */
<span class="lineNum">    1225 </span>            :         int retrans;              /*!&lt; Retransmission number */
<span class="lineNum">    1226 </span>            :         int method;               /*!&lt; SIP method for this packet */
<span class="lineNum">    1227 </span>            :         uint32_t seqno;           /*!&lt; Sequence number */
<span class="lineNum">    1228 </span>            :         char is_resp;             /*!&lt; 1 if this is a response packet (e.g. 200 OK), 0 if it is a request */
<span class="lineNum">    1229 </span>            :         char is_fatal;            /*!&lt; non-zero if there is a fatal error */
<span class="lineNum">    1230 </span>            :         int response_code;        /*!&lt; If this is a response, the response code */
<span class="lineNum">    1231 </span>            :         struct sip_pvt *owner;    /*!&lt; Owner AST call */
<span class="lineNum">    1232 </span>            :         int retransid;            /*!&lt; Retransmission ID */
<span class="lineNum">    1233 </span>            :         int timer_a;              /*!&lt; SIP timer A, retransmission timer */
<span class="lineNum">    1234 </span>            :         int timer_t1;             /*!&lt; SIP Timer T1, estimated RTT or 500 ms */
<span class="lineNum">    1235 </span>            :         struct timeval time_sent;  /*!&lt; When pkt was sent */
<span class="lineNum">    1236 </span>            :         int64_t retrans_stop_time; /*!&lt; Time in ms after 'now' that retransmission must stop */
<span class="lineNum">    1237 </span>            :         int retrans_stop;         /*!&lt; Timeout is reached, stop retransmission  */
<span class="lineNum">    1238 </span>            :         struct ast_str *data;
<span class="lineNum">    1239 </span>            : };
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            : enum sip_mailbox_status {
<span class="lineNum">    1242 </span>            :         SIP_MAILBOX_STATUS_UNKNOWN = 0,
<span class="lineNum">    1243 </span>            :         SIP_MAILBOX_STATUS_EXISTING,
<span class="lineNum">    1244 </span>            :         SIP_MAILBOX_STATUS_NEW,
<span class="lineNum">    1245 </span>            : };
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span>            : /*!
<span class="lineNum">    1248 </span>            :  * \brief A peer's mailbox
<span class="lineNum">    1249 </span>            :  *
<span class="lineNum">    1250 </span>            :  * We could use STRINGFIELDS here, but for only one string, its
<span class="lineNum">    1251 </span>            :  * too much effort ...
<span class="lineNum">    1252 </span>            :  */
<span class="lineNum">    1253 </span>            : struct sip_mailbox {
<span class="lineNum">    1254 </span>            :         /*! Associated MWI subscription */
<span class="lineNum">    1255 </span>            :         struct stasis_subscription *event_sub;
<span class="lineNum">    1256 </span>            :         AST_LIST_ENTRY(sip_mailbox) entry;
<span class="lineNum">    1257 </span>            :         struct sip_peer *peer;
<span class="lineNum">    1258 </span>            :         enum sip_mailbox_status status;
<span class="lineNum">    1259 </span>            :         char id[1];
<span class="lineNum">    1260 </span>            : };
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            : /*! \brief Structure for SIP peer data, we place calls to peers if registered  or fixed IP address (host)
<span class="lineNum">    1263 </span>            : */
<span class="lineNum">    1264 </span>            : /* XXX field 'name' must be first otherwise sip_addrcmp() will fail, as will astobj2 hashing of the structure */
<span class="lineNum">    1265 </span>            : struct sip_peer {
<span class="lineNum">    1266 </span>            :         char name[80];                          /*!&lt; the unique name of this object */
<span class="lineNum">    1267 </span>            :         AST_DECLARE_STRING_FIELDS(
<span class="lineNum">    1268 </span>            :                 AST_STRING_FIELD(secret);       /*!&lt; Password for inbound auth */
<span class="lineNum">    1269 </span>            :                 AST_STRING_FIELD(md5secret);    /*!&lt; Password in MD5 */
<span class="lineNum">    1270 </span>            :                 AST_STRING_FIELD(description);  /*!&lt; Description of this peer */
<span class="lineNum">    1271 </span>            :                 AST_STRING_FIELD(remotesecret); /*!&lt; Remote secret (trunks, remote devices) */
<span class="lineNum">    1272 </span>            :                 AST_STRING_FIELD(context);      /*!&lt; Default context for incoming calls */
<span class="lineNum">    1273 </span>            :                 AST_STRING_FIELD(messagecontext); /*!&lt; Default context for outofcall messages. */
<span class="lineNum">    1274 </span>            :                 AST_STRING_FIELD(subscribecontext); /*!&lt; Default context for subscriptions */
<span class="lineNum">    1275 </span>            :                 AST_STRING_FIELD(username);     /*!&lt; Temporary username until registration */
<span class="lineNum">    1276 </span>            :                 AST_STRING_FIELD(accountcode);  /*!&lt; Account code */
<span class="lineNum">    1277 </span>            :                 AST_STRING_FIELD(tohost);       /*!&lt; If not dynamic, IP address */
<span class="lineNum">    1278 </span>            :                 AST_STRING_FIELD(regexten);     /*!&lt; Extension to register (if regcontext is used) */
<span class="lineNum">    1279 </span>            :                 AST_STRING_FIELD(fromuser);     /*!&lt; From: user when calling this peer */
<span class="lineNum">    1280 </span>            :                 AST_STRING_FIELD(fromdomain);   /*!&lt; From: domain when calling this peer */
<span class="lineNum">    1281 </span>            :                 AST_STRING_FIELD(fullcontact);  /*!&lt; Contact registered with us (not in sip.conf) */
<span class="lineNum">    1282 </span>            :                 AST_STRING_FIELD(cid_num);      /*!&lt; Caller ID num */
<span class="lineNum">    1283 </span>            :                 AST_STRING_FIELD(cid_name);     /*!&lt; Caller ID name */
<span class="lineNum">    1284 </span>            :                 AST_STRING_FIELD(cid_tag);      /*!&lt; Caller ID tag */
<span class="lineNum">    1285 </span>            :                 AST_STRING_FIELD(vmexten);      /*!&lt; Dialplan extension for MWI notify message*/
<span class="lineNum">    1286 </span>            :                 AST_STRING_FIELD(language);     /*!&lt;  Default language for prompts */
<span class="lineNum">    1287 </span>            :                 AST_STRING_FIELD(mohinterpret); /*!&lt;  Music on Hold class */
<span class="lineNum">    1288 </span>            :                 AST_STRING_FIELD(mohsuggest);   /*!&lt;  Music on Hold class */
<span class="lineNum">    1289 </span>            :                 AST_STRING_FIELD(parkinglot);   /*!&lt;  Parkinglot */
<span class="lineNum">    1290 </span>            :                 AST_STRING_FIELD(useragent);    /*!&lt;  User agent in SIP request (saved from registration) */
<span class="lineNum">    1291 </span>            :                 AST_STRING_FIELD(mwi_from);     /*!&lt; Name to place in From header for outgoing NOTIFY requests */
<span class="lineNum">    1292 </span>            :                 AST_STRING_FIELD(engine);       /*!&lt;  RTP Engine to use */
<span class="lineNum">    1293 </span>            :                 AST_STRING_FIELD(unsolicited_mailbox);  /*!&lt; Mailbox to store received unsolicited MWI NOTIFY messages information in */
<span class="lineNum">    1294 </span>            :                 AST_STRING_FIELD(zone);         /*!&lt; Tonezone for this device */
<span class="lineNum">    1295 </span>            :                 AST_STRING_FIELD(record_on_feature); /*!&lt; Feature to use when receiving INFO with record: on during a call */
<span class="lineNum">    1296 </span>            :                 AST_STRING_FIELD(record_off_feature); /*!&lt; Feature to use when receiving INFO with record: off during a call */
<span class="lineNum">    1297 </span>            :                 AST_STRING_FIELD(callback); /*!&lt; Callback extension */
<span class="lineNum">    1298 </span>            :                 );
<span class="lineNum">    1299 </span>            :         struct sip_socket socket;       /*!&lt; Socket used for this peer */
<span class="lineNum">    1300 </span>            :         enum ast_transport default_outbound_transport;   /*!&lt; Peer Registration may change the default outbound transport.
<span class="lineNum">    1301 </span>            :                                                              If register expires, default should be reset. to this value */
<span class="lineNum">    1302 </span>            :         /* things that don't belong in flags */
<span class="lineNum">    1303 </span>            :         unsigned short transports:5;    /*!&lt; Transports (enum ast_transport) that are acceptable for this peer */
<span class="lineNum">    1304 </span>            :         unsigned short is_realtime:1;   /*!&lt; this is a 'realtime' peer */
<span class="lineNum">    1305 </span>            :         unsigned short rt_fromcontact:1;/*!&lt; copy fromcontact from realtime */
<span class="lineNum">    1306 </span>            :         unsigned short host_dynamic:1;  /*!&lt; Dynamic Peers register with Asterisk */
<span class="lineNum">    1307 </span>            :         unsigned short selfdestruct:1;  /*!&lt; Automatic peers need to destruct themselves */
<span class="lineNum">    1308 </span>            :         unsigned short the_mark:1;      /*!&lt; That which bears the_mark should be deleted! */
<span class="lineNum">    1309 </span>            :         unsigned short autoframing:1;   /*!&lt; Whether to use our local configuration for frame sizes (off)
<span class="lineNum">    1310 </span>            :                                          *   or respect the other endpoint's request for frame sizes (on)
<span class="lineNum">    1311 </span>            :                                          *   for incoming calls
<span class="lineNum">    1312 </span>            :                                          */
<span class="lineNum">    1313 </span>            :         unsigned short deprecated_username:1; /*!&lt; If it's a realtime peer, are they using the deprecated &quot;username&quot; instead of &quot;defaultuser&quot; */
<span class="lineNum">    1314 </span>            :         struct sip_auth_container *auth;/*!&lt; Realm authentication credentials */
<span class="lineNum">    1315 </span>            :         int amaflags;                   /*!&lt; AMA Flags (for billing) */
<span class="lineNum">    1316 </span>            :         int callingpres;                /*!&lt; Calling id presentation */
<span class="lineNum">    1317 </span>            :         int inuse;                      /*!&lt; Number of calls in use */
<span class="lineNum">    1318 </span>            :         int ringing;                    /*!&lt; Number of calls ringing */
<span class="lineNum">    1319 </span>            :         int onhold;                     /*!&lt; Peer has someone on hold */
<span class="lineNum">    1320 </span>            :         int call_limit;                 /*!&lt; Limit of concurrent calls */
<span class="lineNum">    1321 </span>            :         unsigned int t38_maxdatagram;            /*!&lt; T.38 FaxMaxDatagram override */
<span class="lineNum">    1322 </span>            :         int busy_level;                 /*!&lt; Level of active channels where we signal busy */
<span class="lineNum">    1323 </span>            :         int maxforwards;                /*!&lt; SIP Loop prevention */
<span class="lineNum">    1324 </span>            :         enum transfermodes allowtransfer;   /*! SIP Refer restriction scheme */
<span class="lineNum">    1325 </span>            :         int lastmsgssent;                               /*!&lt; The last known VM message counts (new/old) */
<span class="lineNum">    1326 </span>            :         unsigned int sipoptions;        /*!&lt;  Supported SIP options */
<span class="lineNum">    1327 </span>            :         struct ast_flags flags[3];      /*!&lt;  SIP_ flags */
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            :         /*! Mailboxes that this peer cares about */
<span class="lineNum">    1330 </span>            :         AST_LIST_HEAD_NOLOCK(, sip_mailbox) mailboxes;
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            :         int maxcallbitrate;             /*!&lt;  Maximum Bitrate for a video call */
<span class="lineNum">    1333 </span>            :         int expire;                     /*!&lt;  When to expire this peer registration */
<span class="lineNum">    1334 </span>            :         struct ast_format_cap *caps;            /*!&lt;  Codec capability */
<span class="lineNum">    1335 </span>            :         int rtptimeout;                 /*!&lt;  RTP timeout */
<span class="lineNum">    1336 </span>            :         int rtpholdtimeout;             /*!&lt;  RTP Hold Timeout */
<span class="lineNum">    1337 </span>            :         int rtpkeepalive;               /*!&lt;  Send RTP packets for keepalive */
<span class="lineNum">    1338 </span>            :         ast_group_t callgroup;          /*!&lt;  Call group */
<span class="lineNum">    1339 </span>            :         ast_group_t pickupgroup;        /*!&lt;  Pickup group */
<span class="lineNum">    1340 </span>            :         struct ast_namedgroups *named_callgroups;   /*!&lt; Named call group */
<span class="lineNum">    1341 </span>            :         struct ast_namedgroups *named_pickupgroups; /*!&lt; Named pickup group */
<span class="lineNum">    1342 </span>            :         struct sip_proxy *outboundproxy;/*!&lt; Outbound proxy for this peer */
<span class="lineNum">    1343 </span>            :         struct ast_dnsmgr_entry *dnsmgr;/*!&lt;  DNS refresh manager for peer */
<span class="lineNum">    1344 </span>            :         struct ast_sockaddr addr;        /*!&lt;  IP address of peer */
<span class="lineNum">    1345 </span>            :         unsigned int portinuri:1;       /*!&lt; Whether the port should be included in the URI */
<span class="lineNum">    1346 </span>            :         struct sip_pvt *call;           /*!&lt;  Call pointer */
<span class="lineNum">    1347 </span>            :         int pokeexpire;                 /*!&lt;  Qualification: When to expire poke (qualify= checking) */
<span class="lineNum">    1348 </span>            :         int lastms;                     /*!&lt;  Qualification: How long last response took (in ms), or -1 for no response */
<span class="lineNum">    1349 </span>            :         int maxms;                      /*!&lt;  Qualification: Max ms we will accept for the host to be up, 0 to not monitor */
<span class="lineNum">    1350 </span>            :         int qualifyfreq;                /*!&lt;  Qualification: Qualification: How often to check for the host to be up */
<span class="lineNum">    1351 </span>            :         struct timeval ps;              /*!&lt;  Qualification: Time for sending SIP OPTION in sip_pke_peer() */
<span class="lineNum">    1352 </span>            :         int keepalive;                  /*!&lt;  Keepalive: How often to send keep alive packet */
<span class="lineNum">    1353 </span>            :         int keepalivesend;              /*!&lt;  Keepalive: Scheduled item for sending keep alive packet */
<span class="lineNum">    1354 </span>            :         struct ast_sockaddr defaddr;     /*!&lt;  Default IP address, used until registration */
<span class="lineNum">    1355 </span>            :         struct ast_acl_list *acl;              /*!&lt;  Access control list */
<span class="lineNum">    1356 </span>            :         struct ast_acl_list *contactacl;       /*!&lt;  Restrict what IPs are allowed in the Contact header (for registration) */
<span class="lineNum">    1357 </span>            :         struct ast_acl_list *directmediaacl;   /*!&lt;  Restrict what IPs are allowed to interchange direct media with */
<span class="lineNum">    1358 </span>            :         struct ast_variable *chanvars;  /*!&lt;  Variables to set for channel created by user */
<span class="lineNum">    1359 </span>            :         struct sip_pvt *mwipvt;         /*!&lt;  Subscription for MWI */
<span class="lineNum">    1360 </span>            :         struct sip_st_cfg stimer;       /*!&lt;  SIP Session-Timers */
<span class="lineNum">    1361 </span>            :         int timer_t1;                   /*!&lt;  The maximum T1 value for the peer */
<span class="lineNum">    1362 </span>            :         int timer_b;                    /*!&lt;  The maximum timer B (transaction timeouts) */
<span class="lineNum">    1363 </span>            :         int fromdomainport;             /*!&lt;  The From: domain port */
<span class="lineNum">    1364 </span>            :         struct sip_route path;          /*!&lt;  List of out-of-dialog outgoing routing steps (fm Path headers) */
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            :         /*XXX Seems like we suddenly have two flags with the same content. Why? To be continued... */
<span class="lineNum">    1367 </span>            :         enum sip_peer_type type; /*!&lt; Distinguish between &quot;user&quot; and &quot;peer&quot; types. This is used solely for CLI and manager commands */
<span class="lineNum">    1368 </span>            :         unsigned int disallowed_methods;
<span class="lineNum">    1369 </span>            :         struct ast_cc_config_params *cc_params;
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span>            :         struct ast_endpoint *endpoint;
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            :         struct ast_rtp_dtls_cfg dtls_cfg;
<span class="lineNum">    1374 </span>            : };
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span>            : /*!
<span class="lineNum">    1377 </span>            :  * \brief Registrations with other SIP proxies
<span class="lineNum">    1378 </span>            :  *
<span class="lineNum">    1379 </span>            :  * Created by sip_register(), the entry is linked in the 'regl' list,
<span class="lineNum">    1380 </span>            :  * and never deleted (other than at 'sip reload' or module unload times).
<span class="lineNum">    1381 </span>            :  * The entry always has a pending timeout, either waiting for an ACK to
<span class="lineNum">    1382 </span>            :  * the REGISTER message (in which case we have to retransmit the request),
<span class="lineNum">    1383 </span>            :  * or waiting for the next REGISTER message to be sent (either the initial one,
<span class="lineNum">    1384 </span>            :  * or once the previously completed registration one expires).
<span class="lineNum">    1385 </span>            :  * The registration can be in one of many states, though at the moment
<span class="lineNum">    1386 </span>            :  * the handling is a bit mixed.
<span class="lineNum">    1387 </span>            :  */
<span class="lineNum">    1388 </span>            : struct sip_registry {
<span class="lineNum">    1389 </span>            :         AST_DECLARE_STRING_FIELDS(
<span class="lineNum">    1390 </span>            :                 AST_STRING_FIELD(configvalue);/*!&lt; register string from config */
<span class="lineNum">    1391 </span>            :                 AST_STRING_FIELD(callid);     /*!&lt; Global Call-ID */
<span class="lineNum">    1392 </span>            :                 AST_STRING_FIELD(realm);      /*!&lt; Authorization realm */
<span class="lineNum">    1393 </span>            :                 AST_STRING_FIELD(nonce);      /*!&lt; Authorization nonce */
<span class="lineNum">    1394 </span>            :                 AST_STRING_FIELD(opaque);     /*!&lt; Opaque nonsense */
<span class="lineNum">    1395 </span>            :                 AST_STRING_FIELD(qop);        /*!&lt; Quality of Protection, since SIP wasn't complicated enough yet. */
<span class="lineNum">    1396 </span>            :                 AST_STRING_FIELD(authdomain); /*!&lt; Authorization domain */
<span class="lineNum">    1397 </span>            :                 AST_STRING_FIELD(regdomain);  /*!&lt; Registration doamin */
<span class="lineNum">    1398 </span>            :                 AST_STRING_FIELD(username);   /*!&lt; Who we are registering as */
<span class="lineNum">    1399 </span>            :                 AST_STRING_FIELD(authuser);   /*!&lt; Who we *authenticate* as */
<span class="lineNum">    1400 </span>            :                 AST_STRING_FIELD(hostname);   /*!&lt; Domain or host we register to */
<span class="lineNum">    1401 </span>            :                 AST_STRING_FIELD(secret);     /*!&lt; Password in clear text */
<span class="lineNum">    1402 </span>            :                 AST_STRING_FIELD(md5secret);  /*!&lt; Password in md5 */
<span class="lineNum">    1403 </span>            :                 AST_STRING_FIELD(callback);   /*!&lt; Contact extension */
<span class="lineNum">    1404 </span>            :                 AST_STRING_FIELD(peername);   /*!&lt; Peer registering to */
<span class="lineNum">    1405 </span>            :                 AST_STRING_FIELD(localtag);   /*!&lt; Local tag generated same time as callid */
<span class="lineNum">    1406 </span>            :         );
<span class="lineNum">    1407 </span>            :         enum ast_transport transport;   /*!&lt; Transport for this registration UDP, TCP or TLS */
<span class="lineNum">    1408 </span>            :         int portno;                     /*!&lt; Optional port override */
<span class="lineNum">    1409 </span>            :         int regdomainport;              /*!&lt; Port override for domainport */
<span class="lineNum">    1410 </span>            :         int expire;                     /*!&lt; Sched ID of expiration */
<span class="lineNum">    1411 </span>            :         int configured_expiry;          /*!&lt; Configured value to use for the Expires header */
<span class="lineNum">    1412 </span>            :         int expiry;             /*!&lt; Negotiated value used for the Expires header */
<span class="lineNum">    1413 </span>            :         int regattempts;        /*!&lt; Number of attempts (since the last success) */
<span class="lineNum">    1414 </span>            :         int timeout;            /*!&lt; sched id of sip_reg_timeout */
<span class="lineNum">    1415 </span>            :         int refresh;            /*!&lt; How often to refresh */
<span class="lineNum">    1416 </span>            :         struct sip_pvt *call;   /*!&lt; create a sip_pvt structure for each outbound &quot;registration dialog&quot; in progress */
<span class="lineNum">    1417 </span>            :         enum sipregistrystate regstate; /*!&lt; Registration state (see above) */
<span class="lineNum">    1418 </span>            :         struct timeval regtime;         /*!&lt; Last successful registration time */
<span class="lineNum">    1419 </span>            :         int callid_valid;       /*!&lt; 0 means we haven't chosen callid for this registry yet. */
<span class="lineNum">    1420 </span>            :         uint32_t ocseq;         /*!&lt; Sequence number we got to for REGISTERs for this registry */
<span class="lineNum">    1421 </span>            :         struct ast_dnsmgr_entry *dnsmgr;  /*!&lt;  DNS refresh manager for register */
<span class="lineNum">    1422 </span>            :         struct ast_sockaddr us;  /*!&lt; Who the server thinks we are */
<span class="lineNum">    1423 </span>            :         int noncecount;         /*!&lt; Nonce-count */
<span class="lineNum">    1424 </span>            :         char lastmsg[256];      /*!&lt; Last Message sent/received */
<span class="lineNum">    1425 </span>            : };
<span class="lineNum">    1426 </span>            : 
<span class="lineNum">    1427 </span>            : struct tcptls_packet {
<span class="lineNum">    1428 </span>            :         AST_LIST_ENTRY(tcptls_packet) entry;
<span class="lineNum">    1429 </span>            :         struct ast_str *data;
<span class="lineNum">    1430 </span>            :         size_t len;
<span class="lineNum">    1431 </span>            : };
<span class="lineNum">    1432 </span>            : /*! \brief Definition of a thread that handles a socket */
<span class="lineNum">    1433 </span>            : struct sip_threadinfo {
<span class="lineNum">    1434 </span>            :         /*! TRUE if the thread needs to kill itself.  (The module is being unloaded.) */
<span class="lineNum">    1435 </span>            :         int stop;
<span class="lineNum">    1436 </span>            :         int alert_pipe[2];          /*! Used to alert tcptls thread when packet is ready to be written */
<span class="lineNum">    1437 </span>            :         pthread_t threadid;
<span class="lineNum">    1438 </span>            :         struct ast_tcptls_session_instance *tcptls_session;
<span class="lineNum">    1439 </span>            :         enum ast_transport type;    /*!&lt; We keep a copy of the type here so we can display it in the connection list */
<span class="lineNum">    1440 </span>            :         AST_LIST_HEAD_NOLOCK(, tcptls_packet) packet_q;
<span class="lineNum">    1441 </span>            : };
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span>            : /*!
<span class="lineNum">    1444 </span>            :  * \brief Definition of an MWI subscription to another server
<span class="lineNum">    1445 </span>            :  */
<span class="lineNum">    1446 </span>            : struct sip_subscription_mwi {
<span class="lineNum">    1447 </span>            :         AST_DECLARE_STRING_FIELDS(
<span class="lineNum">    1448 </span>            :                 AST_STRING_FIELD(username);     /*!&lt; Who we are sending the subscription as */
<span class="lineNum">    1449 </span>            :                 AST_STRING_FIELD(authuser);     /*!&lt; Who we *authenticate* as */
<span class="lineNum">    1450 </span>            :                 AST_STRING_FIELD(hostname);     /*!&lt; Domain or host we subscribe to */
<span class="lineNum">    1451 </span>            :                 AST_STRING_FIELD(secret);       /*!&lt; Password in clear text */
<span class="lineNum">    1452 </span>            :                 AST_STRING_FIELD(mailbox);      /*!&lt; Mailbox store to put MWI into */
<span class="lineNum">    1453 </span>            :                 );
<span class="lineNum">    1454 </span>            :         enum ast_transport transport;    /*!&lt; Transport to use */
<span class="lineNum">    1455 </span>            :         int portno;                      /*!&lt; Optional port override */
<span class="lineNum">    1456 </span>            :         int resub;                       /*!&lt; Sched ID of resubscription */
<span class="lineNum">    1457 </span>            :         unsigned int subscribed:1;       /*!&lt; Whether we are currently subscribed or not */
<span class="lineNum">    1458 </span>            :         struct sip_pvt *call;            /*!&lt; Outbound subscription dialog */
<span class="lineNum">    1459 </span>            :         struct ast_dnsmgr_entry *dnsmgr; /*!&lt; DNS refresh manager for subscription */
<span class="lineNum">    1460 </span>            :         struct ast_sockaddr us;           /*!&lt; Who the server thinks we are */
<span class="lineNum">    1461 </span>            : };
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span>            : /*!
<span class="lineNum">    1464 </span>            :  * SIP PUBLISH support!
<span class="lineNum">    1465 </span>            :  * PUBLISH support was added to chan_sip due to its use in the call-completion
<span class="lineNum">    1466 </span>            :  * event package. In order to suspend and unsuspend monitoring of a called party,
<span class="lineNum">    1467 </span>            :  * a PUBLISH message must be sent. Rather than try to hack in PUBLISH transmission
<span class="lineNum">    1468 </span>            :  * and reception solely for the purposes of handling call-completion-related messages,
<span class="lineNum">    1469 </span>            :  * an effort has been made to create a generic framework for handling PUBLISH messages.
<span class="lineNum">    1470 </span>            :  *
<span class="lineNum">    1471 </span>            :  * There are two main components to the effort, the event publication agent (EPA) and
<span class="lineNum">    1472 </span>            :  * the event state compositor (ESC). Both of these terms appear in RFC 3903, and the
<span class="lineNum">    1473 </span>            :  * implementation in Asterisk conforms to the defintions there. An EPA is a UAC that
<span class="lineNum">    1474 </span>            :  * transmits PUBLISH requests. An ESC is a UAS that receives PUBLISH requests and
<span class="lineNum">    1475 </span>            :  * acts appropriately based on the content of those requests.
<span class="lineNum">    1476 </span>            :  *
<span class="lineNum">    1477 </span>            :  * ESC:
<span class="lineNum">    1478 </span>            :  * The main structure in chan_sip is the event_state_compositor. There is an
<span class="lineNum">    1479 </span>            :  * event_state_compositor structure for each event package supported (as of Nov 2009
<span class="lineNum">    1480 </span>            :  * this is only the call-completion package). The structure contains data which is
<span class="lineNum">    1481 </span>            :  * intrinsic to the event package itself, such as the name of the package and a set
<span class="lineNum">    1482 </span>            :  * of callbacks for handling incoming PUBLISH requests. In addition, the
<span class="lineNum">    1483 </span>            :  * event_state_compositor struct contains an ao2_container of sip_esc_entries.
<span class="lineNum">    1484 </span>            :  *
<span class="lineNum">    1485 </span>            :  * A sip_esc_entry corresponds to an entity which has sent a PUBLISH to Asterisk. We are
<span class="lineNum">    1486 </span>            :  * able to match the incoming PUBLISH to a sip_esc_entry using the Sip-If-Match header
<span class="lineNum">    1487 </span>            :  * of the message. Of course, if none is present, then a new sip_esc_entry will be created.
<span class="lineNum">    1488 </span>            :  *
<span class="lineNum">    1489 </span>            :  * Once it is determined what type of PUBLISH request has come in (from RFC 3903, it may
<span class="lineNum">    1490 </span>            :  * be an initial, modify, refresh, or remove), then the event package-specific callbacks
<span class="lineNum">    1491 </span>            :  * may be called. If your event package doesn't need to take any specific action for a
<span class="lineNum">    1492 </span>            :  * specific PUBLISH type, it is perfectly safe to not define the callback at all. The callback
<span class="lineNum">    1493 </span>            :  * only needs to take care of application-specific information. If there is a problem, it is
<span class="lineNum">    1494 </span>            :  * up to the callback to take care of sending an appropriate 4xx or 5xx response code. In such
<span class="lineNum">    1495 </span>            :  * a case, the callback should return -1. This will tell the function that called the handler
<span class="lineNum">    1496 </span>            :  * that an appropriate error response has been sent. If the callback returns 0, however, then
<span class="lineNum">    1497 </span>            :  * the caller of the callback will generate a new entity tag and send a 200 OK response.
<span class="lineNum">    1498 </span>            :  *
<span class="lineNum">    1499 </span>            :  * ESC entries are reference-counted, however as an implementor of a specific event package,
<span class="lineNum">    1500 </span>            :  * this should be transparent, since the reference counts are handled by the general ESC
<span class="lineNum">    1501 </span>            :  * framework.
<span class="lineNum">    1502 </span>            :  *
<span class="lineNum">    1503 </span>            :  * EPA:
<span class="lineNum">    1504 </span>            :  * The event publication agent in chan_sip is structured quite a bit differently than the
<span class="lineNum">    1505 </span>            :  * ESC. With an ESC, an appropriate entry has to be found based on the contents of an incoming
<span class="lineNum">    1506 </span>            :  * PUBLISH message. With an EPA, the application interested in sending the PUBLISH can maintain
<span class="lineNum">    1507 </span>            :  * a reference to the appropriate EPA entry instead. Similarly, when matching a PUBLISH response
<span class="lineNum">    1508 </span>            :  * to an appropriate EPA entry, the sip_pvt can maintain a reference to the corresponding
<span class="lineNum">    1509 </span>            :  * EPA entry. The result of this train of thought is that there is no compelling reason to
<span class="lineNum">    1510 </span>            :  * maintain a container of these entries.
<span class="lineNum">    1511 </span>            :  *
<span class="lineNum">    1512 </span>            :  * Instead, there is only the sip_epa_entry structure. Every sip_epa_entry has an entity tag
<span class="lineNum">    1513 </span>            :  * that it maintains so that subsequent PUBLISH requests will be identifiable by the ESC on
<span class="lineNum">    1514 </span>            :  * the far end. In addition, there is a static_data field which contains information that is
<span class="lineNum">    1515 </span>            :  * common to all sip_epa_entries for a specific event package. This static data includes the
<span class="lineNum">    1516 </span>            :  * name of the event package and callbacks for handling specific responses for outgoing PUBLISHes.
<span class="lineNum">    1517 </span>            :  * Also, there is a field for pointing to instance-specific data. This can include the current
<span class="lineNum">    1518 </span>            :  * published state or other identifying information that is specific to an instance of an EPA
<span class="lineNum">    1519 </span>            :  * entry of a particular event package.
<span class="lineNum">    1520 </span>            :  *
<span class="lineNum">    1521 </span>            :  * When an application wishes to send a PUBLISH request, it simply will call create_epa_entry,
<span class="lineNum">    1522 </span>            :  * followed by transmit_publish in order to send the PUBLISH. That's all that is necessary.
<span class="lineNum">    1523 </span>            :  * Like with ESC entries, sip_epa_entries are reference counted. Unlike ESC entries, though,
<span class="lineNum">    1524 </span>            :  * sip_epa_entries reference counts have to be maintained to some degree by the application making
<span class="lineNum">    1525 </span>            :  * use of the sip_epa_entry. The application will acquire a reference to the EPA entry when it
<span class="lineNum">    1526 </span>            :  * calls create_epa_entry. When the application has finished using the EPA entry (which may not
<span class="lineNum">    1527 </span>            :  * be until after several PUBLISH transactions have taken place) it must use ao2_ref to decrease
<span class="lineNum">    1528 </span>            :  * the reference count by 1.
<span class="lineNum">    1529 </span>            :  */
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span>            : /*!
<span class="lineNum">    1532 </span>            :  * \brief The states that can be represented in a SIP call-completion PUBLISH
<span class="lineNum">    1533 </span>            :  */
<span class="lineNum">    1534 </span>            : enum sip_cc_publish_state {
<span class="lineNum">    1535 </span>            :         /*! Closed, i.e. unavailable */
<span class="lineNum">    1536 </span>            :         CC_CLOSED,
<span class="lineNum">    1537 </span>            :         /*! Open, i.e. available */
<span class="lineNum">    1538 </span>            :         CC_OPEN,
<span class="lineNum">    1539 </span>            : };
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span>            : /*!
<span class="lineNum">    1542 </span>            :  * \brief The states that can be represented in a SIP call-completion NOTIFY
<span class="lineNum">    1543 </span>            :  */
<span class="lineNum">    1544 </span>            : enum sip_cc_notify_state {
<span class="lineNum">    1545 </span>            :         /*! Queued, i.e. unavailable */
<span class="lineNum">    1546 </span>            :         CC_QUEUED,
<span class="lineNum">    1547 </span>            :         /*! Ready, i.e. available */
<span class="lineNum">    1548 </span>            :         CC_READY,
<span class="lineNum">    1549 </span>            : };
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span>            : /*!
<span class="lineNum">    1552 </span>            :  * \brief The types of PUBLISH messages defined in RFC 3903
<span class="lineNum">    1553 </span>            :  */
<span class="lineNum">    1554 </span>            : enum sip_publish_type {
<span class="lineNum">    1555 </span>            :         /*!
<span class="lineNum">    1556 </span>            :          * \brief Unknown
<span class="lineNum">    1557 </span>            :          *
<span class="lineNum">    1558 </span>            :          * \details
<span class="lineNum">    1559 </span>            :          * This actually is not defined in RFC 3903. We use this as a constant
<span class="lineNum">    1560 </span>            :          * to indicate that an incoming PUBLISH does not fit into any of the
<span class="lineNum">    1561 </span>            :          * other categories and is thus invalid.
<span class="lineNum">    1562 </span>            :          */
<span class="lineNum">    1563 </span>            :         SIP_PUBLISH_UNKNOWN,
<span class="lineNum">    1564 </span>            :         /*!
<span class="lineNum">    1565 </span>            :          * \brief Initial
<span class="lineNum">    1566 </span>            :          *
<span class="lineNum">    1567 </span>            :          * \details
<span class="lineNum">    1568 </span>            :          * The first PUBLISH sent. This will contain a non-zero Expires header
<span class="lineNum">    1569 </span>            :          * as well as a body that indicates the current state of the endpoint
<span class="lineNum">    1570 </span>            :          * that has sent the message. The initial PUBLISH is the only type
<span class="lineNum">    1571 </span>            :          * of PUBLISH to not contain a Sip-If-Match header in it.
<span class="lineNum">    1572 </span>            :          */
<span class="lineNum">    1573 </span>            :         SIP_PUBLISH_INITIAL,
<span class="lineNum">    1574 </span>            :         /*!
<span class="lineNum">    1575 </span>            :          * \brief Refresh
<span class="lineNum">    1576 </span>            :          *
<span class="lineNum">    1577 </span>            :          * \details
<span class="lineNum">    1578 </span>            :          * Used to keep a published state from expiring. This will contain a
<span class="lineNum">    1579 </span>            :          * non-zero Expires header but no body since its purpose is not to
<span class="lineNum">    1580 </span>            :          * update state.
<span class="lineNum">    1581 </span>            :          */
<span class="lineNum">    1582 </span>            :         SIP_PUBLISH_REFRESH,
<span class="lineNum">    1583 </span>            :         /*!
<span class="lineNum">    1584 </span>            :          * \brief Modify
<span class="lineNum">    1585 </span>            :          *
<span class="lineNum">    1586 </span>            :          * \details
<span class="lineNum">    1587 </span>            :          * Used to change state from its previous value. This will contain
<span class="lineNum">    1588 </span>            :          * a body updating the published state. May or may not contain an
<span class="lineNum">    1589 </span>            :          * Expires header.
<span class="lineNum">    1590 </span>            :          */
<span class="lineNum">    1591 </span>            :         SIP_PUBLISH_MODIFY,
<span class="lineNum">    1592 </span>            :         /*!
<span class="lineNum">    1593 </span>            :          * \brief Remove
<span class="lineNum">    1594 </span>            :          *
<span class="lineNum">    1595 </span>            :          * \details
<span class="lineNum">    1596 </span>            :          * Used to remove published state from an ESC. This will contain
<span class="lineNum">    1597 </span>            :          * an Expires header set to 0 and likely no body.
<span class="lineNum">    1598 </span>            :          */
<span class="lineNum">    1599 </span>            :         SIP_PUBLISH_REMOVE,
<span class="lineNum">    1600 </span>            : };
<span class="lineNum">    1601 </span>            : 
<span class="lineNum">    1602 </span>            : /*!
<span class="lineNum">    1603 </span>            :  * Data which is the same for all instances of an EPA for a
<span class="lineNum">    1604 </span>            :  * particular event package
<span class="lineNum">    1605 </span>            :  */
<span class="lineNum">    1606 </span>            : struct epa_static_data {
<span class="lineNum">    1607 </span>            :         /*! The event type */
<span class="lineNum">    1608 </span>            :         enum subscriptiontype event;
<span class="lineNum">    1609 </span>            :         /*!
<span class="lineNum">    1610 </span>            :          * The name of the event as it would
<span class="lineNum">    1611 </span>            :          * appear in a SIP message
<span class="lineNum">    1612 </span>            :          */
<span class="lineNum">    1613 </span>            :         const char *name;
<span class="lineNum">    1614 </span>            :         /*!
<span class="lineNum">    1615 </span>            :          * The callback called when a 200 OK is received on an outbound PUBLISH
<span class="lineNum">    1616 </span>            :          */
<span class="lineNum">    1617 </span>            :         void (*handle_ok)(struct sip_pvt *, struct sip_request *, struct sip_epa_entry *);
<span class="lineNum">    1618 </span>            :         /*!
<span class="lineNum">    1619 </span>            :          * The callback called when an error response is received on an outbound PUBLISH
<span class="lineNum">    1620 </span>            :          */
<span class="lineNum">    1621 </span>            :         void (*handle_error)(struct sip_pvt *, const int resp, struct sip_request *, struct sip_epa_entry *);
<span class="lineNum">    1622 </span>            :         /*!
<span class="lineNum">    1623 </span>            :          * Destructor to call to clean up instance data
<span class="lineNum">    1624 </span>            :          */
<span class="lineNum">    1625 </span>            :         void (*destructor)(void *instance_data);
<span class="lineNum">    1626 </span>            : };
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span>            : /*!
<span class="lineNum">    1629 </span>            :  * \brief backend for an event publication agent
<span class="lineNum">    1630 </span>            :  */
<span class="lineNum">    1631 </span>            : struct epa_backend {
<span class="lineNum">    1632 </span>            :         const struct epa_static_data *static_data;
<span class="lineNum">    1633 </span>            :         AST_LIST_ENTRY(epa_backend) next;
<span class="lineNum">    1634 </span>            : };
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span>            : struct sip_epa_entry {
<span class="lineNum">    1637 </span>            :         /*!
<span class="lineNum">    1638 </span>            :          * When we are going to send a publish, we need to
<span class="lineNum">    1639 </span>            :          * know the type of PUBLISH to send.
<span class="lineNum">    1640 </span>            :          */
<span class="lineNum">    1641 </span>            :         enum sip_publish_type publish_type;
<span class="lineNum">    1642 </span>            :         /*!
<span class="lineNum">    1643 </span>            :          * When we send a PUBLISH, we have to be
<span class="lineNum">    1644 </span>            :          * sure to include the entity tag that we
<span class="lineNum">    1645 </span>            :          * received in the previous response.
<span class="lineNum">    1646 </span>            :          */
<span class="lineNum">    1647 </span>            :         char entity_tag[SIPBUFSIZE];
<span class="lineNum">    1648 </span>            :         /*!
<span class="lineNum">    1649 </span>            :          * The destination to which this EPA should send
<span class="lineNum">    1650 </span>            :          * PUBLISHes. This may be the name of a SIP peer
<span class="lineNum">    1651 </span>            :          * or a hostname.
<span class="lineNum">    1652 </span>            :          */
<span class="lineNum">    1653 </span>            :         char destination[SIPBUFSIZE];
<span class="lineNum">    1654 </span>            :         /*!
<span class="lineNum">    1655 </span>            :          * The body of the most recently-sent PUBLISH message.
<span class="lineNum">    1656 </span>            :          * This is useful for situations such as authentication,
<span class="lineNum">    1657 </span>            :          * in which we must send a message identical to the
<span class="lineNum">    1658 </span>            :          * one previously sent
<span class="lineNum">    1659 </span>            :          */
<span class="lineNum">    1660 </span>            :         char body[SIPBUFSIZE];
<span class="lineNum">    1661 </span>            :         /*!
<span class="lineNum">    1662 </span>            :          * Every event package has some constant data and
<span class="lineNum">    1663 </span>            :          * callbacks that all instances will share. This
<span class="lineNum">    1664 </span>            :          * data resides in this field.
<span class="lineNum">    1665 </span>            :          */
<span class="lineNum">    1666 </span>            :         const struct epa_static_data *static_data;
<span class="lineNum">    1667 </span>            :         /*!
<span class="lineNum">    1668 </span>            :          * In addition to the static data that all instances
<span class="lineNum">    1669 </span>            :          * of sip_epa_entry will have, each instance will
<span class="lineNum">    1670 </span>            :          * require its own instance-specific data.
<span class="lineNum">    1671 </span>            :          */
<span class="lineNum">    1672 </span>            :         void *instance_data;
<span class="lineNum">    1673 </span>            : };
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span>            : /*!
<span class="lineNum">    1676 </span>            :  * \brief Instance data for a Call completion EPA entry
<span class="lineNum">    1677 </span>            :  */
<span class="lineNum">    1678 </span>            : struct cc_epa_entry {
<span class="lineNum">    1679 </span>            :         /*!
<span class="lineNum">    1680 </span>            :          * The core ID of the CC transaction
<span class="lineNum">    1681 </span>            :          * for which this EPA entry belongs. This
<span class="lineNum">    1682 </span>            :          * essentially acts as a unique identifier
<span class="lineNum">    1683 </span>            :          * for the entry and is used in the hash
<span class="lineNum">    1684 </span>            :          * and comparison functions
<span class="lineNum">    1685 </span>            :          */
<span class="lineNum">    1686 </span>            :         int core_id;
<span class="lineNum">    1687 </span>            :         /*!
<span class="lineNum">    1688 </span>            :          * We keep the last known state of the
<span class="lineNum">    1689 </span>            :          * device in question handy in case
<span class="lineNum">    1690 </span>            :          * it needs to be known by a third party.
<span class="lineNum">    1691 </span>            :          * Also, in the case where for some reason
<span class="lineNum">    1692 </span>            :          * we get asked to transmit state that we
<span class="lineNum">    1693 </span>            :          * already sent, we can just ignore the
<span class="lineNum">    1694 </span>            :          * request.
<span class="lineNum">    1695 </span>            :          */
<span class="lineNum">    1696 </span>            :         enum sip_cc_publish_state current_state;
<span class="lineNum">    1697 </span>            : };
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            : struct event_state_compositor;
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span>            : /*!
<span class="lineNum">    1702 </span>            :  * \brief common ESC items for all event types
<span class="lineNum">    1703 </span>            :  *
<span class="lineNum">    1704 </span>            :  * The entity_id field serves as a means by which
<span class="lineNum">    1705 </span>            :  * A specific entry may be found.
<span class="lineNum">    1706 </span>            :  */
<span class="lineNum">    1707 </span>            : struct sip_esc_entry {
<span class="lineNum">    1708 </span>            :         /*!
<span class="lineNum">    1709 </span>            :          * The name of the party who
<span class="lineNum">    1710 </span>            :          * sent us the PUBLISH. This will more
<span class="lineNum">    1711 </span>            :          * than likely correspond to a peer name.
<span class="lineNum">    1712 </span>            :          *
<span class="lineNum">    1713 </span>            :          * This field's utility isn't really that
<span class="lineNum">    1714 </span>            :          * great. It's mainly just a user-recognizable
<span class="lineNum">    1715 </span>            :          * handle that can be printed in debug messages.
<span class="lineNum">    1716 </span>            :          */
<span class="lineNum">    1717 </span>            :         const char *device_name;
<span class="lineNum">    1718 </span>            :         /*!
<span class="lineNum">    1719 </span>            :          * The event package for which this esc_entry
<span class="lineNum">    1720 </span>            :          * exists. Most of the time this isn't really
<span class="lineNum">    1721 </span>            :          * necessary since you'll have easy access to the
<span class="lineNum">    1722 </span>            :          * ESC which contains this entry. However, in
<span class="lineNum">    1723 </span>            :          * some circumstances, we won't have the ESC
<span class="lineNum">    1724 </span>            :          * available.
<span class="lineNum">    1725 </span>            :          */
<span class="lineNum">    1726 </span>            :         const char *event;
<span class="lineNum">    1727 </span>            :         /*!
<span class="lineNum">    1728 </span>            :          * The entity ID used when corresponding
<span class="lineNum">    1729 </span>            :          * with the EPA on the other side. As the
<span class="lineNum">    1730 </span>            :          * ESC, we generate an entity ID for each
<span class="lineNum">    1731 </span>            :          * received PUBLISH and store it in this
<span class="lineNum">    1732 </span>            :          * structure.
<span class="lineNum">    1733 </span>            :          */
<span class="lineNum">    1734 </span>            :         char entity_tag[30];
<span class="lineNum">    1735 </span>            :         /*!
<span class="lineNum">    1736 </span>            :          * The ID for the scheduler. We schedule
<span class="lineNum">    1737 </span>            :          * destruction of a sip_esc_entry when we
<span class="lineNum">    1738 </span>            :          * receive a PUBLISH. The destruction is
<span class="lineNum">    1739 </span>            :          * scheduled for the duration received in
<span class="lineNum">    1740 </span>            :          * the Expires header.
<span class="lineNum">    1741 </span>            :          */
<span class="lineNum">    1742 </span>            :         int sched_id;
<span class="lineNum">    1743 </span>            :         /*!
<span class="lineNum">    1744 </span>            :          * Each ESC entry will be for a specific
<span class="lineNum">    1745 </span>            :          * event type. Those entries will need to
<span class="lineNum">    1746 </span>            :          * carry data which is intrinsic to the
<span class="lineNum">    1747 </span>            :          * ESC entry but which is specific to
<span class="lineNum">    1748 </span>            :          * the event package
<span class="lineNum">    1749 </span>            :          */
<span class="lineNum">    1750 </span>            :         void *event_specific_data;
<span class="lineNum">    1751 </span>            : };
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span>            : typedef int (* const esc_publish_callback)(struct sip_pvt *, struct sip_request *, struct event_state_compositor *, struct sip_esc_entry *);
<span class="lineNum">    1754 </span>            : 
<span class="lineNum">    1755 </span>            : /*!
<span class="lineNum">    1756 </span>            :  * \brief Callbacks for SIP ESCs
<span class="lineNum">    1757 </span>            :  *
<span class="lineNum">    1758 </span>            :  * \details
<span class="lineNum">    1759 </span>            :  * The names of the callbacks are self-explanatory. The
<span class="lineNum">    1760 </span>            :  * corresponding handler is called whenever the specific
<span class="lineNum">    1761 </span>            :  * type of PUBLISH is received.
<span class="lineNum">    1762 </span>            :  */
<span class="lineNum">    1763 </span>            : struct sip_esc_publish_callbacks {
<span class="lineNum">    1764 </span>            :         const esc_publish_callback initial_handler;
<span class="lineNum">    1765 </span>            :         const esc_publish_callback refresh_handler;
<span class="lineNum">    1766 </span>            :         const esc_publish_callback modify_handler;
<span class="lineNum">    1767 </span>            :         const esc_publish_callback remove_handler;
<span class="lineNum">    1768 </span>            : };
<span class="lineNum">    1769 </span>            : 
<span class="lineNum">    1770 </span>            : struct sip_cc_agent_pvt {
<span class="lineNum">    1771 </span>            :         int offer_timer_id;
<span class="lineNum">    1772 </span>            :         /* A copy of the original call's Call-ID.
<span class="lineNum">    1773 </span>            :          * We use this as a search key when attempting
<span class="lineNum">    1774 </span>            :          * to find a particular sip_pvt.
<span class="lineNum">    1775 </span>            :          */
<span class="lineNum">    1776 </span>            :         char original_callid[SIPBUFSIZE];
<span class="lineNum">    1777 </span>            :         /* A copy of the exten called originally.
<span class="lineNum">    1778 </span>            :          * We use this to set the proper extension
<span class="lineNum">    1779 </span>            :          * to dial during the recall since the incoming
<span class="lineNum">    1780 </span>            :          * request URI is one that was generated just
<span class="lineNum">    1781 </span>            :          * for the recall
<span class="lineNum">    1782 </span>            :          */
<span class="lineNum">    1783 </span>            :         char original_exten[SIPBUFSIZE];
<span class="lineNum">    1784 </span>            :         /* A reference to the dialog which we will
<span class="lineNum">    1785 </span>            :          * be sending a NOTIFY on when it comes time
<span class="lineNum">    1786 </span>            :          * to send one
<span class="lineNum">    1787 </span>            :          */
<span class="lineNum">    1788 </span>            :         struct sip_pvt *subscribe_pvt;
<span class="lineNum">    1789 </span>            :         /* When we send a NOTIFY, we include a URI
<span class="lineNum">    1790 </span>            :          * that should be used by the caller when he
<span class="lineNum">    1791 </span>            :          * wishes to send a PUBLISH or INVITE to us.
<span class="lineNum">    1792 </span>            :          * We store that URI here.
<span class="lineNum">    1793 </span>            :          */
<span class="lineNum">    1794 </span>            :         char notify_uri[SIPBUFSIZE];
<span class="lineNum">    1795 </span>            :         /* When we advertise call completion to a caller,
<span class="lineNum">    1796 </span>            :          * we provide a URI for the caller to use when
<span class="lineNum">    1797 </span>            :          * he sends us a SUBSCRIBE. We store it for matching
<span class="lineNum">    1798 </span>            :          * purposes when we receive the SUBSCRIBE from the
<span class="lineNum">    1799 </span>            :          * caller.
<span class="lineNum">    1800 </span>            :          */
<span class="lineNum">    1801 </span>            :         char subscribe_uri[SIPBUFSIZE];
<span class="lineNum">    1802 </span>            :         char is_available;
<span class="lineNum">    1803 </span>            : };
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span>            : struct sip_monitor_instance {
<span class="lineNum">    1806 </span>            :         AST_DECLARE_STRING_FIELDS(
<span class="lineNum">    1807 </span>            :                 AST_STRING_FIELD(subscribe_uri);
<span class="lineNum">    1808 </span>            :                 AST_STRING_FIELD(notify_uri);
<span class="lineNum">    1809 </span>            :                 AST_STRING_FIELD(peername);
<span class="lineNum">    1810 </span>            :                 AST_STRING_FIELD(device_name);
<span class="lineNum">    1811 </span>            :         );
<span class="lineNum">    1812 </span>            :         int core_id;
<span class="lineNum">    1813 </span>            :         struct sip_pvt *subscription_pvt;
<span class="lineNum">    1814 </span>            :         struct sip_epa_entry *suspension_entry;
<span class="lineNum">    1815 </span>            : };
<span class="lineNum">    1816 </span>            : 
<span class="lineNum">    1817 </span>            : /*! \brief List of well-known SIP options. If we get this in a require,
<span class="lineNum">    1818 </span>            :    we should check the list and answer accordingly. */
<span class="lineNum">    1819 </span>            : static const struct cfsip_options {
<span class="lineNum">    1820 </span>            :         int id;             /*!&lt; Bitmap ID */
<span class="lineNum">    1821 </span>            :         int supported;      /*!&lt; Supported by Asterisk ? */
<span class="lineNum">    1822 </span>            :         char * const text;  /*!&lt; Text id, as in standard */
<span class="lineNum">    1823 </span>            : } sip_options[] = {     /* XXX used in 3 places */
<span class="lineNum">    1824 </span>            :         /* RFC3262: PRACK 100% reliability */
<span class="lineNum">    1825 </span>            :         { SIP_OPT_100REL,       NOT_SUPPORTED,  &quot;100rel&quot; },
<span class="lineNum">    1826 </span>            :         /* RFC3959: SIP Early session support */
<span class="lineNum">    1827 </span>            :         { SIP_OPT_EARLY_SESSION, NOT_SUPPORTED, &quot;early-session&quot; },
<span class="lineNum">    1828 </span>            :         /* SIMPLE events:  RFC4662 */
<span class="lineNum">    1829 </span>            :         { SIP_OPT_EVENTLIST,    NOT_SUPPORTED,  &quot;eventlist&quot; },
<span class="lineNum">    1830 </span>            :         /* RFC 4916- Connected line ID updates */
<span class="lineNum">    1831 </span>            :         { SIP_OPT_FROMCHANGE,   NOT_SUPPORTED,  &quot;from-change&quot; },
<span class="lineNum">    1832 </span>            :         /* GRUU: Globally Routable User Agent URI's */
<span class="lineNum">    1833 </span>            :         { SIP_OPT_GRUU,         NOT_SUPPORTED,  &quot;gruu&quot; },
<span class="lineNum">    1834 </span>            :         /* RFC4244 History info */
<span class="lineNum">    1835 </span>            :         { SIP_OPT_HISTINFO,     NOT_SUPPORTED,  &quot;histinfo&quot; },
<span class="lineNum">    1836 </span>            :         /* RFC3911: SIP Join header support */
<span class="lineNum">    1837 </span>            :         { SIP_OPT_JOIN,         NOT_SUPPORTED,  &quot;join&quot; },
<span class="lineNum">    1838 </span>            :         /* Disable the REFER subscription, RFC 4488 */
<span class="lineNum">    1839 </span>            :         { SIP_OPT_NOREFERSUB,   NOT_SUPPORTED,  &quot;norefersub&quot; },
<span class="lineNum">    1840 </span>            :         /* SIP outbound - the final NAT battle - draft-sip-outbound */
<span class="lineNum">    1841 </span>            :         { SIP_OPT_OUTBOUND,     NOT_SUPPORTED,  &quot;outbound&quot; },
<span class="lineNum">    1842 </span>            :         /* RFC3327: Path support */
<span class="lineNum">    1843 </span>            :         { SIP_OPT_PATH,         NOT_SUPPORTED,  &quot;path&quot; },
<span class="lineNum">    1844 </span>            :         /* RFC3840: Callee preferences */
<span class="lineNum">    1845 </span>            :         { SIP_OPT_PREF,         NOT_SUPPORTED,  &quot;pref&quot; },
<span class="lineNum">    1846 </span>            :         /* RFC3312: Precondition support */
<span class="lineNum">    1847 </span>            :         { SIP_OPT_PRECONDITION, NOT_SUPPORTED,  &quot;precondition&quot; },
<span class="lineNum">    1848 </span>            :         /* RFC3323: Privacy with proxies*/
<span class="lineNum">    1849 </span>            :         { SIP_OPT_PRIVACY,      NOT_SUPPORTED,  &quot;privacy&quot; },
<span class="lineNum">    1850 </span>            :         /* RFC-ietf-sip-uri-list-conferencing-02.txt conference invite lists */
<span class="lineNum">    1851 </span>            :         { SIP_OPT_RECLISTINV,   NOT_SUPPORTED,  &quot;recipient-list-invite&quot; },
<span class="lineNum">    1852 </span>            :         /* RFC-ietf-sip-uri-list-subscribe-02.txt - subscription lists */
<span class="lineNum">    1853 </span>            :         { SIP_OPT_RECLISTSUB,   NOT_SUPPORTED,  &quot;recipient-list-subscribe&quot; },
<span class="lineNum">    1854 </span>            :         /* RFC3891: Replaces: header for transfer */
<span class="lineNum">    1855 </span>            :         { SIP_OPT_REPLACES,     SUPPORTED,      &quot;replaces&quot; },
<span class="lineNum">    1856 </span>            :         /* One version of Polycom firmware has the wrong label */
<span class="lineNum">    1857 </span>            :         { SIP_OPT_REPLACES,     SUPPORTED,      &quot;replace&quot; },
<span class="lineNum">    1858 </span>            :         /* RFC4412 Resource priorities */
<span class="lineNum">    1859 </span>            :         { SIP_OPT_RESPRIORITY,  NOT_SUPPORTED,  &quot;resource-priority&quot; },
<span class="lineNum">    1860 </span>            :         /* RFC3329: Security agreement mechanism */
<span class="lineNum">    1861 </span>            :         { SIP_OPT_SEC_AGREE,    NOT_SUPPORTED,  &quot;sec_agree&quot; },
<span class="lineNum">    1862 </span>            :         /* RFC4092: Usage of the SDP ANAT Semantics in the SIP */
<span class="lineNum">    1863 </span>            :         { SIP_OPT_SDP_ANAT,     NOT_SUPPORTED,  &quot;sdp-anat&quot; },
<span class="lineNum">    1864 </span>            :         /* RFC4028: SIP Session-Timers */
<span class="lineNum">    1865 </span>            :         { SIP_OPT_TIMER,        SUPPORTED,      &quot;timer&quot; },
<span class="lineNum">    1866 </span>            :         /* RFC4538: Target-dialog */
<span class="lineNum">    1867 </span>            :         { SIP_OPT_TARGET_DIALOG,NOT_SUPPORTED,  &quot;tdialog&quot; },
<span class="lineNum">    1868 </span>            : };
<span class="lineNum">    1869 </span>            : 
<span class="lineNum">    1870 </span>            : struct digestkeys {
<span class="lineNum">    1871 </span>            :         const char *key;
<span class="lineNum">    1872 </span>            :         const char *s;
<a name="1873"><span class="lineNum">    1873 </span>            : };</a>
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span><span class="lineCov">         14 : AST_THREADSTORAGE(check_auth_buf);</span>
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span>            : /*----------------------------------------------------------*/
<span class="lineNum">    1878 </span>            : /*----                    FUNCTIONS                     ----*/
<span class="lineNum">    1879 </span>            : /*----------------------------------------------------------*/
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span>            : struct sip_peer *sip_find_peer(const char *peer, struct ast_sockaddr *addr, int realtime, int which_objects, int devstate_only, int transport);
<span class="lineNum">    1882 </span>            : void sip_auth_headers(enum sip_auth_type code, char **header, char **respheader);
<span class="lineNum">    1883 </span>            : const char *sip_get_header(const struct sip_request *req, const char *name);
<span class="lineNum">    1884 </span>            : const char *sip_get_transport(enum ast_transport t);
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span>            : #define sip_ref_peer(peer, tag) ao2_t_bump(peer, tag)
<span class="lineNum">    1887 </span>            : #define sip_unref_peer(peer, tag) ({ ao2_t_cleanup(peer, tag); (NULL); })
<span class="lineNum">    1888 </span>            : 
<span class="lineNum">    1889 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
