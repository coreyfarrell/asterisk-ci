<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Asterisk GIT-16-d8ac5bf1a5 - codecs/lpc10/analys.c</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">codecs/lpc10</a> - analys.c<span style="font-size: 80%;"> (source / <a href="analys.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Asterisk GIT-16-d8ac5bf1a5</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">89</td>
            <td class="headerCovTableEntry">89</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-07-23 21:48:22</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            : 
<span class="lineNum">       3 </span>            : $Log$
<span class="lineNum">       4 </span>            : Revision 1.16  2004/06/26 03:50:14  markster
<span class="lineNum">       5 </span>            : Merge source cleanups (bug #1911)
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : Revision 1.15  2003/09/19 01:20:22  markster
<span class="lineNum">       8 </span>            : Code cleanups (bug #66)
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : Revision 1.2  2003/09/19 01:20:22  markster
<span class="lineNum">      11 </span>            : Code cleanups (bug #66)
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : Revision 1.1.1.1  2003/02/12 13:59:14  matteo
<span class="lineNum">      14 </span>            : mer feb 12 14:56:57 CET 2003
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : Revision 1.2  2000/01/05 08:20:39  markster
<span class="lineNum">      17 </span>            : Some OSS fixes and a few lpc changes to make it actually work
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            :  * Revision 1.2  1996/08/20  20:16:01  jaf
<span class="lineNum">      20 </span>            :  * Removed all static local variables that were SAVE'd in the Fortran
<span class="lineNum">      21 </span>            :  * code, and put them in struct lpc10_encoder_state that is passed as an
<span class="lineNum">      22 </span>            :  * argument.
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  * Removed init function, since all initialization is now done in
<span class="lineNum">      25 </span>            :  * init_lpc10_encoder_state().
<span class="lineNum">      26 </span>            :  *
<span class="lineNum">      27 </span>            :  * Revision 1.1  1996/08/19  22:29:08  jaf
<span class="lineNum">      28 </span>            :  * Initial revision
<span class="lineNum">      29 </span>            :  *
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : */
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #include &quot;f2c.h&quot;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #ifdef P_R_O_T_O_T_Y_P_E_S
<span class="lineNum">      36 </span>            : extern int analys_(real *speech, integer *voice, integer *pitch, real *rms, real *rc, struct lpc10_encoder_state *st);
<span class="lineNum">      37 </span>            : /* comlen contrl_ 12 */
<span class="lineNum">      38 </span>            : /*:ref: preemp_ 14 5 6 6 4 6 6 */
<span class="lineNum">      39 </span>            : /*:ref: onset_ 14 7 6 4 4 4 4 4 4 */
<span class="lineNum">      40 </span>            : /*:ref: placev_ 14 11 4 4 4 4 4 4 4 4 4 4 4 */
<span class="lineNum">      41 </span>            : /*:ref: lpfilt_ 14 4 6 6 4 4 */
<span class="lineNum">      42 </span>            : /*:ref: ivfilt_ 14 5 6 6 4 4 6 */
<span class="lineNum">      43 </span>            : /*:ref: tbdm_ 14 8 6 4 4 4 6 4 4 4 */
<span class="lineNum">      44 </span>            : /*:ref: voicin_ 14 12 4 6 6 4 4 6 6 4 6 4 4 4 */
<span class="lineNum">      45 </span>            : /*:ref: dyptrk_ 14 6 6 4 4 4 4 4 */
<span class="lineNum">      46 </span>            : /*:ref: placea_ 14 9 4 4 4 4 4 4 4 4 4 */
<span class="lineNum">      47 </span>            : /*:ref: dcbias_ 14 3 4 6 6 */
<span class="lineNum">      48 </span>            : /*:ref: energy_ 14 3 4 6 6 */
<span class="lineNum">      49 </span>            : /*:ref: mload_ 14 6 4 4 4 6 6 6 */
<span class="lineNum">      50 </span>            : /*:ref: invert_ 14 4 4 6 6 6 */
<span class="lineNum">      51 </span>            : /*:ref: rcchk_ 14 3 4 6 6 */
<span class="lineNum">      52 </span>            : /*:ref: initonset_ 14 0 */
<span class="lineNum">      53 </span>            : /*:ref: initvoicin_ 14 0 */
<span class="lineNum">      54 </span>            : /*:ref: initdyptrk_ 14 0 */
<span class="lineNum">      55 </span>            : /* Rerunning f2c -P may change prototypes or declarations. */
<span class="lineNum">      56 </span>            : #endif
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : /*  -- translated by f2c (version 19951025).
<span class="lineNum">      59 </span>            :    You must link the resulting object file with the libraries:
<span class="lineNum">      60 </span>            :         -lf2c -lm   (in that order)
<span class="lineNum">      61 </span>            : */
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : /* Common Block Declarations */
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : extern struct {
<span class="lineNum">      66 </span>            :     integer order, lframe;
<span class="lineNum">      67 </span>            :     logical corrp;
<span class="lineNum">      68 </span>            : } contrl_;
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : #define contrl_1 contrl_
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : /* Table of constant values */
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : static integer c__10 = 10;
<span class="lineNum">      75 </span>            : static integer c__181 = 181;
<span class="lineNum">      76 </span>            : static integer c__720 = 720;
<span class="lineNum">      77 </span>            : static integer c__3 = 3;
<span class="lineNum">      78 </span>            : static integer c__90 = 90;
<span class="lineNum">      79 </span>            : static integer c__156 = 156;
<span class="lineNum">      80 </span>            : static integer c__307 = 307;
<span class="lineNum">      81 </span>            : static integer c__462 = 462;
<span class="lineNum">      82 </span>            : static integer c__312 = 312;
<span class="lineNum">      83 </span>            : static integer c__60 = 60;
<span class="lineNum">      84 </span>            : static integer c__1 = 1;
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : /* ****************************************************************** */
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : /*      ANALYS Version 55 */
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : /* $Log$
<span class="lineNum">      91 </span>            :  * Revision 1.16  2004/06/26 03:50:14  markster
<span class="lineNum">      92 </span>            :  * Merge source cleanups (bug #1911)
<span class="lineNum">      93 </span>            :  *
<span class="lineNum">      94 </span>            :  * Revision 1.15  2003/09/19 01:20:22  markster
<span class="lineNum">      95 </span>            :  * Code cleanups (bug #66)
<span class="lineNum">      96 </span>            :  *
<span class="lineNum">      97 </span>            :  * Revision 1.2  2003/09/19 01:20:22  markster
<span class="lineNum">      98 </span>            :  * Code cleanups (bug #66)
<span class="lineNum">      99 </span>            :  *
<span class="lineNum">     100 </span>            :  * Revision 1.1.1.1  2003/02/12 13:59:14  matteo
<span class="lineNum">     101 </span>            :  * mer feb 12 14:56:57 CET 2003
<span class="lineNum">     102 </span>            :  *
<span class="lineNum">     103 </span>            :  * Revision 1.2  2000/01/05 08:20:39  markster
<span class="lineNum">     104 </span>            :  * Some OSS fixes and a few lpc changes to make it actually work
<span class="lineNum">     105 </span>            :  *
<span class="lineNum">     106 </span>            :  * Revision 1.2  1996/08/20  20:16:01  jaf
<span class="lineNum">     107 </span>            :  * Removed all static local variables that were SAVE'd in the Fortran
<span class="lineNum">     108 </span>            :  * code, and put them in struct lpc10_encoder_state that is passed as an
<span class="lineNum">     109 </span>            :  * argument.
<span class="lineNum">     110 </span>            :  *
<span class="lineNum">     111 </span>            :  * Removed init function, since all initialization is now done in
<span class="lineNum">     112 </span>            :  * init_lpc10_encoder_state().
<span class="lineNum">     113 </span>            :  *
<span class="lineNum">     114 </span>            :  * Revision 1.1  1996/08/19  22:29:08  jaf
<span class="lineNum">     115 </span>            :  * Initial revision
<span class="lineNum">     116 </span>            :  * */
<span class="lineNum">     117 </span>            : /* Revision 1.9  1996/05/23  19:41:07  jaf */
<span class="lineNum">     118 </span>            : /* Commented out some unnecessary lines that were reading uninitialized */
<span class="lineNum">     119 </span>            : /* values. */
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : /* Revision 1.8  1996/03/27  23:57:55  jaf */
<span class="lineNum">     122 </span>            : /* Added some comments about which indices of the local buffers INBUF, */
<span class="lineNum">     123 </span>            : /* LPBUF, etc., get read or modified by some of the subroutine calls.  I */
<span class="lineNum">     124 </span>            : /* just did this while trying to figure out the discrepancy between the */
<span class="lineNum">     125 </span>            : /* embedded code compiled with all local variables implicitly saved, and */
<span class="lineNum">     126 </span>            : /* without. */
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : /* I added some debugging write statements in hopes of finding a problem. */
<span class="lineNum">     129 </span>            : /* None of them ever printed anything while running with the long input */
<span class="lineNum">     130 </span>            : /* speech file dam9.spd provided in the distribution. */
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : /* Revision 1.7  1996/03/27  18:06:20  jaf */
<span class="lineNum">     133 </span>            : /* Commented out access to MAXOSP, which is just a debugging variable */
<span class="lineNum">     134 </span>            : /* that was defined in the COMMON block CONTRL in contrl.fh. */
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : /* Revision 1.6  1996/03/26  19:31:33  jaf */
<span class="lineNum">     137 </span>            : /* Commented out trace statements. */
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : /* Revision 1.5  1996/03/21  15:19:35  jaf */
<span class="lineNum">     140 </span>            : /* Added comments for ENTRY PITDEC. */
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : /* Revision 1.4  1996/03/19  20:54:27  jaf */
<span class="lineNum">     143 </span>            : /* Added a line to INITANALYS.  See comments there. */
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : /* Revision 1.3  1996/03/19  20:52:49  jaf */
<span class="lineNum">     146 </span>            : /* Rearranged the order of the local variables quite a bit, to separate */
<span class="lineNum">     147 </span>            : /* them into groups of &quot;constants&quot;, &quot;locals that don't need to be saved */
<span class="lineNum">     148 </span>            : /* from one call to the next&quot;, and &quot;local that do need to be saved from */
<span class="lineNum">     149 </span>            : /* one call to the next&quot;. */
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : /* Several locals in the last set should have been given initial values, */
<span class="lineNum">     152 </span>            : /* but weren't.  I gave them all initial values of 0. */
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : /* Added a separate ENTRY INITANALYS that initializes all local state */
<span class="lineNum">     155 </span>            : /* that should be, and also calls the corresponding entries of the */
<span class="lineNum">     156 </span>            : /* subroutines called by ANALYS that also have local state. */
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : /* There used to be DATA statements in ANALYS.  I got rid of most of */
<span class="lineNum">     159 </span>            : /* them, and added a local logical variable FIRST that calls the entry */
<span class="lineNum">     160 </span>            : /* INITANALYS on the first call to ANALYS.  This is just so that one need */
<span class="lineNum">     161 </span>            : /* not remember to call INITANALYS first in order for the state to be */
<span class="lineNum">     162 </span>            : /* initialized. */
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /* Revision 1.2  1996/03/11  23:29:32  jaf */
<span class="lineNum">     165 </span>            : /* Added several comments with my own personal questions about the */
<span class="lineNum">     166 </span>            : /* Fortran 77 meaning of the parameters passed to the subroutine PREEMP. */
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : /* Revision 1.1  1996/02/07  14:42:29  jaf */
<span class="lineNum">     169 </span>            : /* Initial revision */
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : /* ****************************************************************** */
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span>            : /* SUBROUTINE ANALYS */
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : /* Input: */
<span class="lineNum">     177 </span>            : /*  SPEECH */
<span class="lineNum">     178 </span>            : /*       Indices 1 through LFRAME read. */
<span class="lineNum">     179 </span>            : /* Output: */
<span class="lineNum">     180 </span>            : /*  VOICE */
<span class="lineNum">     181 </span>            : /*       Indices 1 through 2 written. */
<span class="lineNum">     182 </span>            : /*  PITCH */
<span class="lineNum">     183 </span>            : /*       Written in subroutine DYPTRK, and then perhaps read and written */
<span class="lineNum">     184 </span>            : /*       some more. */
<span class="lineNum">     185 </span>            : /*  RMS */
<span class="lineNum">     186 </span>            : /*       Written. */
<span class="lineNum">     187 </span>            : /*  RC */
<span class="lineNum">     188 </span>            : /*       Indices 1 through ORDER written (ORDER defined in contrl.fh). */
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : /* This subroutine maintains local state from one call to the next.  If */
<span class="lineNum">     191 </span>            : /* you want to switch to using a new audio stream for this filter, or */
<span class="lineNum">     192 </span>            : /* reinitialize its state for any other reason, call the ENTRY */
<span class="lineNum">     193 </span>            : /* INITANALYS. */
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            : /* ENTRY PITDEC */
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            : /* Input: */
<span class="lineNum">     199 </span>            : /*  PITCH   - Encoded pitch index */
<span class="lineNum">     200 </span>            : /* Output: */
<span class="lineNum">     201 </span>            : /*  PTAU    - Decoded pitch period */
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            : /* This entry has no local state.  It accesses a &quot;constant&quot; array */
<a name="204"><span class="lineNum">     204 </span>            : /* declared in ANALYS. */</a>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineCov">      50265 : /* Subroutine */ int analys_(real *speech, integer *voice, integer</span>
<span class="lineNum">     207 </span>            :         *pitch, real *rms, real *rc, struct lpc10_encoder_state *st)
<span class="lineNum">     208 </span>            : {
<span class="lineNum">     209 </span>            :     /* Initialized data */
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :     static integer tau[60] = { 20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,
<span class="lineNum">     212 </span>            :             35,36,37,38,39,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
<span class="lineNum">     213 </span>            :             74,76,78,80,84,88,92,96,100,104,108,112,116,120,124,128,132,136,
<span class="lineNum">     214 </span>            :             140,144,148,152,156 };
<span class="lineNum">     215 </span>            :     static integer buflim[4] = { 181,720,25,720 };
<span class="lineNum">     216 </span>            :     static real precoef = .9375f;
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :     /* System generated locals */
<span class="lineNum">     219 </span>            :     integer i__1;
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :     /* Local variables */
<span class="lineNum">     222 </span>            :     real amdf[60];
<span class="lineNum">     223 </span>            :     integer half;
<span class="lineNum">     224 </span>            :     real abuf[156];
<span class="lineNum">     225 </span>            :     real *bias;
<span class="lineNum">     226 </span>            :     extern /* Subroutine */ int tbdm_(real *, integer *, integer *, integer *,
<span class="lineNum">     227 </span>            :              real *, integer *, integer *, integer *);
<span class="lineNum">     228 </span>            :     integer *awin;
<span class="lineNum">     229 </span>            :     integer midx, ewin[6]       /* was [2][3] */;
<span class="lineNum">     230 </span>            :     real ivrc[2], temp;
<span class="lineNum">     231 </span>            :     real *zpre;
<span class="lineNum">     232 </span>            :     integer *vwin;
<span class="lineNum">     233 </span>            :     integer i__, j, lanal;
<span class="lineNum">     234 </span>            :     extern /* Subroutine */ int rcchk_(integer *, real *, real *), mload_(
<span class="lineNum">     235 </span>            :             integer *, integer *, integer *, real *, real *, real *);
<span class="lineNum">     236 </span>            :     real *inbuf, *pebuf;
<span class="lineNum">     237 </span>            :     real *lpbuf, *ivbuf;
<span class="lineNum">     238 </span>            :     real *rcbuf;
<span class="lineNum">     239 </span>            :     integer *osbuf;
<span class="lineNum">     240 </span>            :     extern /* Subroutine */ int onset_(real *, integer *, integer *, integer *
<span class="lineNum">     241 </span>            :             , integer *, integer *, integer *, struct lpc10_encoder_state *);
<span class="lineNum">     242 </span>            :     integer *osptr;
<span class="lineNum">     243 </span>            :     extern int dcbias_(integer *, real *, real *);
<span class="lineNum">     244 </span>            :     integer ipitch;
<span class="lineNum">     245 </span>            :     integer *obound;
<span class="lineNum">     246 </span>            :     extern /* Subroutine */ int preemp_(real *, real *, integer *, real *,
<span class="lineNum">     247 </span>            :             real *), voicin_(integer *, real *, real *, integer *, integer *,
<span class="lineNum">     248 </span>            :             real *, real *, integer *, real *, integer *, integer *, integer *,
<span class="lineNum">     249 </span>            :             struct lpc10_encoder_state *);
<span class="lineNum">     250 </span>            :     integer *voibuf;
<span class="lineNum">     251 </span>            :     integer mintau;
<span class="lineNum">     252 </span>            :     real *rmsbuf;
<span class="lineNum">     253 </span>            :     extern /* Subroutine */ int lpfilt_(real *, real *, integer *, integer *),
<span class="lineNum">     254 </span>            :              ivfilt_(real *, real *, integer *, integer *, real *), energy_(
<span class="lineNum">     255 </span>            :             integer *, real *, real *), invert_(integer *, real *, real *,
<span class="lineNum">     256 </span>            :             real *);
<span class="lineNum">     257 </span>            :     integer minptr, maxptr;
<span class="lineNum">     258 </span>            :     extern /* Subroutine */ int dyptrk_(real *, integer *, integer *, integer
<span class="lineNum">     259 </span>            :             *, integer *, integer *, struct lpc10_encoder_state *);
<span class="lineNum">     260 </span>            :     real phi[100]       /* was [10][10] */, psi[10];
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : /* $Log$
<span class="lineNum">     263 </span>            :  * Revision 1.16  2004/06/26 03:50:14  markster
<span class="lineNum">     264 </span>            :  * Merge source cleanups (bug #1911)
<span class="lineNum">     265 </span>            :  *
<span class="lineNum">     266 </span>            :  * Revision 1.15  2003/09/19 01:20:22  markster
<span class="lineNum">     267 </span>            :  * Code cleanups (bug #66)
<span class="lineNum">     268 </span>            :  *
<span class="lineNum">     269 </span>            :  * Revision 1.2  2003/09/19 01:20:22  markster
<span class="lineNum">     270 </span>            :  * Code cleanups (bug #66)
<span class="lineNum">     271 </span>            :  *
<span class="lineNum">     272 </span>            :  * Revision 1.1.1.1  2003/02/12 13:59:14  matteo
<span class="lineNum">     273 </span>            :  * mer feb 12 14:56:57 CET 2003
<span class="lineNum">     274 </span>            :  *
<span class="lineNum">     275 </span>            :  * Revision 1.2  2000/01/05 08:20:39  markster
<span class="lineNum">     276 </span>            :  * Some OSS fixes and a few lpc changes to make it actually work
<span class="lineNum">     277 </span>            :  *
<span class="lineNum">     278 </span>            :  * Revision 1.2  1996/08/20  20:16:01  jaf
<span class="lineNum">     279 </span>            :  * Removed all static local variables that were SAVE'd in the Fortran
<span class="lineNum">     280 </span>            :  * code, and put them in struct lpc10_encoder_state that is passed as an
<span class="lineNum">     281 </span>            :  * argument.
<span class="lineNum">     282 </span>            :  *
<span class="lineNum">     283 </span>            :  * Removed init function, since all initialization is now done in
<span class="lineNum">     284 </span>            :  * init_lpc10_encoder_state().
<span class="lineNum">     285 </span>            :  *
<span class="lineNum">     286 </span>            :  * Revision 1.1  1996/08/19  22:29:08  jaf
<span class="lineNum">     287 </span>            :  * Initial revision
<span class="lineNum">     288 </span>            :  * */
<span class="lineNum">     289 </span>            : /* Revision 1.3  1996/03/29  22:03:47  jaf */
<span class="lineNum">     290 </span>            : /* Removed definitions for any constants that were no longer used. */
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            : /* Revision 1.2  1996/03/26  19:34:33  jaf */
<span class="lineNum">     293 </span>            : /* Added comments indicating which constants are not needed in an */
<span class="lineNum">     294 </span>            : /* application that uses the LPC-10 coder. */
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            : /* Revision 1.1  1996/02/07  14:43:51  jaf */
<span class="lineNum">     297 </span>            : /* Initial revision */
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : /*   LPC Configuration parameters: */
<span class="lineNum">     300 </span>            : /* Frame size, Prediction order, Pitch period */
<span class="lineNum">     301 </span>            : /*       Arguments to ANALYS */
<span class="lineNum">     302 </span>            : /* $Log$
<span class="lineNum">     303 </span>            :  * Revision 1.16  2004/06/26 03:50:14  markster
<span class="lineNum">     304 </span>            :  * Merge source cleanups (bug #1911)
<span class="lineNum">     305 </span>            :  *
<span class="lineNum">     306 </span>            :  * Revision 1.15  2003/09/19 01:20:22  markster
<span class="lineNum">     307 </span>            :  * Code cleanups (bug #66)
<span class="lineNum">     308 </span>            :  *
<span class="lineNum">     309 </span>            :  * Revision 1.2  2003/09/19 01:20:22  markster
<span class="lineNum">     310 </span>            :  * Code cleanups (bug #66)
<span class="lineNum">     311 </span>            :  *
<span class="lineNum">     312 </span>            :  * Revision 1.1.1.1  2003/02/12 13:59:14  matteo
<span class="lineNum">     313 </span>            :  * mer feb 12 14:56:57 CET 2003
<span class="lineNum">     314 </span>            :  *
<span class="lineNum">     315 </span>            :  * Revision 1.2  2000/01/05 08:20:39  markster
<span class="lineNum">     316 </span>            :  * Some OSS fixes and a few lpc changes to make it actually work
<span class="lineNum">     317 </span>            :  *
<span class="lineNum">     318 </span>            :  * Revision 1.2  1996/08/20  20:16:01  jaf
<span class="lineNum">     319 </span>            :  * Removed all static local variables that were SAVE'd in the Fortran
<span class="lineNum">     320 </span>            :  * code, and put them in struct lpc10_encoder_state that is passed as an
<span class="lineNum">     321 </span>            :  * argument.
<span class="lineNum">     322 </span>            :  *
<span class="lineNum">     323 </span>            :  * Removed init function, since all initialization is now done in
<span class="lineNum">     324 </span>            :  * init_lpc10_encoder_state().
<span class="lineNum">     325 </span>            :  *
<span class="lineNum">     326 </span>            :  * Revision 1.1  1996/08/19  22:29:08  jaf
<span class="lineNum">     327 </span>            :  * Initial revision
<span class="lineNum">     328 </span>            :  * */
<span class="lineNum">     329 </span>            : /* Revision 1.3  1996/03/29  22:05:55  jaf */
<span class="lineNum">     330 </span>            : /* Commented out the common block variables that are not needed by the */
<span class="lineNum">     331 </span>            : /* embedded version. */
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            : /* Revision 1.2  1996/03/26  19:34:50  jaf */
<span class="lineNum">     334 </span>            : /* Added comments indicating which constants are not needed in an */
<span class="lineNum">     335 </span>            : /* application that uses the LPC-10 coder. */
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : /* Revision 1.1  1996/02/07  14:44:09  jaf */
<span class="lineNum">     338 </span>            : /* Initial revision */
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            : /*   LPC Processing control variables: */
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : /* *** Read-only: initialized in setup */
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : /*  Files for Speech, Parameter, and Bitstream Input &amp; Output, */
<span class="lineNum">     345 </span>            : /*    and message and debug outputs. */
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : /* Here are the only files which use these variables: */
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            : /* lpcsim.f setup.f trans.f error.f vqsetup.f */
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : /* Many files which use fdebug are not listed, since it is only used in */
<span class="lineNum">     352 </span>            : /* those other files conditionally, to print trace statements. */
<span class="lineNum">     353 </span>            : /*      integer fsi, fso, fpi, fpo, fbi, fbo, pbin, fmsg, fdebug */
<span class="lineNum">     354 </span>            : /*  LPC order, Frame size, Quantization rate, Bits per frame, */
<span class="lineNum">     355 </span>            : /*    Error correction */
<span class="lineNum">     356 </span>            : /* Subroutine SETUP is the only place where order is assigned a value, */
<span class="lineNum">     357 </span>            : /* and that value is 10.  It could increase efficiency 1% or so to */
<span class="lineNum">     358 </span>            : /* declare order as a constant (i.e., a Fortran PARAMETER) instead of as
<span class="lineNum">     359 </span>            : */
<span class="lineNum">     360 </span>            : /* a variable in a COMMON block, since it is used in many places in the */
<span class="lineNum">     361 </span>            : /* core of the coding and decoding routines.  Actually, I take that back.
<span class="lineNum">     362 </span>            : */
<span class="lineNum">     363 </span>            : /* At least when compiling with f2c, the upper bound of DO loops is */
<span class="lineNum">     364 </span>            : /* stored in a local variable before the DO loop begins, and then that is
<span class="lineNum">     365 </span>            : */
<span class="lineNum">     366 </span>            : /* compared against on each iteration. */
<span class="lineNum">     367 </span>            : /* Similarly for lframe, which is given a value of MAXFRM in SETUP. */
<span class="lineNum">     368 </span>            : /* Similarly for quant, which is given a value of 2400 in SETUP.  quant */
<span class="lineNum">     369 </span>            : /* is used in only a few places, and never in the core coding and */
<span class="lineNum">     370 </span>            : /* decoding routines, so it could be eliminated entirely. */
<span class="lineNum">     371 </span>            : /* nbits is similar to quant, and is given a value of 54 in SETUP. */
<span class="lineNum">     372 </span>            : /* corrp is given a value of .TRUE. in SETUP, and is only used in the */
<span class="lineNum">     373 </span>            : /* subroutines ENCODE and DECODE.  It doesn't affect the speed of the */
<span class="lineNum">     374 </span>            : /* coder significantly whether it is .TRUE. or .FALSE., or whether it is
<span class="lineNum">     375 </span>            : */
<span class="lineNum">     376 </span>            : /* a constant or a variable, since it is only examined once per frame. */
<span class="lineNum">     377 </span>            : /* Leaving it as a variable that is set to .TRUE.  seems like a good */
<span class="lineNum">     378 </span>            : /* idea, since it does enable some error-correction capability for */
<span class="lineNum">     379 </span>            : /* unvoiced frames, with no change in the coding rate, and no noticeable
<span class="lineNum">     380 </span>            : */
<span class="lineNum">     381 </span>            : /* quality difference in the decoded speech. */
<span class="lineNum">     382 </span>            : /*      integer quant, nbits */
<span class="lineNum">     383 </span>            : /* *** Read/write: variables for debugging, not needed for LPC algorithm
<span class="lineNum">     384 </span>            : */
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : /*  Current frame, Unstable frames, Output clip count, Max onset buffer,
<span class="lineNum">     387 </span>            : */
<span class="lineNum">     388 </span>            : /*    Debug listing detail level, Line count on listing page */
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            : /* nframe is not needed for an embedded LPC10 at all. */
<span class="lineNum">     391 </span>            : /* nunsfm is initialized to 0 in SETUP, and incremented in subroutine */
<span class="lineNum">     392 </span>            : /* ERROR, which is only called from RCCHK.  When LPC10 is embedded into */
<span class="lineNum">     393 </span>            : /* an application, I would recommend removing the call to ERROR in RCCHK,
<span class="lineNum">     394 </span>            : */
<span class="lineNum">     395 </span>            : /* and remove ERROR and nunsfm completely. */
<span class="lineNum">     396 </span>            : /* iclip is initialized to 0 in SETUP, and incremented in entry SWRITE in
<span class="lineNum">     397 </span>            : */
<span class="lineNum">     398 </span>            : /* sread.f.  When LPC10 is embedded into an application, one might want */
<span class="lineNum">     399 </span>            : /* to cause it to be incremented in a routine that takes the output of */
<span class="lineNum">     400 </span>            : /* SYNTHS and sends it to an audio device.  It could be optionally */
<span class="lineNum">     401 </span>            : /* displayed, for those that might want to know what it is. */
<span class="lineNum">     402 </span>            : /* maxosp is never initialized to 0 in SETUP, although it probably should
<span class="lineNum">     403 </span>            : */
<span class="lineNum">     404 </span>            : /* be, and it is updated in subroutine ANALYS.  I doubt that its value */
<span class="lineNum">     405 </span>            : /* would be of much interest to an application in which LPC10 is */
<span class="lineNum">     406 </span>            : /* embedded. */
<span class="lineNum">     407 </span>            : /* listl and lincnt are not needed for an embedded LPC10 at all. */
<span class="lineNum">     408 </span>            : /*      integer nframe, nunsfm, iclip, maxosp, listl, lincnt */
<span class="lineNum">     409 </span>            : /*      common /contrl/ fsi, fso, fpi, fpo, fbi, fbo, pbin, fmsg, fdebug */
<span class="lineNum">     410 </span>            : /*      common /contrl/ quant, nbits */
<span class="lineNum">     411 </span>            : /*      common /contrl/ nframe, nunsfm, iclip, maxosp, listl, lincnt */
<span class="lineNum">     412 </span>            : /*       Arguments to entry PITDEC (below) */
<span class="lineNum">     413 </span>            : /*      Parameters/constants */
<span class="lineNum">     414 </span>            : /*  Constants */
<span class="lineNum">     415 </span>            : /*    NF =     Number of frames */
<span class="lineNum">     416 </span>            : /*    AF =     Frame in which analysis is done */
<span class="lineNum">     417 </span>            : /*    OSLEN =  Length of the onset buffer */
<span class="lineNum">     418 </span>            : /*    LTAU =   Number of pitch lags */
<span class="lineNum">     419 </span>            : /*    SBUFL, SBUFH =   Start and end index of speech buffers */
<span class="lineNum">     420 </span>            : /*    LBUFL, LBUFH =   Start and end index of LPF speech buffer */
<span class="lineNum">     421 </span>            : /*   MINWIN, MAXWIN = Min and Max length of voicing (and analysis) windows
<span class="lineNum">     422 </span>            : */
<span class="lineNum">     423 </span>            : /*    PWLEN, PWINH, PWINL = Length, upper and lower limits of pitch window
<span class="lineNum">     424 </span>            :  */
<span class="lineNum">     425 </span>            : /*    DVWINL, DVWINH = Default lower and upper limits of voicing window */
<span class="lineNum">     426 </span>            : /*       The tables TAU and BUFLIM, and the variable PRECOEF, are not */
<span class="lineNum">     427 </span>            : /*       Fortran PARAMETER's, but they are initialized with DATA */
<span class="lineNum">     428 </span>            : /*       statements, and never modified.  Thus, they need not have SAVE */
<span class="lineNum">     429 </span>            : /*       statements for them to keep their values from one invocation to
<span class="lineNum">     430 </span>            : */
<span class="lineNum">     431 </span>            : /*       the next. */
<span class="lineNum">     432 </span>            : /*       Local variables that need not be saved */
<span class="lineNum">     433 </span>            : /*       Local state */
<span class="lineNum">     434 </span>            : /*  Data Buffers */
<span class="lineNum">     435 </span>            : /*    INBUF     Raw speech (with DC bias removed each frame) */
<span class="lineNum">     436 </span>            : /*    PEBUF     Preemphasized speech */
<span class="lineNum">     437 </span>            : /*    LPBUF     Low pass speech buffer */
<span class="lineNum">     438 </span>            : /*    IVBUF     Inverse filtered speech */
<span class="lineNum">     439 </span>            : /*    OSBUF     Indexes of onsets in speech buffers */
<span class="lineNum">     440 </span>            : /*    VWIN      Voicing window indices */
<span class="lineNum">     441 </span>            : /*    AWIN      Analysis window indices */
<span class="lineNum">     442 </span>            : /*    EWIN      Energy window indices */
<span class="lineNum">     443 </span>            : /*    VOIBUF    Voicing decisions on windows in VWIN */
<span class="lineNum">     444 </span>            : /*    RMSBUF    RMS energy */
<span class="lineNum">     445 </span>            : /*    RCBUF     Reflection Coefficients */
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            : /*  Pitch is handled separately from the above parameters. */
<span class="lineNum">     448 </span>            : /*  The following variables deal with pitch: */
<span class="lineNum">     449 </span>            : /*    MIDX      Encoded initial pitch estimate for analysis frame */
<span class="lineNum">     450 </span>            : /*    IPITCH    Initial pitch computed for frame AF (decoded from MIDX) */
<span class="lineNum">     451 </span>            : /*    PITCH     The encoded pitch value (index into TAU) for the present */
<span class="lineNum">     452 </span>            : /*              frame (delayed and smoothed by Dyptrack) */
<span class="lineNum">     453 </span>            :     /* Parameter adjustments */
<span class="lineNum">     454 </span><span class="lineCov">      50265 :     if (speech) {</span>
<span class="lineNum">     455 </span><span class="lineCov">      50265 :         --speech;</span>
<span class="lineNum">     456 </span>            :         }
<span class="lineNum">     457 </span><span class="lineCov">      50265 :     if (voice) {</span>
<span class="lineNum">     458 </span><span class="lineCov">      50265 :         --voice;</span>
<span class="lineNum">     459 </span>            :         }
<span class="lineNum">     460 </span><span class="lineCov">      50265 :     if (rc) {</span>
<span class="lineNum">     461 </span><span class="lineCov">      50265 :         --rc;</span>
<span class="lineNum">     462 </span>            :         }
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            :     /* Function Body */
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            : /*   Calculations are done on future frame due to requirements */
<span class="lineNum">     467 </span>            : /*   of the pitch tracker.  Delay RMS and RC's 2 frames to give */
<span class="lineNum">     468 </span>            : /*   current frame parameters on return. */
<span class="lineNum">     469 </span>            : /*   Update all buffers */
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineCov">      50265 :     inbuf = &amp;(st-&gt;inbuf[0]);</span>
<span class="lineNum">     472 </span><span class="lineCov">      50265 :     pebuf = &amp;(st-&gt;pebuf[0]);</span>
<span class="lineNum">     473 </span><span class="lineCov">      50265 :     lpbuf = &amp;(st-&gt;lpbuf[0]);</span>
<span class="lineNum">     474 </span><span class="lineCov">      50265 :     ivbuf = &amp;(st-&gt;ivbuf[0]);</span>
<span class="lineNum">     475 </span><span class="lineCov">      50265 :     bias = &amp;(st-&gt;bias);</span>
<span class="lineNum">     476 </span><span class="lineCov">      50265 :     osbuf = &amp;(st-&gt;osbuf[0]);</span>
<span class="lineNum">     477 </span><span class="lineCov">      50265 :     osptr = &amp;(st-&gt;osptr);</span>
<span class="lineNum">     478 </span><span class="lineCov">      50265 :     obound = &amp;(st-&gt;obound[0]);</span>
<span class="lineNum">     479 </span><span class="lineCov">      50265 :     vwin = &amp;(st-&gt;vwin[0]);</span>
<span class="lineNum">     480 </span><span class="lineCov">      50265 :     awin = &amp;(st-&gt;awin[0]);</span>
<span class="lineNum">     481 </span><span class="lineCov">      50265 :     voibuf = &amp;(st-&gt;voibuf[0]);</span>
<span class="lineNum">     482 </span><span class="lineCov">      50265 :     rmsbuf = &amp;(st-&gt;rmsbuf[0]);</span>
<span class="lineNum">     483 </span><span class="lineCov">      50265 :     rcbuf = &amp;(st-&gt;rcbuf[0]);</span>
<span class="lineNum">     484 </span><span class="lineCov">      50265 :     zpre = &amp;(st-&gt;zpre);</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineCov">      50265 :     i__1 = 720 - contrl_1.lframe;</span>
<span class="lineNum">     487 </span><span class="lineCov">   18145665 :     for (i__ = 181; i__ &lt;= i__1; ++i__) {</span>
<span class="lineNum">     488 </span><span class="lineCov">   18095400 :         inbuf[i__ - 181] = inbuf[contrl_1.lframe + i__ - 181];</span>
<span class="lineNum">     489 </span><span class="lineCov">   18095400 :         pebuf[i__ - 181] = pebuf[contrl_1.lframe + i__ - 181];</span>
<span class="lineNum">     490 </span>            :     }
<span class="lineNum">     491 </span><span class="lineCov">      50265 :     i__1 = 540 - contrl_1.lframe;</span>
<span class="lineNum">     492 </span><span class="lineCov">    6685245 :     for (i__ = 229; i__ &lt;= i__1; ++i__) {</span>
<span class="lineNum">     493 </span><span class="lineCov">    6634980 :         ivbuf[i__ - 229] = ivbuf[contrl_1.lframe + i__ - 229];</span>
<span class="lineNum">     494 </span>            :     }
<span class="lineNum">     495 </span><span class="lineCov">      50265 :     i__1 = 720 - contrl_1.lframe;</span>
<span class="lineNum">     496 </span><span class="lineCov">   25987005 :     for (i__ = 25; i__ &lt;= i__1; ++i__) {</span>
<span class="lineNum">     497 </span><span class="lineCov">   25936740 :         lpbuf[i__ - 25] = lpbuf[contrl_1.lframe + i__ - 25];</span>
<span class="lineNum">     498 </span>            :     }
<span class="lineNum">     499 </span><span class="lineCov">      50265 :     j = 1;</span>
<span class="lineNum">     500 </span><span class="lineCov">      50265 :     i__1 = (*osptr) - 1;</span>
<span class="lineNum">     501 </span><span class="lineCov">      54733 :     for (i__ = 1; i__ &lt;= i__1; ++i__) {</span>
<span class="lineNum">     502 </span><span class="lineCov">       4468 :         if (osbuf[i__ - 1] &gt; contrl_1.lframe) {</span>
<span class="lineNum">     503 </span><span class="lineCov">       3351 :             osbuf[j - 1] = osbuf[i__ - 1] - contrl_1.lframe;</span>
<span class="lineNum">     504 </span><span class="lineCov">       3351 :             ++j;</span>
<span class="lineNum">     505 </span>            :         }
<span class="lineNum">     506 </span>            :     }
<span class="lineNum">     507 </span><span class="lineCov">      50265 :     *osptr = j;</span>
<span class="lineNum">     508 </span><span class="lineCov">      50265 :     voibuf[0] = voibuf[2];</span>
<span class="lineNum">     509 </span><span class="lineCov">      50265 :     voibuf[1] = voibuf[3];</span>
<span class="lineNum">     510 </span><span class="lineCov">     150795 :     for (i__ = 1; i__ &lt;= 2; ++i__) {</span>
<span class="lineNum">     511 </span><span class="lineCov">     100530 :         vwin[(i__ &lt;&lt; 1) - 2] = vwin[((i__ + 1) &lt;&lt; 1) - 2] - contrl_1.lframe;</span>
<span class="lineNum">     512 </span><span class="lineCov">     100530 :         vwin[(i__ &lt;&lt; 1) - 1] = vwin[((i__ + 1) &lt;&lt; 1) - 1] - contrl_1.lframe;</span>
<span class="lineNum">     513 </span><span class="lineCov">     100530 :         awin[(i__ &lt;&lt; 1) - 2] = awin[((i__ + 1) &lt;&lt; 1) - 2] - contrl_1.lframe;</span>
<span class="lineNum">     514 </span><span class="lineCov">     100530 :         awin[(i__ &lt;&lt; 1) - 1] = awin[((i__ + 1) &lt;&lt; 1) - 1] - contrl_1.lframe;</span>
<span class="lineNum">     515 </span>            : /*       EWIN(*,J) is unused for J .NE. AF, so the following shift is
<span class="lineNum">     516 </span>            : */
<span class="lineNum">     517 </span>            : /*       unnecessary.  It also causes error messages when the C versio
<span class="lineNum">     518 </span>            : n */
<span class="lineNum">     519 </span>            : /*       of the code created from this by f2c is run with Purify.  It
<span class="lineNum">     520 </span>            : */
<span class="lineNum">     521 </span>            : /*       correctly complains that uninitialized memory is being read.
<span class="lineNum">     522 </span>            : */
<span class="lineNum">     523 </span>            : /*         EWIN(1,I) = EWIN(1,I+1) - LFRAME */
<span class="lineNum">     524 </span>            : /*         EWIN(2,I) = EWIN(2,I+1) - LFRAME */
<span class="lineNum">     525 </span><span class="lineCov">     100530 :         obound[i__ - 1] = obound[i__];</span>
<span class="lineNum">     526 </span><span class="lineCov">     100530 :         voibuf[i__ * 2] = voibuf[(i__ + 1) * 2];</span>
<span class="lineNum">     527 </span><span class="lineCov">     100530 :         voibuf[(i__ &lt;&lt; 1) + 1] = voibuf[((i__ + 1) &lt;&lt; 1) + 1];</span>
<span class="lineNum">     528 </span><span class="lineCov">     100530 :         rmsbuf[i__ - 1] = rmsbuf[i__];</span>
<span class="lineNum">     529 </span><span class="lineCov">     100530 :         i__1 = contrl_1.order;</span>
<span class="lineNum">     530 </span><span class="lineCov">    1105830 :         for (j = 1; j &lt;= i__1; ++j) {</span>
<span class="lineNum">     531 </span><span class="lineCov">    1005300 :             rcbuf[j + i__ * 10 - 11] = rcbuf[j + (i__ + 1) * 10 - 11];</span>
<span class="lineNum">     532 </span>            :         }
<span class="lineNum">     533 </span>            :     }
<span class="lineNum">     534 </span>            : /*   Copy input speech, scale to sign+12 bit integers */
<span class="lineNum">     535 </span>            : /*   Remove long term DC bias. */
<span class="lineNum">     536 </span>            : /*       If the average value in the frame was over 1/4096 (after current
<span class="lineNum">     537 </span>            : */
<span class="lineNum">     538 </span>            : /*       BIAS correction), then subtract that much more from samples in */
<span class="lineNum">     539 </span>            : /*       next frame.  If the average value in the frame was under */
<span class="lineNum">     540 </span>            : /*       -1/4096, add 1/4096 more to samples in next frame.  In all other
<span class="lineNum">     541 </span>            : */
<span class="lineNum">     542 </span>            : /*       cases, keep BIAS the same. */
<span class="lineNum">     543 </span><span class="lineCov">      50265 :     temp = 0.f;</span>
<span class="lineNum">     544 </span><span class="lineCov">      50265 :     i__1 = contrl_1.lframe;</span>
<span class="lineNum">     545 </span><span class="lineCov">    9097965 :     for (i__ = 1; i__ &lt;= i__1; ++i__) {</span>
<span class="lineNum">     546 </span><span class="lineCov">   18095400 :         inbuf[720 - contrl_1.lframe + i__ - 181] = speech[i__] * 4096.f -</span>
<span class="lineNum">     547 </span><span class="lineCov">    9047700 :                 (*bias);</span>
<span class="lineNum">     548 </span><span class="lineCov">    9047700 :         temp += inbuf[720 - contrl_1.lframe + i__ - 181];</span>
<span class="lineNum">     549 </span>            :     }
<span class="lineNum">     550 </span><span class="lineCov">      50265 :     if (temp &gt; (real) contrl_1.lframe) {</span>
<span class="lineNum">     551 </span><span class="lineCov">      13404 :         *bias += 1;</span>
<span class="lineNum">     552 </span>            :     }
<span class="lineNum">     553 </span><span class="lineCov">      50265 :     if (temp &lt; (real) (-contrl_1.lframe)) {</span>
<span class="lineNum">     554 </span><span class="lineCov">      13404 :         *bias += -1;</span>
<span class="lineNum">     555 </span>            :     }
<span class="lineNum">     556 </span>            : /*   Place Voicing Window */
<span class="lineNum">     557 </span><span class="lineCov">      50265 :     i__ = 721 - contrl_1.lframe;</span>
<span class="lineNum">     558 </span><span class="lineCov">      50265 :     preemp_(&amp;inbuf[i__ - 181], &amp;pebuf[i__ - 181], &amp;contrl_1.lframe, &amp;precoef,</span>
<span class="lineNum">     559 </span>            :             zpre);
<span class="lineNum">     560 </span><span class="lineCov">      50265 :     onset_(pebuf, osbuf, osptr, &amp;c__10, &amp;c__181, &amp;c__720, &amp;contrl_1.lframe, st);</span>
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            : /*       MAXOSP is just a debugging variable. */
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : /*      MAXOSP = MAX( MAXOSP, OSPTR ) */
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span><span class="lineCov">      50265 :     placev_(osbuf, osptr, &amp;c__10, &amp;obound[2], vwin, &amp;c__3, &amp;contrl_1.lframe,</span>
<span class="lineNum">     567 </span>            :             &amp;c__90, &amp;c__156, &amp;c__307, &amp;c__462);
<span class="lineNum">     568 </span>            : /*        The Pitch Extraction algorithm estimates the pitch for a frame
<span class="lineNum">     569 </span>            : */
<span class="lineNum">     570 </span>            : /*   of speech by locating the minimum of the average magnitude difference
<span class="lineNum">     571 </span>            :  */
<span class="lineNum">     572 </span>            : /*   function (AMDF).  The AMDF operates on low-pass, inverse filtered */
<span class="lineNum">     573 </span>            : /*   speech.  (The low-pass filter is an 800 Hz, 19 tap, equiripple, FIR
<span class="lineNum">     574 </span>            : */
<span class="lineNum">     575 </span>            : /*   filter and the inverse filter is a 2nd-order LPC filter.)  The pitch
<span class="lineNum">     576 </span>            : */
<span class="lineNum">     577 </span>            : /*   estimate is later refined by dynamic programming (DYPTRK).  However,
<span class="lineNum">     578 </span>            : */
<span class="lineNum">     579 </span>            : /*   since some of DYPTRK's parameters are a function of the voicing */
<span class="lineNum">     580 </span>            : /*  decisions, a voicing decision must precede the final pitch estimation.
<span class="lineNum">     581 </span>            : */
<span class="lineNum">     582 </span>            : /*   See subroutines LPFILT, IVFILT, and TBDM. */
<span class="lineNum">     583 </span>            : /*       LPFILT reads indices LBUFH-LFRAME-29 = 511 through LBUFH = 720 */
<span class="lineNum">     584 </span>            : /*       of INBUF, and writes indices LBUFH+1-LFRAME = 541 through LBUFH
<span class="lineNum">     585 </span>            : */
<span class="lineNum">     586 </span>            : /*       = 720 of LPBUF. */
<span class="lineNum">     587 </span><span class="lineCov">      50265 :     lpfilt_(&amp;inbuf[228], &amp;lpbuf[384], &amp;c__312, &amp;contrl_1.lframe);</span>
<span class="lineNum">     588 </span>            : /*       IVFILT reads indices (PWINH-LFRAME-7) = 353 through PWINH = 540
<span class="lineNum">     589 </span>            : */
<span class="lineNum">     590 </span>            : /*       of LPBUF, and writes indices (PWINH-LFRAME+1) = 361 through */
<span class="lineNum">     591 </span>            : /*       PWINH = 540 of IVBUF. */
<span class="lineNum">     592 </span><span class="lineCov">      50265 :     ivfilt_(&amp;lpbuf[204], ivbuf, &amp;c__312, &amp;contrl_1.lframe, ivrc);</span>
<span class="lineNum">     593 </span>            : /*       TBDM reads indices PWINL = 229 through */
<span class="lineNum">     594 </span>            : /*       (PWINL-1)+MAXWIN+(TAU(LTAU)-TAU(1))/2 = 452 of IVBUF, and writes
<span class="lineNum">     595 </span>            : */
<span class="lineNum">     596 </span>            : /*       indices 1 through LTAU = 60 of AMDF. */
<span class="lineNum">     597 </span><span class="lineCov">      50265 :     tbdm_(ivbuf, &amp;c__156, tau, &amp;c__60, amdf, &amp;minptr, &amp;maxptr, &amp;mintau);</span>
<span class="lineNum">     598 </span>            : /*        Voicing decisions are made for each half frame of input speech.
<span class="lineNum">     599 </span>            : */
<span class="lineNum">     600 </span>            : /*   An initial voicing classification is made for each half of the */
<span class="lineNum">     601 </span>            : /*   analysis frame, and the voicing decisions for the present frame */
<span class="lineNum">     602 </span>            : /*   are finalized.  See subroutine VOICIN. */
<span class="lineNum">     603 </span>            : /*        The voicing detector (VOICIN) classifies the input signal as */
<span class="lineNum">     604 </span>            : /*   unvoiced (including silence) or voiced using the AMDF windowed */
<span class="lineNum">     605 </span>            : /*   maximum-to-minimum ratio, the zero crossing rate, energy measures, */
<span class="lineNum">     606 </span>            : /*   reflection coefficients, and prediction gains. */
<span class="lineNum">     607 </span>            : /*        The pitch and voicing rules apply smoothing and isolated */
<span class="lineNum">     608 </span>            : /*   corrections to the pitch and voicing estimates and, in the process,
<span class="lineNum">     609 </span>            : */
<span class="lineNum">     610 </span>            : /*   introduce two frames of delay into the corrected pitch estimates and
<span class="lineNum">     611 </span>            : */
<span class="lineNum">     612 </span>            : /*   voicing decisions. */
<span class="lineNum">     613 </span><span class="lineCov">     150795 :     for (half = 1; half &lt;= 2; ++half) {</span>
<span class="lineNum">     614 </span><span class="lineCov">     100530 :         voicin_(&amp;vwin[4], inbuf, lpbuf, buflim, &amp;half, &amp;amdf[minptr - 1], &amp;</span>
<span class="lineNum">     615 </span><span class="lineCov">     100530 :                 amdf[maxptr - 1], &amp;mintau, ivrc, obound, voibuf, &amp;c__3, st);</span>
<span class="lineNum">     616 </span>            :     }
<span class="lineNum">     617 </span>            : /*   Find the minimum cost pitch decision over several frames */
<span class="lineNum">     618 </span>            : /*   given the current voicing decision and the AMDF array */
<span class="lineNum">     619 </span><span class="lineCov">      50265 :     dyptrk_(amdf, &amp;c__60, &amp;minptr, &amp;voibuf[7], pitch, &amp;midx, st);</span>
<span class="lineNum">     620 </span><span class="lineCov">      50265 :     ipitch = tau[midx - 1];</span>
<span class="lineNum">     621 </span>            : /*   Place spectrum analysis and energy windows */
<span class="lineNum">     622 </span><span class="lineCov">      50265 :     placea_(&amp;ipitch, voibuf, &amp;obound[2], &amp;c__3, vwin, awin, ewin, &amp;</span>
<span class="lineNum">     623 </span>            :             contrl_1.lframe, &amp;c__156);
<span class="lineNum">     624 </span>            : /*  Remove short term DC bias over the analysis window, Put result in ABUF
<span class="lineNum">     625 </span>            : */
<span class="lineNum">     626 </span><span class="lineCov">      50265 :     lanal = awin[5] + 1 - awin[4];</span>
<span class="lineNum">     627 </span><span class="lineCov">      50265 :     dcbias_(&amp;lanal, &amp;pebuf[awin[4] - 181], abuf);</span>
<span class="lineNum">     628 </span>            : /*       ABUF(1:LANAL) is now defined.  It is equal to */
<span class="lineNum">     629 </span>            : /*       PEBUF(AWIN(1,AF):AWIN(2,AF)) corrected for short term DC bias. */
<span class="lineNum">     630 </span>            : /*   Compute RMS over integer number of pitch periods within the */
<span class="lineNum">     631 </span>            : /*   analysis window. */
<span class="lineNum">     632 </span>            : /*   Note that in a hardware implementation this computation may be */
<span class="lineNum">     633 </span>            : /*   simplified by using diagonal elements of PHI computed by MLOAD. */
<span class="lineNum">     634 </span><span class="lineCov">      50265 :     i__1 = ewin[5] - ewin[4] + 1;</span>
<span class="lineNum">     635 </span><span class="lineCov">      50265 :     energy_(&amp;i__1, &amp;abuf[ewin[4] - awin[4]], &amp;rmsbuf[2]);</span>
<span class="lineNum">     636 </span>            : /*   Matrix load and invert, check RC's for stability */
<span class="lineNum">     637 </span><span class="lineCov">      50265 :     mload_(&amp;contrl_1.order, &amp;c__1, &amp;lanal, abuf, phi, psi);</span>
<span class="lineNum">     638 </span><span class="lineCov">      50265 :     invert_(&amp;contrl_1.order, phi, psi, &amp;rcbuf[20]);</span>
<span class="lineNum">     639 </span><span class="lineCov">      50265 :     rcchk_(&amp;contrl_1.order, &amp;rcbuf[10], &amp;rcbuf[20]);</span>
<span class="lineNum">     640 </span>            : /*   Set return parameters */
<span class="lineNum">     641 </span><span class="lineCov">      50265 :     voice[1] = voibuf[2];</span>
<span class="lineNum">     642 </span><span class="lineCov">      50265 :     voice[2] = voibuf[3];</span>
<span class="lineNum">     643 </span><span class="lineCov">      50265 :     *rms = rmsbuf[0];</span>
<span class="lineNum">     644 </span><span class="lineCov">      50265 :     i__1 = contrl_1.order;</span>
<span class="lineNum">     645 </span><span class="lineCov">     552915 :     for (i__ = 1; i__ &lt;= i__1; ++i__) {</span>
<span class="lineNum">     646 </span><span class="lineCov">     502650 :         rc[i__] = rcbuf[i__ - 1];</span>
<span class="lineNum">     647 </span>            :     }
<span class="lineNum">     648 </span><span class="lineCov">      50265 :     return 0;</span>
<span class="lineNum">     649 </span>            : } /* analys_ */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
