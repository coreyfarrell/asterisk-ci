<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Asterisk GIT-16-d8ac5bf1a5 - pbx/pbx_spool.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">pbx</a> - pbx_spool.c<span style="font-size: 80%;"> (source / <a href="pbx_spool.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Asterisk GIT-16-d8ac5bf1a5</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">257</td>
            <td class="headerCovTableEntry">372</td>
            <td class="headerCovTableEntryLo">69.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-07-23 21:48:22</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntry">21</td>
            <td class="headerCovTableEntryHi">90.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Asterisk -- An open source telephony toolkit.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (C) 1999 - 2010, Digium, Inc.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Mark Spencer &lt;markster@digium.com&gt;
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * See http://www.asterisk.org for more information about
<span class="lineNum">       9 </span>            :  * the Asterisk project. Please do not directly contact
<span class="lineNum">      10 </span>            :  * any of the maintainers of this project for assistance;
<span class="lineNum">      11 </span>            :  * the project provides a web site, mailing lists and IRC
<span class="lineNum">      12 </span>            :  * channels for your use.
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  * This program is free software, distributed under the terms of
<span class="lineNum">      15 </span>            :  * the GNU General Public License Version 2. See the LICENSE file
<span class="lineNum">      16 </span>            :  * at the top of the source tree.
<span class="lineNum">      17 </span>            :  */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : /*! \file
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * \brief Full-featured outgoing call spool support
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  */
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : /*** MODULEINFO
<span class="lineNum">      26 </span>            :         &lt;support_level&gt;core&lt;/support_level&gt;
<span class="lineNum">      27 </span>            :  ***/
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #include &quot;asterisk.h&quot;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &lt;sys/stat.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;utime.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;dirent.h&gt;
<span class="lineNum">      35 </span>            : #ifdef HAVE_INOTIFY
<span class="lineNum">      36 </span>            : #include &lt;sys/inotify.h&gt;
<span class="lineNum">      37 </span>            : #elif defined(HAVE_KQUEUE)
<span class="lineNum">      38 </span>            : #include &lt;sys/types.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      40 </span>            : #include &lt;sys/event.h&gt;
<span class="lineNum">      41 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">      42 </span>            : #endif
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : #include &quot;asterisk/paths.h&quot;   /* use ast_config_AST_SPOOL_DIR */
<span class="lineNum">      45 </span>            : #include &quot;asterisk/lock.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;asterisk/file.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;asterisk/logger.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;asterisk/channel.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;asterisk/callerid.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;asterisk/pbx.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;asterisk/module.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;asterisk/utils.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;asterisk/options.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;asterisk/format.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;asterisk/format_cache.h&quot;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : /*
<span class="lineNum">      58 </span>            :  * pbx_spool is similar in spirit to qcall, but with substantially enhanced functionality...
<span class="lineNum">      59 </span>            :  * The spool file contains a header
<span class="lineNum">      60 </span>            :  */
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : enum {
<span class="lineNum">      63 </span>            :         /*! Always delete the call file after a call succeeds or the
<span class="lineNum">      64 </span>            :          * maximum number of retries is exceeded, even if the
<span class="lineNum">      65 </span>            :          * modification time of the call file is in the future.
<span class="lineNum">      66 </span>            :          */
<span class="lineNum">      67 </span>            :         SPOOL_FLAG_ALWAYS_DELETE = (1 &lt;&lt; 0),
<span class="lineNum">      68 </span>            :         /* Don't unlink the call file after processing, move in qdonedir */
<span class="lineNum">      69 </span>            :         SPOOL_FLAG_ARCHIVE = (1 &lt;&lt; 1),
<span class="lineNum">      70 </span>            :         /* Connect the channel with the outgoing extension once early media is received */
<span class="lineNum">      71 </span>            :         SPOOL_FLAG_EARLY_MEDIA = (1 &lt;&lt; 2),
<span class="lineNum">      72 </span>            : };
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : static char qdir[255];
<span class="lineNum">      75 </span>            : static char qdonedir[255];
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : struct outgoing {
<span class="lineNum">      78 </span>            :         int retries;                              /*!&lt; Current number of retries */
<span class="lineNum">      79 </span>            :         int maxretries;                           /*!&lt; Maximum number of retries permitted */
<span class="lineNum">      80 </span>            :         int retrytime;                            /*!&lt; How long to wait between retries (in seconds) */
<span class="lineNum">      81 </span>            :         int waittime;                             /*!&lt; How long to wait for an answer */
<span class="lineNum">      82 </span>            :         long callingpid;                          /*!&lt; PID which is currently calling */
<span class="lineNum">      83 </span>            :         struct ast_format_cap *capabilities;                 /*!&lt; Formats (codecs) for this call */
<span class="lineNum">      84 </span>            :         AST_DECLARE_STRING_FIELDS (
<span class="lineNum">      85 </span>            :                 AST_STRING_FIELD(fn);                 /*!&lt; File name of call file */
<span class="lineNum">      86 </span>            :                 AST_STRING_FIELD(tech);               /*!&lt; Which channel technology to use for outgoing call */
<span class="lineNum">      87 </span>            :                 AST_STRING_FIELD(dest);               /*!&lt; Which device/line to use for outgoing call */
<span class="lineNum">      88 </span>            :                 AST_STRING_FIELD(app);                /*!&lt; If application: Application name */
<span class="lineNum">      89 </span>            :                 AST_STRING_FIELD(data);               /*!&lt; If application: Application data */
<span class="lineNum">      90 </span>            :                 AST_STRING_FIELD(exten);              /*!&lt; If extension/context/priority: Extension in dialplan */
<span class="lineNum">      91 </span>            :                 AST_STRING_FIELD(context);            /*!&lt; If extension/context/priority: Dialplan context */
<span class="lineNum">      92 </span>            :                 AST_STRING_FIELD(cid_num);            /*!&lt; CallerID Information: Number/extension */
<span class="lineNum">      93 </span>            :                 AST_STRING_FIELD(cid_name);           /*!&lt; CallerID Information: Name */
<span class="lineNum">      94 </span>            :                 AST_STRING_FIELD(account);            /*!&lt; account code */
<span class="lineNum">      95 </span>            :         );
<span class="lineNum">      96 </span>            :         int priority;                             /*!&lt; If extension/context/priority: Dialplan priority */
<span class="lineNum">      97 </span>            :         struct ast_variable *vars;                /*!&lt; Variables and Functions */
<span class="lineNum">      98 </span>            :         int maxlen;                               /*!&lt; Maximum length of call */
<span class="lineNum">      99 </span>            :         struct ast_flags options;                 /*!&lt; options */
<span class="lineNum">     100 </span>            : };
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : #if defined(HAVE_INOTIFY) || defined(HAVE_KQUEUE)
<span class="lineNum">     103 </span>            : struct direntry {
<span class="lineNum">     104 </span>            :         AST_LIST_ENTRY(direntry) list;
<span class="lineNum">     105 </span>            :         time_t mtime;
<span class="lineNum">     106 </span>            :         char name[0];
<span class="lineNum">     107 </span>            : };
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : static AST_LIST_HEAD_STATIC(dirlist, direntry);
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : static void queue_file(const char *filename, time_t when);
<a name="112"><span class="lineNum">     112 </span>            : #endif</a>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineCov">         27 : static void free_outgoing(struct outgoing *o)</span>
<span class="lineNum">     115 </span>            : {
<span class="lineNum">     116 </span><span class="lineCov">         27 :         if (o-&gt;vars) {</span>
<span class="lineNum">     117 </span><span class="lineCov">         27 :                 ast_variables_destroy(o-&gt;vars);</span>
<span class="lineNum">     118 </span>            :         }
<span class="lineNum">     119 </span><span class="lineCov">         27 :         ao2_cleanup(o-&gt;capabilities);</span>
<span class="lineNum">     120 </span><span class="lineCov">         27 :         ast_string_field_free_memory(o);</span>
<span class="lineNum">     121 </span><span class="lineCov">         27 :         ast_free(o);</span>
<a name="122"><span class="lineNum">     122 </span><span class="lineCov">         27 : }</span></a>
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span><span class="lineCov">         27 : static struct outgoing *new_outgoing(const char *fn)</span>
<span class="lineNum">     125 </span>            : {
<span class="lineNum">     126 </span>            :         struct outgoing *o;
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span><span class="lineCov">         27 :         o = ast_calloc(1, sizeof(*o));</span>
<span class="lineNum">     129 </span><span class="lineCov">         27 :         if (!o) {</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     131 </span>            :         }
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :         /* Initialize the new object. */
<span class="lineNum">     134 </span><span class="lineCov">         27 :         o-&gt;priority = 1;</span>
<span class="lineNum">     135 </span><span class="lineCov">         27 :         o-&gt;retrytime = 300;</span>
<span class="lineNum">     136 </span><span class="lineCov">         27 :         o-&gt;waittime = 45;</span>
<span class="lineNum">     137 </span><span class="lineCov">         27 :         ast_set_flag(&amp;o-&gt;options, SPOOL_FLAG_ALWAYS_DELETE);</span>
<span class="lineNum">     138 </span><span class="lineCov">         27 :         if (ast_string_field_init(o, 128)) {</span>
<span class="lineNum">     139 </span>            :                 /*
<span class="lineNum">     140 </span>            :                  * No need to call free_outgoing here since the failure was to
<span class="lineNum">     141 </span>            :                  * allocate string fields and no variables have been allocated
<span class="lineNum">     142 </span>            :                  * yet.
<span class="lineNum">     143 </span>            :                  */
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :                 ast_free(o);</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     146 </span>            :         }
<span class="lineNum">     147 </span><span class="lineCov">         27 :         ast_string_field_set(o, fn, fn);</span>
<span class="lineNum">     148 </span><span class="lineCov">         27 :         if (ast_strlen_zero(o-&gt;fn)) {</span>
<span class="lineNum">     149 </span>            :                 /* String field set failed.  Since this string is important we must fail. */
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :                 free_outgoing(o);</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     152 </span>            :         }
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineCov">         27 :         o-&gt;capabilities = ast_format_cap_alloc(AST_FORMAT_CAP_FLAG_DEFAULT);</span>
<span class="lineNum">     155 </span><span class="lineCov">         27 :         if (!o-&gt;capabilities) {</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :                 free_outgoing(o);</span>
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     158 </span>            :         }
<span class="lineNum">     159 </span><span class="lineCov">         27 :         ast_format_cap_append(o-&gt;capabilities, ast_format_slin, 0);</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineCov">         27 :         return o;</span>
<a name="162"><span class="lineNum">     162 </span>            : }</a>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineCov">         27 : static void append_variable(struct outgoing *o, const char *name, const char *value)</span>
<span class="lineNum">     165 </span>            : {
<span class="lineNum">     166 </span><span class="lineCov">         27 :         struct ast_variable *var = ast_variable_new(name, value, o-&gt;fn);</span>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span><span class="lineCov">         27 :         if (!var) {</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     170 </span>            :         }
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :         /* Always insert at the end, because some people want to treat the spool
<span class="lineNum">     173 </span>            :          * file as a script */
<span class="lineNum">     174 </span><span class="lineCov">         27 :         ast_variable_list_append(&amp;o-&gt;vars, var);</span>
<a name="175"><span class="lineNum">     175 </span>            : }</a>
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span><span class="lineCov">        316 : static void parse_line(char *line, unsigned int lineno, struct outgoing *o)</span>
<span class="lineNum">     178 </span>            : {
<span class="lineNum">     179 </span>            :         char *c;
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            :         /* Trim comments */
<span class="lineNum">     182 </span><span class="lineCov">        316 :         c = line;</span>
<span class="lineNum">     183 </span><span class="lineCov">        316 :         while ((c = strchr(c, '#'))) {</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :                 if ((c == line) || (*(c-1) == ' ') || (*(c-1) == '\t')) {</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :                         *c = '\0';</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     187 </span>            :                 }
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :                 c++;</span>
<span class="lineNum">     189 </span>            :         }
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span><span class="lineCov">        316 :         c = line;</span>
<span class="lineNum">     192 </span><span class="lineCov">        316 :         while ((c = strchr(c, ';'))) {</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :                 if ((c &gt; line) &amp;&amp; (c[-1] == '\\')) {</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :                         memmove(c - 1, c, strlen(c) + 1);</span>
<span class="lineNum">     195 </span>            :                 } else {
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :                         *c = '\0';</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     198 </span>            :                 }
<span class="lineNum">     199 </span>            :         }
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :         /* Trim trailing white space */
<span class="lineNum">     202 </span><span class="lineCov">        316 :         ast_trim_blanks(line);</span>
<span class="lineNum">     203 </span><span class="lineCov">        316 :         if (ast_strlen_zero(line)) {</span>
<span class="lineNum">     204 </span><span class="lineCov">         56 :                 return;</span>
<span class="lineNum">     205 </span>            :         }
<span class="lineNum">     206 </span><span class="lineCov">        260 :         c = strchr(line, ':');</span>
<span class="lineNum">     207 </span><span class="lineCov">        260 :         if (!c) {</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :                 ast_log(LOG_NOTICE, &quot;Syntax error at line %d of %s\n&quot;, lineno, o-&gt;fn);</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     210 </span>            :         }
<span class="lineNum">     211 </span><span class="lineCov">        260 :         *c = '\0';</span>
<span class="lineNum">     212 </span><span class="lineCov">        260 :         c = ast_skip_blanks(c + 1);</span>
<span class="lineNum">     213 </span>            : #if 0
<span class="lineNum">     214 </span>            :         printf(&quot;'%s' is '%s' at line %d\n&quot;, line, c, lineno);
<span class="lineNum">     215 </span>            : #endif
<span class="lineNum">     216 </span><span class="lineCov">        260 :         if (!strcasecmp(line, &quot;channel&quot;)) {</span>
<span class="lineNum">     217 </span>            :                 char *c2;
<span class="lineNum">     218 </span><span class="lineCov">         27 :                 if ((c2 = strchr(c, '/'))) {</span>
<span class="lineNum">     219 </span><span class="lineCov">         27 :                         *c2 = '\0';</span>
<span class="lineNum">     220 </span><span class="lineCov">         27 :                         c2++;</span>
<span class="lineNum">     221 </span><span class="lineCov">         27 :                         ast_string_field_set(o, tech, c);</span>
<span class="lineNum">     222 </span><span class="lineCov">         27 :                         ast_string_field_set(o, dest, c2);</span>
<span class="lineNum">     223 </span>            :                 } else {
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :                         ast_log(LOG_NOTICE, &quot;Channel should be in form Tech/Dest at line %d of %s\n&quot;, lineno, o-&gt;fn);</span>
<span class="lineNum">     225 </span>            :                 }
<span class="lineNum">     226 </span><span class="lineCov">        233 :         } else if (!strcasecmp(line, &quot;callerid&quot;)) {</span>
<span class="lineNum">     227 </span><span class="lineCov">          7 :                 char cid_name[80] = {0}, cid_num[80] = {0};</span>
<span class="lineNum">     228 </span><span class="lineCov">          7 :                 ast_callerid_split(c, cid_name, sizeof(cid_name), cid_num, sizeof(cid_num));</span>
<span class="lineNum">     229 </span><span class="lineCov">          7 :                 ast_string_field_set(o, cid_num, cid_num);</span>
<span class="lineNum">     230 </span><span class="lineCov">          7 :                 ast_string_field_set(o, cid_name, cid_name);</span>
<span class="lineNum">     231 </span><span class="lineCov">        226 :         } else if (!strcasecmp(line, &quot;application&quot;)) {</span>
<span class="lineNum">     232 </span><span class="lineCov">          3 :                 ast_string_field_set(o, app, c);</span>
<span class="lineNum">     233 </span><span class="lineCov">        223 :         } else if (!strcasecmp(line, &quot;data&quot;)) {</span>
<span class="lineNum">     234 </span><span class="lineCov">          3 :                 ast_string_field_set(o, data, c);</span>
<span class="lineNum">     235 </span><span class="lineCov">        220 :         } else if (!strcasecmp(line, &quot;maxretries&quot;)) {</span>
<span class="lineNum">     236 </span><span class="lineCov">         25 :                 if (sscanf(c, &quot;%30d&quot;, &amp;o-&gt;maxretries) != 1) {</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Invalid max retries at line %d of %s\n&quot;, lineno, o-&gt;fn);</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :                         o-&gt;maxretries = 0;</span>
<span class="lineNum">     239 </span>            :                 }
<span class="lineNum">     240 </span><span class="lineCov">        195 :         } else if (!strcasecmp(line, &quot;codecs&quot;)) {</span>
<span class="lineNum">     241 </span><span class="lineCov">          9 :                 ast_format_cap_update_by_allow_disallow(o-&gt;capabilities, c, 1);</span>
<span class="lineNum">     242 </span><span class="lineCov">        186 :         } else if (!strcasecmp(line, &quot;context&quot;)) {</span>
<span class="lineNum">     243 </span><span class="lineCov">         24 :                 ast_string_field_set(o, context, c);</span>
<span class="lineNum">     244 </span><span class="lineCov">        162 :         } else if (!strcasecmp(line, &quot;extension&quot;)) {</span>
<span class="lineNum">     245 </span><span class="lineCov">         24 :                 ast_string_field_set(o, exten, c);</span>
<span class="lineNum">     246 </span><span class="lineCov">        138 :         } else if (!strcasecmp(line, &quot;priority&quot;)) {</span>
<span class="lineNum">     247 </span><span class="lineCov">         24 :                 if ((sscanf(c, &quot;%30d&quot;, &amp;o-&gt;priority) != 1) || (o-&gt;priority &lt; 1)) {</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Invalid priority at line %d of %s\n&quot;, lineno, o-&gt;fn);</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                         o-&gt;priority = 1;</span>
<span class="lineNum">     250 </span>            :                 }
<span class="lineNum">     251 </span><span class="lineCov">        114 :         } else if (!strcasecmp(line, &quot;retrytime&quot;)) {</span>
<span class="lineNum">     252 </span><span class="lineCov">         25 :                 if ((sscanf(c, &quot;%30d&quot;, &amp;o-&gt;retrytime) != 1) || (o-&gt;retrytime &lt; 1)) {</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Invalid retrytime at line %d of %s\n&quot;, lineno, o-&gt;fn);</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :                         o-&gt;retrytime = 300;</span>
<span class="lineNum">     255 </span>            :                 }
<span class="lineNum">     256 </span><span class="lineCov">         89 :         } else if (!strcasecmp(line, &quot;waittime&quot;)) {</span>
<span class="lineNum">     257 </span><span class="lineCov">         25 :                 if ((sscanf(c, &quot;%30d&quot;, &amp;o-&gt;waittime) != 1) || (o-&gt;waittime &lt; 1)) {</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Invalid waittime at line %d of %s\n&quot;, lineno, o-&gt;fn);</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :                         o-&gt;waittime = 45;</span>
<span class="lineNum">     260 </span>            :                 }
<span class="lineNum">     261 </span><span class="lineCov">         64 :         } else if (!strcasecmp(line, &quot;retry&quot;)) {</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :                 o-&gt;retries++;</span>
<span class="lineNum">     263 </span><span class="lineCov">         64 :         } else if (!strcasecmp(line, &quot;startretry&quot;)) {</span>
<span class="lineNum">     264 </span><span class="lineCov">         27 :                 if (sscanf(c, &quot;%30ld&quot;, &amp;o-&gt;callingpid) != 1) {</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Unable to retrieve calling PID!\n&quot;);</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :                         o-&gt;callingpid = 0;</span>
<span class="lineNum">     267 </span>            :                 }
<span class="lineNum">     268 </span><span class="lineCov">         37 :         } else if (!strcasecmp(line, &quot;endretry&quot;) || !strcasecmp(line, &quot;abortretry&quot;)) {</span>
<span class="lineNum">     269 </span><span class="lineCov">         27 :                 o-&gt;callingpid = 0;</span>
<span class="lineNum">     270 </span><span class="lineCov">         27 :                 o-&gt;retries++;</span>
<span class="lineNum">     271 </span><span class="lineCov">         10 :         } else if (!strcasecmp(line, &quot;delayedretry&quot;)) {</span>
<span class="lineNum">     272 </span><span class="lineCov">         10 :         } else if (!strcasecmp(line, &quot;setvar&quot;) || !strcasecmp(line, &quot;set&quot;)) {</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :                 char *c2 = c;</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :                 strsep(&amp;c2, &quot;=&quot;);</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                 if (c2) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :                         append_variable(o, c, c2);</span>
<span class="lineNum">     278 </span>            :                 } else {
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Malformed \&quot;%s\&quot; argument.  Should be \&quot;%s: variable=value\&quot;\n&quot;, line, line);</span>
<span class="lineNum">     280 </span>            :                 }
<span class="lineNum">     281 </span><span class="lineCov">         10 :         } else if (!strcasecmp(line, &quot;account&quot;)) {</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :                 ast_string_field_set(o, account, c);</span>
<span class="lineNum">     283 </span><span class="lineCov">         10 :         } else if (!strcasecmp(line, &quot;alwaysdelete&quot;)) {</span>
<span class="lineNum">     284 </span><span class="lineCov">          5 :                 ast_set2_flag(&amp;o-&gt;options, ast_true(c), SPOOL_FLAG_ALWAYS_DELETE);</span>
<span class="lineNum">     285 </span><span class="lineCov">          5 :         } else if (!strcasecmp(line, &quot;archive&quot;)) {</span>
<span class="lineNum">     286 </span><span class="lineCov">          5 :                 ast_set2_flag(&amp;o-&gt;options, ast_true(c), SPOOL_FLAG_ARCHIVE);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(line, &quot;early_media&quot;)) {</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :                 ast_set2_flag(&amp;o-&gt;options, ast_true(c), SPOOL_FLAG_EARLY_MEDIA);</span>
<span class="lineNum">     289 </span>            :         } else {
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unknown keyword '%s' at line %d of %s\n&quot;, line, lineno, o-&gt;fn);</span>
<span class="lineNum">     291 </span>            :         }
<span class="lineNum">     292 </span>            : }
<span class="lineNum">     293 </span>            : 
<a name="294"><span class="lineNum">     294 </span>            : #define LINE_BUFFER_SIZE 1024</a>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineCov">         27 : static int apply_outgoing(struct outgoing *o, FILE *f)</span>
<span class="lineNum">     297 </span>            : {
<span class="lineNum">     298 </span>            :         char buf[LINE_BUFFER_SIZE];
<span class="lineNum">     299 </span><span class="lineCov">         27 :         unsigned int lineno = 0;</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineCov">        343 :         while (fgets(buf, sizeof(buf), f)) {</span>
<span class="lineNum">     302 </span><span class="lineCov">        316 :                 size_t len = strlen(buf);</span>
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span><span class="lineCov">        316 :                 lineno++;</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span><span class="lineCov">        316 :                 if (buf[len - 1] == '\n' || feof(f)) {</span>
<span class="lineNum">     307 </span>            :                         /* We have a line, parse it */
<span class="lineNum">     308 </span><span class="lineCov">        316 :                         parse_line(buf, lineno, o);</span>
<span class="lineNum">     309 </span><span class="lineCov">        316 :                         continue;</span>
<span class="lineNum">     310 </span>            :                 }
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :                 /* Crazy long line, skip it */
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Skipping extremely long line at line %d of %s\n&quot;, lineno, o-&gt;fn);</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :                 /* Consume the rest of the problematic line */
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :                 while (fgets(buf, sizeof(buf), f)) {</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :                         len = strlen(buf);</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :                         if (buf[len - 1] == '\n' || feof(f)) {</span>
<span class="lineNum">     319 </span>            :                                 break;
<span class="lineNum">     320 </span>            :                         }
<span class="lineNum">     321 </span>            :                 }
<span class="lineNum">     322 </span>            :         }
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span><span class="lineCov">         27 :         if (ast_strlen_zero(o-&gt;tech)</span>
<span class="lineNum">     325 </span><span class="lineCov">         27 :                 || ast_strlen_zero(o-&gt;dest)</span>
<span class="lineNum">     326 </span><span class="lineCov">         27 :                 || (ast_strlen_zero(o-&gt;app) &amp;&amp; ast_strlen_zero(o-&gt;exten))) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;At least one of app or extension must be specified, &quot;</span>
<span class="lineNum">     328 </span>            :                         &quot;along with tech and dest in file %s\n&quot;, o-&gt;fn);
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     330 </span>            :         }
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineCov">         27 :         if (snprintf(buf, sizeof(buf), &quot;%d&quot;, o-&gt;retries + 1) &lt; sizeof(buf)) {</span>
<span class="lineNum">     333 </span><span class="lineCov">         27 :                 append_variable(o, &quot;AST_OUTGOING_ATTEMPT&quot;, buf);</span>
<span class="lineNum">     334 </span>            :         }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineCov">         27 :         return 0;</span>
<a name="337"><span class="lineNum">     337 </span>            : }</a>
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span><span class="lineCov">         40 : static void safe_append(struct outgoing *o, time_t now, char *s)</span>
<span class="lineNum">     340 </span>            : {
<span class="lineNum">     341 </span>            :         FILE *f;
<span class="lineNum">     342 </span><span class="lineCov">         40 :         struct utimbuf tbuf = { .actime = now, .modtime = now + o-&gt;retrytime };</span>
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineCov">         40 :         ast_debug(1, &quot;Outgoing %s/%s: %s\n&quot;, o-&gt;tech, o-&gt;dest, s);</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineCov">         40 :         if ((f = fopen(o-&gt;fn, &quot;a&quot;))) {</span>
<span class="lineNum">     347 </span><span class="lineCov">         40 :                 fprintf(f, &quot;\n%s: %ld %d (%ld)\n&quot;, s, (long)ast_mainpid, o-&gt;retries, (long) now);</span>
<span class="lineNum">     348 </span><span class="lineCov">         40 :                 fclose(f);</span>
<span class="lineNum">     349 </span>            :         }
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            :         /* Update the file time */
<span class="lineNum">     352 </span><span class="lineCov">         40 :         if (utime(o-&gt;fn, &amp;tbuf)) {</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unable to set utime on %s: %s\n&quot;, o-&gt;fn, strerror(errno));</span>
<span class="lineNum">     354 </span>            :         }
<span class="lineNum">     355 </span><span class="lineCov">         40 : }</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            : /*!
<span class="lineNum">     358 </span>            :  * \brief Remove a call file from the outgoing queue optionally moving it in the archive dir
<span class="lineNum">     359 </span>            :  *
<span class="lineNum">     360 </span>            :  * \param o the pointer to outgoing struct
<a name="361"><span class="lineNum">     361 </span>            :  * \param status the exit status of the call. Can be &quot;Completed&quot;, &quot;Failed&quot; or &quot;Expired&quot;</a>
<span class="lineNum">     362 </span>            :  */
<span class="lineNum">     363 </span><span class="lineCov">         14 : static int remove_from_queue(struct outgoing *o, const char *status)</span>
<span class="lineNum">     364 </span>            : {
<span class="lineNum">     365 </span>            :         FILE *f;
<span class="lineNum">     366 </span>            :         char newfn[256];
<span class="lineNum">     367 </span>            :         const char *bname;
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            : #if defined(HAVE_INOTIFY) || defined(HAVE_KQUEUE)
<span class="lineNum">     370 </span>            :         struct direntry *cur;
<span class="lineNum">     371 </span>            : #endif
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineCov">         14 :         if (!ast_test_flag(&amp;o-&gt;options, SPOOL_FLAG_ALWAYS_DELETE)) {</span>
<span class="lineNum">     374 </span>            :                 struct stat current_file_status;
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineCov">          1 :                 if (!stat(o-&gt;fn, &amp;current_file_status)) {</span>
<span class="lineNum">     377 </span><span class="lineCov">          1 :                         if (time(NULL) &lt; current_file_status.st_mtime) {</span>
<span class="lineNum">     378 </span><span class="lineCov">          1 :                                 return 0;</span>
<span class="lineNum">     379 </span>            :                         }
<span class="lineNum">     380 </span>            :                 }
<span class="lineNum">     381 </span>            :         }
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            : #if defined(HAVE_INOTIFY) || defined(HAVE_KQUEUE)
<span class="lineNum">     384 </span><span class="lineCov">         13 :         AST_LIST_LOCK(&amp;dirlist);</span>
<span class="lineNum">     385 </span><span class="lineCov">         13 :         AST_LIST_TRAVERSE_SAFE_BEGIN(&amp;dirlist, cur, list) {</span>
<span class="lineNum">     386 </span><span class="lineCov">         13 :                 if (!strcmp(cur-&gt;name, o-&gt;fn)) {</span>
<span class="lineNum">     387 </span><span class="lineCov">         13 :                         AST_LIST_REMOVE_CURRENT(list);</span>
<span class="lineNum">     388 </span><span class="lineCov">         13 :                         ast_free(cur);</span>
<span class="lineNum">     389 </span><span class="lineCov">         13 :                         break;</span>
<span class="lineNum">     390 </span>            :                 }
<span class="lineNum">     391 </span>            :         }
<span class="lineNum">     392 </span>            :         AST_LIST_TRAVERSE_SAFE_END;
<span class="lineNum">     393 </span><span class="lineCov">         13 :         AST_LIST_UNLOCK(&amp;dirlist);</span>
<span class="lineNum">     394 </span>            : #endif
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineCov">         13 :         if (!ast_test_flag(&amp;o-&gt;options, SPOOL_FLAG_ARCHIVE)) {</span>
<span class="lineNum">     397 </span><span class="lineCov">         12 :                 unlink(o-&gt;fn);</span>
<span class="lineNum">     398 </span><span class="lineCov">         12 :                 return 0;</span>
<span class="lineNum">     399 </span>            :         }
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineCov">          1 :         if (ast_mkdir(qdonedir, 0777)) {</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unable to create queue directory %s -- outgoing spool archiving disabled\n&quot;, qdonedir);</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :                 unlink(o-&gt;fn);</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     405 </span>            :         }
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineCov">          1 :         if (!(bname = strrchr(o-&gt;fn, '/'))) {</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                 bname = o-&gt;fn;</span>
<span class="lineNum">     409 </span>            :         } else {
<span class="lineNum">     410 </span><span class="lineCov">          1 :                 bname++;</span>
<span class="lineNum">     411 </span>            :         }
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span><span class="lineCov">          1 :         snprintf(newfn, sizeof(newfn), &quot;%s/%s&quot;, qdonedir, bname);</span>
<span class="lineNum">     414 </span>            :         /* If there is already a call file with the name in the archive dir, it will be overwritten. */
<span class="lineNum">     415 </span><span class="lineCov">          1 :         unlink(newfn);</span>
<span class="lineNum">     416 </span><span class="lineCov">          1 :         if (rename(o-&gt;fn, newfn) != 0) {</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :                 unlink(o-&gt;fn);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     419 </span>            :         }
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            :         /* Only append to the file AFTER we move it out of the watched directory,
<span class="lineNum">     422 </span>            :          * otherwise the fclose() causes another event for inotify(7) */
<span class="lineNum">     423 </span><span class="lineCov">          1 :         if ((f = fopen(newfn, &quot;a&quot;))) {</span>
<span class="lineNum">     424 </span><span class="lineCov">          1 :                 fprintf(f, &quot;Status: %s\n&quot;, status);</span>
<span class="lineNum">     425 </span><span class="lineCov">          1 :                 fclose(f);</span>
<span class="lineNum">     426 </span>            :         }
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span><span class="lineCov">          1 :         return 0;</span>
<a name="429"><span class="lineNum">     429 </span>            : }</a>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span><span class="lineCov">         27 : static void *attempt_thread(void *data)</span>
<span class="lineNum">     432 </span>            : {
<span class="lineNum">     433 </span><span class="lineCov">         27 :         struct outgoing *o = data;</span>
<span class="lineNum">     434 </span>            :         int res, reason;
<span class="lineNum">     435 </span><span class="lineCov">         27 :         if (!ast_strlen_zero(o-&gt;app)) {</span>
<span class="lineNum">     436 </span><span class="lineCov">          3 :                 ast_verb(3, &quot;Attempting call on %s/%s for application %s(%s) (Retry %d)\n&quot;, o-&gt;tech, o-&gt;dest, o-&gt;app, o-&gt;data, o-&gt;retries);</span>
<span class="lineNum">     437 </span><span class="lineCov">          6 :                 res = ast_pbx_outgoing_app(o-&gt;tech, o-&gt;capabilities, o-&gt;dest,</span>
<span class="lineNum">     438 </span><span class="lineCov">          3 :                         o-&gt;waittime * 1000, o-&gt;app, o-&gt;data, &amp;reason,</span>
<span class="lineNum">     439 </span>            :                         AST_OUTGOING_WAIT_COMPLETE, o-&gt;cid_num, o-&gt;cid_name,
<span class="lineNum">     440 </span>            :                         o-&gt;vars, o-&gt;account, NULL, NULL);
<span class="lineNum">     441 </span>            :         } else {
<span class="lineNum">     442 </span><span class="lineCov">         24 :                 ast_verb(3, &quot;Attempting call on %s/%s for %s@%s:%d (Retry %d)\n&quot;, o-&gt;tech, o-&gt;dest, o-&gt;exten, o-&gt;context,o-&gt;priority, o-&gt;retries);</span>
<span class="lineNum">     443 </span><span class="lineCov">         48 :                 res = ast_pbx_outgoing_exten(o-&gt;tech, o-&gt;capabilities, o-&gt;dest,</span>
<span class="lineNum">     444 </span><span class="lineCov">         24 :                         o-&gt;waittime * 1000, o-&gt;context, o-&gt;exten, o-&gt;priority, &amp;reason,</span>
<span class="lineNum">     445 </span>            :                         AST_OUTGOING_WAIT_COMPLETE, o-&gt;cid_num, o-&gt;cid_name,
<span class="lineNum">     446 </span><span class="lineCov">         24 :                         o-&gt;vars, o-&gt;account, NULL, ast_test_flag(&amp;o-&gt;options, SPOOL_FLAG_EARLY_MEDIA),</span>
<span class="lineNum">     447 </span>            :                         NULL);
<span class="lineNum">     448 </span>            :         }
<span class="lineNum">     449 </span><span class="lineCov">         27 :         if (res) {</span>
<span class="lineNum">     450 </span><span class="lineCov">         15 :                 ast_log(LOG_NOTICE, &quot;Call failed to go through, reason (%d) %s\n&quot;, reason, ast_channel_reason2str(reason));</span>
<span class="lineNum">     451 </span><span class="lineCov">         15 :                 if (o-&gt;retries &gt;= o-&gt;maxretries + 1) {</span>
<span class="lineNum">     452 </span>            :                         /* Max retries exceeded */
<span class="lineNum">     453 </span><span class="lineCov">          2 :                         ast_log(LOG_NOTICE, &quot;Queued call to %s/%s expired without completion after %d attempt%s\n&quot;, o-&gt;tech, o-&gt;dest, o-&gt;retries - 1, ((o-&gt;retries - 1) != 1) ? &quot;s&quot; : &quot;&quot;);</span>
<span class="lineNum">     454 </span><span class="lineCov">          2 :                         remove_from_queue(o, &quot;Expired&quot;);</span>
<span class="lineNum">     455 </span>            :                 } else {
<span class="lineNum">     456 </span>            :                         /* Notate that the call is still active */
<span class="lineNum">     457 </span><span class="lineCov">         13 :                         safe_append(o, time(NULL), &quot;EndRetry&quot;);</span>
<span class="lineNum">     458 </span>            : #if defined(HAVE_INOTIFY) || defined(HAVE_KQUEUE)
<span class="lineNum">     459 </span><span class="lineCov">         13 :                         queue_file(o-&gt;fn, time(NULL) + o-&gt;retrytime);</span>
<span class="lineNum">     460 </span>            : #endif
<span class="lineNum">     461 </span>            :                 }
<span class="lineNum">     462 </span>            :         } else {
<span class="lineNum">     463 </span><span class="lineCov">         12 :                 ast_log(LOG_NOTICE, &quot;Call completed to %s/%s\n&quot;, o-&gt;tech, o-&gt;dest);</span>
<span class="lineNum">     464 </span><span class="lineCov">         12 :                 remove_from_queue(o, &quot;Completed&quot;);</span>
<span class="lineNum">     465 </span>            :         }
<span class="lineNum">     466 </span><span class="lineCov">         27 :         free_outgoing(o);</span>
<span class="lineNum">     467 </span><span class="lineCov">         27 :         return NULL;</span>
<a name="468"><span class="lineNum">     468 </span>            : }</a>
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineCov">         27 : static void launch_service(struct outgoing *o)</span>
<span class="lineNum">     471 </span>            : {
<span class="lineNum">     472 </span>            :         pthread_t t;
<span class="lineNum">     473 </span>            :         int ret;
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineCov">         27 :         if ((ret = ast_pthread_create_detached(&amp;t, NULL, attempt_thread, o))) {</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unable to create thread :( (returned error: %d)\n&quot;, ret);</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :                 free_outgoing(o);</span>
<span class="lineNum">     478 </span>            :         }
<span class="lineNum">     479 </span><span class="lineCov">         27 : }</span>
<a name="480"><span class="lineNum">     480 </span>            : </a>
<span class="lineNum">     481 </span>            : /* Called from scan_thread or queue_file */
<span class="lineNum">     482 </span><span class="lineCov">         27 : static int scan_service(const char *fn, time_t now)</span>
<span class="lineNum">     483 </span>            : {
<span class="lineNum">     484 </span>            :         struct outgoing *o;
<span class="lineNum">     485 </span>            :         FILE *f;
<span class="lineNum">     486 </span>            :         int res;
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span><span class="lineCov">         27 :         o = new_outgoing(fn);</span>
<span class="lineNum">     489 </span><span class="lineCov">         27 :         if (!o) {</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     491 </span>            :         }
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            :         /* Attempt to open the file */
<span class="lineNum">     494 </span><span class="lineCov">         27 :         f = fopen(o-&gt;fn, &quot;r&quot;);</span>
<span class="lineNum">     495 </span><span class="lineCov">         27 :         if (!f) {</span>
<span class="lineNum">     496 </span>            : #if defined(HAVE_INOTIFY) || defined(HAVE_KQUEUE)
<span class="lineNum">     497 </span>            :                 /*!
<span class="lineNum">     498 </span>            :                  * \todo XXX There is some odd delayed duplicate servicing of
<span class="lineNum">     499 </span>            :                  * call files going on.  We need to suppress the error message
<span class="lineNum">     500 </span>            :                  * if the file does not exist as a result.
<span class="lineNum">     501 </span>            :                  */
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :                 if (errno != ENOENT)</span>
<span class="lineNum">     503 </span>            : #endif
<span class="lineNum">     504 </span>            :                 {
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Unable to open %s: '%s'(%d), deleting\n&quot;,</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :                                 o-&gt;fn, strerror(errno), (int) errno);</span>
<span class="lineNum">     507 </span>            :                 }
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :                 remove_from_queue(o, &quot;Failed&quot;);</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :                 free_outgoing(o);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     511 </span>            :         }
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            :         /* Read in and verify the contents */
<span class="lineNum">     514 </span><span class="lineCov">         27 :         res = apply_outgoing(o, f);</span>
<span class="lineNum">     515 </span><span class="lineCov">         27 :         fclose(f);</span>
<span class="lineNum">     516 </span><span class="lineCov">         27 :         if (res) {</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Invalid file contents in %s, deleting\n&quot;, o-&gt;fn);</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                 remove_from_queue(o, &quot;Failed&quot;);</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                 free_outgoing(o);</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     521 </span>            :         }
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineCov">         27 :         ast_debug(1, &quot;Filename: %s, Retries: %d, max: %d\n&quot;, o-&gt;fn, o-&gt;retries, o-&gt;maxretries);</span>
<span class="lineNum">     524 </span><span class="lineCov">         27 :         if (o-&gt;retries &lt;= o-&gt;maxretries) {</span>
<span class="lineNum">     525 </span><span class="lineCov">         27 :                 now += o-&gt;retrytime;</span>
<span class="lineNum">     526 </span><span class="lineCov">         27 :                 if (o-&gt;callingpid &amp;&amp; (o-&gt;callingpid == ast_mainpid)) {</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                         safe_append(o, time(NULL), &quot;DelayedRetry&quot;);</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :                         ast_debug(1, &quot;Delaying retry since we're currently running '%s'\n&quot;, o-&gt;fn);</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :                         free_outgoing(o);</span>
<span class="lineNum">     530 </span>            :                 } else {
<span class="lineNum">     531 </span>            :                         /* Increment retries */
<span class="lineNum">     532 </span><span class="lineCov">         27 :                         o-&gt;retries++;</span>
<span class="lineNum">     533 </span>            :                         /* If someone else was calling, they're presumably gone now
<span class="lineNum">     534 </span>            :                            so abort their retry and continue as we were... */
<span class="lineNum">     535 </span><span class="lineCov">         27 :                         if (o-&gt;callingpid)</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :                                 safe_append(o, time(NULL), &quot;AbortRetry&quot;);</span>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineCov">         27 :                         safe_append(o, now, &quot;StartRetry&quot;);</span>
<span class="lineNum">     539 </span><span class="lineCov">         27 :                         launch_service(o);</span>
<span class="lineNum">     540 </span>            :                 }
<span class="lineNum">     541 </span><span class="lineCov">         27 :                 return now;</span>
<span class="lineNum">     542 </span>            :         }
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :         ast_log(LOG_NOTICE, &quot;Queued call to %s/%s expired without completion after %d attempt%s\n&quot;,</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                 o-&gt;tech, o-&gt;dest, o-&gt;retries - 1, ((o-&gt;retries - 1) != 1) ? &quot;s&quot; : &quot;&quot;);</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         remove_from_queue(o, &quot;Expired&quot;);</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         free_outgoing(o);</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     549 </span>            : }
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            : #if defined(HAVE_INOTIFY)
<span class="lineNum">     553 </span>            : /* Only one thread is accessing this list, so no lock is necessary */
<span class="lineNum">     554 </span>            : static AST_LIST_HEAD_NOLOCK_STATIC(createlist, direntry);
<span class="lineNum">     555 </span>            : static AST_LIST_HEAD_NOLOCK_STATIC(openlist, direntry);
<span class="lineNum">     556 </span>            : #endif
<span class="lineNum">     557 </span>            : 
<a name="558"><span class="lineNum">     558 </span>            : #if defined(HAVE_INOTIFY) || defined(HAVE_KQUEUE)</a>
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineCov">       2270 : static void queue_file(const char *filename, time_t when)</span>
<span class="lineNum">     561 </span>            : {
<span class="lineNum">     562 </span>            :         struct stat st;
<span class="lineNum">     563 </span>            :         struct direntry *cur, *new;
<span class="lineNum">     564 </span>            :         int res;
<span class="lineNum">     565 </span><span class="lineCov">       2270 :         time_t now = time(NULL);</span>
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span><span class="lineCov">       2270 :         if (!strchr(filename, '/')) {</span>
<span class="lineNum">     568 </span><span class="lineCov">       2245 :                 char *fn = ast_alloca(strlen(qdir) + strlen(filename) + 2);</span>
<span class="lineNum">     569 </span><span class="lineCov">       2245 :                 sprintf(fn, &quot;%s/%s&quot;, qdir, filename); /* SAFE */</span>
<span class="lineNum">     570 </span><span class="lineCov">       2245 :                 filename = fn;</span>
<span class="lineNum">     571 </span>            :         }
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineCov">       2270 :         if (when == 0) {</span>
<span class="lineNum">     574 </span><span class="lineCov">       2245 :                 if (stat(filename, &amp;st)) {</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Unable to stat %s: %s\n&quot;, filename, strerror(errno));</span>
<span class="lineNum">     576 </span><span class="lineCov">       2243 :                         return;</span>
<span class="lineNum">     577 </span>            :                 }
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineCov">       2245 :                 if (!S_ISREG(st.st_mode)) {</span>
<span class="lineNum">     580 </span><span class="lineCov">       2230 :                         return;</span>
<span class="lineNum">     581 </span>            :                 }
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineCov">         15 :                 when = st.st_mtime;</span>
<span class="lineNum">     584 </span>            :         }
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :         /* Need to check the existing list in order to avoid duplicates. */
<span class="lineNum">     587 </span><span class="lineCov">         40 :         AST_LIST_LOCK(&amp;dirlist);</span>
<span class="lineNum">     588 </span><span class="lineCov">         48 :         AST_LIST_TRAVERSE(&amp;dirlist, cur, list) {</span>
<span class="lineNum">     589 </span><span class="lineCov">         21 :                 if (cur-&gt;mtime == when &amp;&amp; !strcmp(filename, cur-&gt;name)) {</span>
<span class="lineNum">     590 </span><span class="lineCov">         13 :                         AST_LIST_UNLOCK(&amp;dirlist);</span>
<span class="lineNum">     591 </span><span class="lineCov">         13 :                         return;</span>
<span class="lineNum">     592 </span>            :                 }
<span class="lineNum">     593 </span>            :         }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span><span class="lineCov">         27 :         if ((res = when) &gt; now || (res = scan_service(filename, now)) &gt; 0) {</span>
<span class="lineNum">     596 </span><span class="lineCov">         27 :                 if (!(new = ast_calloc(1, sizeof(*new) + strlen(filename) + 1))) {</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :                         AST_LIST_UNLOCK(&amp;dirlist);</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">     599 </span>            :                 }
<span class="lineNum">     600 </span><span class="lineCov">         27 :                 new-&gt;mtime = res;</span>
<span class="lineNum">     601 </span><span class="lineCov">         27 :                 strcpy(new-&gt;name, filename);</span>
<span class="lineNum">     602 </span>            :                 /* List is ordered by mtime */
<span class="lineNum">     603 </span><span class="lineCov">         27 :                 if (AST_LIST_EMPTY(&amp;dirlist)) {</span>
<span class="lineNum">     604 </span><span class="lineCov">         19 :                         AST_LIST_INSERT_HEAD(&amp;dirlist, new, list);</span>
<span class="lineNum">     605 </span>            :                 } else {
<span class="lineNum">     606 </span><span class="lineCov">          8 :                         int found = 0;</span>
<span class="lineNum">     607 </span><span class="lineCov">         16 :                         AST_LIST_TRAVERSE_SAFE_BEGIN(&amp;dirlist, cur, list) {</span>
<span class="lineNum">     608 </span><span class="lineCov">          8 :                                 if (cur-&gt;mtime &gt; new-&gt;mtime) {</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :                                         AST_LIST_INSERT_BEFORE_CURRENT(new, list);</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :                                         found = 1;</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">     612 </span>            :                                 }
<span class="lineNum">     613 </span>            :                         }
<span class="lineNum">     614 </span>            :                         AST_LIST_TRAVERSE_SAFE_END
<span class="lineNum">     615 </span><span class="lineCov">          8 :                         if (!found) {</span>
<span class="lineNum">     616 </span><span class="lineCov">          8 :                                 AST_LIST_INSERT_TAIL(&amp;dirlist, new, list);</span>
<span class="lineNum">     617 </span>            :                         }
<span class="lineNum">     618 </span>            :                 }
<span class="lineNum">     619 </span>            :         }
<span class="lineNum">     620 </span><span class="lineCov">         27 :         AST_LIST_UNLOCK(&amp;dirlist);</span>
<span class="lineNum">     621 </span>            : }
<a name="622"><span class="lineNum">     622 </span>            : </a>
<span class="lineNum">     623 </span>            : #ifdef HAVE_INOTIFY
<span class="lineNum">     624 </span><span class="lineNoCov">          0 : static void queue_file_create(const char *filename)</span>
<span class="lineNum">     625 </span>            : {
<span class="lineNum">     626 </span>            :         struct direntry *cur;
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         AST_LIST_TRAVERSE(&amp;createlist, cur, list) {</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :                 if (!strcmp(cur-&gt;name, filename)) {</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">     631 </span>            :                 }
<span class="lineNum">     632 </span>            :         }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :         if (!(cur = ast_calloc(1, sizeof(*cur) + strlen(filename) + 1))) {</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     636 </span>            :         }
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :         strcpy(cur-&gt;name, filename);</span>
<span class="lineNum">     638 </span>            :         /* We'll handle this file unless an IN_OPEN event occurs within 2 seconds */
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         cur-&gt;mtime = time(NULL) + 2;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         AST_LIST_INSERT_TAIL(&amp;createlist, cur, list);</span>
<a name="641"><span class="lineNum">     641 </span>            : }</a>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineCov">       1155 : static void queue_file_open(const char *filename)</span>
<span class="lineNum">     644 </span>            : {
<span class="lineNum">     645 </span>            :         struct direntry *cur;
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineCov">       1155 :         AST_LIST_TRAVERSE_SAFE_BEGIN(&amp;createlist, cur, list) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :                 if (!strcmp(cur-&gt;name, filename)) {</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :                         AST_LIST_REMOVE_CURRENT(list);</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :                         AST_LIST_INSERT_TAIL(&amp;openlist, cur, list);</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     652 </span>            :                 }
<span class="lineNum">     653 </span>            :         }
<span class="lineNum">     654 </span>            :         AST_LIST_TRAVERSE_SAFE_END
<a name="655"><span class="lineNum">     655 </span><span class="lineCov">       1155 : }</span></a>
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span><span class="lineCov">       1178 : static void queue_created_files(void)</span>
<span class="lineNum">     658 </span>            : {
<span class="lineNum">     659 </span>            :         struct direntry *cur;
<span class="lineNum">     660 </span><span class="lineCov">       1178 :         time_t now = time(NULL);</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineCov">       1178 :         AST_LIST_TRAVERSE_SAFE_BEGIN(&amp;createlist, cur, list) {</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :                 if (cur-&gt;mtime &gt; now) {</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     665 </span>            :                 }
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :                 AST_LIST_REMOVE_CURRENT(list);</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :                 queue_file(cur-&gt;name, 0);</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :                 ast_free(cur);</span>
<span class="lineNum">     670 </span>            :         }
<span class="lineNum">     671 </span>            :         AST_LIST_TRAVERSE_SAFE_END
<a name="672"><span class="lineNum">     672 </span><span class="lineCov">       1178 : }</span></a>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineCov">         40 : static void queue_file_write(const char *filename)</span>
<span class="lineNum">     675 </span>            : {
<span class="lineNum">     676 </span>            :         struct direntry *cur;
<span class="lineNum">     677 </span>            :         /* Only queue entries where an IN_CREATE preceded the IN_CLOSE_WRITE */
<span class="lineNum">     678 </span><span class="lineCov">         40 :         AST_LIST_TRAVERSE_SAFE_BEGIN(&amp;openlist, cur, list) {</span>
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :                 if (!strcmp(cur-&gt;name, filename)) {</span>
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :                         AST_LIST_REMOVE_CURRENT(list);</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :                         ast_free(cur);</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :                         queue_file(filename, 0);</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     684 </span>            :                 }
<span class="lineNum">     685 </span>            :         }
<span class="lineNum">     686 </span>            :         AST_LIST_TRAVERSE_SAFE_END
<span class="lineNum">     687 </span><span class="lineCov">         40 : }</span>
<a name="688"><span class="lineNum">     688 </span>            : #endif</a>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineCov">       1117 : static void *scan_thread(void *unused)</span>
<span class="lineNum">     691 </span>            : {
<span class="lineNum">     692 </span>            :         DIR *dir;
<span class="lineNum">     693 </span>            :         struct dirent *de;
<span class="lineNum">     694 </span>            :         time_t now;
<span class="lineNum">     695 </span><span class="lineCov">       1117 :         struct timespec ts = { .tv_sec = 1 };</span>
<span class="lineNum">     696 </span>            : #ifdef HAVE_INOTIFY
<span class="lineNum">     697 </span>            :         ssize_t res;
<span class="lineNum">     698 </span><span class="lineCov">       1117 :         int inotify_fd = inotify_init();</span>
<span class="lineNum">     699 </span>            :         struct inotify_event *iev;
<span class="lineNum">     700 </span>            :         char buf[8192] __attribute__((aligned (sizeof(int))));
<span class="lineNum">     701 </span><span class="lineCov">       1117 :         struct pollfd pfd = { .fd = inotify_fd, .events = POLLIN };</span>
<span class="lineNum">     702 </span>            : #else
<span class="lineNum">     703 </span>            :         struct timespec nowait = { .tv_sec = 0, .tv_nsec = 1 };
<span class="lineNum">     704 </span>            :         int inotify_fd = kqueue();
<span class="lineNum">     705 </span>            :         struct kevent kev;
<span class="lineNum">     706 </span>            :         struct kevent event;
<span class="lineNum">     707 </span>            : #endif
<span class="lineNum">     708 </span>            :         struct direntry *cur;
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span><span class="lineCov">       2333 :         while (!ast_fully_booted) {</span>
<span class="lineNum">     711 </span><span class="lineCov">       1218 :                 nanosleep(&amp;ts, NULL);</span>
<span class="lineNum">     712 </span>            :         }
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineCov">       1115 :         if (inotify_fd &lt; 0) {</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Unable to initialize &quot;</span>
<span class="lineNum">     716 </span>            : #ifdef HAVE_INOTIFY
<span class="lineNum">     717 </span>            :                         &quot;inotify(7)&quot;
<span class="lineNum">     718 </span>            : #else
<span class="lineNum">     719 </span>            :                         &quot;kqueue(2)&quot;
<span class="lineNum">     720 </span>            : #endif
<span class="lineNum">     721 </span>            :                         &quot;\n&quot;);
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     723 </span>            :         }
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            : #ifdef HAVE_INOTIFY
<span class="lineNum">     726 </span><span class="lineCov">       1115 :         inotify_add_watch(inotify_fd, qdir, IN_CREATE | IN_OPEN | IN_CLOSE_WRITE | IN_MOVED_TO);</span>
<span class="lineNum">     727 </span>            : #endif
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :         /* First, run through the directory and clear existing entries */
<span class="lineNum">     730 </span><span class="lineCov">       1115 :         if (!(dir = opendir(qdir))) {</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Unable to open directory %s: %s\n&quot;, qdir, strerror(errno));</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     733 </span>            :         }
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            : #ifndef HAVE_INOTIFY
<span class="lineNum">     736 </span>            :         EV_SET(&amp;kev, dirfd(dir), EVFILT_VNODE, EV_ADD | EV_ENABLE | EV_CLEAR, NOTE_WRITE, 0, NULL);
<span class="lineNum">     737 </span>            :         if (kevent(inotify_fd, &amp;kev, 1, &amp;event, 1, &amp;nowait) &lt; 0 &amp;&amp; errno != 0) {
<span class="lineNum">     738 </span>            :                 ast_log(LOG_ERROR, &quot;Unable to watch directory %s: %s\n&quot;, qdir, strerror(errno));
<span class="lineNum">     739 </span>            :         }
<span class="lineNum">     740 </span>            : #endif
<span class="lineNum">     741 </span><span class="lineCov">       1115 :         now = time(NULL);</span>
<span class="lineNum">     742 </span><span class="lineCov">       3353 :         while ((de = readdir(dir))) {</span>
<span class="lineNum">     743 </span><span class="lineCov">       2238 :                 queue_file(de-&gt;d_name, 0);</span>
<span class="lineNum">     744 </span>            :         }
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            : #ifdef HAVE_INOTIFY
<span class="lineNum">     747 </span>            :         /* Directory needs to remain open for kqueue(2) */
<span class="lineNum">     748 </span><span class="lineCov">       1115 :         closedir(dir);</span>
<span class="lineNum">     749 </span>            : #endif
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            :         /* Wait for either a) next timestamp to occur, or b) a change to happen */
<span class="lineNum">     752 </span><span class="lineCov">       1178 :         for (;/* ever */;) {</span>
<span class="lineNum">     753 </span><span class="lineCov">       2293 :                 time_t next = AST_LIST_EMPTY(&amp;dirlist) ? INT_MAX : AST_LIST_FIRST(&amp;dirlist)-&gt;mtime;</span>
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineCov">       2293 :                 time(&amp;now);</span>
<span class="lineNum">     756 </span><span class="lineCov">       2293 :                 if (next &gt; now) {</span>
<span class="lineNum">     757 </span>            : #ifdef HAVE_INOTIFY
<span class="lineNum">     758 </span><span class="lineCov">       2293 :                         int stage = 0;</span>
<span class="lineNum">     759 </span>            :                         /* Convert from seconds to milliseconds, unless there's nothing
<span class="lineNum">     760 </span>            :                          * in the queue already, in which case, we wait forever. */
<span class="lineNum">     761 </span><span class="lineCov">       2293 :                         int waittime = next == INT_MAX ? -1 : (next - now) * 1000;</span>
<span class="lineNum">     762 </span><span class="lineCov">       2293 :                         if (!AST_LIST_EMPTY(&amp;createlist)) {</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :                                 waittime = 1000;</span>
<span class="lineNum">     764 </span>            :                         }
<span class="lineNum">     765 </span>            :                         /* When a file arrives, add it to the queue, in mtime order. */
<span class="lineNum">     766 </span><span class="lineCov">       2293 :                         if ((res = poll(&amp;pfd, 1, waittime)) &gt; 0 &amp;&amp; (stage = 1) &amp;&amp;</span>
<span class="lineNum">     767 </span><span class="lineCov">       2332 :                                 (res = read(inotify_fd, &amp;buf, sizeof(buf))) &gt;= sizeof(*iev)) {</span>
<span class="lineNum">     768 </span><span class="lineCov">       1166 :                                 ssize_t len = 0;</span>
<span class="lineNum">     769 </span>            :                                 /* File(s) added to directory, add them to my list */
<span class="lineNum">     770 </span><span class="lineCov">       2368 :                                 for (iev = (void *) buf; res &gt;= sizeof(*iev); iev = (struct inotify_event *) (((char *) iev) + len)) {</span>
<span class="lineNum">     771 </span>            :                                         /* For an IN_MOVED_TO event, simply process the file. However, if
<span class="lineNum">     772 </span>            :                                          * we get an IN_CREATE event it *might* be an open(O_CREAT) or it
<span class="lineNum">     773 </span>            :                                          * might be a hardlink (like smsq does, since rename() might
<span class="lineNum">     774 </span>            :                                          * overwrite an existing file). So we have to see if we get a
<span class="lineNum">     775 </span>            :                                          * subsequent IN_OPEN event on the same file. If we do, keep it
<span class="lineNum">     776 </span>            :                                          * on the openlist and wait for the corresponding IN_CLOSE_WRITE.
<span class="lineNum">     777 </span>            :                                          * If we *don't* see an IN_OPEN event, then it was a hard link so
<span class="lineNum">     778 </span>            :                                          * it can be processed immediately.
<span class="lineNum">     779 </span>            :                                          *
<span class="lineNum">     780 </span>            :                                          * Unfortunately, although open(O_CREAT) is an atomic file system
<span class="lineNum">     781 </span>            :                                          * operation, the inotify subsystem doesn't give it to us in a
<span class="lineNum">     782 </span>            :                                          * single event with both IN_CREATE|IN_OPEN set. It's two separate
<span class="lineNum">     783 </span>            :                                          * events, and the kernel doesn't even give them to us at the same
<span class="lineNum">     784 </span>            :                                          * time. We can read() from inotify_fd after the IN_CREATE event,
<span class="lineNum">     785 </span>            :                                          * and get *nothing* from it. The IN_OPEN arrives only later! So
<span class="lineNum">     786 </span>            :                                          * we have a very short timeout of 2 seconds. */
<span class="lineNum">     787 </span><span class="lineCov">       1202 :                                         if (iev-&gt;mask &amp; IN_CREATE) {</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :                                                 queue_file_create(iev-&gt;name);</span>
<span class="lineNum">     789 </span><span class="lineCov">       1202 :                                         } else if (iev-&gt;mask &amp; IN_OPEN) {</span>
<span class="lineNum">     790 </span><span class="lineCov">       1155 :                                                 queue_file_open(iev-&gt;name);</span>
<span class="lineNum">     791 </span><span class="lineCov">         47 :                                         } else if (iev-&gt;mask &amp; IN_CLOSE_WRITE) {</span>
<span class="lineNum">     792 </span><span class="lineCov">         40 :                                                 queue_file_write(iev-&gt;name);</span>
<span class="lineNum">     793 </span><span class="lineCov">          7 :                                         } else if (iev-&gt;mask &amp; IN_MOVED_TO) {</span>
<span class="lineNum">     794 </span><span class="lineCov">          7 :                                                 queue_file(iev-&gt;name, 0);</span>
<span class="lineNum">     795 </span>            :                                         } else {
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :                                                 ast_log(LOG_ERROR, &quot;Unexpected event %d for file '%s'\n&quot;, (int) iev-&gt;mask, iev-&gt;name);</span>
<span class="lineNum">     797 </span>            :                                         }
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span><span class="lineCov">       1202 :                                         len = sizeof(*iev) + iev-&gt;len;</span>
<span class="lineNum">     800 </span><span class="lineCov">       1202 :                                         res -= len;</span>
<span class="lineNum">     801 </span>            :                                 }
<span class="lineNum">     802 </span><span class="lineCov">         12 :                         } else if (res &lt; 0 &amp;&amp; errno != EINTR &amp;&amp; errno != EAGAIN) {</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :                                 ast_debug(1, &quot;Got an error back from %s(2): %s\n&quot;, stage ? &quot;read&quot; : &quot;poll&quot;, strerror(errno));</span>
<span class="lineNum">     804 </span>            :                         }
<span class="lineNum">     805 </span><span class="lineCov">       1178 :                         time(&amp;now);</span>
<span class="lineNum">     806 </span>            :                 }
<span class="lineNum">     807 </span><span class="lineCov">       1178 :                 queue_created_files();</span>
<span class="lineNum">     808 </span>            : #else
<span class="lineNum">     809 </span>            :                         int num_events;
<span class="lineNum">     810 </span>            :                         /* If queue empty then wait forever */
<span class="lineNum">     811 </span>            :                         if (next == INT_MAX) {
<span class="lineNum">     812 </span>            :                                 num_events = kevent(inotify_fd, &amp;kev, 1, &amp;event, 1, NULL);
<span class="lineNum">     813 </span>            :                         } else {
<span class="lineNum">     814 </span>            :                                 struct timespec ts2 = { .tv_sec = (unsigned long int)(next - now), .tv_nsec = 0 };
<span class="lineNum">     815 </span>            :                                 num_events = kevent(inotify_fd, &amp;kev, 1, &amp;event, 1, &amp;ts2);
<span class="lineNum">     816 </span>            :                         }
<span class="lineNum">     817 </span>            :                         if ((num_events &lt; 0) || (event.flags == EV_ERROR)) {
<span class="lineNum">     818 </span>            :                                 ast_debug(10, &quot;KEvent error %s\n&quot;, strerror(errno));
<span class="lineNum">     819 </span>            :                                 continue;
<span class="lineNum">     820 </span>            :                         } else if (num_events == 0) {
<span class="lineNum">     821 </span>            :                                 /* Interrupt or timeout, restart calculations */
<span class="lineNum">     822 </span>            :                                 continue;
<span class="lineNum">     823 </span>            :                         } else {
<span class="lineNum">     824 </span>            :                                 /* Directory changed, rescan */
<span class="lineNum">     825 </span>            :                                 rewinddir(dir);
<span class="lineNum">     826 </span>            :                                 while ((de = readdir(dir))) {
<span class="lineNum">     827 </span>            :                                         queue_file(de-&gt;d_name, 0);
<span class="lineNum">     828 </span>            :                                 }
<span class="lineNum">     829 </span>            :                         }
<span class="lineNum">     830 </span>            :                         time(&amp;now);
<span class="lineNum">     831 </span>            :                 }
<span class="lineNum">     832 </span>            : #endif
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            :                 /* Empty the list of all entries ready to be processed */
<span class="lineNum">     835 </span><span class="lineCov">       1178 :                 AST_LIST_LOCK(&amp;dirlist);</span>
<span class="lineNum">     836 </span><span class="lineCov">       1190 :                 while (!AST_LIST_EMPTY(&amp;dirlist) &amp;&amp; AST_LIST_FIRST(&amp;dirlist)-&gt;mtime &lt;= now) {</span>
<span class="lineNum">     837 </span><span class="lineCov">         12 :                         cur = AST_LIST_REMOVE_HEAD(&amp;dirlist, list);</span>
<span class="lineNum">     838 </span><span class="lineCov">         12 :                         queue_file(cur-&gt;name, cur-&gt;mtime);</span>
<span class="lineNum">     839 </span><span class="lineCov">         12 :                         ast_free(cur);</span>
<span class="lineNum">     840 </span>            :                 }
<span class="lineNum">     841 </span><span class="lineCov">       1178 :                 AST_LIST_UNLOCK(&amp;dirlist);</span>
<span class="lineNum">     842 </span>            :         }
<span class="lineNum">     843 </span>            :         return NULL;
<span class="lineNum">     844 </span>            : }
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            : #else
<span class="lineNum">     847 </span>            : static void *scan_thread(void *unused)
<span class="lineNum">     848 </span>            : {
<span class="lineNum">     849 </span>            :         struct stat st;
<span class="lineNum">     850 </span>            :         DIR *dir;
<span class="lineNum">     851 </span>            :         struct dirent *de;
<span class="lineNum">     852 </span>            :         char fn[256];
<span class="lineNum">     853 </span>            :         int res;
<span class="lineNum">     854 </span>            :         int force_poll = 1;
<span class="lineNum">     855 </span>            :         time_t last = 0;
<span class="lineNum">     856 </span>            :         time_t next = 0;
<span class="lineNum">     857 </span>            :         time_t now;
<span class="lineNum">     858 </span>            :         struct timespec ts = { .tv_sec = 1 };
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :         while (!ast_fully_booted) {
<span class="lineNum">     861 </span>            :                 nanosleep(&amp;ts, NULL);
<span class="lineNum">     862 </span>            :         }
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            :         for (;;) {
<span class="lineNum">     865 </span>            :                 /* Wait a sec */
<span class="lineNum">     866 </span>            :                 nanosleep(&amp;ts, NULL);
<span class="lineNum">     867 </span>            :                 time(&amp;now);
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span>            :                 if (stat(qdir, &amp;st)) {
<span class="lineNum">     870 </span>            :                         ast_log(LOG_WARNING, &quot;Unable to stat %s\n&quot;, qdir);
<span class="lineNum">     871 </span>            :                         continue;
<span class="lineNum">     872 </span>            :                 }
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :                 /* Make sure it is time for us to execute our check */
<span class="lineNum">     875 </span>            :                 if (!force_poll &amp;&amp; st.st_mtime == last &amp;&amp; (!next || now &lt; next)) {
<span class="lineNum">     876 </span>            :                         /*
<span class="lineNum">     877 </span>            :                          * The directory timestamp did not change and any delayed
<span class="lineNum">     878 </span>            :                          * call-file is not ready to be executed.
<span class="lineNum">     879 </span>            :                          */
<span class="lineNum">     880 </span>            :                         continue;
<span class="lineNum">     881 </span>            :                 }
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span>            : #if 0
<span class="lineNum">     884 </span>            :                 printf(&quot;atime: %ld, mtime: %ld, ctime: %ld\n&quot;, st.st_atime, st.st_mtime, st.st_ctime);
<span class="lineNum">     885 </span>            :                 printf(&quot;Ooh, something changed / timeout\n&quot;);
<span class="lineNum">     886 </span>            : #endif
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            :                 if (!(dir = opendir(qdir))) {
<span class="lineNum">     889 </span>            :                         ast_log(LOG_WARNING, &quot;Unable to open directory %s: %s\n&quot;, qdir, strerror(errno));
<span class="lineNum">     890 </span>            :                         continue;
<span class="lineNum">     891 </span>            :                 }
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span>            :                 /*
<span class="lineNum">     894 </span>            :                  * Since the dir timestamp is available at one second
<span class="lineNum">     895 </span>            :                  * resolution, we cannot know if it was updated within the same
<span class="lineNum">     896 </span>            :                  * second after we scanned it.  Therefore, we will force another
<span class="lineNum">     897 </span>            :                  * scan if the dir was just modified.
<span class="lineNum">     898 </span>            :                  */
<span class="lineNum">     899 </span>            :                 force_poll = (st.st_mtime == now);
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            :                 next = 0;
<span class="lineNum">     902 </span>            :                 last = st.st_mtime;
<span class="lineNum">     903 </span>            :                 while ((de = readdir(dir))) {
<span class="lineNum">     904 </span>            :                         snprintf(fn, sizeof(fn), &quot;%s/%s&quot;, qdir, de-&gt;d_name);
<span class="lineNum">     905 </span>            :                         if (stat(fn, &amp;st)) {
<span class="lineNum">     906 </span>            :                                 ast_log(LOG_WARNING, &quot;Unable to stat %s: %s\n&quot;, fn, strerror(errno));
<span class="lineNum">     907 </span>            :                                 continue;
<span class="lineNum">     908 </span>            :                         }
<span class="lineNum">     909 </span>            :                         if (!S_ISREG(st.st_mode)) {
<span class="lineNum">     910 </span>            :                                 /* Not a regular file. */
<span class="lineNum">     911 </span>            :                                 continue;
<span class="lineNum">     912 </span>            :                         }
<span class="lineNum">     913 </span>            :                         if (st.st_mtime &lt;= now) {
<span class="lineNum">     914 </span>            :                                 res = scan_service(fn, now);
<span class="lineNum">     915 </span>            :                                 if (res &gt; 0) {
<span class="lineNum">     916 </span>            :                                         /* The call-file is delayed or to be retried later. */
<span class="lineNum">     917 </span>            :                                         if (!next || res &lt; next) {
<span class="lineNum">     918 </span>            :                                                 /* This delayed call file expires earlier. */
<span class="lineNum">     919 </span>            :                                                 next = res;
<span class="lineNum">     920 </span>            :                                         }
<span class="lineNum">     921 </span>            :                                 } else if (res) {
<span class="lineNum">     922 </span>            :                                         ast_log(LOG_WARNING, &quot;Failed to scan service '%s'\n&quot;, fn);
<span class="lineNum">     923 </span>            :                                 } else if (!next) {
<span class="lineNum">     924 </span>            :                                         /* Expired entry: must recheck on the next go-around */
<span class="lineNum">     925 </span>            :                                         next = st.st_mtime;
<span class="lineNum">     926 </span>            :                                 }
<span class="lineNum">     927 </span>            :                         } else {
<span class="lineNum">     928 </span>            :                                 /* The file's timestamp is in the future. */
<span class="lineNum">     929 </span>            :                                 if (!next || st.st_mtime &lt; next) {
<span class="lineNum">     930 </span>            :                                         /* This call-file's timestamp expires earlier. */
<span class="lineNum">     931 </span>            :                                         next = st.st_mtime;
<span class="lineNum">     932 </span>            :                                 }
<span class="lineNum">     933 </span>            :                         }
<span class="lineNum">     934 </span>            :                 }
<span class="lineNum">     935 </span>            :                 closedir(dir);
<span class="lineNum">     936 </span>            :         }
<span class="lineNum">     937 </span>            :         return NULL;
<span class="lineNum">     938 </span>            : }
<a name="939"><span class="lineNum">     939 </span>            : #endif</a>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span><span class="lineCov">       1115 : static int unload_module(void)</span>
<span class="lineNum">     942 </span>            : {
<span class="lineNum">     943 </span><span class="lineCov">       1115 :         return -1;</span>
<a name="944"><span class="lineNum">     944 </span>            : }</a>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineCov">       1117 : static int load_module(void)</span>
<span class="lineNum">     947 </span>            : {
<span class="lineNum">     948 </span>            :         pthread_t thread;
<span class="lineNum">     949 </span>            :         int ret;
<span class="lineNum">     950 </span><span class="lineCov">       1117 :         snprintf(qdir, sizeof(qdir), &quot;%s/%s&quot;, ast_config_AST_SPOOL_DIR, &quot;outgoing&quot;);</span>
<span class="lineNum">     951 </span><span class="lineCov">       1117 :         if (ast_mkdir(qdir, 0777)) {</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unable to create queue directory %s -- outgoing spool disabled\n&quot;, qdir);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">     954 </span>            :         }
<span class="lineNum">     955 </span><span class="lineCov">       1117 :         snprintf(qdonedir, sizeof(qdir), &quot;%s/%s&quot;, ast_config_AST_SPOOL_DIR, &quot;outgoing_done&quot;);</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span><span class="lineCov">       1117 :         if ((ret = ast_pthread_create_detached_background(&amp;thread, NULL, scan_thread, NULL))) {</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unable to create thread :( (returned error: %d)\n&quot;, ret);</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_FAILURE;</span>
<span class="lineNum">     960 </span>            :         }
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span><span class="lineCov">       1117 :         return AST_MODULE_LOAD_SUCCESS;</span>
<a name="963"><span class="lineNum">     963 </span>            : }</a>
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span><span class="lineCov">       2234 : AST_MODULE_INFO_STANDARD(ASTERISK_GPL_KEY, &quot;Outgoing Spool Support&quot;);</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
