<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Asterisk GIT-16-d8ac5bf1a5 - include/asterisk/config.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">include/asterisk</a> - config.h<span style="font-size: 80%;"> (source / <a href="config.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Asterisk GIT-16-d8ac5bf1a5</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-07-23 21:48:22</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Asterisk -- An open source telephony toolkit.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (C) 1999 - 2005, Digium, Inc.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Mark Spencer &lt;markster@digium.com&gt;
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * See http://www.asterisk.org for more information about
<span class="lineNum">       9 </span>            :  * the Asterisk project. Please do not directly contact
<span class="lineNum">      10 </span>            :  * any of the maintainers of this project for assistance;
<span class="lineNum">      11 </span>            :  * the project provides a web site, mailing lists and IRC
<span class="lineNum">      12 </span>            :  * channels for your use.
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  * This program is free software, distributed under the terms of
<span class="lineNum">      15 </span>            :  * the GNU General Public License Version 2. See the LICENSE file
<span class="lineNum">      16 </span>            :  * at the top of the source tree.
<span class="lineNum">      17 </span>            :  */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : /*! \file
<span class="lineNum">      20 </span>            :  * \brief Configuration File Parser
<span class="lineNum">      21 </span>            :  */
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : #ifndef _ASTERISK_CONFIG_H
<span class="lineNum">      24 </span>            : #define _ASTERISK_CONFIG_H
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #if defined(__cplusplus) || defined(c_plusplus)
<span class="lineNum">      27 </span>            : extern &quot;C&quot; {
<span class="lineNum">      28 </span>            : #endif
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;asterisk/utils.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;asterisk/inline_api.h&quot;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : struct ast_config;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : struct ast_category;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : /*! Options for ast_config_load()
<span class="lineNum">      38 </span>            :  */
<span class="lineNum">      39 </span>            : enum {
<span class="lineNum">      40 </span>            :         /*! Load the configuration, including comments */
<span class="lineNum">      41 </span>            :         CONFIG_FLAG_WITHCOMMENTS  = (1 &lt;&lt; 0),
<span class="lineNum">      42 </span>            :         /*! On a reload, give us a -1 if the file hasn't changed. */
<span class="lineNum">      43 </span>            :         CONFIG_FLAG_FILEUNCHANGED = (1 &lt;&lt; 1),
<span class="lineNum">      44 </span>            :         /*! Don't attempt to cache mtime on this config file. */
<span class="lineNum">      45 </span>            :         CONFIG_FLAG_NOCACHE       = (1 &lt;&lt; 2),
<span class="lineNum">      46 </span>            :         /*! Don't attempt to load from realtime (typically called from a realtime driver dependency) */
<span class="lineNum">      47 </span>            :         CONFIG_FLAG_NOREALTIME    = (1 &lt;&lt; 3),
<span class="lineNum">      48 </span>            : };
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : /*! Flags for ast_config_text_file_save2()
<span class="lineNum">      51 </span>            :  */
<span class="lineNum">      52 </span>            : enum config_save_flags {
<span class="lineNum">      53 </span>            :         CONFIG_SAVE_FLAG_NONE = (0),
<span class="lineNum">      54 </span>            :         /*! Insure a context doesn't effectively change if a template changes (pre 13.2 behavior) */
<span class="lineNum">      55 </span>            :         CONFIG_SAVE_FLAG_PRESERVE_EFFECTIVE_CONTEXT = (1 &lt;&lt; 0),
<span class="lineNum">      56 </span>            : };
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : #define CONFIG_STATUS_FILEMISSING       (void *)0
<span class="lineNum">      59 </span>            : #define CONFIG_STATUS_FILEUNCHANGED     (void *)-1
<span class="lineNum">      60 </span>            : #define CONFIG_STATUS_FILEINVALID       (void *)-2
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : /*!
<span class="lineNum">      63 </span>            :  * \brief Types used in ast_realtime_require_field
<span class="lineNum">      64 </span>            :  */
<span class="lineNum">      65 </span>            : typedef enum {
<span class="lineNum">      66 </span>            :         RQ_INTEGER1,
<span class="lineNum">      67 </span>            :         RQ_UINTEGER1,
<span class="lineNum">      68 </span>            :         RQ_INTEGER2,
<span class="lineNum">      69 </span>            :         RQ_UINTEGER2,
<span class="lineNum">      70 </span>            :         RQ_INTEGER3,
<span class="lineNum">      71 </span>            :         RQ_UINTEGER3,
<span class="lineNum">      72 </span>            :         RQ_INTEGER4,
<span class="lineNum">      73 </span>            :         RQ_UINTEGER4,
<span class="lineNum">      74 </span>            :         RQ_INTEGER8,
<span class="lineNum">      75 </span>            :         RQ_UINTEGER8,
<span class="lineNum">      76 </span>            :         RQ_CHAR,
<span class="lineNum">      77 </span>            :         RQ_FLOAT,
<span class="lineNum">      78 </span>            :         RQ_DATE,
<span class="lineNum">      79 </span>            :         RQ_DATETIME,
<span class="lineNum">      80 </span>            : } require_type;
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : /*! \brief Structure for variables, used for configurations and for channel variables */
<span class="lineNum">      83 </span>            : struct ast_variable {
<span class="lineNum">      84 </span>            :         /*! Variable name.  Stored in stuff[] at struct end. */
<span class="lineNum">      85 </span>            :         const char *name;
<span class="lineNum">      86 </span>            :         /*! Variable value.  Stored in stuff[] at struct end. */
<span class="lineNum">      87 </span>            :         const char *value;
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :         /*! Next node in the list. */
<span class="lineNum">      90 </span>            :         struct ast_variable *next;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :         /*! Filename where variable found.  Stored in stuff[] at struct end. */
<span class="lineNum">      93 </span>            :         const char *file;
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :         int lineno;
<span class="lineNum">      96 </span>            :         int object;             /*!&lt; 0 for variable, 1 for object */
<span class="lineNum">      97 </span>            :         int blanklines;         /*!&lt; Number of blanklines following entry */
<span class="lineNum">      98 </span>            :         int inherited;          /*!&lt; 1 for inherited from template or other base */
<span class="lineNum">      99 </span>            :         struct ast_comment *precomments;
<span class="lineNum">     100 </span>            :         struct ast_comment *sameline;
<span class="lineNum">     101 </span>            :         struct ast_comment *trailing; /*!&lt; the last object in the list will get assigned any trailing comments when EOF is hit */
<span class="lineNum">     102 </span>            :         /*!
<span class="lineNum">     103 </span>            :          * \brief Contents of file, name, and value in that order stuffed here.
<span class="lineNum">     104 </span>            :          * \note File must be stuffed before name because of ast_include_rename().
<span class="lineNum">     105 </span>            :          */
<span class="lineNum">     106 </span>            :         char stuff[0];
<span class="lineNum">     107 </span>            : };
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : typedef struct ast_config *config_load_func(const char *database, const char *table, const char *configfile, struct ast_config *config, struct ast_flags flags, const char *suggested_include_file, const char *who_asked);
<span class="lineNum">     110 </span>            : typedef struct ast_variable *realtime_var_get(const char *database, const char *table, const struct ast_variable *fields);
<span class="lineNum">     111 </span>            : typedef struct ast_config *realtime_multi_get(const char *database, const char *table, const struct ast_variable *fields);
<span class="lineNum">     112 </span>            : typedef int realtime_update(const char *database, const char *table, const char *keyfield, const char *entity, const struct ast_variable *fields);
<span class="lineNum">     113 </span>            : typedef int realtime_update2(const char *database, const char *table, const struct ast_variable *lookup_fields, const struct ast_variable *update_fields);
<span class="lineNum">     114 </span>            : typedef int realtime_store(const char *database, const char *table, const struct ast_variable *fields);
<span class="lineNum">     115 </span>            : typedef int realtime_destroy(const char *database, const char *table, const char *keyfield, const char *entity, const struct ast_variable *fields);
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : /*!
<span class="lineNum">     118 </span>            :  * \brief Function pointer called to ensure database schema is properly configured for realtime use
<span class="lineNum">     119 </span>            :  * \since 1.6.1
<span class="lineNum">     120 </span>            :  */
<span class="lineNum">     121 </span>            : typedef int realtime_require(const char *database, const char *table, va_list ap);
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : /*!
<span class="lineNum">     124 </span>            :  * \brief Function pointer called to clear the database cache and free resources used for such
<span class="lineNum">     125 </span>            :  * \since 1.6.1
<span class="lineNum">     126 </span>            :  */
<span class="lineNum">     127 </span>            : typedef int realtime_unload(const char *database, const char *table);
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : /*! \brief Configuration engine structure, used to define realtime drivers */
<span class="lineNum">     130 </span>            : struct ast_config_engine {
<span class="lineNum">     131 </span>            :         char *name;
<span class="lineNum">     132 </span>            :         config_load_func *load_func;
<span class="lineNum">     133 </span>            :         realtime_var_get *realtime_func;
<span class="lineNum">     134 </span>            :         realtime_multi_get *realtime_multi_func;
<span class="lineNum">     135 </span>            :         realtime_update *update_func;
<span class="lineNum">     136 </span>            :         realtime_update2 *update2_func;
<span class="lineNum">     137 </span>            :         realtime_store *store_func;
<span class="lineNum">     138 </span>            :         realtime_destroy *destroy_func;
<span class="lineNum">     139 </span>            :         realtime_require *require_func;
<span class="lineNum">     140 </span>            :         realtime_unload *unload_func;
<span class="lineNum">     141 </span>            :         struct ast_config_engine *next;
<span class="lineNum">     142 </span>            : };
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : /*!
<span class="lineNum">     145 </span>            :  * \brief Load a config file
<span class="lineNum">     146 </span>            :  *
<span class="lineNum">     147 </span>            :  * \param filename path of file to open.  If no preceding '/' character,
<span class="lineNum">     148 </span>            :  * path is considered relative to AST_CONFIG_DIR
<span class="lineNum">     149 </span>            :  * \param who_asked The module which is making this request.
<span class="lineNum">     150 </span>            :  * \param flags Optional flags:
<span class="lineNum">     151 </span>            :  * CONFIG_FLAG_WITHCOMMENTS - load the file with comments intact;
<span class="lineNum">     152 </span>            :  * CONFIG_FLAG_FILEUNCHANGED - check the file mtime and return CONFIG_STATUS_FILEUNCHANGED if the mtime is the same; or
<span class="lineNum">     153 </span>            :  * CONFIG_FLAG_NOCACHE - don't cache file mtime (main purpose of this option is to save memory on temporary files).
<span class="lineNum">     154 </span>            :  *
<span class="lineNum">     155 </span>            :  * \details
<span class="lineNum">     156 </span>            :  * Create a config structure from a given configuration file.
<span class="lineNum">     157 </span>            :  *
<span class="lineNum">     158 </span>            :  * \return an ast_config data structure on success
<span class="lineNum">     159 </span>            :  * \retval NULL on error
<span class="lineNum">     160 </span>            :  */
<span class="lineNum">     161 </span>            : struct ast_config *ast_config_load2(const char *filename, const char *who_asked, struct ast_flags flags);
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : /*!
<span class="lineNum">     164 </span>            :  * \brief Load a config file
<span class="lineNum">     165 </span>            :  *
<span class="lineNum">     166 </span>            :  * \param filename path of file to open.  If no preceding '/' character,
<span class="lineNum">     167 </span>            :  * path is considered relative to AST_CONFIG_DIR
<span class="lineNum">     168 </span>            :  * \param flags Optional flags:
<span class="lineNum">     169 </span>            :  * CONFIG_FLAG_WITHCOMMENTS - load the file with comments intact;
<span class="lineNum">     170 </span>            :  * CONFIG_FLAG_FILEUNCHANGED - check the file mtime and return CONFIG_STATUS_FILEUNCHANGED if the mtime is the same; or
<span class="lineNum">     171 </span>            :  * CONFIG_FLAG_NOCACHE - don't cache file mtime (main purpose of this option is to save memory on temporary files).
<span class="lineNum">     172 </span>            :  *
<span class="lineNum">     173 </span>            :  * \details
<span class="lineNum">     174 </span>            :  * Create a config structure from a given configuration file.
<span class="lineNum">     175 </span>            :  *
<span class="lineNum">     176 </span>            :  * \return an ast_config data structure on success
<span class="lineNum">     177 </span>            :  * \retval NULL on error
<span class="lineNum">     178 </span>            :  */
<span class="lineNum">     179 </span>            : #define ast_config_load(filename, flags)        ast_config_load2(filename, AST_MODULE, flags)
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : /*!
<span class="lineNum">     182 </span>            :  * \brief Destroys a config
<span class="lineNum">     183 </span>            :  *
<span class="lineNum">     184 </span>            :  * \param config pointer to config data structure
<span class="lineNum">     185 </span>            :  *
<span class="lineNum">     186 </span>            :  * \details
<span class="lineNum">     187 </span>            :  * Free memory associated with a given config
<span class="lineNum">     188 </span>            :  */
<span class="lineNum">     189 </span>            : void ast_config_destroy(struct ast_config *config);
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            : /*!
<span class="lineNum">     192 </span>            :  * \brief returns the root ast_variable of a config
<span class="lineNum">     193 </span>            :  *
<span class="lineNum">     194 </span>            :  * \param config pointer to an ast_config data structure
<span class="lineNum">     195 </span>            :  * \param cat name of the category for which you want the root
<span class="lineNum">     196 </span>            :  *
<span class="lineNum">     197 </span>            :  * \return the category specified
<span class="lineNum">     198 </span>            :  */
<span class="lineNum">     199 </span>            : struct ast_variable *ast_category_root(struct ast_config *config, char *cat);
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : /*!
<span class="lineNum">     202 </span>            :  * \brief Sorts categories in a config in the order of a numerical value contained within them.
<span class="lineNum">     203 </span>            :  *
<span class="lineNum">     204 </span>            :  * \param config The config structure you wish to sort
<span class="lineNum">     205 </span>            :  * \param comparator variable Which numerical value you wish to sort by
<span class="lineNum">     206 </span>            :  * \param descending If true, we sort highest to lowest instead of lowest to highest
<span class="lineNum">     207 </span>            :  *
<span class="lineNum">     208 </span>            :  * \details
<span class="lineNum">     209 </span>            :  * This function will assume a value of 0 for any non-numerical strings and NULL fields.
<span class="lineNum">     210 </span>            :  */
<span class="lineNum">     211 </span>            : void ast_config_sort_categories(struct ast_config *config, int descending,
<span class="lineNum">     212 </span>            :                                                                 int (*comparator)(struct ast_category *p, struct ast_category *q));
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : /*!
<span class="lineNum">     215 </span>            :  * \brief Browse categories with filters
<span class="lineNum">     216 </span>            :  *
<span class="lineNum">     217 </span>            :  * \param config Which config structure you wish to &quot;browse&quot;
<span class="lineNum">     218 </span>            :  * \param category_name An optional category name.
<span class="lineNum">     219 </span>            :  * Pass NULL to not restrict by category name.
<span class="lineNum">     220 </span>            :  * \param prev A pointer to the starting category structure.
<span class="lineNum">     221 </span>            :  * Pass NULL to start at the beginning.
<span class="lineNum">     222 </span>            :  * \param filter An optional comma-separated list of &lt;name_regex&gt;=&lt;value_regex&gt;
<span class="lineNum">     223 </span>            :  * pairs.  Only categories with matching variables will be returned.
<span class="lineNum">     224 </span>            :  * The special name 'TEMPLATES' can be used with the special values
<span class="lineNum">     225 </span>            :  * 'include' or 'restrict' to include templates in the result or
<span class="lineNum">     226 </span>            :  * restrict the result to only templates.
<span class="lineNum">     227 </span>            :  *
<span class="lineNum">     228 </span>            :  * \retval a category on success
<span class="lineNum">     229 </span>            :  * \retval NULL on failure/no-more-categories
<span class="lineNum">     230 </span>            :  */
<span class="lineNum">     231 </span>            : struct ast_category *ast_category_browse_filtered(struct ast_config *config,
<span class="lineNum">     232 </span>            :         const char *category_name, struct ast_category *prev, const char *filter);
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : /*!
<span class="lineNum">     235 </span>            :  * \brief Browse categories
<span class="lineNum">     236 </span>            :  *
<span class="lineNum">     237 </span>            :  * \param config Which config structure you wish to &quot;browse&quot;
<span class="lineNum">     238 </span>            :  * \param prev_name A pointer to a previous category name.
<span class="lineNum">     239 </span>            :  *
<span class="lineNum">     240 </span>            :  * \details
<span class="lineNum">     241 </span>            :  * This function is kind of non-intuitive in it's use.
<span class="lineNum">     242 </span>            :  * To begin, one passes NULL as the second argument.
<span class="lineNum">     243 </span>            :  * It will return a pointer to the string of the first category in the file.
<span class="lineNum">     244 </span>            :  * From here on after, one must then pass the previous usage's return value
<span class="lineNum">     245 </span>            :  * as the second pointer, and it will return a pointer to the category name
<span class="lineNum">     246 </span>            :  * afterwards.
<span class="lineNum">     247 </span>            :  *
<span class="lineNum">     248 </span>            :  * \retval a category name on success
<span class="lineNum">     249 </span>            :  * \retval NULL on failure/no-more-categories
<span class="lineNum">     250 </span>            :  *
<span class="lineNum">     251 </span>            :  * \note ast_category_browse maintains internal state.  Therefore is not thread
<span class="lineNum">     252 </span>            :  * safe, cannot be called recursively, and it is not safe to add or remove
<span class="lineNum">     253 </span>            :  * categories while browsing.
<span class="lineNum">     254 </span>            :  * ast_category_browse_filtered does not have these restrictions.
<span class="lineNum">     255 </span>            :  */
<span class="lineNum">     256 </span>            : char *ast_category_browse(struct ast_config *config, const char *prev_name);
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : /*!
<span class="lineNum">     259 </span>            :  * \brief Browse variables
<span class="lineNum">     260 </span>            :  * \param config Which config structure you wish to &quot;browse&quot;
<span class="lineNum">     261 </span>            :  * \param category_name Which category to &quot;browse&quot;
<span class="lineNum">     262 </span>            :  * \param filter an optional comma-separated list of &lt;name_regex&gt;=&lt;value_regex&gt;
<span class="lineNum">     263 </span>            :  * pairs.  Only categories with matching variables will be browsed.
<span class="lineNum">     264 </span>            :  * The special name 'TEMPLATES' can be used with the special values
<span class="lineNum">     265 </span>            :  * 'include' or 'restrict' to include templates in the result or
<span class="lineNum">     266 </span>            :  * restrict the result to only templates.
<span class="lineNum">     267 </span>            :  *
<span class="lineNum">     268 </span>            :  * \details
<span class="lineNum">     269 </span>            :  * Somewhat similar in intent as the ast_category_browse.
<span class="lineNum">     270 </span>            :  * List variables of config file category
<span class="lineNum">     271 </span>            :  *
<span class="lineNum">     272 </span>            :  * \retval ast_variable list on success
<span class="lineNum">     273 </span>            :  * \retval NULL on failure
<span class="lineNum">     274 </span>            :  */
<span class="lineNum">     275 </span>            : struct ast_variable *ast_variable_browse_filtered(const struct ast_config *config,
<span class="lineNum">     276 </span>            :         const char *category_name, const char *filter);
<span class="lineNum">     277 </span>            : struct ast_variable *ast_variable_browse(const struct ast_config *config,
<span class="lineNum">     278 </span>            :         const char *category_name);
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            : /*!
<span class="lineNum">     281 </span>            :  * \brief given a pointer to a category, return the root variable.
<span class="lineNum">     282 </span>            :  *
<span class="lineNum">     283 </span>            :  * \details
<span class="lineNum">     284 </span>            :  * This is equivalent to ast_variable_browse(), but more efficient if we
<span class="lineNum">     285 </span>            :  * already have the struct ast_category * (e.g. from ast_category_get())
<span class="lineNum">     286 </span>            :  */
<span class="lineNum">     287 </span>            : struct ast_variable *ast_category_first(struct ast_category *cat);
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            : /*!
<span class="lineNum">     290 </span>            :  * \brief Gets a variable by context and variable names
<span class="lineNum">     291 </span>            :  *
<span class="lineNum">     292 </span>            :  * \param config which (opened) config to use
<span class="lineNum">     293 </span>            :  * \param category category under which the variable lies
<span class="lineNum">     294 </span>            :  * \param variable which variable you wish to get the data for
<span class="lineNum">     295 </span>            :  * \param filter an optional comma-separated list of &lt;name_regex&gt;=&lt;value_regex&gt;
<span class="lineNum">     296 </span>            :  * pairs.  Only categories with matching variables will be searched.
<span class="lineNum">     297 </span>            :  * The special name 'TEMPLATES' can be used with the special values
<span class="lineNum">     298 </span>            :  * 'include' or 'restrict' to include templates in the result or
<span class="lineNum">     299 </span>            :  * restrict the result to only templates.
<span class="lineNum">     300 </span>            :  *
<span class="lineNum">     301 </span>            :  * \retval The variable value on success
<span class="lineNum">     302 </span>            :  * \retval NULL if unable to find it.
<span class="lineNum">     303 </span>            :  */
<span class="lineNum">     304 </span>            : const char *ast_variable_retrieve_filtered(struct ast_config *config,
<span class="lineNum">     305 </span>            :         const char *category, const char *variable, const char *filter);
<span class="lineNum">     306 </span>            : const char *ast_variable_retrieve(struct ast_config *config,
<span class="lineNum">     307 </span>            :         const char *category, const char *variable);
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : /*!
<span class="lineNum">     310 </span>            :  * \brief Gets a variable value from a specific category structure by name
<span class="lineNum">     311 </span>            :  *
<span class="lineNum">     312 </span>            :  * \param category category structure under which the variable lies
<span class="lineNum">     313 </span>            :  * \param variable which variable you wish to get the data for
<span class="lineNum">     314 </span>            :  *
<span class="lineNum">     315 </span>            :  * \details
<span class="lineNum">     316 </span>            :  * Goes through a given category and searches for the given variable
<span class="lineNum">     317 </span>            :  *
<span class="lineNum">     318 </span>            :  * \retval The variable value on success
<span class="lineNum">     319 </span>            :  * \retval NULL if unable to find it.
<span class="lineNum">     320 </span>            :  */
<span class="lineNum">     321 </span>            : const char *ast_variable_find(const struct ast_category *category, const char *variable);
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : /*!
<span class="lineNum">     324 </span>            :  * \brief Gets the value of a variable from a variable list by name
<span class="lineNum">     325 </span>            :  *
<span class="lineNum">     326 </span>            :  * \param list variable list to search
<span class="lineNum">     327 </span>            :  * \param variable which variable you wish to get the data for
<span class="lineNum">     328 </span>            :  *
<span class="lineNum">     329 </span>            :  * \details
<span class="lineNum">     330 </span>            :  * Goes through a given variable list and searches for the given variable
<span class="lineNum">     331 </span>            :  *
<span class="lineNum">     332 </span>            :  * \retval The variable value on success
<span class="lineNum">     333 </span>            :  * \retval NULL if unable to find it.
<span class="lineNum">     334 </span>            :  */
<span class="lineNum">     335 </span>            : const char *ast_variable_find_in_list(const struct ast_variable *list, const char *variable);
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : /*!
<span class="lineNum">     338 </span>            :  * \brief Gets the value of the LAST occurrence of a variable from a variable list
<span class="lineNum">     339 </span>            :  *
<span class="lineNum">     340 </span>            :  * \param list The ast_variable list to search
<span class="lineNum">     341 </span>            :  * \param variable The name of the ast_variable you wish to fetch data for
<span class="lineNum">     342 </span>            :  *
<span class="lineNum">     343 </span>            :  * \details
<span class="lineNum">     344 </span>            :  * Iterates over a given ast_variable list to search for the last occurrence of an
<span class="lineNum">     345 </span>            :  * ast_variable entry with a name attribute matching the given name (variable).
<span class="lineNum">     346 </span>            :  * This is useful if the list has duplicate entries (such as in cases where entries
<span class="lineNum">     347 </span>            :  * are created by a template)
<span class="lineNum">     348 </span>            :  *
<span class="lineNum">     349 </span>            :  * \retval The variable value on success
<span class="lineNum">     350 </span>            :  * \retval NULL if unable to find it.
<span class="lineNum">     351 </span>            :  */
<span class="lineNum">     352 </span>            : const char *ast_variable_find_last_in_list(const struct ast_variable *list, const char *variable);
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : /*!
<span class="lineNum">     355 </span>            :  * \brief Gets a variable from a variable list by name
<span class="lineNum">     356 </span>            :  * \since 13.9.0
<span class="lineNum">     357 </span>            :  *
<span class="lineNum">     358 </span>            :  * \param list variable list to search
<span class="lineNum">     359 </span>            :  * \param variable name you wish to get the data for
<span class="lineNum">     360 </span>            :  *
<span class="lineNum">     361 </span>            :  * \details
<span class="lineNum">     362 </span>            :  * Goes through a given variable list and searches for the given variable
<span class="lineNum">     363 </span>            :  *
<span class="lineNum">     364 </span>            :  * \retval The variable (not the value) on success
<span class="lineNum">     365 </span>            :  * \retval NULL if unable to find it.
<span class="lineNum">     366 </span>            :  */
<span class="lineNum">     367 </span>            : const struct ast_variable *ast_variable_find_variable_in_list(const struct ast_variable *list, const char *variable_name);
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            : /*!
<span class="lineNum">     370 </span>            :  * \brief Retrieve a category if it exists
<span class="lineNum">     371 </span>            :  *
<span class="lineNum">     372 </span>            :  * \param config which config to use
<span class="lineNum">     373 </span>            :  * \param category_name name of the category you're looking for
<span class="lineNum">     374 </span>            :  * \param filter If a config contains more than 1 category with the same name,
<span class="lineNum">     375 </span>            :  * you can specify a filter to narrow the search.  The filter is a comma-separated
<span class="lineNum">     376 </span>            :  * list of &lt;name_regex&gt;=&lt;value_regex&gt; pairs.  Only a category with matching
<span class="lineNum">     377 </span>            :  * variables will be returned. The special name 'TEMPLATES' can be used with the
<span class="lineNum">     378 </span>            :  * special values 'include' or 'restrict' to include templates in the result or
<span class="lineNum">     379 </span>            :  * restrict the result to only templates.
<span class="lineNum">     380 </span>            :  *
<span class="lineNum">     381 </span>            :  * \details
<span class="lineNum">     382 </span>            :  * This will search through the categories within a given config file for a match.
<span class="lineNum">     383 </span>            :  *
<span class="lineNum">     384 </span>            :  * \retval pointer to category if found
<span class="lineNum">     385 </span>            :  * \retval NULL if not.
<span class="lineNum">     386 </span>            :  */
<span class="lineNum">     387 </span>            : struct ast_category *ast_category_get(const struct ast_config *config,
<span class="lineNum">     388 </span>            :         const char *category_name, const char *filter);
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            : /*!
<span class="lineNum">     391 </span>            :  * \brief Return the name of the category
<span class="lineNum">     392 </span>            :  *
<span class="lineNum">     393 </span>            :  * \param category category structure
<span class="lineNum">     394 </span>            :  *
<span class="lineNum">     395 </span>            :  * \retval pointer to category name if found
<span class="lineNum">     396 </span>            :  * \retval NULL if not.
<span class="lineNum">     397 </span>            :  */
<span class="lineNum">     398 </span>            : const char *ast_category_get_name(const struct ast_category *category);
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            : /*!
<span class="lineNum">     401 </span>            :  * \brief Check if category is a template
<span class="lineNum">     402 </span>            :  *
<span class="lineNum">     403 </span>            :  * \param category category structure
<span class="lineNum">     404 </span>            :  *
<span class="lineNum">     405 </span>            :  * \retval 1 if a template.
<span class="lineNum">     406 </span>            :  * \retval 0 if not.
<span class="lineNum">     407 </span>            :  */
<span class="lineNum">     408 </span>            : int ast_category_is_template(const struct ast_category *category);
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            : /*!
<span class="lineNum">     411 </span>            :  * \brief Return the template names this category inherits from
<span class="lineNum">     412 </span>            :  *
<span class="lineNum">     413 </span>            :  * \param category category structure
<span class="lineNum">     414 </span>            :  *
<span class="lineNum">     415 </span>            :  * \return an ast_str (which must be freed after use) with a comma
<span class="lineNum">     416 </span>            :  * separated list of templates names or NULL if there were no templates.
<span class="lineNum">     417 </span>            :  */
<span class="lineNum">     418 </span>            : struct ast_str *ast_category_get_templates(const struct ast_category *category);
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            : /*!
<span class="lineNum">     421 </span>            :  * \brief Check for category duplicates
<span class="lineNum">     422 </span>            :  *
<span class="lineNum">     423 </span>            :  * \param config which config to use
<span class="lineNum">     424 </span>            :  * \param category_name name of the category you're looking for
<span class="lineNum">     425 </span>            :  * \param filter an optional comma-separated list of &lt;name_regex&gt;=&lt;value_regex&gt;
<span class="lineNum">     426 </span>            :  * pairs.  Only categories with matching variables will be returned.
<span class="lineNum">     427 </span>            :  * The special name 'TEMPLATES' can be used with the special values
<span class="lineNum">     428 </span>            :  * 'include' or 'restrict' to include templates in the result or
<span class="lineNum">     429 </span>            :  * restrict the result to only templates.
<span class="lineNum">     430 </span>            :  *
<span class="lineNum">     431 </span>            :  * \details
<span class="lineNum">     432 </span>            :  * This will search through the categories within a given config file for a match.
<span class="lineNum">     433 </span>            :  *
<span class="lineNum">     434 </span>            :  * \return non-zero if found
<span class="lineNum">     435 </span>            :  */
<span class="lineNum">     436 </span>            : int ast_category_exist(const struct ast_config *config, const char *category_name,
<span class="lineNum">     437 </span>            :         const char *filter);
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            : /*!
<span class="lineNum">     440 </span>            :  * \brief Retrieve realtime configuration
<span class="lineNum">     441 </span>            :  *
<span class="lineNum">     442 </span>            :  * \param family which family/config to lookup
<span class="lineNum">     443 </span>            :  *
<span class="lineNum">     444 </span>            :  * \details
<span class="lineNum">     445 </span>            :  * This will use builtin configuration backends to look up a particular
<span class="lineNum">     446 </span>            :  * entity in realtime and return a variable list of its parameters.
<span class="lineNum">     447 </span>            :  *
<span class="lineNum">     448 </span>            :  * \note
<span class="lineNum">     449 </span>            :  * Unlike the variables in ast_config, the resulting list of variables
<span class="lineNum">     450 </span>            :  * MUST be freed with ast_variables_destroy() as there is no container.
<span class="lineNum">     451 </span>            :  *
<span class="lineNum">     452 </span>            :  * \note
<span class="lineNum">     453 </span>            :  * The difference between these two calls is that ast_load_realtime excludes
<span class="lineNum">     454 </span>            :  * fields whose values are NULL, while ast_load_realtime_all loads all columns.
<span class="lineNum">     455 </span>            :  *
<span class="lineNum">     456 </span>            :  * \note
<span class="lineNum">     457 </span>            :  * You should use the constant SENTINEL to terminate arguments, in
<span class="lineNum">     458 </span>            :  * order to preserve cross-platform compatibility.
<span class="lineNum">     459 </span>            :  */
<span class="lineNum">     460 </span>            : struct ast_variable *ast_load_realtime_fields(const char *family, const struct ast_variable *fields);
<span class="lineNum">     461 </span>            : struct ast_variable *ast_load_realtime(const char *family, ...) attribute_sentinel;
<span class="lineNum">     462 </span>            : struct ast_variable *ast_load_realtime_all_fields(const char *family, const struct ast_variable *fields);
<span class="lineNum">     463 </span>            : struct ast_variable *ast_load_realtime_all(const char *family, ...) attribute_sentinel;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : /*!
<span class="lineNum">     466 </span>            :  * \brief Release any resources cached for a realtime family
<span class="lineNum">     467 </span>            :  * \since 1.6.1
<span class="lineNum">     468 </span>            :  *
<span class="lineNum">     469 </span>            :  * \param family which family/config to destroy
<span class="lineNum">     470 </span>            :  *
<span class="lineNum">     471 </span>            :  * \details
<span class="lineNum">     472 </span>            :  * Various backends may cache attributes about a realtime data storage
<span class="lineNum">     473 </span>            :  * facility; on reload, a front end resource may request to purge that cache.
<span class="lineNum">     474 </span>            :  *
<span class="lineNum">     475 </span>            :  * \retval 0 If any cache was purged
<span class="lineNum">     476 </span>            :  * \retval -1 If no cache was found
<span class="lineNum">     477 </span>            :  */
<span class="lineNum">     478 </span>            : int ast_unload_realtime(const char *family);
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            : /*!
<span class="lineNum">     481 </span>            :  * \brief Inform realtime what fields that may be stored
<span class="lineNum">     482 </span>            :  * \since 1.6.1
<span class="lineNum">     483 </span>            :  *
<span class="lineNum">     484 </span>            :  * \param family which family/config is referenced
<span class="lineNum">     485 </span>            :  *
<span class="lineNum">     486 </span>            :  * \details
<span class="lineNum">     487 </span>            :  * This will inform builtin configuration backends that particular fields
<span class="lineNum">     488 </span>            :  * may be updated during the use of that configuration section.  This is
<span class="lineNum">     489 </span>            :  * mainly to be used during startup routines, to ensure that various fields
<span class="lineNum">     490 </span>            :  * exist in the backend.  The backends may take various actions, such as
<span class="lineNum">     491 </span>            :  * creating new fields in the data store or warning the administrator that
<span class="lineNum">     492 </span>            :  * new fields may need to be created, in order to ensure proper function.
<span class="lineNum">     493 </span>            :  *
<span class="lineNum">     494 </span>            :  * The arguments are specified in groups of 3:  column name, column type,
<span class="lineNum">     495 </span>            :  * and column size.  The column types are specified as integer constants,
<span class="lineNum">     496 </span>            :  * defined by the enum require_type.  Note that the size is specified as
<span class="lineNum">     497 </span>            :  * the number of equivalent character fields that a field may take up, even
<span class="lineNum">     498 </span>            :  * if a field is otherwise specified as an integer type.  This is due to
<span class="lineNum">     499 </span>            :  * the fact that some fields have historically been specified as character
<span class="lineNum">     500 </span>            :  * types, even if they contained integer values.
<span class="lineNum">     501 </span>            :  *
<span class="lineNum">     502 </span>            :  * A family should always specify its fields to the minimum necessary
<span class="lineNum">     503 </span>            :  * requirements to fulfill all possible values (within reason; for example,
<span class="lineNum">     504 </span>            :  * a timeout value may reasonably be specified as an INTEGER2, with size 5.
<span class="lineNum">     505 </span>            :  * Even though values above 32767 seconds are possible, they are unlikely
<span class="lineNum">     506 </span>            :  * to be useful, and we should not complain about that size).
<span class="lineNum">     507 </span>            :  *
<span class="lineNum">     508 </span>            :  * \retval 0 Required fields met specified standards
<span class="lineNum">     509 </span>            :  * \retval -1 One or more fields was missing or insufficient
<span class="lineNum">     510 </span>            :  *
<span class="lineNum">     511 </span>            :  * \note You should use the constant SENTINEL to terminate arguments, in
<span class="lineNum">     512 </span>            :  * order to preserve cross-platform compatibility.
<span class="lineNum">     513 </span>            :  *
<span class="lineNum">     514 </span>            :  * TODO The return value of this function is routinely ignored. Ignoring
<span class="lineNum">     515 </span>            :  * the return value means that it's mostly pointless to be calling this.
<span class="lineNum">     516 </span>            :  * You'll see some warning messages potentially, but that's it.
<span class="lineNum">     517 </span>            :  *
<span class="lineNum">     518 </span>            :  * XXX This function is super useful for detecting configuration problems
<span class="lineNum">     519 </span>            :  * early, but unfortunately, the latest in configuration management, sorcery,
<span class="lineNum">     520 </span>            :  * doesn't work well with this. Users of sorcery are familiar with the fields
<span class="lineNum">     521 </span>            :  * they will need to write but don't know if realtime is being used. Sorcery
<span class="lineNum">     522 </span>            :  * knows what storage mechanism is being used but has no high-level knowledge
<span class="lineNum">     523 </span>            :  * of what sort of data is going to be written.
<span class="lineNum">     524 </span>            :  */
<span class="lineNum">     525 </span>            : int ast_realtime_require_field(const char *family, ...) attribute_sentinel;
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : /*!
<span class="lineNum">     528 </span>            :  * \brief Retrieve realtime configuration
<span class="lineNum">     529 </span>            :  *
<span class="lineNum">     530 </span>            :  * \param family which family/config to lookup
<span class="lineNum">     531 </span>            :  * \param fields list of fields
<span class="lineNum">     532 </span>            :  *
<span class="lineNum">     533 </span>            :  * \details
<span class="lineNum">     534 </span>            :  * This will use builtin configuration backends to look up a particular
<span class="lineNum">     535 </span>            :  * entity in realtime and return a variable list of its parameters. Unlike
<span class="lineNum">     536 </span>            :  * the ast_load_realtime, this function can return more than one entry and
<span class="lineNum">     537 </span>            :  * is thus stored inside a traditional ast_config structure rather than
<span class="lineNum">     538 </span>            :  * just returning a linked list of variables.
<span class="lineNum">     539 </span>            :  *
<span class="lineNum">     540 </span>            :  * \return An ast_config with one or more results
<span class="lineNum">     541 </span>            :  * \retval NULL Error or no results returned
<span class="lineNum">     542 </span>            :  */
<span class="lineNum">     543 </span>            : struct ast_config *ast_load_realtime_multientry_fields(const char *family, const struct ast_variable *fields);
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            : /*!
<span class="lineNum">     546 </span>            :  * \brief Retrieve realtime configuration
<span class="lineNum">     547 </span>            :  *
<span class="lineNum">     548 </span>            :  * \param family which family/config to lookup
<span class="lineNum">     549 </span>            :  *
<span class="lineNum">     550 </span>            :  * \details
<span class="lineNum">     551 </span>            :  * This will use builtin configuration backends to look up a particular
<span class="lineNum">     552 </span>            :  * entity in realtime and return a variable list of its parameters. Unlike
<span class="lineNum">     553 </span>            :  * the ast_load_realtime, this function can return more than one entry and
<span class="lineNum">     554 </span>            :  * is thus stored inside a traditional ast_config structure rather than
<span class="lineNum">     555 </span>            :  * just returning a linked list of variables.
<span class="lineNum">     556 </span>            :  *
<span class="lineNum">     557 </span>            :  * \return An ast_config with one or more results
<span class="lineNum">     558 </span>            :  * \retval NULL Error or no results returned
<span class="lineNum">     559 </span>            :  *
<span class="lineNum">     560 </span>            :  * \note You should use the constant SENTINEL to terminate arguments, in
<span class="lineNum">     561 </span>            :  * order to preserve cross-platform compatibility.
<span class="lineNum">     562 </span>            :  */
<span class="lineNum">     563 </span>            : struct ast_config *ast_load_realtime_multientry(const char *family, ...) attribute_sentinel;
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            : /*!
<span class="lineNum">     566 </span>            :  * \brief Update realtime configuration
<span class="lineNum">     567 </span>            :  *
<span class="lineNum">     568 </span>            :  * \param family which family/config to be updated
<span class="lineNum">     569 </span>            :  * \param keyfield which field to use as the key
<span class="lineNum">     570 </span>            :  * \param lookup which value to look for in the key field to match the entry.
<span class="lineNum">     571 </span>            :  * \param fields fields to update
<span class="lineNum">     572 </span>            :  *
<span class="lineNum">     573 </span>            :  * \details
<span class="lineNum">     574 </span>            :  * This function is used to update a parameter in realtime configuration space.
<span class="lineNum">     575 </span>            :  *
<span class="lineNum">     576 </span>            :  * \return Number of rows affected, or -1 on error.
<span class="lineNum">     577 </span>            :  */
<span class="lineNum">     578 </span>            : int ast_update_realtime_fields(const char *family, const char *keyfield, const char *lookup, const struct ast_variable *fields);
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            : /*!
<span class="lineNum">     581 </span>            :  * \brief Update realtime configuration
<span class="lineNum">     582 </span>            :  *
<span class="lineNum">     583 </span>            :  * \param family which family/config to be updated
<span class="lineNum">     584 </span>            :  * \param keyfield which field to use as the key
<span class="lineNum">     585 </span>            :  * \param lookup which value to look for in the key field to match the entry.
<span class="lineNum">     586 </span>            :  *
<span class="lineNum">     587 </span>            :  * \details
<span class="lineNum">     588 </span>            :  * This function is used to update a parameter in realtime configuration space.
<span class="lineNum">     589 </span>            :  *
<span class="lineNum">     590 </span>            :  * \return Number of rows affected, or -1 on error.
<span class="lineNum">     591 </span>            :  *
<span class="lineNum">     592 </span>            :  * \note You should use the constant SENTINEL to terminate arguments, in
<span class="lineNum">     593 </span>            :  * order to preserve cross-platform compatibility.
<span class="lineNum">     594 </span>            :  */
<span class="lineNum">     595 </span>            : int ast_update_realtime(const char *family, const char *keyfield, const char *lookup, ...) attribute_sentinel;
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            : /*!
<span class="lineNum">     598 </span>            :  * \brief Update realtime configuration
<span class="lineNum">     599 </span>            :  *
<span class="lineNum">     600 </span>            :  * \param family which family/config to be updated
<span class="lineNum">     601 </span>            :  * \param lookup_fields fields used to look up entries
<span class="lineNum">     602 </span>            :  * \param update_fields fields to update
<span class="lineNum">     603 </span>            :  *
<span class="lineNum">     604 </span>            :  * \details
<span class="lineNum">     605 </span>            :  * This function is used to update a parameter in realtime configuration space.
<span class="lineNum">     606 </span>            :  * It includes the ability to lookup a row based upon multiple key criteria.
<span class="lineNum">     607 </span>            :  * As a result, this function includes two sentinel values, one to terminate
<span class="lineNum">     608 </span>            :  * lookup values and the other to terminate the listing of fields to update.
<span class="lineNum">     609 </span>            :  *
<span class="lineNum">     610 </span>            :  * \return Number of rows affected, or -1 on error.
<span class="lineNum">     611 </span>            :  */
<span class="lineNum">     612 </span>            : int ast_update2_realtime_fields(const char *family, const struct ast_variable *lookup_fields, const struct ast_variable *update_fields);
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            : /*!
<span class="lineNum">     615 </span>            :  * \brief Update realtime configuration
<span class="lineNum">     616 </span>            :  *
<span class="lineNum">     617 </span>            :  * \param family which family/config to be updated
<span class="lineNum">     618 </span>            :  *
<span class="lineNum">     619 </span>            :  * \details
<span class="lineNum">     620 </span>            :  * This function is used to update a parameter in realtime configuration space.
<span class="lineNum">     621 </span>            :  * It includes the ability to lookup a row based upon multiple key criteria.
<span class="lineNum">     622 </span>            :  * As a result, this function includes two sentinel values, one to terminate
<span class="lineNum">     623 </span>            :  * lookup values and the other to terminate the listing of fields to update.
<span class="lineNum">     624 </span>            :  *
<span class="lineNum">     625 </span>            :  * \return Number of rows affected, or -1 on error.
<span class="lineNum">     626 </span>            :  *
<span class="lineNum">     627 </span>            :  * \note You should use the constant SENTINEL to terminate arguments, in
<span class="lineNum">     628 </span>            :  * order to preserve cross-platform compatibility.
<span class="lineNum">     629 </span>            :  */
<span class="lineNum">     630 </span>            : int ast_update2_realtime(const char *family, ...) attribute_sentinel;
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : /*!
<span class="lineNum">     633 </span>            :  * \brief Create realtime configuration
<span class="lineNum">     634 </span>            :  *
<span class="lineNum">     635 </span>            :  * \param family which family/config to be created
<span class="lineNum">     636 </span>            :  * \param fields fields themselves
<span class="lineNum">     637 </span>            :  *
<span class="lineNum">     638 </span>            :  * \details
<span class="lineNum">     639 </span>            :  * This function is used to create a parameter in realtime configuration space.
<span class="lineNum">     640 </span>            :  *
<span class="lineNum">     641 </span>            :  * \return Number of rows affected, or -1 on error.
<span class="lineNum">     642 </span>            :  *
<span class="lineNum">     643 </span>            :  * \note
<span class="lineNum">     644 </span>            :  * On the MySQL engine only, for reasons of backwards compatibility, the return
<span class="lineNum">     645 </span>            :  * value is the insert ID.  This value is nonportable and may be changed in a
<span class="lineNum">     646 </span>            :  * future version to match the other engines.
<span class="lineNum">     647 </span>            :  */
<span class="lineNum">     648 </span>            : int ast_store_realtime_fields(const char *family, const struct ast_variable *fields);
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : /*!
<span class="lineNum">     651 </span>            :  * \brief Create realtime configuration
<span class="lineNum">     652 </span>            :  *
<span class="lineNum">     653 </span>            :  * \param family which family/config to be created
<span class="lineNum">     654 </span>            :  *
<span class="lineNum">     655 </span>            :  * \details
<span class="lineNum">     656 </span>            :  * This function is used to create a parameter in realtime configuration space.
<span class="lineNum">     657 </span>            :  *
<span class="lineNum">     658 </span>            :  * \return Number of rows affected, or -1 on error.
<span class="lineNum">     659 </span>            :  *
<span class="lineNum">     660 </span>            :  * \note
<span class="lineNum">     661 </span>            :  * On the MySQL engine only, for reasons of backwards compatibility, the return
<span class="lineNum">     662 </span>            :  * value is the insert ID.  This value is nonportable and may be changed in a
<span class="lineNum">     663 </span>            :  * future version to match the other engines.
<span class="lineNum">     664 </span>            :  *
<span class="lineNum">     665 </span>            :  * \note You should use the constant SENTINEL to terminate arguments, in
<span class="lineNum">     666 </span>            :  * order to preserve cross-platform compatibility.
<span class="lineNum">     667 </span>            :  */
<span class="lineNum">     668 </span>            : int ast_store_realtime(const char *family, ...) attribute_sentinel;
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            : /*!
<span class="lineNum">     671 </span>            :  * \brief Destroy realtime configuration
<span class="lineNum">     672 </span>            :  *
<span class="lineNum">     673 </span>            :  * \param family which family/config to be destroyed
<span class="lineNum">     674 </span>            :  * \param keyfield which field to use as the key
<span class="lineNum">     675 </span>            :  * \param lookup which value to look for in the key field to match the entry.
<span class="lineNum">     676 </span>            :  * \param fields fields themselves
<span class="lineNum">     677 </span>            :  *
<span class="lineNum">     678 </span>            :  * \details
<span class="lineNum">     679 </span>            :  * This function is used to destroy an entry in realtime configuration space.
<span class="lineNum">     680 </span>            :  * Additional params are used as keys.
<span class="lineNum">     681 </span>            :  *
<span class="lineNum">     682 </span>            :  * \return Number of rows affected, or -1 on error.
<span class="lineNum">     683 </span>            :  */
<span class="lineNum">     684 </span>            : int ast_destroy_realtime_fields(const char *family, const char *keyfield, const char *lookup, const struct ast_variable *fields);
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            : /*!
<span class="lineNum">     687 </span>            :  * \brief Destroy realtime configuration
<span class="lineNum">     688 </span>            :  *
<span class="lineNum">     689 </span>            :  * \param family which family/config to be destroyed
<span class="lineNum">     690 </span>            :  * \param keyfield which field to use as the key
<span class="lineNum">     691 </span>            :  * \param lookup which value to look for in the key field to match the entry.
<span class="lineNum">     692 </span>            :  *
<span class="lineNum">     693 </span>            :  * \details
<span class="lineNum">     694 </span>            :  * This function is used to destroy an entry in realtime configuration space.
<span class="lineNum">     695 </span>            :  * Additional params are used as keys.
<span class="lineNum">     696 </span>            :  *
<span class="lineNum">     697 </span>            :  * \return Number of rows affected, or -1 on error.
<span class="lineNum">     698 </span>            :  *
<span class="lineNum">     699 </span>            :  * \note You should use the constant SENTINEL to terminate arguments, in
<span class="lineNum">     700 </span>            :  * order to preserve cross-platform compatibility.
<span class="lineNum">     701 </span>            :  */
<span class="lineNum">     702 </span>            : int ast_destroy_realtime(const char *family, const char *keyfield, const char *lookup, ...) attribute_sentinel;
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : /*!
<span class="lineNum">     705 </span>            :  * \brief Check if realtime engine is configured for family
<span class="lineNum">     706 </span>            :  * \param family which family/config to be checked
<span class="lineNum">     707 </span>            :  * \return 1 if family is configured in realtime and engine exists
<span class="lineNum">     708 </span>            :  */
<span class="lineNum">     709 </span>            : int ast_check_realtime(const char *family);
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            : /*! \brief Check if there's any realtime engines loaded */
<span class="lineNum">     712 </span>            : int ast_realtime_enabled(void);
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            : /*!
<span class="lineNum">     715 </span>            :  * \brief Duplicate variable list
<span class="lineNum">     716 </span>            :  * \param var the linked list of variables to clone
<span class="lineNum">     717 </span>            :  * \return A duplicated list which you'll need to free with
<span class="lineNum">     718 </span>            :  * ast_variables_destroy or NULL when out of memory.
<span class="lineNum">     719 </span>            :  *
<span class="lineNum">     720 </span>            :  * \note Do not depend on this to copy more than just name, value and filename
<span class="lineNum">     721 </span>            :  * (the arguments to ast_variables_new).
<span class="lineNum">     722 </span>            :  */
<span class="lineNum">     723 </span>            : struct ast_variable *ast_variables_dup(struct ast_variable *var);
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            : /*!
<span class="lineNum">     726 </span>            :  * \brief Reverse a variable list
<span class="lineNum">     727 </span>            :  * \param var the linked list of variables to reverse
<span class="lineNum">     728 </span>            :  * \return The head of the reversed variable list
<span class="lineNum">     729 </span>            :  *
<span class="lineNum">     730 </span>            :  * \note The variable list var is not preserved in this function and should
<span class="lineNum">     731 </span>            :  * not be used after reversing it.
<span class="lineNum">     732 </span>            :  */
<span class="lineNum">     733 </span>            : struct ast_variable *ast_variables_reverse(struct ast_variable *var);
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            : /*!
<span class="lineNum">     736 </span>            :  * \brief Free variable list
<span class="lineNum">     737 </span>            :  * \param var the linked list of variables to free
<span class="lineNum">     738 </span>            :  *
<span class="lineNum">     739 </span>            :  * \details
<span class="lineNum">     740 </span>            :  * This function frees a list of variables.
<span class="lineNum">     741 </span>            :  */
<span class="lineNum">     742 </span>            : void ast_variables_destroy(struct ast_variable *var);
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            : /*!
<span class="lineNum">     745 </span>            :  * \brief Register config engine
<span class="lineNum">     746 </span>            :  * \retval 1 Always
<span class="lineNum">     747 </span>            :  */
<span class="lineNum">     748 </span>            : int ast_config_engine_register(struct ast_config_engine *newconfig);
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            : /*!
<span class="lineNum">     751 </span>            :  * \brief Deregister config engine
<span class="lineNum">     752 </span>            :  * \retval 0 Always
<span class="lineNum">     753 </span>            :  */
<span class="lineNum">     754 </span>            : int ast_config_engine_deregister(struct ast_config_engine *del);
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            : /*!
<span class="lineNum">     757 </span>            :  * \brief Determine if a mapping exists for a given family
<span class="lineNum">     758 </span>            :  *
<span class="lineNum">     759 </span>            :  * \param family which family you are looking to see if a mapping exists for
<span class="lineNum">     760 </span>            :  * \retval 1 if it is mapped
<span class="lineNum">     761 </span>            :  * \retval 0 if it is not
<span class="lineNum">     762 </span>            :  */
<span class="lineNum">     763 </span>            : int ast_realtime_is_mapping_defined(const char *family);
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            : #ifdef TEST_FRAMEWORK
<span class="lineNum">     766 </span>            : /*!
<span class="lineNum">     767 </span>            :  * \brief Add an explicit mapping for a family
<span class="lineNum">     768 </span>            :  *
<span class="lineNum">     769 </span>            :  * \param name Family name
<span class="lineNum">     770 </span>            :  * \param driver Driver to use
<span class="lineNum">     771 </span>            :  * \param database Database to access
<span class="lineNum">     772 </span>            :  * \param table Table to use
<span class="lineNum">     773 </span>            :  * \param priority Priority of this mapping
<span class="lineNum">     774 </span>            :  */
<span class="lineNum">     775 </span>            : int ast_realtime_append_mapping(const char *name, const char *driver, const char *database, const char *table, int priority);
<span class="lineNum">     776 </span>            : #endif
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : /*!
<span class="lineNum">     779 </span>            :  * \brief Exposed initialization method for core process
<span class="lineNum">     780 </span>            :  *
<span class="lineNum">     781 </span>            :  * \details
<span class="lineNum">     782 </span>            :  * This method is intended for use only with the core initialization and is
<span class="lineNum">     783 </span>            :  * not designed to be called from any user applications.
<span class="lineNum">     784 </span>            :  */
<span class="lineNum">     785 </span>            : int register_config_cli(void);
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            : /*! \brief Create a new base configuration structure */
<span class="lineNum">     788 </span>            : struct ast_config *ast_config_new(void);
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            : /*!
<span class="lineNum">     791 </span>            :  * \brief Retrieve the current category name being built.
<span class="lineNum">     792 </span>            :  *
<span class="lineNum">     793 </span>            :  * \details
<span class="lineNum">     794 </span>            :  * API for backend configuration engines while building a configuration set.
<span class="lineNum">     795 </span>            :  */
<span class="lineNum">     796 </span>            : struct ast_category *ast_config_get_current_category(const struct ast_config *cfg);
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : /*!
<span class="lineNum">     799 </span>            :  * \brief Set the category within the configuration as being current.
<span class="lineNum">     800 </span>            :  *
<span class="lineNum">     801 </span>            :  * \details
<span class="lineNum">     802 </span>            :  * API for backend configuration engines while building a configuration set.
<span class="lineNum">     803 </span>            :  */
<span class="lineNum">     804 </span>            : void ast_config_set_current_category(struct ast_config *cfg, const struct ast_category *cat);
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            : /*!
<span class="lineNum">     807 </span>            :  * \brief Retrieve a configuration variable within the configuration set.
<span class="lineNum">     808 </span>            :  *
<span class="lineNum">     809 </span>            :  * \details
<span class="lineNum">     810 </span>            :  * Retrieves the named variable \p var within category \p cat of configuration
<span class="lineNum">     811 </span>            :  * set \p cfg.  If not found, attempts to retrieve the named variable \p var
<span class="lineNum">     812 </span>            :  * from within category \em general.
<span class="lineNum">     813 </span>            :  *
<span class="lineNum">     814 </span>            :  * \return Value of \p var, or NULL if not found.
<span class="lineNum">     815 </span>            :  */
<span class="lineNum">     816 </span>            : const char *ast_config_option(struct ast_config *cfg, const char *cat, const char *var);
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            : /*!
<span class="lineNum">     819 </span>            :  * \brief Create a category
<span class="lineNum">     820 </span>            :  *
<span class="lineNum">     821 </span>            :  * \param name name of new category
<span class="lineNum">     822 </span>            :  * \param in_file filename which contained the new config
<span class="lineNum">     823 </span>            :  * \param lineno line number
<span class="lineNum">     824 </span>            :  */
<span class="lineNum">     825 </span>            : struct ast_category *ast_category_new(const char *name, const char *in_file, int lineno);
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            : /*!
<span class="lineNum">     828 </span>            :  * \brief Create a category that is not backed by a file
<span class="lineNum">     829 </span>            :  *
<span class="lineNum">     830 </span>            :  * \param name name of new category
<span class="lineNum">     831 </span>            :  */
<span class="lineNum">     832 </span>            : #define ast_category_new_dynamic(name) ast_category_new(name, &quot;&quot;, -1)
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            : /*!
<span class="lineNum">     835 </span>            :  * \brief Create a nameless category that is not backed by a file
<span class="lineNum">     836 </span>            :  */
<span class="lineNum">     837 </span>            : #define ast_category_new_anonymous() ast_category_new_dynamic(&quot;&quot;)
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            : /*!
<span class="lineNum">     840 </span>            :  * \brief Create a category making it a template
<span class="lineNum">     841 </span>            :  *
<span class="lineNum">     842 </span>            :  * \param name name of new template
<span class="lineNum">     843 </span>            :  * \param in_file filename which contained the new config
<span class="lineNum">     844 </span>            :  * \param lineno line number
<span class="lineNum">     845 </span>            :  */
<span class="lineNum">     846 </span>            : struct ast_category *ast_category_new_template(const char *name, const char *in_file, int lineno);
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            : /*!
<span class="lineNum">     849 </span>            :  * \brief Inserts new category
<span class="lineNum">     850 </span>            :  *
<span class="lineNum">     851 </span>            :  * \param config which config to use
<span class="lineNum">     852 </span>            :  * \param cat newly created category to insert
<span class="lineNum">     853 </span>            :  * \param match which category to insert above
<span class="lineNum">     854 </span>            :  *
<span class="lineNum">     855 </span>            :  * \details
<span class="lineNum">     856 </span>            :  * This function is used to insert a new category above another category
<span class="lineNum">     857 </span>            :  * matching the match parameter.
<span class="lineNum">     858 </span>            :  *
<span class="lineNum">     859 </span>            :  * \retval 0 if succeeded
<span class="lineNum">     860 </span>            :  * \retval -1 if the specified match category wasn't found
<span class="lineNum">     861 </span>            :  */
<span class="lineNum">     862 </span>            : int ast_category_insert(struct ast_config *config, struct ast_category *cat, const char *match);
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : /*!
<span class="lineNum">     865 </span>            :  * \brief Delete a category
<span class="lineNum">     866 </span>            :  *
<span class="lineNum">     867 </span>            :  * \param config which config to use
<span class="lineNum">     868 </span>            :  * \param category category to delete
<span class="lineNum">     869 </span>            :  *
<span class="lineNum">     870 </span>            :  * \return the category after the deleted one which could be NULL.
<span class="lineNum">     871 </span>            :  *
<span class="lineNum">     872 </span>            :  * \note It is not safe to call ast_category_delete while browsing with
<span class="lineNum">     873 </span>            :  * ast_category_browse.  It is safe with ast_category_browse_filtered.
<span class="lineNum">     874 </span>            :  */
<span class="lineNum">     875 </span>            : struct ast_category *ast_category_delete(struct ast_config *cfg, struct ast_category *category);
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            : /*!
<span class="lineNum">     878 </span>            :  * \brief Appends a category to a config
<span class="lineNum">     879 </span>            :  *
<span class="lineNum">     880 </span>            :  * \param config which config to use
<span class="lineNum">     881 </span>            :  * \param cat category to insert
<span class="lineNum">     882 </span>            :  */
<span class="lineNum">     883 </span>            : void ast_category_append(struct ast_config *config, struct ast_category *cat);
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span>            : /*!
<span class="lineNum">     886 </span>            :  * \brief Applies base (template) to category.
<span class="lineNum">     887 </span>            :  *
<span class="lineNum">     888 </span>            :  * \param existing existing category
<span class="lineNum">     889 </span>            :  * \param base base category
<span class="lineNum">     890 </span>            :  *
<span class="lineNum">     891 </span>            :  * \details
<span class="lineNum">     892 </span>            :  * This function is used to apply a base (template) to an existing category
<span class="lineNum">     893 </span>            :  *
<span class="lineNum">     894 </span>            :  * \retval 0 if succeeded
<span class="lineNum">     895 </span>            :  * \retval -1 if the memory allocation failed
<span class="lineNum">     896 </span>            :  */
<span class="lineNum">     897 </span>            : int ast_category_inherit(struct ast_category *existing, const struct ast_category *base);
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            : /*!
<span class="lineNum">     900 </span>            :  * \brief Removes and destroys all variables in a category
<span class="lineNum">     901 </span>            :  *
<span class="lineNum">     902 </span>            :  * \param category category to empty
<span class="lineNum">     903 </span>            :  *
<span class="lineNum">     904 </span>            :  * \retval 0 if succeeded
<span class="lineNum">     905 </span>            :  * \retval -1 if categopry is NULL
<span class="lineNum">     906 </span>            :  */
<span class="lineNum">     907 </span>            : int ast_category_empty(struct ast_category *category);
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            : void ast_category_destroy(struct ast_category *cat);
<span class="lineNum">     910 </span>            : struct ast_variable *ast_category_detach_variables(struct ast_category *cat);
<span class="lineNum">     911 </span>            : void ast_category_rename(struct ast_category *cat, const char *name);
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            : struct ast_variable *_ast_variable_new(const char *name, const char *value, const char *filename, const char *file, const char *function, int lineno);
<span class="lineNum">     914 </span>            : #define ast_variable_new(name, value, filename) _ast_variable_new(name, value, filename, __FILE__, __PRETTY_FUNCTION__, __LINE__)
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            : struct ast_config_include *ast_include_new(struct ast_config *conf, const char *from_file, const char *included_file, int is_exec, const char *exec_file, int from_lineno, char *real_included_file_name, int real_included_file_name_size);
<span class="lineNum">     917 </span>            : struct ast_config_include *ast_include_find(struct ast_config *conf, const char *included_file);
<span class="lineNum">     918 </span>            : void ast_include_rename(struct ast_config *conf, const char *from_file, const char *to_file);
<span class="lineNum">     919 </span>            : void ast_variable_append(struct ast_category *category, struct ast_variable *variable);
<span class="lineNum">     920 </span>            : void ast_variable_insert(struct ast_category *category, struct ast_variable *variable, const char *line);
<span class="lineNum">     921 </span>            : int ast_variable_delete(struct ast_category *category, const char *variable, const char *match, const char *line);
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            : /*!
<span class="lineNum">     924 </span>            :  * \brief Performs an in-place sort on the variable list by ascending name
<span class="lineNum">     925 </span>            :  *
<span class="lineNum">     926 </span>            :  * \param head The variable list head
<span class="lineNum">     927 </span>            :  *
<span class="lineNum">     928 </span>            :  * \return The new list head
<span class="lineNum">     929 </span>            :  */
<span class="lineNum">     930 </span>            : struct ast_variable *ast_variable_list_sort(struct ast_variable *head);
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            : /*!
<span class="lineNum">     933 </span>            :  * \brief Appends a variable list to the end of another list
<span class="lineNum">     934 </span>            :  *
<span class="lineNum">     935 </span>            :  * \param head A pointer to an ast_variable * of the existing variable list head. May NOT be NULL
<span class="lineNum">     936 </span>            :  * but the content may be to initialize a new list.  If so, upon return, this parameter will be updated
<span class="lineNum">     937 </span>            :  * with a pointer to the new list head.
<span class="lineNum">     938 </span>            :  * \param search_hint The place in the current list to start searching for the end of the list.
<span class="lineNum">     939 </span>            :  * Might help performance on longer lists.  If NULL, it defaults to head.
<span class="lineNum">     940 </span>            :  * \param new_var The head of the new variable list to be appended
<span class="lineNum">     941 </span>            :  *
<span class="lineNum">     942 </span>            :  * \return The tail of the resulting list.
<span class="lineNum">     943 </span>            :  *
<span class="lineNum">     944 </span>            :  * \note If the existing *head is NULL, it will be updated to new_var.  This allows you to call
<span class="lineNum">     945 </span>            :  * ast_variable_list_append in a loop or callback without initializing the list first.
<span class="lineNum">     946 </span>            :  */
<span class="lineNum">     947 </span>            : struct ast_variable *ast_variable_list_append_hint(struct ast_variable **head, struct ast_variable *search_hint,
<span class="lineNum">     948 </span>            :         struct ast_variable *new_var);
<span class="lineNum">     949 </span>            : #define ast_variable_list_append(head, new_var) ast_variable_list_append_hint(head, NULL, new_var)
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : /*!
<span class="lineNum">     952 </span>            :  * \brief Update variable value within a config
<span class="lineNum">     953 </span>            :  *
<span class="lineNum">     954 </span>            :  * \param category Category element within the config
<span class="lineNum">     955 </span>            :  * \param variable Name of the variable to change
<span class="lineNum">     956 </span>            :  * \param value New value of the variable
<span class="lineNum">     957 </span>            :  * \param match If set, previous value of the variable (if NULL or zero-length, no matching will be done)
<span class="lineNum">     958 </span>            :  * \param object Boolean of whether to make the new variable an object
<span class="lineNum">     959 </span>            :  *
<span class="lineNum">     960 </span>            :  * \return 0 on success or -1 on failure.
<span class="lineNum">     961 </span>            :  */
<span class="lineNum">     962 </span>            : int ast_variable_update(struct ast_category *category, const char *variable,
<span class="lineNum">     963 </span>            :                                                 const char *value, const char *match, unsigned int object);
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            : /*!
<span class="lineNum">     966 </span>            :  * \brief Save a config text file
<span class="lineNum">     967 </span>            :  * \since 13.2.0
<span class="lineNum">     968 </span>            :  *
<span class="lineNum">     969 </span>            :  * \param filename Filename
<span class="lineNum">     970 </span>            :  * \param cfg ast_config
<span class="lineNum">     971 </span>            :  * \param generator generator
<span class="lineNum">     972 </span>            :  * \param flags List of config_save_flags
<span class="lineNum">     973 </span>            :  *
<span class="lineNum">     974 </span>            :  * \return 0 on success or -1 on failure.
<span class="lineNum">     975 </span>            :  */
<span class="lineNum">     976 </span>            : int ast_config_text_file_save2(const char *filename, const struct ast_config *cfg, const char *generator, uint32_t flags);
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            : /*!
<span class="lineNum">     979 </span>            :  * \brief Save a config text file preserving the pre 13.2 behavior
<span class="lineNum">     980 </span>            :  *
<span class="lineNum">     981 </span>            :  * \param filename Filename
<span class="lineNum">     982 </span>            :  * \param cfg ast_config
<span class="lineNum">     983 </span>            :  * \param generator generator
<span class="lineNum">     984 </span>            :  *
<span class="lineNum">     985 </span>            :  * \return 0 on success or -1 on failure.
<span class="lineNum">     986 </span>            :  */
<span class="lineNum">     987 </span>            : int ast_config_text_file_save(const char *filename, const struct ast_config *cfg, const char *generator);
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            : struct ast_config *ast_config_internal_load(const char *configfile, struct ast_config *cfg, struct ast_flags flags, const char *suggested_incl_file, const char *who_asked);
<span class="lineNum">     990 </span>            : /*!
<span class="lineNum">     991 </span>            :  * \brief
<span class="lineNum">     992 </span>            :  * Copies the contents of one ast_config into another
<span class="lineNum">     993 </span>            :  *
<span class="lineNum">     994 </span>            :  * \note
<span class="lineNum">     995 </span>            :  * This creates a config on the heap. The caller of this must
<span class="lineNum">     996 </span>            :  * be prepared to free the memory returned.
<span class="lineNum">     997 </span>            :  *
<span class="lineNum">     998 </span>            :  * \param orig the config to copy
<span class="lineNum">     999 </span>            :  * \return The new config on success, NULL on failure.
<span class="lineNum">    1000 </span>            :  */
<span class="lineNum">    1001 </span>            : struct ast_config *ast_config_copy(const struct ast_config *orig);
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span>            : /*!
<span class="lineNum">    1004 </span>            :  * \brief
<span class="lineNum">    1005 </span>            :  * Flags that affect the behaviour of config hooks.
<span class="lineNum">    1006 </span>            :  */
<span class="lineNum">    1007 </span>            : enum config_hook_flags {
<span class="lineNum">    1008 </span>            :         butt,
<span class="lineNum">    1009 </span>            : };
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            : /*
<span class="lineNum">    1012 </span>            :  * \brief Callback when configuration is updated
<span class="lineNum">    1013 </span>            :  *
<span class="lineNum">    1014 </span>            :  * \param cfg A copy of the configuration that is being changed.
<span class="lineNum">    1015 </span>            :  *            This MUST be freed by the callback before returning.
<span class="lineNum">    1016 </span>            :  */
<span class="lineNum">    1017 </span>            : typedef int (*config_hook_cb)(struct ast_config *cfg);
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            : /*!
<span class="lineNum">    1020 </span>            :  * \brief
<span class="lineNum">    1021 </span>            :  * Register a config hook for a particular file and module
<span class="lineNum">    1022 </span>            :  *
<span class="lineNum">    1023 </span>            :  * \param name The name of the hook you are registering.
<span class="lineNum">    1024 </span>            :  * \param filename The file whose config you wish to hook into.
<span class="lineNum">    1025 </span>            :  * \param module The module that is reloading the config. This
<span class="lineNum">    1026 </span>            :  *               can be useful if multiple modules may possibly
<span class="lineNum">    1027 </span>            :  *               reload the same file, but you are only interested
<span class="lineNum">    1028 </span>            :  *               when a specific module reloads the file
<span class="lineNum">    1029 </span>            :  * \param flags Flags that affect the way hooks work.
<span class="lineNum">    1030 </span>            :  * \param hook The callback to be called when config is loaded.
<span class="lineNum">    1031 </span>            :  * return 0 Success
<span class="lineNum">    1032 </span>            :  * return -1 Unsuccess, also known as UTTER AND COMPLETE FAILURE
<span class="lineNum">    1033 </span>            :  */
<span class="lineNum">    1034 </span>            : int ast_config_hook_register(const char *name,
<span class="lineNum">    1035 </span>            :                 const char *filename,
<span class="lineNum">    1036 </span>            :                 const char *module,
<span class="lineNum">    1037 </span>            :                 enum config_hook_flags flags,
<span class="lineNum">    1038 </span>            :                 config_hook_cb hook);
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            : /*!
<span class="lineNum">    1041 </span>            :  * \brief
<span class="lineNum">    1042 </span>            :  * Unregister a config hook
<span class="lineNum">    1043 </span>            :  *
<span class="lineNum">    1044 </span>            :  * \param name The name of the hook to unregister
<span class="lineNum">    1045 </span>            :  */
<span class="lineNum">    1046 </span>            : void ast_config_hook_unregister(const char *name);
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            : /*!
<span class="lineNum">    1049 </span>            :  * \brief Support code to parse config file arguments
<span class="lineNum">    1050 </span>            :  *
<span class="lineNum">    1051 </span>            :  * \details
<span class="lineNum">    1052 </span>            :  * The function ast_parse_arg() provides a generic interface to parse
<span class="lineNum">    1053 </span>            :  * strings (e.g. numbers, network addresses and so on) in a flexible
<span class="lineNum">    1054 </span>            :  * way, e.g. by doing proper error and bound checks, provide default
<span class="lineNum">    1055 </span>            :  * values, and so on.
<span class="lineNum">    1056 </span>            :  * The function (described later) takes a string as an argument,
<span class="lineNum">    1057 </span>            :  * a set of flags to specify the result format and checks to perform,
<span class="lineNum">    1058 </span>            :  * a pointer to the result, and optionally some additional arguments.
<span class="lineNum">    1059 </span>            :  *
<span class="lineNum">    1060 </span>            :  * \return It returns 0 on success, != 0 otherwise.
<span class="lineNum">    1061 </span>            :  */
<span class="lineNum">    1062 </span>            : enum ast_parse_flags {
<span class="lineNum">    1063 </span>            :         /* low 4 bits of flags are used for the operand type */
<span class="lineNum">    1064 </span>            :         PARSE_TYPE      =       0x000f,
<span class="lineNum">    1065 </span>            :         /* numeric types, with optional default value and bound checks.
<span class="lineNum">    1066 </span>            :          * Additional arguments are passed by value.
<span class="lineNum">    1067 </span>            :          */
<span class="lineNum">    1068 </span>            :         PARSE_INT32     =       0x0001,
<span class="lineNum">    1069 </span>            :         PARSE_UINT32    =       0x0002,
<span class="lineNum">    1070 </span>            :         PARSE_DOUBLE    =       0x0003,
<span class="lineNum">    1071 </span>            : #if 0   /* not supported yet */
<span class="lineNum">    1072 </span>            :         PARSE_INT16     =       0x0004,
<span class="lineNum">    1073 </span>            :         PARSE_UINT16    =       0x0005,
<span class="lineNum">    1074 </span>            : #endif
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            :         /* Returns an int processed by ast_app_parse_timelen.
<span class="lineNum">    1077 </span>            :          * The first argument is an enum ast_timelen value (required).
<span class="lineNum">    1078 </span>            :          */
<span class="lineNum">    1079 </span>            :         PARSE_TIMELEN   =       0x0006,
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            :         /* Returns a struct ast_sockaddr, with optional default value
<span class="lineNum">    1082 </span>            :          * (passed by reference) and port handling (accept, ignore,
<span class="lineNum">    1083 </span>            :          * require, forbid). The format is 'ipaddress[:port]'. IPv6 address
<span class="lineNum">    1084 </span>            :          * literals need square brackets around them if a port is specified.
<span class="lineNum">    1085 </span>            :          */
<span class="lineNum">    1086 </span>            :         PARSE_ADDR      =       0x000e,
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span>            :         /* Returns a struct sockaddr_in, with optional default value
<span class="lineNum">    1089 </span>            :          * (passed by reference) and port handling (accept, ignore,
<span class="lineNum">    1090 </span>            :          * require, forbid). The format is 'host.name[:port]'
<span class="lineNum">    1091 </span>            :          */
<span class="lineNum">    1092 </span>            :         PARSE_INADDR    =       0x000f,
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            :         /* Other data types can be added as needed */
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :         /* If PARSE_DEFAULT is set, next argument is a default value
<span class="lineNum">    1097 </span>            :          * which is returned in case of error. The argument is passed
<span class="lineNum">    1098 </span>            :          * by value in case of numeric types, by reference in other cases.
<span class="lineNum">    1099 </span>            :          */
<span class="lineNum">    1100 </span>            :         PARSE_DEFAULT   =       0x0010, /* assign default on error */
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            :         /* Request a range check, applicable to numbers. Two additional
<span class="lineNum">    1103 </span>            :          * arguments are passed by value, specifying the low-high end of
<span class="lineNum">    1104 </span>            :          * the range (inclusive). An error is returned if the value
<span class="lineNum">    1105 </span>            :          * is outside or inside the range, respectively.
<span class="lineNum">    1106 </span>            :          */
<span class="lineNum">    1107 </span>            :         PARSE_IN_RANGE =       0x0020, /* accept values inside a range */
<span class="lineNum">    1108 </span>            :         PARSE_OUT_RANGE =      0x0040, /* accept values outside a range */
<span class="lineNum">    1109 </span>            :         PARSE_RANGE_DEFAULTS = 0x0080, /* default to range min/max on range error */
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            :         /* Port handling, for ast_sockaddr. accept/ignore/require/forbid
<span class="lineNum">    1112 </span>            :          * port number after the hostname or address.
<span class="lineNum">    1113 </span>            :          */
<span class="lineNum">    1114 </span>            :         PARSE_PORT_MASK =       0x0300, /* 0x000: accept port if present */
<span class="lineNum">    1115 </span>            :         PARSE_PORT_IGNORE =     0x0100, /* 0x100: ignore port if present */
<span class="lineNum">    1116 </span>            :         PARSE_PORT_REQUIRE =    0x0200, /* 0x200: require port number */
<span class="lineNum">    1117 </span>            :         PARSE_PORT_FORBID =     0x0300, /* 0x100: forbid port number */
<span class="lineNum">    1118 </span>            : };
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            : /*!
<span class="lineNum">    1121 </span>            :  * \brief The argument parsing routine.
<span class="lineNum">    1122 </span>            :  *
<span class="lineNum">    1123 </span>            :  * \param arg the string to parse. It is not modified.
<span class="lineNum">    1124 </span>            :  * \param flags combination of ast_parse_flags to specify the
<span class="lineNum">    1125 </span>            :  *      return type and additional checks.
<span class="lineNum">    1126 </span>            :  * \param result pointer to the result. NULL is valid here, and can
<span class="lineNum">    1127 </span>            :  *      be used to perform only the validity checks.
<span class="lineNum">    1128 </span>            :  * \param ... extra arguments are required according to flags.
<span class="lineNum">    1129 </span>            :  *
<span class="lineNum">    1130 </span>            :  * \retval 0 in case of success, != 0 otherwise.
<span class="lineNum">    1131 </span>            :  * \retval result returns the parsed value in case of success,
<span class="lineNum">    1132 </span>            :  * the default value in case of error, or it is left unchanged
<span class="lineNum">    1133 </span>            :  * in case of error and no default specified. Note that in certain
<span class="lineNum">    1134 </span>            :  * cases (e.g. sockaddr_in, with multi-field return values) some
<span class="lineNum">    1135 </span>            :  * of the fields in result may be changed even if an error occurs.
<span class="lineNum">    1136 </span>            :  *
<span class="lineNum">    1137 </span>            :  * \details
<span class="lineNum">    1138 </span>            :  * Examples of use:
<span class="lineNum">    1139 </span>            :  *     ast_parse_arg(&quot;223&quot;, PARSE_INT32|PARSE_IN_RANGE, &amp;a, -1000, 1000);
<span class="lineNum">    1140 </span>            :  * returns 0, a = 223
<span class="lineNum">    1141 </span>            :  *     ast_parse_arg(&quot;22345&quot;, PARSE_INT32|PARSE_IN_RANGE|PARSE_DEFAULT, &amp;a, 9999, 10, 100);
<span class="lineNum">    1142 </span>            :  * returns 1, a = 9999
<span class="lineNum">    1143 </span>            :  *     ast_parse_arg(&quot;22345ssf&quot;, PARSE_UINT32|PARSE_IN_RANGE, &amp;b, 10, 100);
<span class="lineNum">    1144 </span>            :  * returns 1, b unchanged
<span class="lineNum">    1145 </span>            :  *    ast_parse_arg(&quot;12&quot;, PARSE_UINT32|PARSE_IN_RANGE|PARSE_RANGE_DEFAULTS, &amp;a, 1, 10);
<span class="lineNum">    1146 </span>            :  * returns 1, a = 10
<span class="lineNum">    1147 </span>            :  *     ast_parse_arg(&quot;223&quot;, PARSE_TIMELEN|PARSE_IN_RANGE, &amp;a, TIMELEN_SECONDS, -1000, 1000);
<span class="lineNum">    1148 </span>            :  * returns 0, a = 1000
<span class="lineNum">    1149 </span>            :  *     ast_parse_arg(&quot;223&quot;, PARSE_TIMELEN|PARSE_IN_RANGE, &amp;a, TIMELEN_SECONDS, -1000, 250000);
<span class="lineNum">    1150 </span>            :  * returns 0, a = 223000
<span class="lineNum">    1151 </span>            :  *     ast_parse_arg(&quot;223&quot;, PARSE_TIMELEN|PARSE_IN_RANGE|PARSE_DEFAULT, &amp;a, TIMELEN_SECONDS, 9999, -1000, 250000);
<span class="lineNum">    1152 </span>            :  * returns 0, a = 9999
<span class="lineNum">    1153 </span>            :  *    ast_parse_arg(&quot;www.foo.biz:44&quot;, PARSE_INADDR, &amp;sa);
<span class="lineNum">    1154 </span>            :  * returns 0, sa contains address and port
<span class="lineNum">    1155 </span>            :  *    ast_parse_arg(&quot;www.foo.biz&quot;, PARSE_INADDR|PARSE_PORT_REQUIRE, &amp;sa);
<span class="lineNum">    1156 </span>            :  * returns 1 because port is missing, sa contains address
<span class="lineNum">    1157 </span>            :  */
<span class="lineNum">    1158 </span>            : int ast_parse_arg(const char *arg, enum ast_parse_flags flags,
<span class="lineNum">    1159 </span>            :         void *result, ...);
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            : /*
<span class="lineNum">    1162 </span>            :  * Parsing config file options in C is slightly annoying because we cannot use
<span class="lineNum">    1163 </span>            :  * string in a switch() statement, yet we need a similar behaviour, with many
<span class="lineNum">    1164 </span>            :  * branches and a break on a matching one.
<span class="lineNum">    1165 </span>            :  * The following somehow simplifies the job: we create a block using
<span class="lineNum">    1166 </span>            :  * the CV_START and CV_END macros, and then within the block we can run
<span class="lineNum">    1167 </span>            :  * actions such as &quot;if (condition) { body; break; }&quot;
<span class="lineNum">    1168 </span>            :  * Additional macros are present to run simple functions (e.g. ast_copy_string)
<span class="lineNum">    1169 </span>            :  * or to pass arguments to ast_parse_arg()
<span class="lineNum">    1170 </span>            :  *
<span class="lineNum">    1171 </span>            :  * As an example:
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            :         CV_START(v-&gt;name, v-&gt;value);      // start the block
<span class="lineNum">    1174 </span>            :         CV_STR(&quot;foo&quot;, x_foo);         // static string
<span class="lineNum">    1175 </span>            :         CV_DSTR(&quot;bar&quot;, y_bar);                // malloc'ed string
<span class="lineNum">    1176 </span>            :         CV_F(&quot;bar&quot;, ...);             // call a generic function
<span class="lineNum">    1177 </span>            :         CV_END;                         // end the block
<span class="lineNum">    1178 </span>            :  */
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            : /*! \brief the macro to open a block for variable parsing */
<span class="lineNum">    1181 </span>            : #define CV_START(__in_var, __in_val)            \
<span class="lineNum">    1182 </span>            :         do {                                    \
<span class="lineNum">    1183 </span>            :                 const char *__var = __in_var;   \
<span class="lineNum">    1184 </span>            :                 const char *__val = __in_val;
<span class="lineNum">    1185 </span>            : 
<span class="lineNum">    1186 </span>            : /*! \brief close a variable parsing block */
<span class="lineNum">    1187 </span>            : #define CV_END                  } while (0)
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            : /*! \brief call a generic function if the name matches. */
<span class="lineNum">    1190 </span>            : #define CV_F(__pattern, __body) if (!strcasecmp((__var), __pattern)) { __body; break; }
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            : /*!
<span class="lineNum">    1193 </span>            :  * \brief helper macros to assign the value to a BOOL, UINT, static string and
<span class="lineNum">    1194 </span>            :  * dynamic string
<span class="lineNum">    1195 </span>            :  */
<span class="lineNum">    1196 </span>            : #define CV_BOOL(__x, __dst)     CV_F(__x, (__dst) = ast_true(__val) )
<span class="lineNum">    1197 </span>            : #define CV_UINT(__x, __dst)     CV_F(__x, (__dst) = strtoul(__val, NULL, 0) )
<span class="lineNum">    1198 </span>            : #define CV_STR(__x, __dst)      CV_F(__x, ast_copy_string(__dst, __val, sizeof(__dst)))
<span class="lineNum">    1199 </span>            : #define CV_DSTR(__x, __dst)     CV_F(__x, ast_free(__dst); __dst = ast_strdup(__val))
<span class="lineNum">    1200 </span>            : #define CV_STRFIELD(__x, __obj, __field) CV_F(__x, ast_string_field_set(__obj, __field, __val))
<a name="1201"><span class="lineNum">    1201 </span>            : </a>
<span class="lineNum">    1202 </span>            : /*! \brief Check if require type is an integer type */
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 : AST_INLINE_API(</span>
<span class="lineNum">    1204 </span>            : int ast_rq_is_int(require_type type),
<span class="lineNum">    1205 </span>            : {
<span class="lineNum">    1206 </span>            :         switch (type) {
<span class="lineNum">    1207 </span>            :         case RQ_INTEGER1:
<span class="lineNum">    1208 </span>            :         case RQ_UINTEGER1:
<span class="lineNum">    1209 </span>            :         case RQ_INTEGER2:
<span class="lineNum">    1210 </span>            :         case RQ_UINTEGER2:
<span class="lineNum">    1211 </span>            :         case RQ_INTEGER3:
<span class="lineNum">    1212 </span>            :         case RQ_UINTEGER3:
<span class="lineNum">    1213 </span>            :         case RQ_INTEGER4:
<span class="lineNum">    1214 </span>            :         case RQ_UINTEGER4:
<span class="lineNum">    1215 </span>            :         case RQ_INTEGER8:
<span class="lineNum">    1216 </span>            :         case RQ_UINTEGER8:
<span class="lineNum">    1217 </span>            :                 return 1;
<span class="lineNum">    1218 </span>            :         default:
<span class="lineNum">    1219 </span>            :                 return 0;
<span class="lineNum">    1220 </span>            :         }
<span class="lineNum">    1221 </span>            : }
<span class="lineNum">    1222 </span>            : )
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            : /*!
<span class="lineNum">    1225 </span>            :  * \brief Remove standard encoding from realtime values, which ensures
<span class="lineNum">    1226 </span>            :  * that a semicolon embedded within a single value is not treated upon
<span class="lineNum">    1227 </span>            :  * retrieval as multiple values.
<span class="lineNum">    1228 </span>            :  * \param chunk Data to be decoded
<span class="lineNum">    1229 </span>            :  * \return The decoded data, in the original buffer
<span class="lineNum">    1230 </span>            :  * \since 1.8
<span class="lineNum">    1231 </span>            :  * \warning This function modifies the original buffer
<span class="lineNum">    1232 </span>            :  */
<span class="lineNum">    1233 </span>            : char *ast_realtime_decode_chunk(char *chunk);
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span>            : /*!
<span class="lineNum">    1236 </span>            :  * \brief Encodes a chunk of data for realtime
<span class="lineNum">    1237 </span>            :  * \param dest Destination buffer
<span class="lineNum">    1238 </span>            :  * \param maxlen Length passed through to ast_str_* functions
<span class="lineNum">    1239 </span>            :  * \param chunk Source data to be encoded
<span class="lineNum">    1240 </span>            :  * \return Buffer within dest
<span class="lineNum">    1241 </span>            :  * \since 1.8
<span class="lineNum">    1242 </span>            :  */
<span class="lineNum">    1243 </span>            : char *ast_realtime_encode_chunk(struct ast_str **dest, ssize_t maxlen, const char *chunk);
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            : /*!
<span class="lineNum">    1246 </span>            :  * \brief Tests 2 variable values to see if they match
<span class="lineNum">    1247 </span>            :  * \since 13.9.0
<span class="lineNum">    1248 </span>            :  *
<span class="lineNum">    1249 </span>            :  * \param left Variable to test
<span class="lineNum">    1250 </span>            :  * \param right Variable to match against with an optional realtime-style operator in the name
<span class="lineNum">    1251 </span>            :  *
<span class="lineNum">    1252 </span>            :  * \retval 1 matches
<span class="lineNum">    1253 </span>            :  * \retval 0 doesn't match
<span class="lineNum">    1254 </span>            :  *
<span class="lineNum">    1255 </span>            :  * \details
<span class="lineNum">    1256 </span>            :  *
<span class="lineNum">    1257 </span>            :  * The values of the variables are passed to ast_strings_match.
<span class="lineNum">    1258 </span>            :  * If right-&gt;name is suffixed with a space and an operator, that operator
<span class="lineNum">    1259 </span>            :  * is also passed to ast_strings_match.
<span class="lineNum">    1260 </span>            :  *
<span class="lineNum">    1261 </span>            :  * Examples:
<span class="lineNum">    1262 </span>            :  *
<span class="lineNum">    1263 </span>            :  * left-&gt;name = &quot;id&quot; (ignored)
<span class="lineNum">    1264 </span>            :  * left-&gt;value = &quot;abc&quot;
<span class="lineNum">    1265 </span>            :  * right-&gt;name = &quot;id regex&quot; (id is ignored)
<span class="lineNum">    1266 </span>            :  * right-&gt;value = &quot;a[bdef]c&quot;
<span class="lineNum">    1267 </span>            :  *
<span class="lineNum">    1268 </span>            :  * will result in ast_strings_match(&quot;abc&quot;, &quot;regex&quot;, &quot;a[bdef]c&quot;) which will return 1.
<span class="lineNum">    1269 </span>            :  *
<span class="lineNum">    1270 </span>            :  * left-&gt;name = &quot;id&quot; (ignored)
<span class="lineNum">    1271 </span>            :  * left-&gt;value = &quot;abc&quot;
<span class="lineNum">    1272 </span>            :  * right-&gt;name = &quot;id&quot; (ignored)
<span class="lineNum">    1273 </span>            :  * right-&gt;value = &quot;abc&quot;
<span class="lineNum">    1274 </span>            :  *
<span class="lineNum">    1275 </span>            :  * will result in ast_strings_match(&quot;abc&quot;, NULL, &quot;abc&quot;) which will return 1.
<span class="lineNum">    1276 </span>            :  *
<span class="lineNum">    1277 </span>            :  * See the documentation for ast_strings_match for the valid operators.
<span class="lineNum">    1278 </span>            :  */
<span class="lineNum">    1279 </span>            : int ast_variables_match(const struct ast_variable *left, const struct ast_variable *right);
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span>            : /*!
<span class="lineNum">    1282 </span>            :  * \brief Tests 2 variable lists to see if they match
<span class="lineNum">    1283 </span>            :  * \since 13.9.0
<span class="lineNum">    1284 </span>            :  *
<span class="lineNum">    1285 </span>            :  * \param left Variable list to test
<span class="lineNum">    1286 </span>            :  * \param right Variable list with an optional realtime-style operator in the names
<span class="lineNum">    1287 </span>            :  * \param exact_match If true, all variables in left must match all variables in right
<span class="lineNum">    1288 </span>            :  *        and vice versa.  This does exact value matches only.  Operators aren't supported.
<span class="lineNum">    1289 </span>            :  *        Except for order, the left and right lists must be equal.
<span class="lineNum">    1290 </span>            :  *
<span class="lineNum">    1291 </span>            :  *        If false, every variable in the right list must match some variable in the left list
<span class="lineNum">    1292 </span>            :  *        using the operators supplied. Variables in the left list that aren't in the right
<span class="lineNum">    1293 </span>            :  *        list are ignored for matching purposes.
<span class="lineNum">    1294 </span>            :  *
<span class="lineNum">    1295 </span>            :  * \retval 1 matches
<span class="lineNum">    1296 </span>            :  * \retval 0 doesn't match
<span class="lineNum">    1297 </span>            :  *
<span class="lineNum">    1298 </span>            :  * \details
<span class="lineNum">    1299 </span>            :  * Iterates over the variable lists calling ast_variables_match.  If any match fails
<span class="lineNum">    1300 </span>            :  * or a variable in the right list isn't in the left list, 0 is returned.
<span class="lineNum">    1301 </span>            :  */
<span class="lineNum">    1302 </span>            : int ast_variable_lists_match(const struct ast_variable *left, const struct ast_variable *right,
<span class="lineNum">    1303 </span>            :         int exact_match);
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            : #if defined(__cplusplus) || defined(c_plusplus)
<span class="lineNum">    1306 </span>            : }
<span class="lineNum">    1307 </span>            : #endif
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            : #endif /* _ASTERISK_CONFIG_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
