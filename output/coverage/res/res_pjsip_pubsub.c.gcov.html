<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Asterisk GIT-16-d8ac5bf1a5 - res/res_pjsip_pubsub.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">res</a> - res_pjsip_pubsub.c<span style="font-size: 80%;"> (source / <a href="res_pjsip_pubsub.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Asterisk GIT-16-d8ac5bf1a5</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1490</td>
            <td class="headerCovTableEntry">2213</td>
            <td class="headerCovTableEntryLo">67.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-07-23 21:48:22</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">173</td>
            <td class="headerCovTableEntry">210</td>
            <td class="headerCovTableEntryMed">82.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Asterisk -- An open source telephony toolkit.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (C) 2013, Digium, Inc.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Mark Michelson &lt;mmichelson@digium.com&gt;
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * See http://www.asterisk.org for more information about
<span class="lineNum">       9 </span>            :  * the Asterisk project. Please do not directly contact
<span class="lineNum">      10 </span>            :  * any of the maintainers of this project for assistance;
<span class="lineNum">      11 </span>            :  * the project provides a web site, mailing lists and IRC
<span class="lineNum">      12 </span>            :  * channels for your use.
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  * This program is free software, distributed under the terms of
<span class="lineNum">      15 </span>            :  * the GNU General Public License Version 2. See the LICENSE file
<span class="lineNum">      16 </span>            :  * at the top of the source tree.
<span class="lineNum">      17 </span>            :  */
<span class="lineNum">      18 </span>            : /*!
<span class="lineNum">      19 </span>            :  * \brief Opaque structure representing an RFC 3265 SIP subscription
<span class="lineNum">      20 </span>            :  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : /*** MODULEINFO
<span class="lineNum">      23 </span>            :         &lt;depend&gt;pjproject&lt;/depend&gt;
<span class="lineNum">      24 </span>            :         &lt;depend&gt;res_pjsip&lt;/depend&gt;
<span class="lineNum">      25 </span>            :         &lt;support_level&gt;core&lt;/support_level&gt;
<span class="lineNum">      26 </span>            :  ***/
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;asterisk.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &lt;pjsip.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;pjsip_simple.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;pjlib.h&gt;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &quot;asterisk/app.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;asterisk/res_pjsip_pubsub.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;asterisk/module.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;asterisk/linkedlists.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;asterisk/astobj2.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;asterisk/datastore.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;asterisk/uuid.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;asterisk/taskprocessor.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;asterisk/sched.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;asterisk/res_pjsip.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;asterisk/callerid.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;asterisk/manager.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;asterisk/cli.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;asterisk/test.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;res_pjsip/include/res_pjsip_private.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;asterisk/res_pjsip_presence_xml.h&quot;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : /*** DOCUMENTATION
<span class="lineNum">      52 </span>            :         &lt;manager name=&quot;PJSIPShowSubscriptionsInbound&quot; language=&quot;en_US&quot;&gt;
<span class="lineNum">      53 </span>            :                 &lt;synopsis&gt;
<span class="lineNum">      54 </span>            :                         Lists subscriptions.
<span class="lineNum">      55 </span>            :                 &lt;/synopsis&gt;
<span class="lineNum">      56 </span>            :                 &lt;syntax /&gt;
<span class="lineNum">      57 </span>            :                 &lt;description&gt;
<span class="lineNum">      58 </span>            :                         &lt;para&gt;
<span class="lineNum">      59 </span>            :                         Provides a listing of all inbound subscriptions.  An event &lt;literal&gt;InboundSubscriptionDetail&lt;/literal&gt;
<span class="lineNum">      60 </span>            :                         is issued for each subscription object.  Once all detail events are completed an
<span class="lineNum">      61 </span>            :                         &lt;literal&gt;InboundSubscriptionDetailComplete&lt;/literal&gt; event is issued.
<span class="lineNum">      62 </span>            :                         &lt;/para&gt;
<span class="lineNum">      63 </span>            :                 &lt;/description&gt;
<span class="lineNum">      64 </span>            :         &lt;/manager&gt;
<span class="lineNum">      65 </span>            :         &lt;manager name=&quot;PJSIPShowSubscriptionsOutbound&quot; language=&quot;en_US&quot;&gt;
<span class="lineNum">      66 </span>            :                 &lt;synopsis&gt;
<span class="lineNum">      67 </span>            :                         Lists subscriptions.
<span class="lineNum">      68 </span>            :                 &lt;/synopsis&gt;
<span class="lineNum">      69 </span>            :                 &lt;syntax /&gt;
<span class="lineNum">      70 </span>            :                 &lt;description&gt;
<span class="lineNum">      71 </span>            :                         &lt;para&gt;
<span class="lineNum">      72 </span>            :                         Provides a listing of all outbound subscriptions.  An event &lt;literal&gt;OutboundSubscriptionDetail&lt;/literal&gt;
<span class="lineNum">      73 </span>            :                         is issued for each subscription object.  Once all detail events are completed an
<span class="lineNum">      74 </span>            :                         &lt;literal&gt;OutboundSubscriptionDetailComplete&lt;/literal&gt; event is issued.
<span class="lineNum">      75 </span>            :                         &lt;/para&gt;
<span class="lineNum">      76 </span>            :                 &lt;/description&gt;
<span class="lineNum">      77 </span>            :         &lt;/manager&gt;
<span class="lineNum">      78 </span>            :         &lt;manager name=&quot;PJSIPShowResourceLists&quot; language=&quot;en_US&quot;&gt;
<span class="lineNum">      79 </span>            :                 &lt;synopsis&gt;
<span class="lineNum">      80 </span>            :                         Displays settings for configured resource lists.
<span class="lineNum">      81 </span>            :                 &lt;/synopsis&gt;
<span class="lineNum">      82 </span>            :                 &lt;syntax /&gt;
<span class="lineNum">      83 </span>            :                 &lt;description&gt;
<span class="lineNum">      84 </span>            :                         &lt;para&gt;
<span class="lineNum">      85 </span>            :                         Provides a listing of all resource lists.  An event &lt;literal&gt;ResourceListDetail&lt;/literal&gt;
<span class="lineNum">      86 </span>            :                         is issued for each resource list object.  Once all detail events are completed a
<span class="lineNum">      87 </span>            :                         &lt;literal&gt;ResourceListDetailComplete&lt;/literal&gt; event is issued.
<span class="lineNum">      88 </span>            :                         &lt;/para&gt;
<span class="lineNum">      89 </span>            :                 &lt;/description&gt;
<span class="lineNum">      90 </span>            :         &lt;/manager&gt;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :         &lt;configInfo name=&quot;res_pjsip_pubsub&quot; language=&quot;en_US&quot;&gt;
<span class="lineNum">      93 </span>            :                 &lt;synopsis&gt;Module that implements publish and subscribe support.&lt;/synopsis&gt;
<span class="lineNum">      94 </span>            :                 &lt;configFile name=&quot;pjsip.conf&quot;&gt;
<span class="lineNum">      95 </span>            :                         &lt;configObject name=&quot;subscription_persistence&quot;&gt;
<span class="lineNum">      96 </span>            :                                 &lt;synopsis&gt;Persists SIP subscriptions so they survive restarts.&lt;/synopsis&gt;
<span class="lineNum">      97 </span>            :                                 &lt;configOption name=&quot;packet&quot;&gt;
<span class="lineNum">      98 </span>            :                                         &lt;synopsis&gt;Entire SIP SUBSCRIBE packet that created the subscription&lt;/synopsis&gt;
<span class="lineNum">      99 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     100 </span>            :                                 &lt;configOption name=&quot;src_name&quot;&gt;
<span class="lineNum">     101 </span>            :                                         &lt;synopsis&gt;The source address of the subscription&lt;/synopsis&gt;
<span class="lineNum">     102 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     103 </span>            :                                 &lt;configOption name=&quot;src_port&quot;&gt;
<span class="lineNum">     104 </span>            :                                         &lt;synopsis&gt;The source port of the subscription&lt;/synopsis&gt;
<span class="lineNum">     105 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     106 </span>            :                                 &lt;configOption name=&quot;transport_key&quot;&gt;
<span class="lineNum">     107 </span>            :                                         &lt;synopsis&gt;The type of transport the subscription was received on&lt;/synopsis&gt;
<span class="lineNum">     108 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     109 </span>            :                                 &lt;configOption name=&quot;local_name&quot;&gt;
<span class="lineNum">     110 </span>            :                                         &lt;synopsis&gt;The local address the subscription was received on&lt;/synopsis&gt;
<span class="lineNum">     111 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     112 </span>            :                                 &lt;configOption name=&quot;local_port&quot;&gt;
<span class="lineNum">     113 </span>            :                                         &lt;synopsis&gt;The local port the subscription was received on&lt;/synopsis&gt;
<span class="lineNum">     114 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     115 </span>            :                                 &lt;configOption name=&quot;cseq&quot;&gt;
<span class="lineNum">     116 </span>            :                                         &lt;synopsis&gt;The sequence number of the next NOTIFY to be sent&lt;/synopsis&gt;
<span class="lineNum">     117 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     118 </span>            :                                 &lt;configOption name=&quot;tag&quot;&gt;
<span class="lineNum">     119 </span>            :                                         &lt;synopsis&gt;The local tag of the dialog for the subscription&lt;/synopsis&gt;
<span class="lineNum">     120 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     121 </span>            :                                 &lt;configOption name=&quot;endpoint&quot;&gt;
<span class="lineNum">     122 </span>            :                                         &lt;synopsis&gt;The name of the endpoint that subscribed&lt;/synopsis&gt;
<span class="lineNum">     123 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     124 </span>            :                                 &lt;configOption name=&quot;expires&quot;&gt;
<span class="lineNum">     125 </span>            :                                         &lt;synopsis&gt;The time at which the subscription expires&lt;/synopsis&gt;
<span class="lineNum">     126 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     127 </span>            :                                 &lt;configOption name=&quot;contact_uri&quot;&gt;
<span class="lineNum">     128 </span>            :                                         &lt;synopsis&gt;The Contact URI of the dialog for the subscription&lt;/synopsis&gt;
<span class="lineNum">     129 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     130 </span>            :                                 &lt;configOption name=&quot;prune_on_boot&quot;&gt;
<span class="lineNum">     131 </span>            :                                         &lt;synopsis&gt;If set, indicates that the contact used a reliable transport
<span class="lineNum">     132 </span>            :                                         and therefore the subscription must be deleted after an asterisk restart.
<span class="lineNum">     133 </span>            :                                         &lt;/synopsis&gt;
<span class="lineNum">     134 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     135 </span>            :                         &lt;/configObject&gt;
<span class="lineNum">     136 </span>            :                         &lt;configObject name=&quot;resource_list&quot;&gt;
<span class="lineNum">     137 </span>            :                                 &lt;synopsis&gt;Resource list configuration parameters.&lt;/synopsis&gt;
<span class="lineNum">     138 </span>            :                                 &lt;description&gt;
<span class="lineNum">     139 </span>            :                                         &lt;para&gt;This configuration object allows for RFC 4662 resource list subscriptions
<span class="lineNum">     140 </span>            :                                         to be specified. This can be useful to decrease the amount of subscription traffic
<span class="lineNum">     141 </span>            :                                         that a server has to process.&lt;/para&gt;
<span class="lineNum">     142 </span>            :                                         &lt;note&gt;
<span class="lineNum">     143 </span>            :                                                 &lt;para&gt;Current limitations limit the size of SIP NOTIFY requests that Asterisk sends
<span class="lineNum">     144 </span>            :                                                 to 64000 bytes. If your resource list notifications are larger than this maximum, you
<span class="lineNum">     145 </span>            :                                                 will need to make adjustments.&lt;/para&gt;
<span class="lineNum">     146 </span>            :                                         &lt;/note&gt;
<span class="lineNum">     147 </span>            :                                 &lt;/description&gt;
<span class="lineNum">     148 </span>            :                                 &lt;configOption name=&quot;type&quot;&gt;
<span class="lineNum">     149 </span>            :                                         &lt;synopsis&gt;Must be of type 'resource_list'&lt;/synopsis&gt;
<span class="lineNum">     150 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     151 </span>            :                                 &lt;configOption name=&quot;event&quot;&gt;
<span class="lineNum">     152 </span>            :                                         &lt;synopsis&gt;The SIP event package that the list resource belong to.&lt;/synopsis&gt;
<span class="lineNum">     153 </span>            :                                         &lt;description&gt;&lt;para&gt;
<span class="lineNum">     154 </span>            :                                                 The SIP event package describes the types of resources that Asterisk reports
<span class="lineNum">     155 </span>            :                                                 the state of.
<span class="lineNum">     156 </span>            :                                         &lt;/para&gt;
<span class="lineNum">     157 </span>            :                                                 &lt;enumlist&gt;
<span class="lineNum">     158 </span>            :                                                         &lt;enum name=&quot;presence&quot;&gt;&lt;para&gt;
<span class="lineNum">     159 </span>            :                                                                 Device state and presence reporting.
<span class="lineNum">     160 </span>            :                                                         &lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">     161 </span>            :                                                         &lt;enum name=&quot;dialog&quot;&gt;&lt;para&gt;
<span class="lineNum">     162 </span>            :                                                                 This is identical to &lt;replaceable&gt;presence&lt;/replaceable&gt;.
<span class="lineNum">     163 </span>            :                                                         &lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">     164 </span>            :                                                         &lt;enum name=&quot;message-summary&quot;&gt;&lt;para&gt;
<span class="lineNum">     165 </span>            :                                                                 Message-waiting indication (MWI) reporting.
<span class="lineNum">     166 </span>            :                                                         &lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">     167 </span>            :                                                 &lt;/enumlist&gt;
<span class="lineNum">     168 </span>            :                                         &lt;/description&gt;
<span class="lineNum">     169 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     170 </span>            :                                 &lt;configOption name=&quot;list_item&quot;&gt;
<span class="lineNum">     171 </span>            :                                         &lt;synopsis&gt;The name of a resource to report state on&lt;/synopsis&gt;
<span class="lineNum">     172 </span>            :                                         &lt;description&gt;
<span class="lineNum">     173 </span>            :                                                 &lt;para&gt;In general Asterisk looks up list items in the following way:&lt;/para&gt;
<span class="lineNum">     174 </span>            :                                                 &lt;para&gt;1. Check if the list item refers to another configured resource list.&lt;/para&gt;
<span class="lineNum">     175 </span>            :                                                 &lt;para&gt;2. Pass the name of the resource off to event-package-specific handlers
<span class="lineNum">     176 </span>            :                                                    to find the specified resource.&lt;/para&gt;
<span class="lineNum">     177 </span>            :                                                 &lt;para&gt;The second part means that the way the list item is specified depends
<span class="lineNum">     178 </span>            :                                                 on what type of list this is. For instance, if you have the &lt;replaceable&gt;event&lt;/replaceable&gt;
<span class="lineNum">     179 </span>            :                                                 set to &lt;literal&gt;presence&lt;/literal&gt;, then list items should be in the form of
<span class="lineNum">     180 </span>            :                                                 dialplan_extension@dialplan_context. For &lt;literal&gt;message-summary&lt;/literal&gt; mailbox
<span class="lineNum">     181 </span>            :                                                 names should be listed.&lt;/para&gt;
<span class="lineNum">     182 </span>            :                                         &lt;/description&gt;
<span class="lineNum">     183 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     184 </span>            :                                 &lt;configOption name=&quot;full_state&quot; default=&quot;no&quot;&gt;
<span class="lineNum">     185 </span>            :                                         &lt;synopsis&gt;Indicates if the entire list's state should be sent out.&lt;/synopsis&gt;
<span class="lineNum">     186 </span>            :                                         &lt;description&gt;
<span class="lineNum">     187 </span>            :                                                 &lt;para&gt;If this option is enabled, and a resource changes state, then Asterisk will construct
<span class="lineNum">     188 </span>            :                                                 a notification that contains the state of all resources in the list. If the option is
<span class="lineNum">     189 </span>            :                                                 disabled, Asterisk will construct a notification that only contains the states of
<span class="lineNum">     190 </span>            :                                                 resources that have changed.&lt;/para&gt;
<span class="lineNum">     191 </span>            :                                                 &lt;note&gt;
<span class="lineNum">     192 </span>            :                                                         &lt;para&gt;Even with this option disabled, there are certain situations where Asterisk is forced
<span class="lineNum">     193 </span>            :                                                         to send a notification with the states of all resources in the list. When a subscriber
<span class="lineNum">     194 </span>            :                                                         renews or terminates its subscription to the list, Asterisk MUST send a full state
<span class="lineNum">     195 </span>            :                                                         notification.&lt;/para&gt;
<span class="lineNum">     196 </span>            :                                                 &lt;/note&gt;
<span class="lineNum">     197 </span>            :                                         &lt;/description&gt;
<span class="lineNum">     198 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     199 </span>            :                                 &lt;configOption name=&quot;notification_batch_interval&quot; default=&quot;0&quot;&gt;
<span class="lineNum">     200 </span>            :                                         &lt;synopsis&gt;Time Asterisk should wait, in milliseconds, before sending notifications.&lt;/synopsis&gt;
<span class="lineNum">     201 </span>            :                                         &lt;description&gt;
<span class="lineNum">     202 </span>            :                                                 &lt;para&gt;When a resource's state changes, it may be desired to wait a certain amount before Asterisk
<span class="lineNum">     203 </span>            :                                                 sends a notification to subscribers. This allows for other state changes to accumulate, so that
<span class="lineNum">     204 </span>            :                                                 Asterisk can communicate multiple state changes in a single notification instead of rapidly sending
<span class="lineNum">     205 </span>            :                                                 many notifications.&lt;/para&gt;
<span class="lineNum">     206 </span>            :                                         &lt;/description&gt;
<span class="lineNum">     207 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     208 </span>            :                         &lt;/configObject&gt;
<span class="lineNum">     209 </span>            :                         &lt;configObject name=&quot;inbound-publication&quot;&gt;
<span class="lineNum">     210 </span>            :                                 &lt;synopsis&gt;The configuration for inbound publications&lt;/synopsis&gt;
<span class="lineNum">     211 </span>            :                                 &lt;configOption name=&quot;endpoint&quot; default=&quot;&quot;&gt;
<span class="lineNum">     212 </span>            :                                         &lt;synopsis&gt;Optional name of an endpoint that is only allowed to publish to this resource&lt;/synopsis&gt;
<span class="lineNum">     213 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     214 </span>            :                                 &lt;configOption name=&quot;type&quot;&gt;
<span class="lineNum">     215 </span>            :                                         &lt;synopsis&gt;Must be of type 'inbound-publication'.&lt;/synopsis&gt;
<span class="lineNum">     216 </span>            :                                 &lt;/configOption&gt;
<span class="lineNum">     217 </span>            :                         &lt;/configObject&gt;
<span class="lineNum">     218 </span>            :                 &lt;/configFile&gt;
<span class="lineNum">     219 </span>            :         &lt;/configInfo&gt;
<span class="lineNum">     220 </span>            :  ***/
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            : static pj_bool_t pubsub_on_rx_request(pjsip_rx_data *rdata);
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : static struct pjsip_module pubsub_module = {
<span class="lineNum">     225 </span>            :         .name = { &quot;PubSub Module&quot;, 13 },
<span class="lineNum">     226 </span>            :         .priority = PJSIP_MOD_PRIORITY_APPLICATION,
<span class="lineNum">     227 </span>            :         .on_rx_request = pubsub_on_rx_request,
<span class="lineNum">     228 </span>            : };
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : #define MOD_DATA_PERSISTENCE &quot;sub_persistence&quot;
<span class="lineNum">     231 </span>            : #define MOD_DATA_MSG &quot;sub_msg&quot;
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : static const pj_str_t str_event_name = { &quot;Event&quot;, 5 };
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : /*! \brief Scheduler used for automatically expiring publications */
<span class="lineNum">     236 </span>            : static struct ast_sched_context *sched;
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            : /*! \brief Number of buckets for publications (on a per handler) */
<span class="lineNum">     239 </span>            : #define PUBLICATIONS_BUCKETS 37
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            : /*! \brief Default expiration time for PUBLISH if one is not specified */
<span class="lineNum">     242 </span>            : #define DEFAULT_PUBLISH_EXPIRES 3600
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : /*! \brief Number of buckets for subscription datastore */
<span class="lineNum">     245 </span>            : #define DATASTORE_BUCKETS 53
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : /*! \brief Default expiration for subscriptions */
<span class="lineNum">     248 </span>            : #define DEFAULT_EXPIRES 3600
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : /*! \brief Defined method for PUBLISH */
<span class="lineNum">     251 </span>            : const pjsip_method pjsip_publish_method =
<span class="lineNum">     252 </span>            : {
<span class="lineNum">     253 </span>            :         PJSIP_OTHER_METHOD,
<span class="lineNum">     254 </span>            :         { &quot;PUBLISH&quot;, 7 }
<span class="lineNum">     255 </span>            : };
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : /*!
<span class="lineNum">     258 </span>            :  * \brief The types of PUBLISH messages defined in RFC 3903
<span class="lineNum">     259 </span>            :  */
<span class="lineNum">     260 </span>            : enum sip_publish_type {
<span class="lineNum">     261 </span>            :         /*!
<span class="lineNum">     262 </span>            :          * \brief Unknown
<span class="lineNum">     263 </span>            :          *
<span class="lineNum">     264 </span>            :          * \details
<span class="lineNum">     265 </span>            :          * This actually is not defined in RFC 3903. We use this as a constant
<span class="lineNum">     266 </span>            :          * to indicate that an incoming PUBLISH does not fit into any of the
<span class="lineNum">     267 </span>            :          * other categories and is thus invalid.
<span class="lineNum">     268 </span>            :          */
<span class="lineNum">     269 </span>            :         SIP_PUBLISH_UNKNOWN,
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :         /*!
<span class="lineNum">     272 </span>            :          * \brief Initial
<span class="lineNum">     273 </span>            :          *
<span class="lineNum">     274 </span>            :          * \details
<span class="lineNum">     275 </span>            :          * The first PUBLISH sent. This will contain a non-zero Expires header
<span class="lineNum">     276 </span>            :          * as well as a body that indicates the current state of the endpoint
<span class="lineNum">     277 </span>            :          * that has sent the message. The initial PUBLISH is the only type
<span class="lineNum">     278 </span>            :          * of PUBLISH to not contain a Sip-If-Match header in it.
<span class="lineNum">     279 </span>            :          */
<span class="lineNum">     280 </span>            :         SIP_PUBLISH_INITIAL,
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            :         /*!
<span class="lineNum">     283 </span>            :          * \brief Refresh
<span class="lineNum">     284 </span>            :          *
<span class="lineNum">     285 </span>            :          * \details
<span class="lineNum">     286 </span>            :          * Used to keep a published state from expiring. This will contain a
<span class="lineNum">     287 </span>            :          * non-zero Expires header but no body since its purpose is not to
<span class="lineNum">     288 </span>            :          * update state.
<span class="lineNum">     289 </span>            :          */
<span class="lineNum">     290 </span>            :         SIP_PUBLISH_REFRESH,
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            :         /*!
<span class="lineNum">     293 </span>            :          * \brief Modify
<span class="lineNum">     294 </span>            :          *
<span class="lineNum">     295 </span>            :          * \details
<span class="lineNum">     296 </span>            :          * Used to change state from its previous value. This will contain
<span class="lineNum">     297 </span>            :          * a body updating the published state. May or may not contain an
<span class="lineNum">     298 </span>            :          * Expires header.
<span class="lineNum">     299 </span>            :          */
<span class="lineNum">     300 </span>            :         SIP_PUBLISH_MODIFY,
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :         /*!
<span class="lineNum">     303 </span>            :          * \brief Remove
<span class="lineNum">     304 </span>            :          *
<span class="lineNum">     305 </span>            :          * \details
<span class="lineNum">     306 </span>            :          * Used to remove published state from an ESC. This will contain
<span class="lineNum">     307 </span>            :          * an Expires header set to 0 and likely no body.
<span class="lineNum">     308 </span>            :          */
<span class="lineNum">     309 </span>            :         SIP_PUBLISH_REMOVE,
<span class="lineNum">     310 </span>            : };
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : /*!
<span class="lineNum">     313 </span>            :  * \brief A vector of strings commonly used throughout this module
<span class="lineNum">     314 </span>            :  */
<span class="lineNum">     315 </span>            : AST_VECTOR(resources, const char *);
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : /*!
<span class="lineNum">     318 </span>            :  * \brief Resource list configuration item
<span class="lineNum">     319 </span>            :  */
<span class="lineNum">     320 </span>            : struct resource_list {
<span class="lineNum">     321 </span>            :         SORCERY_OBJECT(details);
<span class="lineNum">     322 </span>            :         /*! SIP event package the list uses. */
<span class="lineNum">     323 </span>            :         char event[32];
<span class="lineNum">     324 </span>            :         /*! Strings representing resources in the list. */
<span class="lineNum">     325 </span>            :         struct resources items;
<span class="lineNum">     326 </span>            :         /*! Indicates if Asterisk sends full or partial state on notifications. */
<span class="lineNum">     327 </span>            :         unsigned int full_state;
<span class="lineNum">     328 </span>            :         /*! Time, in milliseconds Asterisk waits before sending a batched notification.*/
<span class="lineNum">     329 </span>            :         unsigned int notification_batch_interval;
<span class="lineNum">     330 </span>            : };
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : /*!
<span class="lineNum">     333 </span>            :  * Used to create new entity IDs by ESCs.
<span class="lineNum">     334 </span>            :  */
<span class="lineNum">     335 </span>            : static int esc_etag_counter;
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : /*!
<span class="lineNum">     338 </span>            :  * \brief Structure representing a SIP publication
<span class="lineNum">     339 </span>            :  */
<span class="lineNum">     340 </span>            : struct ast_sip_publication {
<span class="lineNum">     341 </span>            :         /*! Publication datastores set up by handlers */
<span class="lineNum">     342 </span>            :         struct ao2_container *datastores;
<span class="lineNum">     343 </span>            :         /*! \brief Entity tag for the publication */
<span class="lineNum">     344 </span>            :         int entity_tag;
<span class="lineNum">     345 </span>            :         /*! \brief Handler for this publication */
<span class="lineNum">     346 </span>            :         struct ast_sip_publish_handler *handler;
<span class="lineNum">     347 </span>            :         /*! \brief The endpoint with which the subscription is communicating */
<span class="lineNum">     348 </span>            :         struct ast_sip_endpoint *endpoint;
<span class="lineNum">     349 </span>            :         /*! \brief Expiration time of the publication */
<span class="lineNum">     350 </span>            :         int expires;
<span class="lineNum">     351 </span>            :         /*! \brief Scheduled item for expiration of publication */
<span class="lineNum">     352 </span>            :         int sched_id;
<span class="lineNum">     353 </span>            :         /*! \brief The resource the publication is to */
<span class="lineNum">     354 </span>            :         char *resource;
<span class="lineNum">     355 </span>            :         /*! \brief The name of the event type configuration */
<span class="lineNum">     356 </span>            :         char *event_configuration_name;
<span class="lineNum">     357 </span>            :         /*! \brief Data containing the above */
<span class="lineNum">     358 </span>            :         char data[0];
<span class="lineNum">     359 </span>            : };
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : /*!
<span class="lineNum">     363 </span>            :  * \brief Structure used for persisting an inbound subscription
<span class="lineNum">     364 </span>            :  */
<span class="lineNum">     365 </span>            : struct subscription_persistence {
<span class="lineNum">     366 </span>            :         /*! Sorcery object details */
<span class="lineNum">     367 </span>            :         SORCERY_OBJECT(details);
<span class="lineNum">     368 </span>            :         /*! The name of the endpoint involved in the subscription */
<span class="lineNum">     369 </span>            :         char *endpoint;
<span class="lineNum">     370 </span>            :         /*! SIP message that creates the subscription */
<span class="lineNum">     371 </span>            :         char packet[PJSIP_MAX_PKT_LEN];
<span class="lineNum">     372 </span>            :         /*! Source address of the message */
<span class="lineNum">     373 </span>            :         char src_name[PJ_INET6_ADDRSTRLEN];
<span class="lineNum">     374 </span>            :         /*! Source port of the message */
<span class="lineNum">     375 </span>            :         int src_port;
<span class="lineNum">     376 </span>            :         /*! Local transport key type */
<span class="lineNum">     377 </span>            :         char transport_key[32];
<span class="lineNum">     378 </span>            :         /*! Local transport address */
<span class="lineNum">     379 </span>            :         char local_name[PJ_INET6_ADDRSTRLEN];
<span class="lineNum">     380 </span>            :         /*! Local transport port */
<span class="lineNum">     381 </span>            :         int local_port;
<span class="lineNum">     382 </span>            :         /*! Next CSeq to use for message */
<span class="lineNum">     383 </span>            :         unsigned int cseq;
<span class="lineNum">     384 </span>            :         /*! Local tag of the dialog */
<span class="lineNum">     385 </span>            :         char *tag;
<span class="lineNum">     386 </span>            :         /*! When this subscription expires */
<span class="lineNum">     387 </span>            :         struct timeval expires;
<span class="lineNum">     388 </span>            :         /*! Contact URI */
<span class="lineNum">     389 </span>            :         char contact_uri[PJSIP_MAX_URL_SIZE];
<span class="lineNum">     390 </span>            :         /*! Prune subscription on restart */
<span class="lineNum">     391 </span>            :         int prune_on_boot;
<span class="lineNum">     392 </span>            : };
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            : /*!
<span class="lineNum">     395 </span>            :  * \brief The state of the subscription tree
<span class="lineNum">     396 </span>            :  */
<span class="lineNum">     397 </span>            : enum sip_subscription_tree_state {
<span class="lineNum">     398 </span>            :         /*! Normal operation */
<span class="lineNum">     399 </span>            :         SIP_SUB_TREE_NORMAL = 0,
<span class="lineNum">     400 </span>            :         /*! A terminate has been requested by Asterisk, the client, or pjproject */
<span class="lineNum">     401 </span>            :         SIP_SUB_TREE_TERMINATE_PENDING,
<span class="lineNum">     402 </span>            :         /*! The terminate is in progress */
<span class="lineNum">     403 </span>            :         SIP_SUB_TREE_TERMINATE_IN_PROGRESS,
<span class="lineNum">     404 </span>            :         /*! The terminate process has finished and the subscription tree is no longer valid */
<span class="lineNum">     405 </span>            :         SIP_SUB_TREE_TERMINATED,
<span class="lineNum">     406 </span>            : };
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : static char *sub_tree_state_description[] = {
<span class="lineNum">     409 </span>            :         &quot;Normal&quot;,
<span class="lineNum">     410 </span>            :         &quot;TerminatePending&quot;,
<span class="lineNum">     411 </span>            :         &quot;TerminateInProgress&quot;,
<span class="lineNum">     412 </span>            :         &quot;Terminated&quot;
<span class="lineNum">     413 </span>            : };
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : /*!
<span class="lineNum">     416 </span>            :  * \brief A tree of SIP subscriptions
<span class="lineNum">     417 </span>            :  *
<span class="lineNum">     418 </span>            :  * Because of the ability to subscribe to resource lists, a SIP
<span class="lineNum">     419 </span>            :  * subscription can result in a tree of subscriptions being created.
<span class="lineNum">     420 </span>            :  * This structure represents the information relevant to the subscription
<span class="lineNum">     421 </span>            :  * as a whole, to include the underlying PJSIP structure for the
<span class="lineNum">     422 </span>            :  * subscription.
<span class="lineNum">     423 </span>            :  */
<span class="lineNum">     424 </span>            : struct sip_subscription_tree {
<span class="lineNum">     425 </span>            :         /*! The endpoint with which the subscription is communicating */
<span class="lineNum">     426 </span>            :         struct ast_sip_endpoint *endpoint;
<span class="lineNum">     427 </span>            :         /*! Serializer on which to place operations for this subscription */
<span class="lineNum">     428 </span>            :         struct ast_taskprocessor *serializer;
<span class="lineNum">     429 </span>            :         /*! The role for this subscription */
<span class="lineNum">     430 </span>            :         enum ast_sip_subscription_role role;
<span class="lineNum">     431 </span>            :         /*! Persistence information */
<span class="lineNum">     432 </span>            :         struct subscription_persistence *persistence;
<span class="lineNum">     433 </span>            :         /*! The underlying PJSIP event subscription structure */
<span class="lineNum">     434 </span>            :         pjsip_evsub *evsub;
<span class="lineNum">     435 </span>            :         /*! The underlying PJSIP dialog */
<span class="lineNum">     436 </span>            :         pjsip_dialog *dlg;
<span class="lineNum">     437 </span>            :         /*! Interval to use for batching notifications */
<span class="lineNum">     438 </span>            :         unsigned int notification_batch_interval;
<span class="lineNum">     439 </span>            :         /*! Scheduler ID for batched notification */
<span class="lineNum">     440 </span>            :         int notify_sched_id;
<span class="lineNum">     441 </span>            :         /*! Indicator if scheduled batched notification should be sent */
<span class="lineNum">     442 </span>            :         unsigned int send_scheduled_notify;
<span class="lineNum">     443 </span>            :         /*! The root of the subscription tree */
<span class="lineNum">     444 </span>            :         struct ast_sip_subscription *root;
<span class="lineNum">     445 </span>            :         /*! Is this subscription to a list? */
<span class="lineNum">     446 </span>            :         int is_list;
<span class="lineNum">     447 </span>            :         /*! Next item in the list */
<span class="lineNum">     448 </span>            :         AST_LIST_ENTRY(sip_subscription_tree) next;
<span class="lineNum">     449 </span>            :         /*! Subscription tree state */
<span class="lineNum">     450 </span>            :         enum sip_subscription_tree_state state;
<span class="lineNum">     451 </span>            :         /*! On asterisk restart, this is the task data used
<span class="lineNum">     452 </span>            :          * to restart the expiration timer if pjproject isn't
<span class="lineNum">     453 </span>            :          * capable of restarting the timer.
<span class="lineNum">     454 </span>            :          */
<span class="lineNum">     455 </span>            :         struct ast_sip_sched_task *expiration_task;
<span class="lineNum">     456 </span>            :         /*! The transport the subscription was received on.
<span class="lineNum">     457 </span>            :          * Only used for reliable transports.
<span class="lineNum">     458 </span>            :          */
<span class="lineNum">     459 </span>            :         pjsip_transport *transport;
<span class="lineNum">     460 </span>            : };
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : /*!
<span class="lineNum">     463 </span>            :  * \brief Structure representing a &quot;virtual&quot; SIP subscription.
<span class="lineNum">     464 </span>            :  *
<span class="lineNum">     465 </span>            :  * This structure serves a dual purpose. Structurally, it is
<span class="lineNum">     466 </span>            :  * the constructed tree of subscriptions based on the resources
<span class="lineNum">     467 </span>            :  * being subscribed to. API-wise, this serves as the handle that
<span class="lineNum">     468 </span>            :  * subscription handlers use in order to interact with the pubsub API.
<span class="lineNum">     469 </span>            :  */
<span class="lineNum">     470 </span>            : struct ast_sip_subscription {
<span class="lineNum">     471 </span>            :         /*! Subscription datastores set up by handlers */
<span class="lineNum">     472 </span>            :         struct ao2_container *datastores;
<span class="lineNum">     473 </span>            :         /*! The handler for this subscription */
<span class="lineNum">     474 </span>            :         const struct ast_sip_subscription_handler *handler;
<span class="lineNum">     475 </span>            :         /*! Pointer to the base of the tree */
<span class="lineNum">     476 </span>            :         struct sip_subscription_tree *tree;
<span class="lineNum">     477 </span>            :         /*! Body generaator for NOTIFYs */
<span class="lineNum">     478 </span>            :         struct ast_sip_pubsub_body_generator *body_generator;
<span class="lineNum">     479 </span>            :         /*! Vector of child subscriptions */
<span class="lineNum">     480 </span>            :         AST_VECTOR(, struct ast_sip_subscription *) children;
<span class="lineNum">     481 </span>            :         /*! Saved NOTIFY body text for this subscription */
<span class="lineNum">     482 </span>            :         struct ast_str *body_text;
<span class="lineNum">     483 </span>            :         /*! Indicator that the body text has changed since the last notification */
<span class="lineNum">     484 </span>            :         int body_changed;
<span class="lineNum">     485 </span>            :         /*! The current state of the subscription */
<span class="lineNum">     486 </span>            :         pjsip_evsub_state subscription_state;
<span class="lineNum">     487 </span>            :         /*! For lists, the current version to place in the RLMI body */
<span class="lineNum">     488 </span>            :         unsigned int version;
<span class="lineNum">     489 </span>            :         /*! For lists, indicates if full state should always be communicated. */
<span class="lineNum">     490 </span>            :         unsigned int full_state;
<span class="lineNum">     491 </span>            :         /*! URI associated with the subscription */
<span class="lineNum">     492 </span>            :         pjsip_sip_uri *uri;
<span class="lineNum">     493 </span>            :         /*! Name of resource being subscribed to */
<span class="lineNum">     494 </span>            :         char resource[0];
<span class="lineNum">     495 </span>            : };
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            : /*!
<span class="lineNum">     498 </span>            :  * \brief Structure representing a publication resource
<span class="lineNum">     499 </span>            :  */
<span class="lineNum">     500 </span>            : struct ast_sip_publication_resource {
<span class="lineNum">     501 </span>            :         /*! \brief Sorcery object details */
<span class="lineNum">     502 </span>            :         SORCERY_OBJECT(details);
<span class="lineNum">     503 </span>            :         /*! \brief Optional name of an endpoint that is only allowed to publish to this resource */
<span class="lineNum">     504 </span>            :         char *endpoint;
<span class="lineNum">     505 </span>            :         /*! \brief Mapping for event types to configuration */
<span class="lineNum">     506 </span>            :         struct ast_variable *events;
<span class="lineNum">     507 </span>            : };
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : static const char *sip_subscription_roles_map[] = {
<span class="lineNum">     510 </span>            :         [AST_SIP_SUBSCRIBER] = &quot;Subscriber&quot;,
<span class="lineNum">     511 </span>            :         [AST_SIP_NOTIFIER] = &quot;Notifier&quot;
<span class="lineNum">     512 </span>            : };
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            : enum sip_persistence_update_type {
<span class="lineNum">     515 </span>            :         /*! Called from send request */
<span class="lineNum">     516 </span>            :         SUBSCRIPTION_PERSISTENCE_SEND_REQUEST = 0,
<span class="lineNum">     517 </span>            :         /*! Subscription created from initial client request */
<span class="lineNum">     518 </span>            :         SUBSCRIPTION_PERSISTENCE_CREATED,
<span class="lineNum">     519 </span>            :         /*! Subscription recreated by asterisk on startup */
<span class="lineNum">     520 </span>            :         SUBSCRIPTION_PERSISTENCE_RECREATED,
<span class="lineNum">     521 </span>            :         /*! Subscription created from client refresh */
<span class="lineNum">     522 </span>            :         SUBSCRIPTION_PERSISTENCE_REFRESHED,
<span class="lineNum">     523 </span>            : };
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            : AST_RWLIST_HEAD_STATIC(subscriptions, sip_subscription_tree);
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : AST_RWLIST_HEAD_STATIC(body_generators, ast_sip_pubsub_body_generator);
<span class="lineNum">     528 </span>            : AST_RWLIST_HEAD_STATIC(body_supplements, ast_sip_pubsub_body_supplement);
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            : static pjsip_media_type rlmi_media_type;
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            : static void pubsub_on_evsub_state(pjsip_evsub *sub, pjsip_event *event);
<span class="lineNum">     533 </span>            : static void pubsub_on_rx_refresh(pjsip_evsub *sub, pjsip_rx_data *rdata,
<span class="lineNum">     534 </span>            :                 int *p_st_code, pj_str_t **p_st_text, pjsip_hdr *res_hdr, pjsip_msg_body **p_body);
<span class="lineNum">     535 </span>            : static void pubsub_on_rx_notify(pjsip_evsub *sub, pjsip_rx_data *rdata, int *p_st_code,
<span class="lineNum">     536 </span>            :                 pj_str_t **p_st_text, pjsip_hdr *res_hdr, pjsip_msg_body **p_body);
<span class="lineNum">     537 </span>            : static void pubsub_on_client_refresh(pjsip_evsub *sub);
<span class="lineNum">     538 </span>            : static void pubsub_on_server_timeout(pjsip_evsub *sub);
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            : static pjsip_evsub_user pubsub_cb = {
<span class="lineNum">     541 </span>            :         .on_evsub_state = pubsub_on_evsub_state,
<span class="lineNum">     542 </span>            :         .on_rx_refresh = pubsub_on_rx_refresh,
<span class="lineNum">     543 </span>            :         .on_rx_notify = pubsub_on_rx_notify,
<span class="lineNum">     544 </span>            :         .on_client_refresh = pubsub_on_client_refresh,
<span class="lineNum">     545 </span>            :         .on_server_timeout = pubsub_on_server_timeout,
<span class="lineNum">     546 </span>            : };
<a name="547"><span class="lineNum">     547 </span>            : </a>
<span class="lineNum">     548 </span>            : /*! \brief Destructor for publication resource */
<span class="lineNum">     549 </span><span class="lineCov">          2 : static void publication_resource_destroy(void *obj)</span>
<span class="lineNum">     550 </span>            : {
<span class="lineNum">     551 </span><span class="lineCov">          2 :         struct ast_sip_publication_resource *resource = obj;</span>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span><span class="lineCov">          2 :         ast_free(resource-&gt;endpoint);</span>
<span class="lineNum">     554 </span><span class="lineCov">          2 :         ast_variables_destroy(resource-&gt;events);</span>
<span class="lineNum">     555 </span><span class="lineCov">          2 : }</span>
<a name="556"><span class="lineNum">     556 </span>            : </a>
<span class="lineNum">     557 </span>            : /*! \brief Allocator for publication resource */
<span class="lineNum">     558 </span><span class="lineCov">          2 : static void *publication_resource_alloc(const char *name)</span>
<span class="lineNum">     559 </span>            : {
<span class="lineNum">     560 </span><span class="lineCov">          2 :         return ast_sorcery_generic_alloc(sizeof(struct ast_sip_publication_resource), publication_resource_destroy);</span>
<a name="561"><span class="lineNum">     561 </span>            : }</a>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineNoCov">          0 : static int sub_tree_subscription_terminate_cb(void *data)</span>
<span class="lineNum">     564 </span>            : {
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :         struct sip_subscription_tree *sub_tree = data;</span>
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :         if (!sub_tree-&gt;evsub) {</span>
<span class="lineNum">     568 </span>            :                 /* Something else already terminated the subscription. */
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :                 ao2_ref(sub_tree, -1);</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     571 </span>            :         }
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :         ast_debug(3, &quot;Transport destroyed.  Removing subscription '%s-&gt;%s'  prune on boot: %d\n&quot;,</span>
<span class="lineNum">     574 </span>            :                 sub_tree-&gt;persistence-&gt;endpoint, sub_tree-&gt;root-&gt;resource,
<span class="lineNum">     575 </span>            :                 sub_tree-&gt;persistence-&gt;prune_on_boot);
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :         sub_tree-&gt;state = SIP_SUB_TREE_TERMINATE_IN_PROGRESS;</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :         pjsip_evsub_terminate(sub_tree-&gt;evsub, PJ_TRUE);</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         ao2_ref(sub_tree, -1);</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     582 </span>            : }
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            : /*!
<span class="lineNum">     585 </span>            :  * \internal
<span class="lineNum">     586 </span>            :  * \brief The reliable transport we used as a subscription contact has shutdown.
<span class="lineNum">     587 </span>            :  *
<span class="lineNum">     588 </span>            :  * \param data What subscription needs to be terminated.
<span class="lineNum">     589 </span>            :  *
<span class="lineNum">     590 </span>            :  * \note Normally executed by the pjsip monitor thread.
<span class="lineNum">     591 </span>            :  *
<a name="592"><span class="lineNum">     592 </span>            :  * \return Nothing</a>
<span class="lineNum">     593 </span>            :  */
<span class="lineNum">     594 </span><span class="lineNoCov">          0 : static void sub_tree_transport_cb(void *data)</span>
<span class="lineNum">     595 </span>            : {
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :         struct sip_subscription_tree *sub_tree = data;</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :         /*
<span class="lineNum">     599 </span>            :          * Push off the subscription termination to the serializer to
<span class="lineNum">     600 </span>            :          * avoid deadlock.  Another thread could be trying to send a
<span class="lineNum">     601 </span>            :          * message on the subscription that can deadlock with this
<span class="lineNum">     602 </span>            :          * thread.
<span class="lineNum">     603 </span>            :          */
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         ao2_ref(sub_tree, +1);</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :         if (ast_sip_push_task(sub_tree-&gt;serializer, sub_tree_subscription_terminate_cb,</span>
<span class="lineNum">     606 </span>            :                 sub_tree)) {
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :                 ao2_ref(sub_tree, -1);</span>
<span class="lineNum">     608 </span>            :         }
<span class="lineNum">     609 </span><span class="lineNoCov">          0 : }</span>
<a name="610"><span class="lineNum">     610 </span>            : </a>
<span class="lineNum">     611 </span>            : /*! \brief Destructor for subscription persistence */
<span class="lineNum">     612 </span><span class="lineCov">         21 : static void subscription_persistence_destroy(void *obj)</span>
<span class="lineNum">     613 </span>            : {
<span class="lineNum">     614 </span><span class="lineCov">         21 :         struct subscription_persistence *persistence = obj;</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span><span class="lineCov">         21 :         ast_free(persistence-&gt;endpoint);</span>
<span class="lineNum">     617 </span><span class="lineCov">         21 :         ast_free(persistence-&gt;tag);</span>
<span class="lineNum">     618 </span><span class="lineCov">         21 : }</span>
<a name="619"><span class="lineNum">     619 </span>            : </a>
<span class="lineNum">     620 </span>            : /*! \brief Allocator for subscription persistence */
<span class="lineNum">     621 </span><span class="lineCov">         77 : static void *subscription_persistence_alloc(const char *name)</span>
<span class="lineNum">     622 </span>            : {
<span class="lineNum">     623 </span><span class="lineCov">         77 :         return ast_sorcery_generic_alloc(sizeof(struct subscription_persistence), subscription_persistence_destroy);</span>
<span class="lineNum">     624 </span>            : }
<a name="625"><span class="lineNum">     625 </span>            : </a>
<span class="lineNum">     626 </span>            : /*! \brief Function which creates initial persistence information of a subscription in sorcery */
<span class="lineNum">     627 </span><span class="lineCov">         76 : static struct subscription_persistence *subscription_persistence_create(struct sip_subscription_tree *sub_tree)</span>
<span class="lineNum">     628 </span><span class="lineCov">         76 : {</span>
<span class="lineNum">     629 </span><span class="lineCov">        152 :         char tag[PJ_GUID_STRING_LENGTH + 1];</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            :         /* The id of this persistence object doesn't matter as we keep it on the subscription and don't need to
<span class="lineNum">     632 </span>            :          * look it up by id at all.
<span class="lineNum">     633 </span>            :          */
<span class="lineNum">     634 </span><span class="lineCov">         76 :         struct subscription_persistence *persistence = ast_sorcery_alloc(ast_sip_get_sorcery(),</span>
<span class="lineNum">     635 </span>            :                 &quot;subscription_persistence&quot;, NULL);
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span><span class="lineCov">         76 :         pjsip_dialog *dlg = sub_tree-&gt;dlg;</span>
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineCov">         76 :         if (!persistence) {</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     641 </span>            :         }
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineCov">         76 :         persistence-&gt;endpoint = ast_strdup(ast_sorcery_object_get_id(sub_tree-&gt;endpoint));</span>
<span class="lineNum">     644 </span><span class="lineCov">         76 :         ast_copy_pj_str(tag, &amp;dlg-&gt;local.info-&gt;tag, sizeof(tag));</span>
<span class="lineNum">     645 </span><span class="lineCov">         76 :         persistence-&gt;tag = ast_strdup(tag);</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineCov">         76 :         ast_sorcery_create(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">     648 </span><span class="lineCov">         76 :         return persistence;</span>
<span class="lineNum">     649 </span>            : }
<a name="650"><span class="lineNum">     650 </span>            : </a>
<span class="lineNum">     651 </span>            : /*! \brief Function which updates persistence information of a subscription in sorcery */
<span class="lineNum">     652 </span><span class="lineCov">        302 : static void subscription_persistence_update(struct sip_subscription_tree *sub_tree,</span>
<span class="lineNum">     653 </span>            :         pjsip_rx_data *rdata, enum sip_persistence_update_type type)
<span class="lineNum">     654 </span>            : {
<span class="lineNum">     655 </span>            :         pjsip_dialog *dlg;
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span><span class="lineCov">        302 :         if (!sub_tree-&gt;persistence) {</span>
<span class="lineNum">     658 </span><span class="lineCov">         21 :                 return;</span>
<span class="lineNum">     659 </span>            :         }
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span><span class="lineCov">        281 :         ast_debug(3, &quot;Updating persistence for '%s-&gt;%s'  prune on boot: %s\n&quot;,</span>
<span class="lineNum">     662 </span>            :                 sub_tree-&gt;persistence-&gt;endpoint, sub_tree-&gt;root-&gt;resource,
<span class="lineNum">     663 </span>            :                 sub_tree-&gt;persistence-&gt;prune_on_boot ? &quot;yes&quot; : &quot;no&quot;);
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span><span class="lineCov">        281 :         dlg = sub_tree-&gt;dlg;</span>
<span class="lineNum">     666 </span><span class="lineCov">        281 :         sub_tree-&gt;persistence-&gt;cseq = dlg-&gt;local.cseq;</span>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineCov">        281 :         if (rdata) {</span>
<span class="lineNum">     669 </span>            :                 int expires;
<span class="lineNum">     670 </span><span class="lineCov">        113 :                 pjsip_expires_hdr *expires_hdr = pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_EXPIRES, NULL);</span>
<span class="lineNum">     671 </span><span class="lineCov">        113 :                 pjsip_contact_hdr *contact_hdr = pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_CONTACT, NULL);</span>
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span><span class="lineCov">        113 :                 expires = expires_hdr ? expires_hdr-&gt;ivalue : DEFAULT_PUBLISH_EXPIRES;</span>
<span class="lineNum">     674 </span><span class="lineCov">        113 :                 sub_tree-&gt;persistence-&gt;expires = ast_tvadd(ast_tvnow(), ast_samp2tv(expires, 1));</span>
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span><span class="lineCov">        113 :                 if (contact_hdr) {</span>
<span class="lineNum">     677 </span><span class="lineCov">        113 :                         if (contact_hdr) {</span>
<span class="lineNum">     678 </span><span class="lineCov">        113 :                                 if (type == SUBSCRIPTION_PERSISTENCE_CREATED) {</span>
<span class="lineNum">     679 </span><span class="lineCov">        152 :                                         sub_tree-&gt;persistence-&gt;prune_on_boot =</span>
<span class="lineNum">     680 </span><span class="lineCov">         76 :                                                 !ast_sip_will_uri_survive_restart(</span>
<span class="lineNum">     681 </span><span class="lineCov">         76 :                                                         (pjsip_sip_uri *)pjsip_uri_get_uri(contact_hdr-&gt;uri),</span>
<span class="lineNum">     682 </span>            :                                                         sub_tree-&gt;endpoint, rdata);
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span><span class="lineCov">         76 :                                         if (sub_tree-&gt;persistence-&gt;prune_on_boot) {</span>
<span class="lineNum">     685 </span><span class="lineCov">          1 :                                                 ast_debug(3, &quot;adding transport monitor on %s for '%s-&gt;%s'  prune on boot: %d\n&quot;,</span>
<span class="lineNum">     686 </span>            :                                                         rdata-&gt;tp_info.transport-&gt;obj_name,
<span class="lineNum">     687 </span>            :                                                         sub_tree-&gt;persistence-&gt;endpoint, sub_tree-&gt;root-&gt;resource,
<span class="lineNum">     688 </span>            :                                                         sub_tree-&gt;persistence-&gt;prune_on_boot);
<span class="lineNum">     689 </span><span class="lineCov">          1 :                                                 sub_tree-&gt;transport = rdata-&gt;tp_info.transport;</span>
<span class="lineNum">     690 </span><span class="lineCov">          1 :                                                 ast_sip_transport_monitor_register(rdata-&gt;tp_info.transport,</span>
<span class="lineNum">     691 </span>            :                                                         sub_tree_transport_cb, sub_tree);
<span class="lineNum">     692 </span>            :                                                 /*
<span class="lineNum">     693 </span>            :                                                  * FYI: ast_sip_transport_monitor_register holds a reference to the sub_tree
<span class="lineNum">     694 </span>            :                                                  */
<span class="lineNum">     695 </span>            :                                         }
<span class="lineNum">     696 </span>            :                                 }
<span class="lineNum">     697 </span>            :                         }
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineCov">        113 :                         pjsip_uri_print(PJSIP_URI_IN_CONTACT_HDR, contact_hdr-&gt;uri,</span>
<span class="lineNum">     700 </span><span class="lineCov">        113 :                                         sub_tree-&gt;persistence-&gt;contact_uri, sizeof(sub_tree-&gt;persistence-&gt;contact_uri));</span>
<span class="lineNum">     701 </span>            :                 } else {
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Contact not updated due to missing contact header\n&quot;);</span>
<span class="lineNum">     703 </span>            :                 }
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            :                 /* When receiving a packet on an streaming transport, it's possible to receive more than one SIP
<span class="lineNum">     706 </span>            :                  * message at a time into the rdata-&gt;pkt_info.packet buffer. However, the rdata-&gt;msg_info.msg_buf
<span class="lineNum">     707 </span>            :                  * will always point to the proper SIP message that is to be processed. When updating subscription
<span class="lineNum">     708 </span>            :                  * persistence that is pulled from persistent storage, though, the rdata-&gt;pkt_info.packet will
<span class="lineNum">     709 </span>            :                  * only ever have a single SIP message on it, and so we base persistence on that.
<span class="lineNum">     710 </span>            :                  */
<span class="lineNum">     711 </span><span class="lineCov">        113 :                 if (type == SUBSCRIPTION_PERSISTENCE_CREATED</span>
<span class="lineNum">     712 </span><span class="lineCov">         37 :                         || type == SUBSCRIPTION_PERSISTENCE_RECREATED) {</span>
<span class="lineNum">     713 </span><span class="lineCov">         77 :                         if (rdata-&gt;msg_info.msg_buf) {</span>
<span class="lineNum">     714 </span><span class="lineCov">         76 :                                 ast_copy_string(sub_tree-&gt;persistence-&gt;packet, rdata-&gt;msg_info.msg_buf,</span>
<span class="lineNum">     715 </span><span class="lineCov">         76 :                                                 MIN(sizeof(sub_tree-&gt;persistence-&gt;packet), rdata-&gt;msg_info.len));</span>
<span class="lineNum">     716 </span>            :                         } else {
<span class="lineNum">     717 </span><span class="lineCov">          1 :                                 ast_copy_string(sub_tree-&gt;persistence-&gt;packet, rdata-&gt;pkt_info.packet,</span>
<span class="lineNum">     718 </span>            :                                                 sizeof(sub_tree-&gt;persistence-&gt;packet));
<span class="lineNum">     719 </span>            :                         }
<span class="lineNum">     720 </span>            :                 }
<span class="lineNum">     721 </span><span class="lineCov">        113 :                 ast_copy_string(sub_tree-&gt;persistence-&gt;src_name, rdata-&gt;pkt_info.src_name,</span>
<span class="lineNum">     722 </span>            :                                 sizeof(sub_tree-&gt;persistence-&gt;src_name));
<span class="lineNum">     723 </span><span class="lineCov">        113 :                 sub_tree-&gt;persistence-&gt;src_port = rdata-&gt;pkt_info.src_port;</span>
<span class="lineNum">     724 </span><span class="lineCov">        113 :                 ast_copy_string(sub_tree-&gt;persistence-&gt;transport_key, rdata-&gt;tp_info.transport-&gt;type_name,</span>
<span class="lineNum">     725 </span>            :                         sizeof(sub_tree-&gt;persistence-&gt;transport_key));
<span class="lineNum">     726 </span><span class="lineCov">        113 :                 ast_copy_pj_str(sub_tree-&gt;persistence-&gt;local_name, &amp;rdata-&gt;tp_info.transport-&gt;local_name.host,</span>
<span class="lineNum">     727 </span>            :                         sizeof(sub_tree-&gt;persistence-&gt;local_name));
<span class="lineNum">     728 </span><span class="lineCov">        113 :                 sub_tree-&gt;persistence-&gt;local_port = rdata-&gt;tp_info.transport-&gt;local_name.port;</span>
<span class="lineNum">     729 </span>            :         }
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span><span class="lineCov">        281 :         ast_sorcery_update(ast_sip_get_sorcery(), sub_tree-&gt;persistence);</span>
<span class="lineNum">     732 </span>            : }
<a name="733"><span class="lineNum">     733 </span>            : </a>
<span class="lineNum">     734 </span>            : /*! \brief Function which removes persistence of a subscription from sorcery */
<span class="lineNum">     735 </span><span class="lineCov">         21 : static void subscription_persistence_remove(struct sip_subscription_tree *sub_tree)</span>
<span class="lineNum">     736 </span>            : {
<span class="lineNum">     737 </span><span class="lineCov">         21 :         if (!sub_tree-&gt;persistence) {</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     739 </span>            :         }
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineCov">         21 :         if (sub_tree-&gt;persistence-&gt;prune_on_boot &amp;&amp; sub_tree-&gt;transport) {</span>
<span class="lineNum">     742 </span><span class="lineCov">          1 :                 ast_debug(3, &quot;Unregistering transport monitor on %s '%s-&gt;%s'\n&quot;,</span>
<span class="lineNum">     743 </span>            :                         sub_tree-&gt;transport-&gt;obj_name,
<span class="lineNum">     744 </span>            :                         sub_tree-&gt;endpoint ? ast_sorcery_object_get_id(sub_tree-&gt;endpoint) : &quot;Unknown&quot;,
<span class="lineNum">     745 </span>            :                         sub_tree-&gt;root ? sub_tree-&gt;root-&gt;resource : &quot;Unknown&quot;);
<span class="lineNum">     746 </span><span class="lineCov">          1 :                 ast_sip_transport_monitor_unregister(sub_tree-&gt;transport,</span>
<span class="lineNum">     747 </span>            :                         sub_tree_transport_cb, sub_tree, NULL);
<span class="lineNum">     748 </span>            :         }
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineCov">         21 :         ast_sorcery_delete(ast_sip_get_sorcery(), sub_tree-&gt;persistence);</span>
<span class="lineNum">     751 </span><span class="lineCov">         21 :         ao2_ref(sub_tree-&gt;persistence, -1);</span>
<span class="lineNum">     752 </span><span class="lineCov">         21 :         sub_tree-&gt;persistence = NULL;</span>
<span class="lineNum">     753 </span>            : }
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            : static struct ast_sip_subscription_handler *find_sub_handler_for_event_name(const char *event_name);
<span class="lineNum">     757 </span>            : static struct ast_sip_pubsub_body_generator *find_body_generator(char accept[AST_SIP_MAX_ACCEPT][64],
<span class="lineNum">     758 </span>            :                 size_t num_accept, const char *body_type);
<a name="759"><span class="lineNum">     759 </span>            : </a>
<span class="lineNum">     760 </span>            : /*! \brief Retrieve a handler using the Event header of an rdata message */
<span class="lineNum">     761 </span><span class="lineCov">         94 : static struct ast_sip_subscription_handler *subscription_get_handler_from_rdata(pjsip_rx_data *rdata)</span>
<span class="lineNum">     762 </span>            : {
<span class="lineNum">     763 </span>            :         pjsip_event_hdr *event_header;
<span class="lineNum">     764 </span>            :         char event[32];
<span class="lineNum">     765 </span>            :         struct ast_sip_subscription_handler *handler;
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span><span class="lineCov">         94 :         event_header = pjsip_msg_find_hdr_by_name(rdata-&gt;msg_info.msg, &amp;str_event_name, rdata-&gt;msg_info.msg-&gt;hdr.next);</span>
<span class="lineNum">     768 </span><span class="lineCov">         94 :         if (!event_header) {</span>
<span class="lineNum">     769 </span><span class="lineCov">          1 :                 ast_log(LOG_WARNING, &quot;Incoming SUBSCRIBE request with no Event header\n&quot;);</span>
<span class="lineNum">     770 </span><span class="lineCov">          1 :                 return NULL;</span>
<span class="lineNum">     771 </span>            :         }
<span class="lineNum">     772 </span><span class="lineCov">         93 :         ast_copy_pj_str(event, &amp;event_header-&gt;event_type, sizeof(event));</span>
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span><span class="lineCov">         93 :         handler = find_sub_handler_for_event_name(event);</span>
<span class="lineNum">     775 </span><span class="lineCov">         93 :         if (!handler) {</span>
<span class="lineNum">     776 </span><span class="lineCov">          1 :                 ast_log(LOG_WARNING, &quot;No registered subscribe handler for event %s\n&quot;, event);</span>
<span class="lineNum">     777 </span>            :         }
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span><span class="lineCov">         93 :         return handler;</span>
<span class="lineNum">     780 </span>            : }
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            : /*!
<span class="lineNum">     783 </span>            :  * \brief Accept headers that are exceptions to the rule
<span class="lineNum">     784 </span>            :  *
<span class="lineNum">     785 </span>            :  * Typically, when a SUBSCRIBE arrives, we attempt to find a
<span class="lineNum">     786 </span>            :  * body generator that matches one of the Accept headers in
<span class="lineNum">     787 </span>            :  * the request. When subscribing to a single resource, this works
<span class="lineNum">     788 </span>            :  * great. However, when subscribing to a list, things work
<span class="lineNum">     789 </span>            :  * differently. Most Accept header values are fine, but there
<span class="lineNum">     790 </span>            :  * are a couple that are endemic to resource lists that need
<span class="lineNum">     791 </span>            :  * to be ignored when searching for a body generator to use
<span class="lineNum">     792 </span>            :  * for the individual resources of the subscription.
<span class="lineNum">     793 </span>            :  */
<span class="lineNum">     794 </span>            : const char *accept_exceptions[] =  {
<span class="lineNum">     795 </span>            :         &quot;multipart/related&quot;,
<span class="lineNum">     796 </span>            :         &quot;application/rlmi+xml&quot;,
<span class="lineNum">     797 </span>            : };
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            : /*!
<span class="lineNum">     800 </span>            :  * \brief Is the Accept header from the SUBSCRIBE in the list of exceptions?
<span class="lineNum">     801 </span>            :  *
<span class="lineNum">     802 </span>            :  * \retval 1 This Accept header value is an exception to the rule.
<a name="803"><span class="lineNum">     803 </span>            :  * \retval 0 This Accept header is not an exception to the rule.</a>
<span class="lineNum">     804 </span>            :  */
<span class="lineNum">     805 </span><span class="lineCov">        245 : static int exceptional_accept(const pj_str_t *accept)</span>
<span class="lineNum">     806 </span>            : {
<span class="lineNum">     807 </span>            :         int i;
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span><span class="lineCov">        558 :         for (i = 0; i &lt; ARRAY_LEN(accept_exceptions); ++i) {</span>
<span class="lineNum">     810 </span><span class="lineCov">        431 :                 if (!pj_strcmp2(accept, accept_exceptions[i])) {</span>
<span class="lineNum">     811 </span><span class="lineCov">        118 :                         return 1;</span>
<span class="lineNum">     812 </span>            :                 }
<span class="lineNum">     813 </span>            :         }
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span><span class="lineCov">        127 :         return 0;</span>
<span class="lineNum">     816 </span>            : }
<a name="817"><span class="lineNum">     817 </span>            : </a>
<span class="lineNum">     818 </span>            : /*! \brief Retrieve a body generator using the Accept header of an rdata message */
<span class="lineNum">     819 </span><span class="lineCov">         92 : static struct ast_sip_pubsub_body_generator *subscription_get_generator_from_rdata(pjsip_rx_data *rdata,</span>
<span class="lineNum">     820 </span>            :         const struct ast_sip_subscription_handler *handler)
<span class="lineNum">     821 </span>            : {
<span class="lineNum">     822 </span><span class="lineCov">         92 :         pjsip_accept_hdr *accept_header = (pjsip_accept_hdr *) &amp;rdata-&gt;msg_info.msg-&gt;hdr;</span>
<span class="lineNum">     823 </span>            :         char accept[AST_SIP_MAX_ACCEPT][64];
<span class="lineNum">     824 </span><span class="lineCov">         92 :         size_t num_accept_headers = 0;</span>
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span><span class="lineCov">        330 :         while ((accept_header = pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_ACCEPT, accept_header-&gt;next)) &amp;&amp;</span>
<span class="lineNum">     827 </span>            :                 (num_accept_headers &lt; AST_SIP_MAX_ACCEPT)) {
<span class="lineNum">     828 </span>            :                 int i;
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineCov">        483 :                 for (i = 0; i &lt; accept_header-&gt;count &amp;&amp; num_accept_headers &lt; AST_SIP_MAX_ACCEPT; ++i) {</span>
<span class="lineNum">     831 </span><span class="lineCov">        245 :                         if (!exceptional_accept(&amp;accept_header-&gt;values[i])) {</span>
<span class="lineNum">     832 </span><span class="lineCov">        127 :                                 ast_copy_pj_str(accept[num_accept_headers], &amp;accept_header-&gt;values[i], sizeof(accept[num_accept_headers]));</span>
<span class="lineNum">     833 </span><span class="lineCov">        127 :                                 ++num_accept_headers;</span>
<span class="lineNum">     834 </span>            :                         }
<span class="lineNum">     835 </span>            :                 }
<span class="lineNum">     836 </span>            :         }
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span><span class="lineCov">         92 :         if (num_accept_headers == 0) {</span>
<span class="lineNum">     839 </span>            :                 /* If a SUBSCRIBE contains no Accept headers, then we must assume that
<span class="lineNum">     840 </span>            :                  * the default accept type for the event package is to be used.
<span class="lineNum">     841 </span>            :                  */
<span class="lineNum">     842 </span><span class="lineCov">          3 :                 ast_copy_string(accept[0], handler-&gt;notifier-&gt;default_accept, sizeof(accept[0]));</span>
<span class="lineNum">     843 </span><span class="lineCov">          3 :                 num_accept_headers = 1;</span>
<span class="lineNum">     844 </span>            :         }
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span><span class="lineCov">         92 :         return find_body_generator(accept, num_accept_headers, handler-&gt;body_type);</span>
<span class="lineNum">     847 </span>            : }
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            : /*! \brief Check if the rdata has a Supported header containing 'eventlist'
<span class="lineNum">     850 </span>            :  *
<span class="lineNum">     851 </span>            :  *  \retval 1 rdata has an eventlist containing supported header
<a name="852"><span class="lineNum">     852 </span>            :  *  \retval 0 rdata doesn't have an eventlist containing supported header</a>
<span class="lineNum">     853 </span>            :  */
<span class="lineNum">     854 </span><span class="lineCov">         85 : static int ast_sip_pubsub_has_eventlist_support(pjsip_rx_data *rdata)</span>
<span class="lineNum">     855 </span>            : {
<span class="lineNum">     856 </span><span class="lineCov">         85 :         pjsip_supported_hdr *supported_header = (pjsip_supported_hdr *) &amp;rdata-&gt;msg_info.msg-&gt;hdr;</span>
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span><span class="lineCov">         92 :         while ((supported_header = pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_SUPPORTED, supported_header-&gt;next))) {</span>
<span class="lineNum">     859 </span>            :                 int i;
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineCov">         90 :                 for (i = 0; i &lt; supported_header-&gt;count; i++) {</span>
<span class="lineNum">     862 </span><span class="lineCov">         83 :                         if (!pj_stricmp2(&amp;supported_header-&gt;values[i], &quot;eventlist&quot;)) {</span>
<span class="lineNum">     863 </span><span class="lineCov">         55 :                                 return 1;</span>
<span class="lineNum">     864 </span>            :                         }
<span class="lineNum">     865 </span>            :                 }
<span class="lineNum">     866 </span>            :         }
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineCov">         30 :         return 0;</span>
<span class="lineNum">     869 </span>            : }
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            : struct resource_tree;
<span class="lineNum">     872 </span>            : 
<span class="lineNum">     873 </span>            : /*!
<span class="lineNum">     874 </span>            :  * \brief A node for a resource tree.
<span class="lineNum">     875 </span>            :  */
<span class="lineNum">     876 </span>            : struct tree_node {
<span class="lineNum">     877 </span>            :         AST_VECTOR(, struct tree_node *) children;
<span class="lineNum">     878 </span>            :         unsigned int full_state;
<span class="lineNum">     879 </span>            :         char resource[0];
<span class="lineNum">     880 </span>            : };
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span>            : /*!
<span class="lineNum">     883 </span>            :  * \brief Helper function for retrieving a resource list for a given event.
<span class="lineNum">     884 </span>            :  *
<span class="lineNum">     885 </span>            :  * This will retrieve a resource list that corresponds to the resource and event provided.
<span class="lineNum">     886 </span>            :  *
<span class="lineNum">     887 </span>            :  * \param resource The name of the resource list to retrieve
<a name="888"><span class="lineNum">     888 </span>            :  * \param event The expected event name on the resource list</a>
<span class="lineNum">     889 </span>            :  */
<span class="lineNum">     890 </span><span class="lineCov">        254 : static struct resource_list *retrieve_resource_list(const char *resource, const char *event)</span>
<span class="lineNum">     891 </span>            : {
<span class="lineNum">     892 </span>            :         struct resource_list *list;
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineCov">        254 :         list = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), &quot;resource_list&quot;, resource);</span>
<span class="lineNum">     895 </span><span class="lineCov">        254 :         if (!list) {</span>
<span class="lineNum">     896 </span><span class="lineCov">        170 :                 return NULL;</span>
<span class="lineNum">     897 </span>            :         }
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineCov">         84 :         if (strcmp(list-&gt;event, event)) {</span>
<span class="lineNum">     900 </span><span class="lineCov">          1 :                 ast_log(LOG_WARNING, &quot;Found resource list %s, but its event type (%s) does not match SUBSCRIBE's (%s)\n&quot;,</span>
<span class="lineNum">     901 </span><span class="lineCov">          1 :                                 resource, list-&gt;event, event);</span>
<span class="lineNum">     902 </span><span class="lineCov">          1 :                 ao2_cleanup(list);</span>
<span class="lineNum">     903 </span><span class="lineCov">          1 :                 return NULL;</span>
<span class="lineNum">     904 </span>            :         }
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineCov">         83 :         return list;</span>
<span class="lineNum">     907 </span>            : }
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            : /*!
<span class="lineNum">     910 </span>            :  * \brief Allocate a tree node
<span class="lineNum">     911 </span>            :  *
<span class="lineNum">     912 </span>            :  * In addition to allocating and initializing the tree node, the node is also added
<span class="lineNum">     913 </span>            :  * to the vector of visited resources. See \ref build_resource_tree for more information
<span class="lineNum">     914 </span>            :  * on the visited resources.
<span class="lineNum">     915 </span>            :  *
<span class="lineNum">     916 </span>            :  * \param resource The name of the resource for this tree node.
<span class="lineNum">     917 </span>            :  * \param visited The vector of resources that have been visited.
<span class="lineNum">     918 </span>            :  * \param if allocating a list, indicate whether full state is requested in notifications.
<span class="lineNum">     919 </span>            :  * \retval NULL Allocation failure.
<a name="920"><span class="lineNum">     920 </span>            :  * \retval non-NULL The newly-allocated tree_node</a>
<span class="lineNum">     921 </span>            :  */
<span class="lineNum">     922 </span><span class="lineCov">        274 : static struct tree_node *tree_node_alloc(const char *resource, struct resources *visited, unsigned int full_state)</span>
<span class="lineNum">     923 </span>            : {
<span class="lineNum">     924 </span>            :         struct tree_node *node;
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span><span class="lineCov">        274 :         node = ast_calloc(1, sizeof(*node) + strlen(resource) + 1);</span>
<span class="lineNum">     927 </span><span class="lineCov">        274 :         if (!node) {</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     929 </span>            :         }
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineCov">        274 :         strcpy(node-&gt;resource, resource);</span>
<span class="lineNum">     932 </span><span class="lineCov">        274 :         if (AST_VECTOR_INIT(&amp;node-&gt;children, 4)) {</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :                 ast_free(node);</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     935 </span>            :         }
<span class="lineNum">     936 </span><span class="lineCov">        274 :         node-&gt;full_state = full_state;</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineCov">        274 :         if (visited) {</span>
<span class="lineNum">     939 </span><span class="lineCov">        239 :                 AST_VECTOR_APPEND(visited, resource);</span>
<span class="lineNum">     940 </span>            :         }
<span class="lineNum">     941 </span><span class="lineCov">        274 :         return node;</span>
<span class="lineNum">     942 </span>            : }
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span>            : /*!
<span class="lineNum">     945 </span>            :  * \brief Destructor for a tree node
<span class="lineNum">     946 </span>            :  *
<span class="lineNum">     947 </span>            :  * This function calls recursively in order to destroy
<span class="lineNum">     948 </span>            :  * all nodes lower in the tree from the given node in
<span class="lineNum">     949 </span>            :  * addition to the node itself.
<span class="lineNum">     950 </span>            :  *
<a name="951"><span class="lineNum">     951 </span>            :  * \param node The node to destroy.</a>
<span class="lineNum">     952 </span>            :  */
<span class="lineNum">     953 </span><span class="lineCov">        274 : static void tree_node_destroy(struct tree_node *node)</span>
<span class="lineNum">     954 </span>            : {
<span class="lineNum">     955 </span>            :         int i;
<span class="lineNum">     956 </span><span class="lineCov">        274 :         if (!node) {</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     958 </span>            :         }
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineCov">        454 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;node-&gt;children); ++i) {</span>
<span class="lineNum">     961 </span><span class="lineCov">        180 :                 tree_node_destroy(AST_VECTOR_GET(&amp;node-&gt;children, i));</span>
<span class="lineNum">     962 </span>            :         }
<span class="lineNum">     963 </span><span class="lineCov">        274 :         AST_VECTOR_FREE(&amp;node-&gt;children);</span>
<span class="lineNum">     964 </span><span class="lineCov">        274 :         ast_free(node);</span>
<span class="lineNum">     965 </span>            : }
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            : /*!
<span class="lineNum">     968 </span>            :  * \brief Determine if this resource has been visited already
<span class="lineNum">     969 </span>            :  *
<span class="lineNum">     970 </span>            :  * See \ref build_resource_tree for more information
<span class="lineNum">     971 </span>            :  *
<span class="lineNum">     972 </span>            :  * \param resource The resource currently being visited
<a name="973"><span class="lineNum">     973 </span>            :  * \param visited The resources that have previously been visited</a>
<span class="lineNum">     974 </span>            :  */
<span class="lineNum">     975 </span><span class="lineCov">        198 : static int have_visited(const char *resource, struct resources *visited)</span>
<span class="lineNum">     976 </span>            : {
<span class="lineNum">     977 </span>            :         int i;
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span><span class="lineCov">        869 :         for (i = 0; i &lt; AST_VECTOR_SIZE(visited); ++i) {</span>
<span class="lineNum">     980 </span><span class="lineCov">        677 :                 if (!strcmp(resource, AST_VECTOR_GET(visited, i))) {</span>
<span class="lineNum">     981 </span><span class="lineCov">          6 :                         return 1;</span>
<span class="lineNum">     982 </span>            :                 }
<span class="lineNum">     983 </span>            :         }
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span><span class="lineCov">        192 :         return 0;</span>
<span class="lineNum">     986 </span>            : }
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span>            : /*!
<span class="lineNum">     989 </span>            :  * \brief Build child nodes for a given parent.
<span class="lineNum">     990 </span>            :  *
<span class="lineNum">     991 </span>            :  * This iterates through the items on a resource list and creates tree nodes for each one. The
<span class="lineNum">     992 </span>            :  * tree nodes created are children of the supplied parent node. If an item in the resource
<span class="lineNum">     993 </span>            :  * list is itself a list, then this function is called recursively to provide children for
<span class="lineNum">     994 </span>            :  * the new node.
<span class="lineNum">     995 </span>            :  *
<span class="lineNum">     996 </span>            :  * If an item in a resource list is not a list, then the supplied subscription handler is
<span class="lineNum">     997 </span>            :  * called into as if a new SUBSCRIBE for the list item were presented. The handler's response
<span class="lineNum">     998 </span>            :  * is used to determine if the node can be added to the tree or not.
<span class="lineNum">     999 </span>            :  *
<span class="lineNum">    1000 </span>            :  * If a parent node ends up having no child nodes added under it, then the parent node is
<span class="lineNum">    1001 </span>            :  * pruned from the tree.
<span class="lineNum">    1002 </span>            :  *
<span class="lineNum">    1003 </span>            :  * \param endpoint The endpoint that sent the inbound SUBSCRIBE.
<span class="lineNum">    1004 </span>            :  * \param handler The subscription handler for leaf nodes in the tree.
<span class="lineNum">    1005 </span>            :  * \param list The configured resource list from which the child node is being built.
<span class="lineNum">    1006 </span>            :  * \param parent The parent node for these children.
<a name="1007"><span class="lineNum">    1007 </span>            :  * \param visited The resources that have already been visited.</a>
<span class="lineNum">    1008 </span>            :  */
<span class="lineNum">    1009 </span><span class="lineCov">         83 : static void build_node_children(struct ast_sip_endpoint *endpoint, const struct ast_sip_subscription_handler *handler,</span>
<span class="lineNum">    1010 </span>            :                 struct resource_list *list, struct tree_node *parent, struct resources *visited)
<span class="lineNum">    1011 </span>            : {
<span class="lineNum">    1012 </span>            :         int i;
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span><span class="lineCov">        281 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;list-&gt;items); ++i) {</span>
<span class="lineNum">    1015 </span>            :                 struct tree_node *current;
<span class="lineNum">    1016 </span>            :                 struct resource_list *child_list;
<span class="lineNum">    1017 </span><span class="lineCov">        198 :                 const char *resource = AST_VECTOR_GET(&amp;list-&gt;items, i);</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span><span class="lineCov">        198 :                 if (have_visited(resource, visited)) {</span>
<span class="lineNum">    1020 </span><span class="lineCov">          6 :                         ast_debug(1, &quot;Already visited resource %s. Avoiding duplicate resource or potential loop.\n&quot;, resource);</span>
<span class="lineNum">    1021 </span><span class="lineCov">          6 :                         continue;</span>
<span class="lineNum">    1022 </span>            :                 }
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span><span class="lineCov">        192 :                 child_list = retrieve_resource_list(resource, list-&gt;event);</span>
<span class="lineNum">    1025 </span><span class="lineCov">        192 :                 if (!child_list) {</span>
<span class="lineNum">    1026 </span><span class="lineCov">        166 :                         int resp = handler-&gt;notifier-&gt;new_subscribe(endpoint, resource);</span>
<span class="lineNum">    1027 </span><span class="lineCov">        166 :                         if (PJSIP_IS_STATUS_IN_CLASS(resp, 200)) {</span>
<span class="lineNum">    1028 </span><span class="lineCov">        156 :                                 current = tree_node_alloc(resource, visited, 0);</span>
<span class="lineNum">    1029 </span><span class="lineCov">        156 :                                 if (!current) {</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :                                         ast_debug(1,</span>
<span class="lineNum">    1031 </span>            :                                                 &quot;Subscription to leaf resource %s was successful, but encountered allocation error afterwards\n&quot;,
<span class="lineNum">    1032 </span>            :                                                 resource);
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    1034 </span>            :                                 }
<span class="lineNum">    1035 </span><span class="lineCov">        156 :                                 ast_debug(2, &quot;Subscription to leaf resource %s resulted in success. Adding to parent %s\n&quot;,</span>
<span class="lineNum">    1036 </span>            :                                                 resource, parent-&gt;resource);
<span class="lineNum">    1037 </span><span class="lineCov">        156 :                                 if (AST_VECTOR_APPEND(&amp;parent-&gt;children, current)) {</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :                                         tree_node_destroy(current);</span>
<span class="lineNum">    1039 </span>            :                                 }
<span class="lineNum">    1040 </span>            :                         } else {
<span class="lineNum">    1041 </span><span class="lineCov">         10 :                                 ast_debug(2, &quot;Subscription to leaf resource %s resulted in error response %d\n&quot;,</span>
<span class="lineNum">    1042 </span>            :                                                 resource, resp);
<span class="lineNum">    1043 </span>            :                         }
<span class="lineNum">    1044 </span>            :                 } else {
<span class="lineNum">    1045 </span><span class="lineCov">         26 :                         ast_debug(2, &quot;Resource %s (child of %s) is a list\n&quot;, resource, parent-&gt;resource);</span>
<span class="lineNum">    1046 </span><span class="lineCov">         26 :                         current = tree_node_alloc(resource, visited, child_list-&gt;full_state);</span>
<span class="lineNum">    1047 </span><span class="lineCov">         26 :                         if (!current) {</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :                                 ast_debug(1, &quot;Cannot build children of resource %s due to allocation failure\n&quot;, resource);</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    1050 </span>            :                         }
<span class="lineNum">    1051 </span><span class="lineCov">         26 :                         build_node_children(endpoint, handler, child_list, current, visited);</span>
<span class="lineNum">    1052 </span><span class="lineCov">         26 :                         if (AST_VECTOR_SIZE(&amp;current-&gt;children) &gt; 0) {</span>
<span class="lineNum">    1053 </span><span class="lineCov">         24 :                                 ast_debug(1, &quot;List %s had no successful children.\n&quot;, resource);</span>
<span class="lineNum">    1054 </span><span class="lineCov">         24 :                                 if (AST_VECTOR_APPEND(&amp;parent-&gt;children, current)) {</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :                                         tree_node_destroy(current);</span>
<span class="lineNum">    1056 </span>            :                                 }
<span class="lineNum">    1057 </span>            :                         } else {
<span class="lineNum">    1058 </span><span class="lineCov">          2 :                                 ast_debug(2, &quot;List %s had successful children. Adding to parent %s\n&quot;,</span>
<span class="lineNum">    1059 </span>            :                                                 resource, parent-&gt;resource);
<span class="lineNum">    1060 </span><span class="lineCov">          2 :                                 tree_node_destroy(current);</span>
<span class="lineNum">    1061 </span>            :                         }
<span class="lineNum">    1062 </span><span class="lineCov">         26 :                         ao2_cleanup(child_list);</span>
<span class="lineNum">    1063 </span>            :                 }
<span class="lineNum">    1064 </span>            :         }
<span class="lineNum">    1065 </span><span class="lineCov">         83 : }</span>
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            : /*!
<span class="lineNum">    1068 </span>            :  * \brief A resource tree
<span class="lineNum">    1069 </span>            :  *
<span class="lineNum">    1070 </span>            :  * When an inbound SUBSCRIBE arrives, the resource being subscribed to may
<span class="lineNum">    1071 </span>            :  * be a resource list. If this is the case, the resource list may contain resources
<span class="lineNum">    1072 </span>            :  * that are themselves lists. The structure needed to hold the resources is
<span class="lineNum">    1073 </span>            :  * a tree.
<span class="lineNum">    1074 </span>            :  *
<span class="lineNum">    1075 </span>            :  * Upon receipt of the SUBSCRIBE, the tree is built by determining if subscriptions
<span class="lineNum">    1076 </span>            :  * to the individual resources in the tree would be successful or not. Any successful
<span class="lineNum">    1077 </span>            :  * subscriptions result in a node in the tree being created. Any unsuccessful subscriptions
<span class="lineNum">    1078 </span>            :  * result in no node being created.
<span class="lineNum">    1079 </span>            :  *
<span class="lineNum">    1080 </span>            :  * This tree can be seen as a bare-bones analog of the tree of ast_sip_subscriptions that
<span class="lineNum">    1081 </span>            :  * will end up being created to actually carry out the duties of a SIP SUBSCRIBE dialog.
<span class="lineNum">    1082 </span>            :  */
<span class="lineNum">    1083 </span>            : struct resource_tree {
<span class="lineNum">    1084 </span>            :         struct tree_node *root;
<span class="lineNum">    1085 </span>            :         unsigned int notification_batch_interval;
<span class="lineNum">    1086 </span>            : };
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span>            : /*!
<span class="lineNum">    1089 </span>            :  * \brief Destroy a resource tree.
<span class="lineNum">    1090 </span>            :  *
<span class="lineNum">    1091 </span>            :  * This function makes no assumptions about how the tree itself was
<span class="lineNum">    1092 </span>            :  * allocated and does not attempt to free the tree itself. Callers
<span class="lineNum">    1093 </span>            :  * of this function are responsible for freeing the tree.
<span class="lineNum">    1094 </span>            :  *
<a name="1095"><span class="lineNum">    1095 </span>            :  * \param tree The tree to destroy.</a>
<span class="lineNum">    1096 </span>            :  */
<span class="lineNum">    1097 </span><span class="lineCov">       6056 : static void resource_tree_destroy(struct resource_tree *tree)</span>
<span class="lineNum">    1098 </span>            : {
<span class="lineNum">    1099 </span><span class="lineCov">       6056 :         if (tree) {</span>
<span class="lineNum">    1100 </span><span class="lineCov">         92 :                 tree_node_destroy(tree-&gt;root);</span>
<span class="lineNum">    1101 </span>            :         }
<span class="lineNum">    1102 </span><span class="lineCov">       6056 : }</span>
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span>            : /*!
<span class="lineNum">    1105 </span>            :  * \brief Build a resource tree
<span class="lineNum">    1106 </span>            :  *
<span class="lineNum">    1107 </span>            :  * This function builds a resource tree based on the requested resource in a SUBSCRIBE request.
<span class="lineNum">    1108 </span>            :  *
<span class="lineNum">    1109 </span>            :  * This function also creates a container that has all resources that have been visited during
<span class="lineNum">    1110 </span>            :  * creation of the tree, whether those resources resulted in a tree node being created or not.
<span class="lineNum">    1111 </span>            :  * Keeping this container of visited resources allows for misconfigurations such as loops in
<span class="lineNum">    1112 </span>            :  * the tree or duplicated resources to be detected.
<span class="lineNum">    1113 </span>            :  *
<span class="lineNum">    1114 </span>            :  * \param endpoint The endpoint that sent the SUBSCRIBE request.
<span class="lineNum">    1115 </span>            :  * \param handler The subscription handler for leaf nodes in the tree.
<span class="lineNum">    1116 </span>            :  * \param resource The resource requested in the SUBSCRIBE request.
<span class="lineNum">    1117 </span>            :  * \param tree The tree that is to be built.
<span class="lineNum">    1118 </span>            :  * \param has_eventlist_support
<span class="lineNum">    1119 </span>            :  *
<span class="lineNum">    1120 </span>            :  * \retval 200-299 Successfully subscribed to at least one resource.
<a name="1121"><span class="lineNum">    1121 </span>            :  * \retval 300-699 Failure to subscribe to requested resource.</a>
<span class="lineNum">    1122 </span>            :  */
<span class="lineNum">    1123 </span><span class="lineCov">         92 : static int build_resource_tree(struct ast_sip_endpoint *endpoint, const struct ast_sip_subscription_handler *handler,</span>
<a name="1124"><span class="lineNum">    1124 </span>            :                 const char *resource, struct resource_tree *tree, int has_eventlist_support)</a>
<span class="lineNum">    1125 </span>            : {
<span class="lineNum">    1126 </span><span class="lineCov">        184 :         RAII_VAR(struct resource_list *, list, NULL, ao2_cleanup);</span>
<span class="lineNum">    1127 </span>            :         struct resources visited;
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span><span class="lineCov">         92 :         if (!has_eventlist_support || !(list = retrieve_resource_list(resource, handler-&gt;event_name))) {</span>
<span class="lineNum">    1130 </span><span class="lineCov">         35 :                 ast_debug(2, &quot;Subscription '%s-&gt;%s' is not to a list\n&quot;,</span>
<span class="lineNum">    1131 </span>            :                         ast_sorcery_object_get_id(endpoint), resource);
<span class="lineNum">    1132 </span><span class="lineCov">         35 :                 tree-&gt;root = tree_node_alloc(resource, NULL, 0);</span>
<span class="lineNum">    1133 </span><span class="lineCov">         35 :                 if (!tree-&gt;root) {</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :                         return 500;</span>
<span class="lineNum">    1135 </span>            :                 }
<span class="lineNum">    1136 </span><span class="lineCov">         35 :                 return handler-&gt;notifier-&gt;new_subscribe(endpoint, resource);</span>
<span class="lineNum">    1137 </span>            :         }
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span><span class="lineCov">         57 :         ast_debug(2, &quot;Subscription '%s-&gt;%s' is a list\n&quot;,</span>
<span class="lineNum">    1140 </span>            :                 ast_sorcery_object_get_id(endpoint), resource);
<span class="lineNum">    1141 </span><span class="lineCov">         57 :         if (AST_VECTOR_INIT(&amp;visited, AST_VECTOR_SIZE(&amp;list-&gt;items))) {</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                 return 500;</span>
<span class="lineNum">    1143 </span>            :         }
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span><span class="lineCov">         57 :         tree-&gt;root = tree_node_alloc(resource, &amp;visited, list-&gt;full_state);</span>
<span class="lineNum">    1146 </span><span class="lineCov">         57 :         if (!tree-&gt;root) {</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :                 AST_VECTOR_FREE(&amp;visited);</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :                 return 500;</span>
<span class="lineNum">    1149 </span>            :         }
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span><span class="lineCov">         57 :         tree-&gt;notification_batch_interval = list-&gt;notification_batch_interval;</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span><span class="lineCov">         57 :         build_node_children(endpoint, handler, list, tree-&gt;root, &amp;visited);</span>
<span class="lineNum">    1154 </span><span class="lineCov">         57 :         AST_VECTOR_FREE(&amp;visited);</span>
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span><span class="lineCov">         57 :         if (AST_VECTOR_SIZE(&amp;tree-&gt;root-&gt;children) &gt; 0) {</span>
<span class="lineNum">    1157 </span><span class="lineCov">         54 :                 return 200;</span>
<span class="lineNum">    1158 </span>            :         } else {
<span class="lineNum">    1159 </span><span class="lineCov">          3 :                 return 500;</span>
<span class="lineNum">    1160 </span>            :         }
<a name="1161"><span class="lineNum">    1161 </span>            : }</a>
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span><span class="lineCov">         77 : static void add_subscription(struct sip_subscription_tree *obj)</span>
<span class="lineNum">    1164 </span>            : {
<span class="lineNum">    1165 </span><span class="lineCov">         77 :         AST_RWLIST_WRLOCK(&amp;subscriptions);</span>
<span class="lineNum">    1166 </span><span class="lineCov">         77 :         AST_RWLIST_INSERT_TAIL(&amp;subscriptions, obj, next);</span>
<span class="lineNum">    1167 </span><span class="lineCov">         77 :         AST_RWLIST_UNLOCK(&amp;subscriptions);</span>
<a name="1168"><span class="lineNum">    1168 </span><span class="lineCov">         77 : }</span></a>
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span><span class="lineCov">         21 : static void remove_subscription(struct sip_subscription_tree *obj)</span>
<span class="lineNum">    1171 </span>            : {
<span class="lineNum">    1172 </span>            :         struct sip_subscription_tree *i;
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span><span class="lineCov">         21 :         AST_RWLIST_WRLOCK(&amp;subscriptions);</span>
<span class="lineNum">    1175 </span><span class="lineCov">         21 :         AST_RWLIST_TRAVERSE_SAFE_BEGIN(&amp;subscriptions, i, next) {</span>
<span class="lineNum">    1176 </span><span class="lineCov">         21 :                 if (i == obj) {</span>
<span class="lineNum">    1177 </span><span class="lineCov">         21 :                         AST_RWLIST_REMOVE_CURRENT(next);</span>
<span class="lineNum">    1178 </span><span class="lineCov">         21 :                         if (i-&gt;root) {</span>
<span class="lineNum">    1179 </span><span class="lineCov">         21 :                                 ast_debug(2, &quot;Removing subscription '%s-&gt;%s' from list of subscriptions\n&quot;,</span>
<span class="lineNum">    1180 </span>            :                                         ast_sorcery_object_get_id(i-&gt;endpoint), ast_sip_subscription_get_resource_name(i-&gt;root));
<span class="lineNum">    1181 </span>            :                         }
<span class="lineNum">    1182 </span><span class="lineCov">         21 :                         break;</span>
<span class="lineNum">    1183 </span>            :                 }
<span class="lineNum">    1184 </span>            :         }
<span class="lineNum">    1185 </span>            :         AST_RWLIST_TRAVERSE_SAFE_END;
<span class="lineNum">    1186 </span><span class="lineCov">         21 :         AST_RWLIST_UNLOCK(&amp;subscriptions);</span>
<a name="1187"><span class="lineNum">    1187 </span><span class="lineCov">         21 : }</span></a>
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span><span class="lineCov">          9 : static void destroy_subscription(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    1190 </span>            : {
<span class="lineNum">    1191 </span><span class="lineCov">          9 :         ast_debug(3, &quot;Destroying SIP subscription from '%s-&gt;%s'\n&quot;,</span>
<span class="lineNum">    1192 </span>            :                 sub-&gt;tree &amp;&amp; sub-&gt;tree-&gt;endpoint ? ast_sorcery_object_get_id(sub-&gt;tree-&gt;endpoint) : &quot;Unknown&quot;,
<span class="lineNum">    1193 </span>            :                 sub-&gt;resource);
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span><span class="lineCov">          9 :         ast_free(sub-&gt;body_text);</span>
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span><span class="lineCov">          9 :         AST_VECTOR_FREE(&amp;sub-&gt;children);</span>
<span class="lineNum">    1198 </span><span class="lineCov">          9 :         ao2_cleanup(sub-&gt;datastores);</span>
<span class="lineNum">    1199 </span><span class="lineCov">          9 :         ast_free(sub);</span>
<a name="1200"><span class="lineNum">    1200 </span><span class="lineCov">          9 : }</span></a>
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span><span class="lineCov">          9 : static void destroy_subscriptions(struct ast_sip_subscription *root)</span>
<span class="lineNum">    1203 </span>            : {
<span class="lineNum">    1204 </span>            :         int i;
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span><span class="lineCov">          9 :         if (!root) {</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1208 </span>            :         }
<span class="lineNum">    1209 </span>            : 
<span class="lineNum">    1210 </span><span class="lineCov">          9 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;root-&gt;children); ++i) {</span>
<span class="lineNum">    1211 </span>            :                 struct ast_sip_subscription *child;
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :                 child = AST_VECTOR_GET(&amp;root-&gt;children, i);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :                 destroy_subscriptions(child);</span>
<span class="lineNum">    1215 </span>            :         }
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span><span class="lineCov">          9 :         destroy_subscription(root);</span>
<a name="1218"><span class="lineNum">    1218 </span>            : }</a>
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span><span class="lineCov">        230 : static struct ast_sip_subscription *allocate_subscription(const struct ast_sip_subscription_handler *handler,</span>
<span class="lineNum">    1221 </span>            :                 const char *resource, struct sip_subscription_tree *tree)
<span class="lineNum">    1222 </span>            : {
<span class="lineNum">    1223 </span>            :         struct ast_sip_subscription *sub;
<span class="lineNum">    1224 </span>            :         pjsip_sip_uri *contact_uri;
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineCov">        230 :         sub = ast_calloc(1, sizeof(*sub) + strlen(resource) + 1);</span>
<span class="lineNum">    1227 </span><span class="lineCov">        230 :         if (!sub) {</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1229 </span>            :         }
<span class="lineNum">    1230 </span><span class="lineCov">        230 :         strcpy(sub-&gt;resource, resource); /* Safe */</span>
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span><span class="lineCov">        230 :         sub-&gt;datastores = ast_datastores_alloc();</span>
<span class="lineNum">    1233 </span><span class="lineCov">        230 :         if (!sub-&gt;datastores) {</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :                 destroy_subscription(sub);</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1236 </span>            :         }
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span><span class="lineCov">        230 :         sub-&gt;body_text = ast_str_create(128);</span>
<span class="lineNum">    1239 </span><span class="lineCov">        230 :         if (!sub-&gt;body_text) {</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :                 destroy_subscription(sub);</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1242 </span>            :         }
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span><span class="lineCov">        230 :         sub-&gt;uri = pjsip_sip_uri_create(tree-&gt;dlg-&gt;pool, PJ_FALSE);</span>
<span class="lineNum">    1245 </span><span class="lineCov">        230 :         contact_uri = pjsip_uri_get_uri(tree-&gt;dlg-&gt;local.contact-&gt;uri);</span>
<span class="lineNum">    1246 </span><span class="lineCov">        230 :         pjsip_sip_uri_assign(tree-&gt;dlg-&gt;pool, sub-&gt;uri, contact_uri);</span>
<span class="lineNum">    1247 </span><span class="lineCov">        230 :         pj_strdup2(tree-&gt;dlg-&gt;pool, &amp;sub-&gt;uri-&gt;user, resource);</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span><span class="lineCov">        230 :         sub-&gt;handler = handler;</span>
<span class="lineNum">    1250 </span><span class="lineCov">        230 :         sub-&gt;subscription_state = PJSIP_EVSUB_STATE_ACTIVE;</span>
<span class="lineNum">    1251 </span><span class="lineCov">        230 :         sub-&gt;tree = ao2_bump(tree);</span>
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span><span class="lineCov">        230 :         return sub;</span>
<span class="lineNum">    1254 </span>            : }
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            : /*!
<span class="lineNum">    1257 </span>            :  * \brief Create a tree of virtual subscriptions based on a resource tree node.
<span class="lineNum">    1258 </span>            :  *
<span class="lineNum">    1259 </span>            :  * \param handler The handler to supply to leaf subscriptions.
<span class="lineNum">    1260 </span>            :  * \param resource The requested resource for this subscription.
<span class="lineNum">    1261 </span>            :  * \param generator Body generator to use for leaf subscriptions.
<span class="lineNum">    1262 </span>            :  * \param tree The root of the subscription tree.
<a name="1263"><span class="lineNum">    1263 </span>            :  * \param current The tree node that corresponds to the subscription being created.</a>
<span class="lineNum">    1264 </span>            :  */
<span class="lineNum">    1265 </span><span class="lineCov">        230 : static struct ast_sip_subscription *create_virtual_subscriptions(const struct ast_sip_subscription_handler *handler,</span>
<span class="lineNum">    1266 </span>            :                 const char *resource, struct ast_sip_pubsub_body_generator *generator,
<span class="lineNum">    1267 </span>            :                 struct sip_subscription_tree *tree, struct tree_node *current)
<span class="lineNum">    1268 </span>            : {
<span class="lineNum">    1269 </span>            :         int i;
<span class="lineNum">    1270 </span>            :         struct ast_sip_subscription *sub;
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span><span class="lineCov">        230 :         sub = allocate_subscription(handler, resource, tree);</span>
<span class="lineNum">    1273 </span><span class="lineCov">        230 :         if (!sub) {</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1275 </span>            :         }
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span><span class="lineCov">        230 :         sub-&gt;full_state = current-&gt;full_state;</span>
<span class="lineNum">    1278 </span><span class="lineCov">        230 :         sub-&gt;body_generator = generator;</span>
<span class="lineNum">    1279 </span><span class="lineCov">        230 :         AST_VECTOR_INIT(&amp;sub-&gt;children, AST_VECTOR_SIZE(&amp;current-&gt;children));</span>
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span><span class="lineCov">        383 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;current-&gt;children); ++i) {</span>
<span class="lineNum">    1282 </span>            :                 struct ast_sip_subscription *child;
<span class="lineNum">    1283 </span><span class="lineCov">        153 :                 struct tree_node *child_node = AST_VECTOR_GET(&amp;current-&gt;children, i);</span>
<span class="lineNum">    1284 </span>            : 
<span class="lineNum">    1285 </span><span class="lineCov">        153 :                 child = create_virtual_subscriptions(handler, child_node-&gt;resource, generator,</span>
<span class="lineNum">    1286 </span>            :                                 tree, child_node);
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span><span class="lineCov">        153 :                 if (!child) {</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :                         ast_debug(1, &quot;Child subscription to resource %s could not be created\n&quot;,</span>
<span class="lineNum">    1290 </span>            :                                         child_node-&gt;resource);
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1292 </span>            :                 }
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">        153 :                 if (AST_VECTOR_APPEND(&amp;sub-&gt;children, child)) {</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :                         ast_debug(1, &quot;Child subscription to resource %s could not be appended\n&quot;,</span>
<span class="lineNum">    1296 </span>            :                                         child_node-&gt;resource);
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :                         destroy_subscription(child);</span>
<span class="lineNum">    1298 </span>            :                         /* Have to release tree here too because a ref was added
<span class="lineNum">    1299 </span>            :                          * to child that destroy_subscription() doesn't release. */
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :                         ao2_cleanup(tree);</span>
<span class="lineNum">    1301 </span>            :                 }
<span class="lineNum">    1302 </span>            :         }
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span><span class="lineCov">        230 :         return sub;</span>
<a name="1305"><span class="lineNum">    1305 </span>            : }</a>
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span><span class="lineCov">         49 : static void shutdown_subscriptions(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    1308 </span>            : {
<span class="lineNum">    1309 </span>            :         int i;
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span><span class="lineCov">         49 :         if (!sub) {</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1313 </span>            :         }
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span><span class="lineCov">         49 :         if (AST_VECTOR_SIZE(&amp;sub-&gt;children) &gt; 0) {</span>
<span class="lineNum">    1316 </span><span class="lineCov">         42 :                 for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;sub-&gt;children); ++i) {</span>
<span class="lineNum">    1317 </span><span class="lineCov">         28 :                         shutdown_subscriptions(AST_VECTOR_GET(&amp;sub-&gt;children, i));</span>
<span class="lineNum">    1318 </span>            :                 }
<span class="lineNum">    1319 </span><span class="lineCov">         14 :                 return;</span>
<span class="lineNum">    1320 </span>            :         }
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            :         /* We notify subscription shutdown only on the tree leaves. */
<span class="lineNum">    1323 </span><span class="lineCov">         35 :         if (sub-&gt;handler-&gt;subscription_shutdown) {</span>
<span class="lineNum">    1324 </span><span class="lineCov">         35 :                 sub-&gt;handler-&gt;subscription_shutdown(sub);</span>
<a name="1325"><span class="lineNum">    1325 </span>            :         }</a>
<span class="lineNum">    1326 </span>            : }
<span class="lineNum">    1327 </span><span class="lineCov">          9 : static int subscription_unreference_dialog(void *obj)</span>
<span class="lineNum">    1328 </span>            : {
<span class="lineNum">    1329 </span><span class="lineCov">          9 :         struct sip_subscription_tree *sub_tree = obj;</span>
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span>            :         /* This is why we keep the dialog on the subscription. When the subscription
<span class="lineNum">    1332 </span>            :          * is destroyed, there is no guarantee that the underlying dialog is ready
<span class="lineNum">    1333 </span>            :          * to be destroyed. Furthermore, there's no guarantee in the opposite direction
<span class="lineNum">    1334 </span>            :          * either. The dialog could be destroyed before our subscription is. We fix
<span class="lineNum">    1335 </span>            :          * this problem by keeping a reference to the dialog until it is time to
<span class="lineNum">    1336 </span>            :          * destroy the subscription. We need to have the dialog available when the
<span class="lineNum">    1337 </span>            :          * subscription is destroyed so that we can guarantee that our attempt to
<span class="lineNum">    1338 </span>            :          * remove the serializer will be successful.
<span class="lineNum">    1339 </span>            :          */
<span class="lineNum">    1340 </span><span class="lineCov">          9 :         pjsip_dlg_dec_session(sub_tree-&gt;dlg, &amp;pubsub_module);</span>
<span class="lineNum">    1341 </span><span class="lineCov">          9 :         sub_tree-&gt;dlg = NULL;</span>
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span><span class="lineCov">          9 :         return 0;</span>
<a name="1344"><span class="lineNum">    1344 </span>            : }</a>
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span><span class="lineCov">          9 : static void subscription_tree_destructor(void *obj)</span>
<span class="lineNum">    1347 </span>            : {
<span class="lineNum">    1348 </span><span class="lineCov">          9 :         struct sip_subscription_tree *sub_tree = obj;</span>
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span><span class="lineCov">          9 :         ast_debug(3, &quot;Destroying subscription tree %p '%s-&gt;%s'\n&quot;,</span>
<span class="lineNum">    1351 </span>            :                 sub_tree,
<span class="lineNum">    1352 </span>            :                 sub_tree-&gt;endpoint ? ast_sorcery_object_get_id(sub_tree-&gt;endpoint) : &quot;Unknown&quot;,
<span class="lineNum">    1353 </span>            :                 sub_tree-&gt;root ? sub_tree-&gt;root-&gt;resource : &quot;Unknown&quot;);
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span><span class="lineCov">          9 :         destroy_subscriptions(sub_tree-&gt;root);</span>
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span><span class="lineCov">          9 :         if (sub_tree-&gt;dlg) {</span>
<span class="lineNum">    1358 </span><span class="lineCov">          9 :                 ast_sip_push_task_wait_servant(sub_tree-&gt;serializer,</span>
<span class="lineNum">    1359 </span>            :                         subscription_unreference_dialog, sub_tree);
<span class="lineNum">    1360 </span>            :         }
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span><span class="lineCov">          9 :         ao2_cleanup(sub_tree-&gt;endpoint);</span>
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span><span class="lineCov">          9 :         ast_taskprocessor_unreference(sub_tree-&gt;serializer);</span>
<span class="lineNum">    1365 </span><span class="lineCov">          9 :         ast_module_unref(ast_module_info-&gt;self);</span>
<a name="1366"><span class="lineNum">    1366 </span><span class="lineCov">          9 : }</span></a>
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span><span class="lineCov">         35 : void ast_sip_subscription_destroy(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    1369 </span>            : {
<span class="lineNum">    1370 </span><span class="lineCov">         35 :         ast_debug(3, &quot;Removing subscription %p '%s-&gt;%s' reference to subscription tree %p\n&quot;,</span>
<span class="lineNum">    1371 </span>            :                 sub, ast_sorcery_object_get_id(sub-&gt;tree-&gt;endpoint), sub-&gt;resource, sub-&gt;tree);
<span class="lineNum">    1372 </span><span class="lineCov">         35 :         ao2_cleanup(sub-&gt;tree);</span>
<a name="1373"><span class="lineNum">    1373 </span><span class="lineCov">         35 : }</span></a>
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span><span class="lineCov">         77 : static void subscription_setup_dialog(struct sip_subscription_tree *sub_tree, pjsip_dialog *dlg)</span>
<span class="lineNum">    1376 </span>            : {
<span class="lineNum">    1377 </span><span class="lineCov">         77 :         sub_tree-&gt;dlg = dlg;</span>
<span class="lineNum">    1378 </span><span class="lineCov">         77 :         ast_sip_dialog_set_serializer(dlg, sub_tree-&gt;serializer);</span>
<span class="lineNum">    1379 </span><span class="lineCov">         77 :         ast_sip_dialog_set_endpoint(dlg, sub_tree-&gt;endpoint);</span>
<span class="lineNum">    1380 </span><span class="lineCov">         77 :         pjsip_evsub_set_mod_data(sub_tree-&gt;evsub, pubsub_module.id, sub_tree);</span>
<span class="lineNum">    1381 </span><span class="lineCov">         77 :         pjsip_dlg_inc_session(dlg, &amp;pubsub_module);</span>
<a name="1382"><span class="lineNum">    1382 </span><span class="lineCov">         77 : }</span></a>
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span><span class="lineCov">         77 : static struct sip_subscription_tree *allocate_subscription_tree(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata)</span>
<span class="lineNum">    1385 </span>            : {
<span class="lineNum">    1386 </span>            :         struct sip_subscription_tree *sub_tree;
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span><span class="lineCov">         77 :         sub_tree = ao2_alloc(sizeof *sub_tree, subscription_tree_destructor);</span>
<span class="lineNum">    1389 </span><span class="lineCov">         77 :         if (!sub_tree) {</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1391 </span>            :         }
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span><span class="lineCov">         77 :         ast_module_ref(ast_module_info-&gt;self);</span>
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span><span class="lineCov">         77 :         if (rdata) {</span>
<span class="lineNum">    1396 </span>            :                 /*
<span class="lineNum">    1397 </span>            :                  * We must continue using the serializer that the original
<span class="lineNum">    1398 </span>            :                  * SUBSCRIBE came in on for the dialog.  There may be
<span class="lineNum">    1399 </span>            :                  * retransmissions already enqueued in the original
<span class="lineNum">    1400 </span>            :                  * serializer that can result in reentrancy and message
<span class="lineNum">    1401 </span>            :                  * sequencing problems.
<span class="lineNum">    1402 </span>            :                  */
<span class="lineNum">    1403 </span><span class="lineCov">         77 :                 sub_tree-&gt;serializer = ast_sip_get_distributor_serializer(rdata);</span>
<span class="lineNum">    1404 </span>            :         } else {
<span class="lineNum">    1405 </span>            :                 char tps_name[AST_TASKPROCESSOR_MAX_NAME + 1];
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span>            :                 /* Create name with seq number appended. */
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :                 ast_taskprocessor_build_name(tps_name, sizeof(tps_name), &quot;pjsip/pubsub/%s&quot;,</span>
<span class="lineNum">    1409 </span>            :                         ast_sorcery_object_get_id(endpoint));
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                 sub_tree-&gt;serializer = ast_sip_create_serializer(tps_name);</span>
<span class="lineNum">    1412 </span>            :         }
<span class="lineNum">    1413 </span><span class="lineCov">         77 :         if (!sub_tree-&gt;serializer) {</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :                 ao2_ref(sub_tree, -1);</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1416 </span>            :         }
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span><span class="lineCov">         77 :         sub_tree-&gt;endpoint = ao2_bump(endpoint);</span>
<span class="lineNum">    1419 </span><span class="lineCov">         77 :         sub_tree-&gt;notify_sched_id = -1;</span>
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span><span class="lineCov">         77 :         return sub_tree;</span>
<span class="lineNum">    1422 </span>            : }
<span class="lineNum">    1423 </span>            : 
<span class="lineNum">    1424 </span>            : /*!
<span class="lineNum">    1425 </span>            :  * \brief Create a subscription tree based on a resource tree.
<span class="lineNum">    1426 </span>            :  *
<span class="lineNum">    1427 </span>            :  * Using the previously-determined valid resources in the provided resource tree,
<span class="lineNum">    1428 </span>            :  * a corresponding tree of ast_sip_subscriptions are created. The root of the
<span class="lineNum">    1429 </span>            :  * subscription tree is a real subscription, and the rest in the tree are
<span class="lineNum">    1430 </span>            :  * virtual subscriptions.
<span class="lineNum">    1431 </span>            :  *
<span class="lineNum">    1432 </span>            :  * \param handler The handler to use for leaf subscriptions
<span class="lineNum">    1433 </span>            :  * \param endpoint The endpoint that sent the SUBSCRIBE request
<span class="lineNum">    1434 </span>            :  * \param rdata The SUBSCRIBE content
<span class="lineNum">    1435 </span>            :  * \param resource The requested resource in the SUBSCRIBE request
<span class="lineNum">    1436 </span>            :  * \param generator The body generator to use in leaf subscriptions
<span class="lineNum">    1437 </span>            :  * \param tree The resource tree on which the subscription tree is based
<span class="lineNum">    1438 </span>            :  * \param dlg_status[out] The result of attempting to create a dialog.
<span class="lineNum">    1439 </span>            :  *
<span class="lineNum">    1440 </span>            :  * \retval NULL Could not create the subscription tree
<span class="lineNum">    1441 </span>            :  * \retval non-NULL The root of the created subscription tree
<a name="1442"><span class="lineNum">    1442 </span>            :  */</a>
<span class="lineNum">    1443 </span>            : 
<span class="lineNum">    1444 </span><span class="lineCov">         77 : static struct sip_subscription_tree *create_subscription_tree(const struct ast_sip_subscription_handler *handler,</span>
<span class="lineNum">    1445 </span>            :                 struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata, const char *resource,
<span class="lineNum">    1446 </span>            :                 struct ast_sip_pubsub_body_generator *generator, struct resource_tree *tree,
<span class="lineNum">    1447 </span>            :                 pj_status_t *dlg_status)
<span class="lineNum">    1448 </span>            : {
<span class="lineNum">    1449 </span>            :         struct sip_subscription_tree *sub_tree;
<span class="lineNum">    1450 </span>            :         pjsip_dialog *dlg;
<span class="lineNum">    1451 </span>            :         struct subscription_persistence *persistence;
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span><span class="lineCov">         77 :         sub_tree = allocate_subscription_tree(endpoint, rdata);</span>
<span class="lineNum">    1454 </span><span class="lineCov">         77 :         if (!sub_tree) {</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :                 *dlg_status = PJ_ENOMEM;</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1457 </span>            :         }
<span class="lineNum">    1458 </span><span class="lineCov">         77 :         sub_tree-&gt;role = AST_SIP_NOTIFIER;</span>
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span><span class="lineCov">         77 :         dlg = ast_sip_create_dialog_uas(endpoint, rdata, dlg_status);</span>
<span class="lineNum">    1461 </span><span class="lineCov">         77 :         if (!dlg) {</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :                 if (*dlg_status != PJ_EEXISTS) {</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Unable to create dialog for SIP subscription\n&quot;);</span>
<span class="lineNum">    1464 </span>            :                 }
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :                 ao2_ref(sub_tree, -1);</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1467 </span>            :         }
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span><span class="lineCov">         77 :         persistence = ast_sip_mod_data_get(rdata-&gt;endpt_info.mod_data,</span>
<span class="lineNum">    1470 </span>            :                         pubsub_module.id, MOD_DATA_PERSISTENCE);
<span class="lineNum">    1471 </span><span class="lineCov">         77 :         if (persistence) {</span>
<span class="lineNum">    1472 </span>            :                 /* Update the created dialog with the persisted information */
<span class="lineNum">    1473 </span><span class="lineCov">          1 :                 pjsip_ua_unregister_dlg(pjsip_ua_instance(), dlg);</span>
<span class="lineNum">    1474 </span><span class="lineCov">          1 :                 pj_strdup2(dlg-&gt;pool, &amp;dlg-&gt;local.info-&gt;tag, persistence-&gt;tag);</span>
<span class="lineNum">    1475 </span><span class="lineCov">          1 :                 dlg-&gt;local.tag_hval = pj_hash_calc_tolower(0, NULL, &amp;dlg-&gt;local.info-&gt;tag);</span>
<span class="lineNum">    1476 </span><span class="lineCov">          1 :                 pjsip_ua_register_dlg(pjsip_ua_instance(), dlg);</span>
<span class="lineNum">    1477 </span><span class="lineCov">          1 :                 dlg-&gt;local.cseq = persistence-&gt;cseq;</span>
<span class="lineNum">    1478 </span>            :         }
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span><span class="lineCov">         77 :         pjsip_evsub_create_uas(dlg, &amp;pubsub_cb, rdata, 0, &amp;sub_tree-&gt;evsub);</span>
<span class="lineNum">    1481 </span><span class="lineCov">         77 :         subscription_setup_dialog(sub_tree, dlg);</span>
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            : #ifdef HAVE_PJSIP_EVSUB_GRP_LOCK
<span class="lineNum">    1484 </span><span class="lineCov">         77 :         pjsip_evsub_add_ref(sub_tree-&gt;evsub);</span>
<span class="lineNum">    1485 </span>            : #endif
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span><span class="lineCov">         77 :         ast_sip_mod_data_set(dlg-&gt;pool, dlg-&gt;mod_data, pubsub_module.id, MOD_DATA_MSG,</span>
<span class="lineNum">    1488 </span>            :                         pjsip_msg_clone(dlg-&gt;pool, rdata-&gt;msg_info.msg));
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span><span class="lineCov">         77 :         sub_tree-&gt;notification_batch_interval = tree-&gt;notification_batch_interval;</span>
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span><span class="lineCov">         77 :         sub_tree-&gt;root = create_virtual_subscriptions(handler, resource, generator, sub_tree, tree-&gt;root);</span>
<span class="lineNum">    1493 </span><span class="lineCov">         77 :         if (AST_VECTOR_SIZE(&amp;sub_tree-&gt;root-&gt;children) &gt; 0) {</span>
<span class="lineNum">    1494 </span><span class="lineCov">         49 :                 sub_tree-&gt;is_list = 1;</span>
<span class="lineNum">    1495 </span>            :         }
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span><span class="lineCov">         77 :         add_subscription(sub_tree);</span>
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span><span class="lineCov">         77 :         return sub_tree;</span>
<span class="lineNum">    1500 </span>            : }
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span>            : /*! Wrapper structure for initial_notify_task */
<span class="lineNum">    1503 </span>            : struct initial_notify_data {
<span class="lineNum">    1504 </span>            :         struct sip_subscription_tree *sub_tree;
<span class="lineNum">    1505 </span>            :         int expires;
<span class="lineNum">    1506 </span>            : };
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span>            : static int initial_notify_task(void *obj);
<span class="lineNum">    1509 </span>            : static int send_notify(struct sip_subscription_tree *sub_tree, unsigned int force_full_state);
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span>            : /*! Persistent subscription recreation continuation under distributor serializer data */
<span class="lineNum">    1512 </span>            : struct persistence_recreate_data {
<span class="lineNum">    1513 </span>            :         struct subscription_persistence *persistence;
<span class="lineNum">    1514 </span>            :         pjsip_rx_data *rdata;
<span class="lineNum">    1515 </span>            : };
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span>            : /*!
<span class="lineNum">    1518 </span>            :  * \internal
<span class="lineNum">    1519 </span>            :  * \brief subscription_persistence_recreate continuation under distributor serializer.
<span class="lineNum">    1520 </span>            :  * \since 13.10.0
<span class="lineNum">    1521 </span>            :  *
<span class="lineNum">    1522 </span>            :  * \retval 0 on success.
<a name="1523"><span class="lineNum">    1523 </span>            :  * \retval -1 on error.</a>
<span class="lineNum">    1524 </span>            :  */
<span class="lineNum">    1525 </span><span class="lineCov">          1 : static int sub_persistence_recreate(void *obj)</span>
<span class="lineNum">    1526 </span>            : {
<span class="lineNum">    1527 </span><span class="lineCov">          1 :         struct persistence_recreate_data *recreate_data = obj;</span>
<span class="lineNum">    1528 </span><span class="lineCov">          1 :         struct subscription_persistence *persistence = recreate_data-&gt;persistence;</span>
<span class="lineNum">    1529 </span><span class="lineCov">          1 :         pjsip_rx_data *rdata = recreate_data-&gt;rdata;</span>
<span class="lineNum">    1530 </span>            :         struct ast_sip_endpoint *endpoint;
<span class="lineNum">    1531 </span>            :         struct sip_subscription_tree *sub_tree;
<span class="lineNum">    1532 </span>            :         struct ast_sip_pubsub_body_generator *generator;
<span class="lineNum">    1533 </span>            :         struct ast_sip_subscription_handler *handler;
<span class="lineNum">    1534 </span>            :         char *resource;
<span class="lineNum">    1535 </span>            :         pjsip_sip_uri *request_uri;
<span class="lineNum">    1536 </span>            :         size_t resource_size;
<span class="lineNum">    1537 </span>            :         int resp;
<span class="lineNum">    1538 </span>            :         struct resource_tree tree;
<span class="lineNum">    1539 </span>            :         pjsip_expires_hdr *expires_header;
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span><span class="lineCov">          1 :         request_uri = pjsip_uri_get_uri(rdata-&gt;msg_info.msg-&gt;line.req.uri);</span>
<span class="lineNum">    1542 </span><span class="lineCov">          1 :         resource_size = pj_strlen(&amp;request_uri-&gt;user) + 1;</span>
<span class="lineNum">    1543 </span><span class="lineCov">          1 :         resource = ast_alloca(resource_size);</span>
<span class="lineNum">    1544 </span><span class="lineCov">          1 :         ast_copy_pj_str(resource, &amp;request_uri-&gt;user, resource_size);</span>
<span class="lineNum">    1545 </span>            : 
<span class="lineNum">    1546 </span>            :         /*
<span class="lineNum">    1547 </span>            :          * We may want to match without any user options getting
<span class="lineNum">    1548 </span>            :          * in the way.
<span class="lineNum">    1549 </span>            :          */
<span class="lineNum">    1550 </span><span class="lineCov">          1 :         AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(resource);</span>
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span><span class="lineCov">          1 :         handler = subscription_get_handler_from_rdata(rdata);</span>
<span class="lineNum">    1553 </span><span class="lineCov">          1 :         if (!handler || !handler-&gt;notifier) {</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Failed recreating '%s' subscription: Could not get subscription handler.\n&quot;,</span>
<span class="lineNum">    1555 </span>            :                         persistence-&gt;endpoint);
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1558 </span>            :         }
<span class="lineNum">    1559 </span>            : 
<span class="lineNum">    1560 </span><span class="lineCov">          1 :         generator = subscription_get_generator_from_rdata(rdata, handler);</span>
<span class="lineNum">    1561 </span><span class="lineCov">          1 :         if (!generator) {</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Failed recreating '%s' subscription: Body generator not available.\n&quot;,</span>
<span class="lineNum">    1563 </span>            :                         persistence-&gt;endpoint);
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1566 </span>            :         }
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span><span class="lineCov">          1 :         ast_sip_mod_data_set(rdata-&gt;tp_info.pool, rdata-&gt;endpt_info.mod_data,</span>
<span class="lineNum">    1569 </span>            :                 pubsub_module.id, MOD_DATA_PERSISTENCE, persistence);
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            :         /* Getting the endpoint may take some time that can affect the expiration. */
<span class="lineNum">    1572 </span><span class="lineCov">          1 :         endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), &quot;endpoint&quot;,</span>
<span class="lineNum">    1573 </span><span class="lineCov">          1 :                 persistence-&gt;endpoint);</span>
<span class="lineNum">    1574 </span><span class="lineCov">          1 :         if (!endpoint) {</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Failed recreating '%s' subscription: The endpoint was not found\n&quot;,</span>
<span class="lineNum">    1576 </span>            :                         persistence-&gt;endpoint);
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1579 </span>            :         }
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span>            :         /* Update the expiration header with the new expiration */
<span class="lineNum">    1582 </span><span class="lineCov">          1 :         expires_header = pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_EXPIRES,</span>
<span class="lineNum">    1583 </span><span class="lineCov">          1 :                 rdata-&gt;msg_info.msg-&gt;hdr.next);</span>
<span class="lineNum">    1584 </span><span class="lineCov">          1 :         if (!expires_header) {</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :                 expires_header = pjsip_expires_hdr_create(rdata-&gt;tp_info.pool, 0);</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :                 if (!expires_header) {</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Failed recreating '%s' subscription: Could not update expires header.\n&quot;,</span>
<span class="lineNum">    1588 </span>            :                                 persistence-&gt;endpoint);
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :                         ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :                         ao2_ref(endpoint, -1);</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :                         return 0;</span>
<span class="lineNum">    1592 </span>            :                 }
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :                 pjsip_msg_add_hdr(rdata-&gt;msg_info.msg, (pjsip_hdr *) expires_header);</span>
<span class="lineNum">    1594 </span>            :         }
<span class="lineNum">    1595 </span>            : 
<span class="lineNum">    1596 </span><span class="lineCov">          1 :         expires_header-&gt;ivalue = (ast_tvdiff_ms(persistence-&gt;expires, ast_tvnow()) / 1000);</span>
<span class="lineNum">    1597 </span><span class="lineCov">          1 :         if (expires_header-&gt;ivalue &lt;= 0) {</span>
<span class="lineNum">    1598 </span>            :                 /* The subscription expired since we started recreating the subscription. */
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :                 ast_debug(3, &quot;Expired subscription retrived from persistent store '%s' %s\n&quot;,</span>
<span class="lineNum">    1600 </span>            :                         persistence-&gt;endpoint, persistence-&gt;tag);
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :                 ao2_ref(endpoint, -1);</span>
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1604 </span>            :         }
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span><span class="lineCov">          1 :         memset(&amp;tree, 0, sizeof(tree));</span>
<span class="lineNum">    1607 </span><span class="lineCov">          1 :         resp = build_resource_tree(endpoint, handler, resource, &amp;tree,</span>
<span class="lineNum">    1608 </span>            :                 ast_sip_pubsub_has_eventlist_support(rdata));
<span class="lineNum">    1609 </span><span class="lineCov">          1 :         if (PJSIP_IS_STATUS_IN_CLASS(resp, 200)) {</span>
<span class="lineNum">    1610 </span>            :                 pj_status_t dlg_status;
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span><span class="lineCov">          1 :                 sub_tree = create_subscription_tree(handler, endpoint, rdata, resource, generator,</span>
<span class="lineNum">    1613 </span>            :                         &amp;tree, &amp;dlg_status);
<span class="lineNum">    1614 </span><span class="lineCov">          1 :                 if (!sub_tree) {</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :                         if (dlg_status != PJ_EEXISTS) {</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;Failed recreating '%s' subscription: Could not create subscription tree.\n&quot;,</span>
<span class="lineNum">    1617 </span>            :                                         persistence-&gt;endpoint);
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :                                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1619 </span>            :                         }
<span class="lineNum">    1620 </span>            :                 } else {
<span class="lineNum">    1621 </span><span class="lineCov">          1 :                         struct initial_notify_data *ind = ast_malloc(sizeof(*ind));</span>
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span><span class="lineCov">          1 :                         if (!ind) {</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :                                 pjsip_evsub_terminate(sub_tree-&gt;evsub, PJ_TRUE);</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :                                 goto error;</span>
<span class="lineNum">    1626 </span>            :                         }
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span><span class="lineCov">          1 :                         ind-&gt;sub_tree = ao2_bump(sub_tree);</span>
<span class="lineNum">    1629 </span><span class="lineCov">          1 :                         ind-&gt;expires = expires_header-&gt;ivalue;</span>
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span><span class="lineCov">          1 :                         sub_tree-&gt;persistence = ao2_bump(persistence);</span>
<span class="lineNum">    1632 </span><span class="lineCov">          1 :                         subscription_persistence_update(sub_tree, rdata, SUBSCRIPTION_PERSISTENCE_RECREATED);</span>
<span class="lineNum">    1633 </span><span class="lineCov">          1 :                         if (ast_sip_push_task(sub_tree-&gt;serializer, initial_notify_task, ind)) {</span>
<span class="lineNum">    1634 </span>            :                                 /* Could not send initial subscribe NOTIFY */
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :                                 pjsip_evsub_terminate(sub_tree-&gt;evsub, PJ_TRUE);</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :                                 ao2_ref(sub_tree, -1);</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :                                 ast_free(ind);</span>
<span class="lineNum">    1638 </span>            :                         }
<span class="lineNum">    1639 </span>            :                 }
<span class="lineNum">    1640 </span>            :         } else {
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1642 </span>            :         }
<span class="lineNum">    1643 </span>            : 
<span class="lineNum">    1644 </span><span class="lineCov">          1 : error:</span>
<span class="lineNum">    1645 </span><span class="lineCov">          1 :         resource_tree_destroy(&amp;tree);</span>
<span class="lineNum">    1646 </span><span class="lineCov">          1 :         ao2_ref(endpoint, -1);</span>
<span class="lineNum">    1647 </span>            : 
<span class="lineNum">    1648 </span><span class="lineCov">          1 :         return 0;</span>
<span class="lineNum">    1649 </span>            : }
<a name="1650"><span class="lineNum">    1650 </span>            : </a>
<span class="lineNum">    1651 </span>            : /*! \brief Callback function to perform the actual recreation of a subscription */
<span class="lineNum">    1652 </span><span class="lineCov">          1 : static int subscription_persistence_recreate(void *obj, void *arg, int flags)</span>
<span class="lineNum">    1653 </span>            : {
<span class="lineNum">    1654 </span><span class="lineCov">          1 :         struct subscription_persistence *persistence = obj;</span>
<span class="lineNum">    1655 </span><span class="lineCov">          1 :         pj_pool_t *pool = arg;</span>
<span class="lineNum">    1656 </span>            :         struct ast_taskprocessor *serializer;
<span class="lineNum">    1657 </span>            :         pjsip_rx_data rdata;
<span class="lineNum">    1658 </span>            :         struct persistence_recreate_data recreate_data;
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span>            :         /* If this subscription used a reliable transport it can't be reestablished so remove it */
<span class="lineNum">    1661 </span><span class="lineCov">          1 :         if (persistence-&gt;prune_on_boot) {</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :                 ast_debug(3, &quot;Deleting subscription marked as 'prune' from persistent store '%s' %s\n&quot;,</span>
<span class="lineNum">    1663 </span>            :                         persistence-&gt;endpoint, persistence-&gt;tag);
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1666 </span>            :         }
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            :         /* If this subscription has already expired remove it */
<span class="lineNum">    1669 </span><span class="lineCov">          1 :         if (ast_tvdiff_ms(persistence-&gt;expires, ast_tvnow()) &lt;= 0) {</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :                 ast_debug(3, &quot;Expired subscription retrived from persistent store '%s' %s\n&quot;,</span>
<span class="lineNum">    1671 </span>            :                         persistence-&gt;endpoint, persistence-&gt;tag);
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1674 </span>            :         }
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span><span class="lineCov">          1 :         memset(&amp;rdata, 0, sizeof(rdata));</span>
<span class="lineNum">    1677 </span><span class="lineCov">          1 :         pj_pool_reset(pool);</span>
<span class="lineNum">    1678 </span><span class="lineCov">          1 :         rdata.tp_info.pool = pool;</span>
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span><span class="lineCov">          1 :         if (ast_sip_create_rdata_with_contact(&amp;rdata, persistence-&gt;packet, persistence-&gt;src_name,</span>
<span class="lineNum">    1681 </span><span class="lineCov">          1 :                 persistence-&gt;src_port, persistence-&gt;transport_key, persistence-&gt;local_name,</span>
<span class="lineNum">    1682 </span><span class="lineCov">          1 :                 persistence-&gt;local_port, persistence-&gt;contact_uri)) {</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Failed recreating '%s' subscription: The message could not be parsed\n&quot;,</span>
<span class="lineNum">    1684 </span>            :                         persistence-&gt;endpoint);
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1687 </span>            :         }
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span><span class="lineCov">          1 :         if (rdata.msg_info.msg-&gt;type != PJSIP_REQUEST_MSG) {</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :                 ast_log(LOG_NOTICE, &quot;Failed recreating '%s' subscription: Stored a SIP response instead of a request.\n&quot;,</span>
<span class="lineNum">    1691 </span>            :                         persistence-&gt;endpoint);
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1694 </span>            :         }
<span class="lineNum">    1695 </span>            : 
<span class="lineNum">    1696 </span>            :         /* Continue the remainder in the distributor serializer */
<span class="lineNum">    1697 </span><span class="lineCov">          1 :         serializer = ast_sip_get_distributor_serializer(&amp;rdata);</span>
<span class="lineNum">    1698 </span><span class="lineCov">          1 :         if (!serializer) {</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Failed recreating '%s' subscription: Could not get distributor serializer.\n&quot;,</span>
<span class="lineNum">    1700 </span>            :                         persistence-&gt;endpoint);
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1703 </span>            :         }
<span class="lineNum">    1704 </span><span class="lineCov">          1 :         recreate_data.persistence = persistence;</span>
<span class="lineNum">    1705 </span><span class="lineCov">          1 :         recreate_data.rdata = &amp;rdata;</span>
<span class="lineNum">    1706 </span><span class="lineCov">          1 :         if (ast_sip_push_task_wait_serializer(serializer, sub_persistence_recreate,</span>
<span class="lineNum">    1707 </span>            :                 &amp;recreate_data)) {
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Failed recreating '%s' subscription: Could not continue under distributor serializer.\n&quot;,</span>
<span class="lineNum">    1709 </span>            :                         persistence-&gt;endpoint);
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :                 ast_sorcery_delete(ast_sip_get_sorcery(), persistence);</span>
<span class="lineNum">    1711 </span>            :         }
<span class="lineNum">    1712 </span><span class="lineCov">          1 :         ast_taskprocessor_unreference(serializer);</span>
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span><span class="lineCov">          1 :         return 0;</span>
<span class="lineNum">    1715 </span>            : }
<a name="1716"><span class="lineNum">    1716 </span>            : </a>
<span class="lineNum">    1717 </span>            : /*! \brief Function which loads and recreates persisted subscriptions upon startup when the system is fully booted */
<span class="lineNum">    1718 </span><span class="lineCov">        852 : static int subscription_persistence_load(void *data)</span>
<span class="lineNum">    1719 </span>            : {
<span class="lineNum">    1720 </span><span class="lineCov">        852 :         struct ao2_container *persisted_subscriptions = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(),</span>
<span class="lineNum">    1721 </span>            :                 &quot;subscription_persistence&quot;, AST_RETRIEVE_FLAG_MULTIPLE | AST_RETRIEVE_FLAG_ALL, NULL);
<span class="lineNum">    1722 </span>            :         pj_pool_t *pool;
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span><span class="lineCov">        852 :         pool = pjsip_endpt_create_pool(ast_sip_get_pjsip_endpoint(), &quot;rtd%p&quot;, PJSIP_POOL_RDATA_LEN,</span>
<span class="lineNum">    1725 </span>            :                 PJSIP_POOL_RDATA_INC);
<span class="lineNum">    1726 </span><span class="lineCov">        852 :         if (!pool) {</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Could not create a memory pool for recreating SIP subscriptions\n&quot;);</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1729 </span>            :         }
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span><span class="lineCov">        852 :         ao2_callback(persisted_subscriptions, OBJ_NODATA, subscription_persistence_recreate, pool);</span>
<span class="lineNum">    1732 </span>            : 
<span class="lineNum">    1733 </span><span class="lineCov">        852 :         pjsip_endpt_release_pool(ast_sip_get_pjsip_endpoint(), pool);</span>
<span class="lineNum">    1734 </span>            : 
<span class="lineNum">    1735 </span><span class="lineCov">        852 :         ao2_ref(persisted_subscriptions, -1);</span>
<span class="lineNum">    1736 </span><span class="lineCov">        852 :         return 0;</span>
<span class="lineNum">    1737 </span>            : }
<a name="1738"><span class="lineNum">    1738 </span>            : </a>
<span class="lineNum">    1739 </span>            : /*! \brief Event callback which fires subscription persistence recreation when the system is fully booted */
<span class="lineNum">    1740 </span><span class="lineCov">      42855 : static void subscription_persistence_event_cb(void *data, struct stasis_subscription *sub, struct stasis_message *message)</span>
<span class="lineNum">    1741 </span>            : {
<span class="lineNum">    1742 </span>            :         struct ast_json_payload *payload;
<span class="lineNum">    1743 </span>            :         const char *type;
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span><span class="lineCov">      42855 :         if (stasis_message_type(message) != ast_manager_get_generic_type()) {</span>
<span class="lineNum">    1746 </span><span class="lineCov">      42003 :                 return;</span>
<span class="lineNum">    1747 </span>            :         }
<span class="lineNum">    1748 </span>            : 
<span class="lineNum">    1749 </span><span class="lineCov">        852 :         payload = stasis_message_data(message);</span>
<span class="lineNum">    1750 </span><span class="lineCov">        852 :         type = ast_json_string_get(ast_json_object_get(payload-&gt;json, &quot;type&quot;));</span>
<span class="lineNum">    1751 </span>            : 
<span class="lineNum">    1752 </span>            :         /* This subscription only responds to the FullyBooted event so that all modules have been loaded when we
<span class="lineNum">    1753 </span>            :          * recreate SIP subscriptions.
<span class="lineNum">    1754 </span>            :          */
<span class="lineNum">    1755 </span><span class="lineCov">        852 :         if (strcmp(type, &quot;FullyBooted&quot;)) {</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1757 </span>            :         }
<span class="lineNum">    1758 </span>            : 
<span class="lineNum">    1759 </span>            :         /* This has to be here so the subscription is recreated when the body generator is available */
<span class="lineNum">    1760 </span><span class="lineCov">        852 :         ast_sip_push_task(NULL, subscription_persistence_load, NULL);</span>
<span class="lineNum">    1761 </span>            : 
<span class="lineNum">    1762 </span>            :         /* Once the system is fully booted we don't care anymore */
<span class="lineNum">    1763 </span><span class="lineCov">        852 :         stasis_unsubscribe(sub);</span>
<span class="lineNum">    1764 </span>            : }
<span class="lineNum">    1765 </span>            : 
<a name="1766"><span class="lineNum">    1766 </span>            : typedef int (*on_subscription_t)(struct sip_subscription_tree *sub, void *arg);</a>
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span><span class="lineCov">          1 : static int for_each_subscription(on_subscription_t on_subscription, void *arg)</span>
<span class="lineNum">    1769 </span>            : {
<span class="lineNum">    1770 </span><span class="lineCov">          1 :         int num = 0;</span>
<span class="lineNum">    1771 </span>            :         struct sip_subscription_tree *i;
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span><span class="lineCov">          1 :         if (!on_subscription) {</span>
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :                 return num;</span>
<span class="lineNum">    1775 </span>            :         }
<span class="lineNum">    1776 </span>            : 
<span class="lineNum">    1777 </span><span class="lineCov">          1 :         AST_RWLIST_RDLOCK(&amp;subscriptions);</span>
<span class="lineNum">    1778 </span><span class="lineCov">          3 :         AST_RWLIST_TRAVERSE(&amp;subscriptions, i, next) {</span>
<span class="lineNum">    1779 </span><span class="lineCov">          2 :                 if (on_subscription(i, arg)) {</span>
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1781 </span>            :                 }
<span class="lineNum">    1782 </span><span class="lineCov">          2 :                 ++num;</span>
<span class="lineNum">    1783 </span>            :         }
<span class="lineNum">    1784 </span><span class="lineCov">          1 :         AST_RWLIST_UNLOCK(&amp;subscriptions);</span>
<span class="lineNum">    1785 </span><span class="lineCov">          1 :         return num;</span>
<a name="1786"><span class="lineNum">    1786 </span>            : }</a>
<span class="lineNum">    1787 </span>            : 
<span class="lineNum">    1788 </span><span class="lineCov">          2 : static void sip_subscription_to_ami(struct sip_subscription_tree *sub_tree,</span>
<span class="lineNum">    1789 </span>            :                                     struct ast_str **buf)
<span class="lineNum">    1790 </span>            : {
<span class="lineNum">    1791 </span>            :         char str[256];
<span class="lineNum">    1792 </span><span class="lineCov">          2 :         struct ast_sip_endpoint_id_configuration *id = &amp;sub_tree-&gt;endpoint-&gt;id;</span>
<span class="lineNum">    1793 </span>            : 
<span class="lineNum">    1794 </span><span class="lineCov">          2 :         ast_str_append(buf, 0, &quot;Role: %s\r\n&quot;,</span>
<span class="lineNum">    1795 </span><span class="lineCov">          2 :                        sip_subscription_roles_map[sub_tree-&gt;role]);</span>
<span class="lineNum">    1796 </span><span class="lineCov">          2 :         ast_str_append(buf, 0, &quot;Endpoint: %s\r\n&quot;,</span>
<span class="lineNum">    1797 </span><span class="lineCov">          2 :                        ast_sorcery_object_get_id(sub_tree-&gt;endpoint));</span>
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span><span class="lineCov">          2 :         if (sub_tree-&gt;dlg) {</span>
<span class="lineNum">    1800 </span><span class="lineCov">          2 :                 ast_copy_pj_str(str, &amp;sub_tree-&gt;dlg-&gt;call_id-&gt;id, sizeof(str));</span>
<span class="lineNum">    1801 </span>            :         } else {
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :                 ast_copy_string(str, &quot;&lt;unknown&gt;&quot;, sizeof(str));</span>
<span class="lineNum">    1803 </span>            :         }
<span class="lineNum">    1804 </span><span class="lineCov">          2 :         ast_str_append(buf, 0, &quot;Callid: %s\r\n&quot;, str);</span>
<span class="lineNum">    1805 </span>            : 
<span class="lineNum">    1806 </span><span class="lineCov">          2 :         ast_str_append(buf, 0, &quot;State: %s\r\n&quot;, pjsip_evsub_get_state_name(sub_tree-&gt;evsub));</span>
<span class="lineNum">    1807 </span>            : 
<span class="lineNum">    1808 </span><span class="lineCov">          2 :         ast_callerid_merge(str, sizeof(str),</span>
<span class="lineNum">    1809 </span><span class="lineCov">          2 :                            S_COR(id-&gt;self.name.valid, id-&gt;self.name.str, NULL),</span>
<span class="lineNum">    1810 </span><span class="lineCov">          2 :                            S_COR(id-&gt;self.number.valid, id-&gt;self.number.str, NULL),</span>
<span class="lineNum">    1811 </span>            :                            &quot;Unknown&quot;);
<span class="lineNum">    1812 </span>            : 
<span class="lineNum">    1813 </span><span class="lineCov">          2 :         ast_str_append(buf, 0, &quot;Callerid: %s\r\n&quot;, str);</span>
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span>            :         /* XXX This needs to be done recursively for lists */
<span class="lineNum">    1816 </span><span class="lineCov">          2 :         if (sub_tree-&gt;root-&gt;handler-&gt;to_ami) {</span>
<span class="lineNum">    1817 </span><span class="lineCov">          2 :                 sub_tree-&gt;root-&gt;handler-&gt;to_ami(sub_tree-&gt;root, buf);</span>
<span class="lineNum">    1818 </span>            :         }
<span class="lineNum">    1819 </span><span class="lineCov">          2 : }</span>
<a name="1820"><span class="lineNum">    1820 </span>            : </a>
<span class="lineNum">    1821 </span>            : 
<span class="lineNum">    1822 </span><span class="lineCov">         96 : void *ast_sip_subscription_get_header(const struct ast_sip_subscription *sub, const char *header)</span>
<span class="lineNum">    1823 </span>            : {
<span class="lineNum">    1824 </span>            :         pjsip_dialog *dlg;
<span class="lineNum">    1825 </span>            :         pjsip_msg *msg;
<span class="lineNum">    1826 </span>            :         pj_str_t name;
<span class="lineNum">    1827 </span>            : 
<span class="lineNum">    1828 </span><span class="lineCov">         96 :         dlg = sub-&gt;tree-&gt;dlg;</span>
<span class="lineNum">    1829 </span><span class="lineCov">         96 :         msg = ast_sip_mod_data_get(dlg-&gt;mod_data, pubsub_module.id, MOD_DATA_MSG);</span>
<span class="lineNum">    1830 </span><span class="lineCov">         96 :         pj_cstr(&amp;name, header);</span>
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span><span class="lineCov">         96 :         return pjsip_msg_find_hdr_by_name(msg, &amp;name, NULL);</span>
<span class="lineNum">    1833 </span>            : }
<a name="1834"><span class="lineNum">    1834 </span>            : </a>
<span class="lineNum">    1835 </span>            : /* XXX This function is not used. */
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 : struct ast_sip_subscription *ast_sip_create_subscription(const struct ast_sip_subscription_handler *handler,</span>
<span class="lineNum">    1837 </span>            :                 struct ast_sip_endpoint *endpoint, const char *resource)
<span class="lineNum">    1838 </span>            : {
<span class="lineNum">    1839 </span>            :         struct ast_sip_subscription *sub;
<span class="lineNum">    1840 </span>            :         pjsip_dialog *dlg;
<span class="lineNum">    1841 </span>            :         struct ast_sip_contact *contact;
<span class="lineNum">    1842 </span>            :         pj_str_t event;
<span class="lineNum">    1843 </span>            :         pjsip_tx_data *tdata;
<span class="lineNum">    1844 </span>            :         pjsip_evsub *evsub;
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :         struct sip_subscription_tree *sub_tree = NULL;</span>
<span class="lineNum">    1846 </span>            : 
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :         sub_tree = allocate_subscription_tree(endpoint, NULL);</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :         if (!sub_tree) {</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1850 </span>            :         }
<span class="lineNum">    1851 </span>            : 
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :         sub = allocate_subscription(handler, resource, sub_tree);</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :         if (!sub) {</span>
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :                 ao2_cleanup(sub_tree);</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1856 </span>            :         }
<span class="lineNum">    1857 </span>            : 
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :         contact = ast_sip_location_retrieve_contact_from_aor_list(endpoint-&gt;aors);</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :         if (!contact || ast_strlen_zero(contact-&gt;uri)) {</span>
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;No contacts configured for endpoint %s. Unable to create SIP subsription\n&quot;,</span>
<span class="lineNum">    1861 </span>            :                                 ast_sorcery_object_get_id(endpoint));
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :                 ao2_ref(sub_tree, -1);</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :                 ao2_cleanup(contact);</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1865 </span>            :         }
<span class="lineNum">    1866 </span>            : 
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :         dlg = ast_sip_create_dialog_uac(endpoint, contact-&gt;uri, NULL);</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :         ao2_cleanup(contact);</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :         if (!dlg) {</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unable to create dialog for SIP subscription\n&quot;);</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :                 ao2_ref(sub_tree, -1);</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1873 </span>            :         }
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :         pj_cstr(&amp;event, handler-&gt;event_name);</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :         pjsip_evsub_create_uac(dlg, &amp;pubsub_cb, &amp;event, 0, &amp;sub_tree-&gt;evsub);</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :         subscription_setup_dialog(sub_tree, dlg);</span>
<span class="lineNum">    1878 </span>            : 
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :         evsub = sub_tree-&gt;evsub;</span>
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :         if (pjsip_evsub_initiate(evsub, NULL, -1, &amp;tdata) == PJ_SUCCESS) {</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :                 pjsip_evsub_send_request(sub_tree-&gt;evsub, tdata);</span>
<span class="lineNum">    1883 </span>            :         } else {
<span class="lineNum">    1884 </span>            :                 /* pjsip_evsub_terminate will result in pubsub_on_evsub_state,
<span class="lineNum">    1885 </span>            :                  * being called and terminating the subscription. Therefore, we don't
<span class="lineNum">    1886 </span>            :                  * need to decrease the reference count of sub here.
<span class="lineNum">    1887 </span>            :                  */
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :                 pjsip_evsub_terminate(evsub, PJ_TRUE);</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :                 ao2_ref(sub_tree, -1);</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1891 </span>            :         }
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :         add_subscription(sub_tree);</span>
<span class="lineNum">    1894 </span>            : 
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :         return sub;</span>
<a name="1896"><span class="lineNum">    1896 </span>            : }</a>
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span><span class="lineCov">         83 : pjsip_dialog *ast_sip_subscription_get_dialog(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    1899 </span>            : {
<span class="lineNum">    1900 </span><span class="lineCov">         83 :         ast_assert(sub-&gt;tree-&gt;dlg != NULL);</span>
<span class="lineNum">    1901 </span><span class="lineCov">         83 :         return sub-&gt;tree-&gt;dlg;</span>
<a name="1902"><span class="lineNum">    1902 </span>            : }</a>
<span class="lineNum">    1903 </span>            : 
<span class="lineNum">    1904 </span><span class="lineCov">        252 : struct ast_sip_endpoint *ast_sip_subscription_get_endpoint(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    1905 </span>            : {
<span class="lineNum">    1906 </span><span class="lineCov">        252 :         ast_assert(sub-&gt;tree-&gt;endpoint != NULL);</span>
<span class="lineNum">    1907 </span><span class="lineCov">        252 :         return ao2_bump(sub-&gt;tree-&gt;endpoint);</span>
<a name="1908"><span class="lineNum">    1908 </span>            : }</a>
<span class="lineNum">    1909 </span>            : 
<span class="lineNum">    1910 </span><span class="lineCov">        117 : struct ast_taskprocessor *ast_sip_subscription_get_serializer(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    1911 </span>            : {
<span class="lineNum">    1912 </span><span class="lineCov">        117 :         ast_assert(sub-&gt;tree-&gt;serializer != NULL);</span>
<span class="lineNum">    1913 </span><span class="lineCov">        117 :         return sub-&gt;tree-&gt;serializer;</span>
<span class="lineNum">    1914 </span>            : }
<span class="lineNum">    1915 </span>            : 
<span class="lineNum">    1916 </span>            : /*!
<span class="lineNum">    1917 </span>            :  * \brief Pre-allocate a buffer for the transmission
<span class="lineNum">    1918 </span>            :  *
<span class="lineNum">    1919 </span>            :  * Typically, we let PJSIP do this step for us when we send a request. PJSIP's buffer
<span class="lineNum">    1920 </span>            :  * allocation algorithm is to allocate a buffer of PJSIP_MAX_PKT_LEN bytes and attempt
<span class="lineNum">    1921 </span>            :  * to write the packet to the allocated buffer. If the buffer is too small to hold the
<span class="lineNum">    1922 </span>            :  * packet, then we get told the message is too long to be sent.
<span class="lineNum">    1923 </span>            :  *
<span class="lineNum">    1924 </span>            :  * When dealing with SIP NOTIFY, especially with RLS, it is possible to exceed
<span class="lineNum">    1925 </span>            :  * PJSIP_MAX_PKT_LEN. Rather than accepting the limitation imposed on us by default,
<span class="lineNum">    1926 </span>            :  * we instead take the strategy of pre-allocating the buffer, testing for ourselves
<span class="lineNum">    1927 </span>            :  * if the message will fit, and resizing the buffer as required.
<span class="lineNum">    1928 </span>            :  *
<span class="lineNum">    1929 </span>            :  * RFC 3261 says that a SIP UDP request can be up to 65535 bytes long. We're capping
<span class="lineNum">    1930 </span>            :  * it at 64000 for a couple of reasons:
<span class="lineNum">    1931 </span>            :  * 1) Allocating more than 64K at a time is hard to justify
<span class="lineNum">    1932 </span>            :  * 2) If the message goes through proxies, those proxies will want to add Via and
<span class="lineNum">    1933 </span>            :  *    Record-Route headers, making the message even larger. Giving some space for
<span class="lineNum">    1934 </span>            :  *    those headers is a nice thing to do.
<span class="lineNum">    1935 </span>            :  *
<span class="lineNum">    1936 </span>            :  * RFC 3261 does not place an upper limit on the size of TCP requests, but we are
<span class="lineNum">    1937 </span>            :  * going to impose the same 64K limit as a memory savings.
<span class="lineNum">    1938 </span>            :  *
<span class="lineNum">    1939 </span>            :  * \param tdata The tdata onto which to allocate a buffer
<span class="lineNum">    1940 </span>            :  * \retval 0 Success
<a name="1941"><span class="lineNum">    1941 </span>            :  * \retval -1 The message is too large</a>
<span class="lineNum">    1942 </span>            :  */
<span class="lineNum">    1943 </span><span class="lineCov">        189 : static int allocate_tdata_buffer(pjsip_tx_data *tdata)</span>
<span class="lineNum">    1944 </span>            : {
<span class="lineNum">    1945 </span>            :         int buf_size;
<span class="lineNum">    1946 </span><span class="lineCov">        189 :         int size = -1;</span>
<span class="lineNum">    1947 </span>            :         char *buf;
<span class="lineNum">    1948 </span>            : 
<span class="lineNum">    1949 </span><span class="lineCov">        378 :         for (buf_size = PJSIP_MAX_PKT_LEN; size == -1 &amp;&amp; buf_size &lt; 64000; buf_size *= 2) {</span>
<span class="lineNum">    1950 </span><span class="lineCov">        189 :                 buf = pj_pool_alloc(tdata-&gt;pool, buf_size);</span>
<span class="lineNum">    1951 </span><span class="lineCov">        189 :                 size = pjsip_msg_print(tdata-&gt;msg, buf, buf_size);</span>
<span class="lineNum">    1952 </span>            :         }
<span class="lineNum">    1953 </span>            : 
<span class="lineNum">    1954 </span><span class="lineCov">        189 :         if (size == -1) {</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    1956 </span>            :         }
<span class="lineNum">    1957 </span>            : 
<span class="lineNum">    1958 </span><span class="lineCov">        189 :         tdata-&gt;buf.start = buf;</span>
<span class="lineNum">    1959 </span><span class="lineCov">        189 :         tdata-&gt;buf.cur = tdata-&gt;buf.start;</span>
<span class="lineNum">    1960 </span><span class="lineCov">        189 :         tdata-&gt;buf.end = tdata-&gt;buf.start + buf_size;</span>
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span><span class="lineCov">        189 :         return 0;</span>
<a name="1963"><span class="lineNum">    1963 </span>            : }</a>
<span class="lineNum">    1964 </span>            : 
<span class="lineNum">    1965 </span><span class="lineCov">        189 : static int sip_subscription_send_request(struct sip_subscription_tree *sub_tree, pjsip_tx_data *tdata)</span>
<span class="lineNum">    1966 </span>            : {
<span class="lineNum">    1967 </span>            : #ifdef TEST_FRAMEWORK
<span class="lineNum">    1968 </span><span class="lineCov">        189 :         struct ast_sip_endpoint *endpoint = sub_tree-&gt;endpoint;</span>
<span class="lineNum">    1969 </span><span class="lineCov">        189 :         pjsip_evsub *evsub = sub_tree-&gt;evsub;</span>
<span class="lineNum">    1970 </span>            : #endif
<span class="lineNum">    1971 </span>            :         int res;
<span class="lineNum">    1972 </span>            : 
<span class="lineNum">    1973 </span><span class="lineCov">        189 :         if (allocate_tdata_buffer(tdata)) {</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;SIP request %s is too large to send.\n&quot;, tdata-&gt;info);</span>
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :                 pjsip_tx_data_dec_ref(tdata);</span>
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    1977 </span>            :         }
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span><span class="lineCov">        189 :         res = pjsip_evsub_send_request(sub_tree-&gt;evsub, tdata);</span>
<span class="lineNum">    1980 </span>            : 
<span class="lineNum">    1981 </span><span class="lineCov">        189 :         subscription_persistence_update(sub_tree, NULL, SUBSCRIPTION_PERSISTENCE_SEND_REQUEST);</span>
<span class="lineNum">    1982 </span>            : 
<span class="lineNum">    1983 </span><span class="lineCov">        189 :         ast_test_suite_event_notify(&quot;SUBSCRIPTION_STATE_SET&quot;,</span>
<span class="lineNum">    1984 </span>            :                 &quot;StateText: %s\r\n&quot;
<span class="lineNum">    1985 </span>            :                 &quot;Endpoint: %s\r\n&quot;,
<span class="lineNum">    1986 </span>            :                 pjsip_evsub_get_state_name(evsub),
<span class="lineNum">    1987 </span>            :                 ast_sorcery_object_get_id(endpoint));
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span><span class="lineCov">        189 :         return (res == PJ_SUCCESS ? 0 : -1);</span>
<span class="lineNum">    1990 </span>            : }
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span>            : /*!
<span class="lineNum">    1993 </span>            :  * \brief Add a resource XML element to an RLMI body
<span class="lineNum">    1994 </span>            :  *
<span class="lineNum">    1995 </span>            :  * Each resource element represents a subscribed resource in the list. This function currently
<span class="lineNum">    1996 </span>            :  * will unconditionally add an instance element to each created resource element. Instance
<span class="lineNum">    1997 </span>            :  * elements refer to later parts in the multipart body.
<span class="lineNum">    1998 </span>            :  *
<span class="lineNum">    1999 </span>            :  * \param pool PJLIB allocation pool
<span class="lineNum">    2000 </span>            :  * \param cid Content-ID header of the resource
<span class="lineNum">    2001 </span>            :  * \param resource_name Name of the resource
<span class="lineNum">    2002 </span>            :  * \param resource_uri URI of the resource
<a name="2003"><span class="lineNum">    2003 </span>            :  * \param state State of the subscribed resource</a>
<span class="lineNum">    2004 </span>            :  */
<span class="lineNum">    2005 </span><span class="lineCov">        289 : static void add_rlmi_resource(pj_pool_t *pool, pj_xml_node *rlmi, const pjsip_generic_string_hdr *cid,</span>
<span class="lineNum">    2006 </span>            :                 const char *resource_name, const pjsip_sip_uri *resource_uri, pjsip_evsub_state state)
<span class="lineNum">    2007 </span>            : {
<span class="lineNum">    2008 </span>            :         static pj_str_t cid_name = { &quot;cid&quot;, 3 };
<span class="lineNum">    2009 </span>            :         pj_xml_node *resource;
<span class="lineNum">    2010 </span>            :         pj_xml_node *name;
<span class="lineNum">    2011 </span>            :         pj_xml_node *instance;
<span class="lineNum">    2012 </span>            :         pj_xml_attr *cid_attr;
<span class="lineNum">    2013 </span>            :         char id[6];
<span class="lineNum">    2014 </span>            :         char uri[PJSIP_MAX_URL_SIZE];
<span class="lineNum">    2015 </span>            : 
<span class="lineNum">    2016 </span>            :         /* This creates a string representing the Content-ID without the enclosing &lt; &gt; */
<span class="lineNum">    2017 </span><span class="lineCov">        578 :         const pj_str_t cid_stripped = {</span>
<span class="lineNum">    2018 </span><span class="lineCov">        289 :                 .ptr = cid-&gt;hvalue.ptr + 1,</span>
<span class="lineNum">    2019 </span><span class="lineCov">        289 :                 .slen = cid-&gt;hvalue.slen - 2,</span>
<span class="lineNum">    2020 </span>            :         };
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span><span class="lineCov">        289 :         resource = ast_sip_presence_xml_create_node(pool, rlmi, &quot;resource&quot;);</span>
<span class="lineNum">    2023 </span><span class="lineCov">        289 :         name = ast_sip_presence_xml_create_node(pool, resource, &quot;name&quot;);</span>
<span class="lineNum">    2024 </span><span class="lineCov">        289 :         instance = ast_sip_presence_xml_create_node(pool, resource, &quot;instance&quot;);</span>
<span class="lineNum">    2025 </span>            : 
<span class="lineNum">    2026 </span><span class="lineCov">        289 :         pjsip_uri_print(PJSIP_URI_IN_CONTACT_HDR, resource_uri, uri, sizeof(uri));</span>
<span class="lineNum">    2027 </span><span class="lineCov">        289 :         ast_sip_presence_xml_create_attr(pool, resource, &quot;uri&quot;, uri);</span>
<span class="lineNum">    2028 </span>            : 
<span class="lineNum">    2029 </span><span class="lineCov">        289 :         pj_strdup2(pool, &amp;name-&gt;content, resource_name);</span>
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span><span class="lineCov">        289 :         ast_generate_random_string(id, sizeof(id));</span>
<span class="lineNum">    2032 </span>            : 
<span class="lineNum">    2033 </span><span class="lineCov">        289 :         ast_sip_presence_xml_create_attr(pool, instance, &quot;id&quot;, id);</span>
<span class="lineNum">    2034 </span><span class="lineCov">        289 :         ast_sip_presence_xml_create_attr(pool, instance, &quot;state&quot;,</span>
<span class="lineNum">    2035 </span>            :                         state == PJSIP_EVSUB_STATE_TERMINATED ? &quot;terminated&quot; : &quot;active&quot;);
<span class="lineNum">    2036 </span>            : 
<span class="lineNum">    2037 </span>            :         /* Use the PJLIB-util XML library directly here since we are using a
<span class="lineNum">    2038 </span>            :          * pj_str_t
<span class="lineNum">    2039 </span>            :          */
<span class="lineNum">    2040 </span>            : 
<span class="lineNum">    2041 </span><span class="lineCov">        289 :         cid_attr = pj_xml_attr_new(pool, &amp;cid_name, &amp;cid_stripped);</span>
<span class="lineNum">    2042 </span><span class="lineCov">        289 :         pj_xml_add_attr(instance, cid_attr);</span>
<span class="lineNum">    2043 </span><span class="lineCov">        289 : }</span>
<span class="lineNum">    2044 </span>            : 
<span class="lineNum">    2045 </span>            : /*!
<span class="lineNum">    2046 </span>            :  * \brief A multipart body part and meta-information
<span class="lineNum">    2047 </span>            :  *
<span class="lineNum">    2048 </span>            :  * When creating a multipart body part, the end result (the
<span class="lineNum">    2049 </span>            :  * pjsip_multipart_part) is hard to inspect without undoing
<span class="lineNum">    2050 </span>            :  * a lot of what was done to create it. Therefore, we use this
<span class="lineNum">    2051 </span>            :  * structure to store meta-information about the body part.
<span class="lineNum">    2052 </span>            :  *
<span class="lineNum">    2053 </span>            :  * The main consumer of this is the creator of the RLMI body
<span class="lineNum">    2054 </span>            :  * part of a multipart resource list body.
<span class="lineNum">    2055 </span>            :  */
<span class="lineNum">    2056 </span>            : struct body_part {
<span class="lineNum">    2057 </span>            :         /*! Content-ID header for the body part */
<span class="lineNum">    2058 </span>            :         pjsip_generic_string_hdr *cid;
<span class="lineNum">    2059 </span>            :         /*! Subscribed resource represented in the body part */
<span class="lineNum">    2060 </span>            :         const char *resource;
<span class="lineNum">    2061 </span>            :         /*! URI for the subscribed body part */
<span class="lineNum">    2062 </span>            :         pjsip_sip_uri *uri;
<span class="lineNum">    2063 </span>            :         /*! Subscription state of the resource represented in the body part */
<span class="lineNum">    2064 </span>            :         pjsip_evsub_state state;
<span class="lineNum">    2065 </span>            :         /*! The actual body part that will be present in the multipart body */
<span class="lineNum">    2066 </span>            :         pjsip_multipart_part *part;
<span class="lineNum">    2067 </span>            : };
<span class="lineNum">    2068 </span>            : 
<span class="lineNum">    2069 </span>            : /*!
<span class="lineNum">    2070 </span>            :  * \brief Type declaration for container of body part structures
<span class="lineNum">    2071 </span>            :  */
<span class="lineNum">    2072 </span>            : AST_VECTOR(body_part_list, struct body_part *);
<span class="lineNum">    2073 </span>            : 
<span class="lineNum">    2074 </span>            : /*!
<span class="lineNum">    2075 </span>            :  * \brief Create a Content-ID header
<span class="lineNum">    2076 </span>            :  *
<span class="lineNum">    2077 </span>            :  * Content-ID headers are required by RFC2387 for multipart/related
<span class="lineNum">    2078 </span>            :  * bodies. They serve as identifiers for each part of the multipart body.
<span class="lineNum">    2079 </span>            :  *
<span class="lineNum">    2080 </span>            :  * \param pool PJLIB allocation pool
<a name="2081"><span class="lineNum">    2081 </span>            :  * \param sub Subscription to a resource</a>
<span class="lineNum">    2082 </span>            :  */
<span class="lineNum">    2083 </span><span class="lineCov">        516 : static pjsip_generic_string_hdr *generate_content_id_hdr(pj_pool_t *pool,</span>
<span class="lineNum">    2084 </span>            :                 const struct ast_sip_subscription *sub)
<span class="lineNum">    2085 </span>            : {
<span class="lineNum">    2086 </span>            :         static const pj_str_t cid_name = { &quot;Content-ID&quot;, 10 };
<span class="lineNum">    2087 </span>            :         pjsip_generic_string_hdr *cid;
<span class="lineNum">    2088 </span>            :         char id[6];
<span class="lineNum">    2089 </span>            :         size_t alloc_size;
<span class="lineNum">    2090 </span>            :         pj_str_t cid_value;
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            :         /* '&lt;' + '@' + '&gt;' = 3. pj_str_t does not require a null-terminator */
<span class="lineNum">    2093 </span><span class="lineCov">        516 :         alloc_size = sizeof(id) + pj_strlen(&amp;sub-&gt;uri-&gt;host) + 3;</span>
<span class="lineNum">    2094 </span><span class="lineCov">        516 :         cid_value.ptr = pj_pool_alloc(pool, alloc_size);</span>
<span class="lineNum">    2095 </span><span class="lineCov">        516 :         cid_value.slen = sprintf(cid_value.ptr, &quot;&lt;%s@%.*s&gt;&quot;,</span>
<span class="lineNum">    2096 </span>            :                         ast_generate_random_string(id, sizeof(id)),
<span class="lineNum">    2097 </span><span class="lineCov">        516 :                         (int) pj_strlen(&amp;sub-&gt;uri-&gt;host), pj_strbuf(&amp;sub-&gt;uri-&gt;host));</span>
<span class="lineNum">    2098 </span><span class="lineCov">        516 :         cid = pjsip_generic_string_hdr_create(pool, &amp;cid_name, &amp;cid_value);</span>
<span class="lineNum">    2099 </span>            : 
<span class="lineNum">    2100 </span><span class="lineCov">        516 :         return cid;</span>
<a name="2101"><span class="lineNum">    2101 </span>            : }</a>
<span class="lineNum">    2102 </span>            : 
<span class="lineNum">    2103 </span><span class="lineCov">        349 : static int rlmi_print_body(struct pjsip_msg_body *msg_body, char *buf, pj_size_t size)</span>
<span class="lineNum">    2104 </span>            : {
<span class="lineNum">    2105 </span>            :         int num_printed;
<span class="lineNum">    2106 </span><span class="lineCov">        349 :         pj_xml_node *rlmi = msg_body-&gt;data;</span>
<span class="lineNum">    2107 </span>            : 
<span class="lineNum">    2108 </span><span class="lineCov">        349 :         num_printed = pj_xml_print(rlmi, buf, size, PJ_TRUE);</span>
<span class="lineNum">    2109 </span><span class="lineCov">        349 :         if (num_printed &lt;= AST_PJSIP_XML_PROLOG_LEN) {</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2111 </span>            :         }
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span><span class="lineCov">        349 :         return num_printed;</span>
<a name="2114"><span class="lineNum">    2114 </span>            : }</a>
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 : static void *rlmi_clone_data(pj_pool_t *pool, const void *data, unsigned len)</span>
<span class="lineNum">    2117 </span>            : {
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :         const pj_xml_node *rlmi = data;</span>
<span class="lineNum">    2119 </span>            : 
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :         return pj_xml_clone(pool, rlmi);</span>
<span class="lineNum">    2121 </span>            : }
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span>            : /*!
<span class="lineNum">    2124 </span>            :  * \brief Create an RLMI body part for a multipart resource list body
<span class="lineNum">    2125 </span>            :  *
<span class="lineNum">    2126 </span>            :  * RLMI (Resource list meta information) is a special body type that lists
<span class="lineNum">    2127 </span>            :  * the subscribed resources and tells subscribers the number of subscribed
<span class="lineNum">    2128 </span>            :  * resources and what other body parts are in the multipart body. The
<span class="lineNum">    2129 </span>            :  * RLMI body also has a version number that a subscriber can use to ensure
<span class="lineNum">    2130 </span>            :  * that the locally-stored state corresponds to server state.
<span class="lineNum">    2131 </span>            :  *
<span class="lineNum">    2132 </span>            :  * \param pool The allocation pool
<span class="lineNum">    2133 </span>            :  * \param sub The subscription representing the subscribed resource list
<span class="lineNum">    2134 </span>            :  * \param body_parts A container of body parts that RLMI will refer to
<span class="lineNum">    2135 </span>            :  * \param full_state Indicates whether this is a full or partial state notification
<a name="2136"><span class="lineNum">    2136 </span>            :  * \return The multipart part representing the RLMI body</a>
<span class="lineNum">    2137 </span>            :  */
<span class="lineNum">    2138 </span><span class="lineCov">        160 : static pjsip_multipart_part *build_rlmi_body(pj_pool_t *pool, struct ast_sip_subscription *sub,</span>
<span class="lineNum">    2139 </span>            :                 struct body_part_list *body_parts, unsigned int full_state)
<span class="lineNum">    2140 </span>            : {
<span class="lineNum">    2141 </span>            :         pj_xml_node *rlmi;
<span class="lineNum">    2142 </span>            :         pj_xml_node *name;
<span class="lineNum">    2143 </span>            :         pjsip_multipart_part *rlmi_part;
<span class="lineNum">    2144 </span>            :         char version_str[32];
<span class="lineNum">    2145 </span>            :         char uri[PJSIP_MAX_URL_SIZE];
<span class="lineNum">    2146 </span>            :         pjsip_generic_string_hdr *cid;
<span class="lineNum">    2147 </span>            :         int i;
<span class="lineNum">    2148 </span>            : 
<span class="lineNum">    2149 </span><span class="lineCov">        160 :         rlmi = ast_sip_presence_xml_create_node(pool, NULL, &quot;list&quot;);</span>
<span class="lineNum">    2150 </span><span class="lineCov">        160 :         ast_sip_presence_xml_create_attr(pool, rlmi, &quot;xmlns&quot;, &quot;urn:ietf:params:xml:ns:rlmi&quot;);</span>
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span><span class="lineCov">        160 :         ast_sip_subscription_get_local_uri(sub, uri, sizeof(uri));</span>
<span class="lineNum">    2153 </span><span class="lineCov">        160 :         ast_sip_presence_xml_create_attr(pool, rlmi, &quot;uri&quot;, uri);</span>
<span class="lineNum">    2154 </span>            : 
<span class="lineNum">    2155 </span><span class="lineCov">        160 :         snprintf(version_str, sizeof(version_str), &quot;%u&quot;, sub-&gt;version++);</span>
<span class="lineNum">    2156 </span><span class="lineCov">        160 :         ast_sip_presence_xml_create_attr(pool, rlmi, &quot;version&quot;, version_str);</span>
<span class="lineNum">    2157 </span><span class="lineCov">        160 :         ast_sip_presence_xml_create_attr(pool, rlmi, &quot;fullState&quot;, full_state ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="lineNum">    2158 </span>            : 
<span class="lineNum">    2159 </span><span class="lineCov">        160 :         name = ast_sip_presence_xml_create_node(pool, rlmi, &quot;name&quot;);</span>
<span class="lineNum">    2160 </span><span class="lineCov">        160 :         pj_strdup2(pool, &amp;name-&gt;content, ast_sip_subscription_get_resource_name(sub));</span>
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span><span class="lineCov">        449 :         for (i = 0; i &lt; AST_VECTOR_SIZE(body_parts); ++i) {</span>
<span class="lineNum">    2163 </span><span class="lineCov">        289 :                 const struct body_part *part = AST_VECTOR_GET(body_parts, i);</span>
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span><span class="lineCov">        289 :                 add_rlmi_resource(pool, rlmi, part-&gt;cid, part-&gt;resource, part-&gt;uri, part-&gt;state);</span>
<span class="lineNum">    2166 </span>            :         }
<span class="lineNum">    2167 </span>            : 
<span class="lineNum">    2168 </span><span class="lineCov">        160 :         rlmi_part = pjsip_multipart_create_part(pool);</span>
<span class="lineNum">    2169 </span>            : 
<span class="lineNum">    2170 </span><span class="lineCov">        160 :         rlmi_part-&gt;body = PJ_POOL_ZALLOC_T(pool, pjsip_msg_body);</span>
<span class="lineNum">    2171 </span><span class="lineCov">        160 :         pjsip_media_type_cp(pool, &amp;rlmi_part-&gt;body-&gt;content_type, &amp;rlmi_media_type);</span>
<span class="lineNum">    2172 </span>            : 
<span class="lineNum">    2173 </span><span class="lineCov">        160 :         rlmi_part-&gt;body-&gt;data = pj_xml_clone(pool, rlmi);</span>
<span class="lineNum">    2174 </span><span class="lineCov">        160 :         rlmi_part-&gt;body-&gt;clone_data = rlmi_clone_data;</span>
<span class="lineNum">    2175 </span><span class="lineCov">        160 :         rlmi_part-&gt;body-&gt;print_body = rlmi_print_body;</span>
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span><span class="lineCov">        160 :         cid = generate_content_id_hdr(pool, sub);</span>
<span class="lineNum">    2178 </span><span class="lineCov">        160 :         pj_list_insert_before(&amp;rlmi_part-&gt;hdr, cid);</span>
<span class="lineNum">    2179 </span>            : 
<span class="lineNum">    2180 </span><span class="lineCov">        160 :         return rlmi_part;</span>
<span class="lineNum">    2181 </span>            : }
<span class="lineNum">    2182 </span>            : 
<span class="lineNum">    2183 </span>            : static pjsip_msg_body *generate_notify_body(pj_pool_t *pool, struct ast_sip_subscription *root,
<span class="lineNum">    2184 </span>            :                 unsigned int force_full_state);
<span class="lineNum">    2185 </span>            : 
<span class="lineNum">    2186 </span>            : /*!
<span class="lineNum">    2187 </span>            :  * \brief Destroy a list of body parts
<span class="lineNum">    2188 </span>            :  *
<a name="2189"><span class="lineNum">    2189 </span>            :  * \param parts The container of parts to destroy</a>
<span class="lineNum">    2190 </span>            :  */
<span class="lineNum">    2191 </span><span class="lineCov">        167 : static void free_body_parts(struct body_part_list *parts)</span>
<span class="lineNum">    2192 </span>            : {
<span class="lineNum">    2193 </span>            :         int i;
<span class="lineNum">    2194 </span>            : 
<span class="lineNum">    2195 </span><span class="lineCov">        456 :         for (i = 0; i &lt; AST_VECTOR_SIZE(parts); ++i) {</span>
<span class="lineNum">    2196 </span><span class="lineCov">        289 :                 struct body_part *part = AST_VECTOR_GET(parts, i);</span>
<span class="lineNum">    2197 </span><span class="lineCov">        289 :                 ast_free(part);</span>
<span class="lineNum">    2198 </span>            :         }
<span class="lineNum">    2199 </span>            : 
<span class="lineNum">    2200 </span><span class="lineCov">        167 :         AST_VECTOR_FREE(parts);</span>
<span class="lineNum">    2201 </span><span class="lineCov">        167 : }</span>
<span class="lineNum">    2202 </span>            : 
<span class="lineNum">    2203 </span>            : /*!
<span class="lineNum">    2204 </span>            :  * \brief Allocate and initialize a body part structure
<span class="lineNum">    2205 </span>            :  *
<span class="lineNum">    2206 </span>            :  * \param pool PJLIB allocation pool
<a name="2207"><span class="lineNum">    2207 </span>            :  * \param sub Subscription representing a subscribed resource</a>
<span class="lineNum">    2208 </span>            :  */
<span class="lineNum">    2209 </span><span class="lineCov">        356 : static struct body_part *allocate_body_part(pj_pool_t *pool, const struct ast_sip_subscription *sub)</span>
<span class="lineNum">    2210 </span>            : {
<span class="lineNum">    2211 </span>            :         struct body_part *bp;
<span class="lineNum">    2212 </span>            : 
<span class="lineNum">    2213 </span><span class="lineCov">        356 :         bp = ast_calloc(1, sizeof(*bp));</span>
<span class="lineNum">    2214 </span><span class="lineCov">        356 :         if (!bp) {</span>
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    2216 </span>            :         }
<span class="lineNum">    2217 </span>            : 
<span class="lineNum">    2218 </span><span class="lineCov">        356 :         bp-&gt;cid = generate_content_id_hdr(pool, sub);</span>
<span class="lineNum">    2219 </span><span class="lineCov">        356 :         bp-&gt;resource = sub-&gt;resource;</span>
<span class="lineNum">    2220 </span><span class="lineCov">        356 :         bp-&gt;state = sub-&gt;subscription_state;</span>
<span class="lineNum">    2221 </span><span class="lineCov">        356 :         bp-&gt;uri = sub-&gt;uri;</span>
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span><span class="lineCov">        356 :         return bp;</span>
<span class="lineNum">    2224 </span>            : }
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span>            : /*!
<span class="lineNum">    2227 </span>            :  * \brief Create a multipart body part for a subscribed resource
<span class="lineNum">    2228 </span>            :  *
<span class="lineNum">    2229 </span>            :  * \param pool PJLIB allocation pool
<span class="lineNum">    2230 </span>            :  * \param sub The subscription representing a subscribed resource
<span class="lineNum">    2231 </span>            :  * \param parts A vector of parts to append the created part to.
<a name="2232"><span class="lineNum">    2232 </span>            :  * \param use_full_state Unused locally, but may be passed to other functions</a>
<span class="lineNum">    2233 </span>            :  */
<span class="lineNum">    2234 </span><span class="lineCov">        356 : static void build_body_part(pj_pool_t *pool, struct ast_sip_subscription *sub,</span>
<span class="lineNum">    2235 </span>            :                 struct body_part_list *parts, unsigned int use_full_state)
<span class="lineNum">    2236 </span>            : {
<span class="lineNum">    2237 </span>            :         struct body_part *bp;
<span class="lineNum">    2238 </span>            :         pjsip_msg_body *body;
<span class="lineNum">    2239 </span>            : 
<span class="lineNum">    2240 </span><span class="lineCov">        356 :         bp = allocate_body_part(pool, sub);</span>
<span class="lineNum">    2241 </span><span class="lineCov">        356 :         if (!bp) {</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    2243 </span>            :         }
<span class="lineNum">    2244 </span>            : 
<span class="lineNum">    2245 </span><span class="lineCov">        356 :         body = generate_notify_body(pool, sub, use_full_state);</span>
<span class="lineNum">    2246 </span><span class="lineCov">        356 :         if (!body) {</span>
<span class="lineNum">    2247 </span>            :                 /* Partial state was requested and the resource has not changed state */
<span class="lineNum">    2248 </span><span class="lineCov">         67 :                 ast_free(bp);</span>
<span class="lineNum">    2249 </span><span class="lineCov">         67 :                 return;</span>
<span class="lineNum">    2250 </span>            :         }
<span class="lineNum">    2251 </span>            : 
<span class="lineNum">    2252 </span><span class="lineCov">        289 :         bp-&gt;part = pjsip_multipart_create_part(pool);</span>
<span class="lineNum">    2253 </span><span class="lineCov">        289 :         bp-&gt;part-&gt;body = body;</span>
<span class="lineNum">    2254 </span><span class="lineCov">        289 :         pj_list_insert_before(&amp;bp-&gt;part-&gt;hdr, bp-&gt;cid);</span>
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span><span class="lineCov">        289 :         if (AST_VECTOR_APPEND(parts, bp)) {</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :                 ast_free(bp);</span>
<span class="lineNum">    2258 </span>            :         }
<span class="lineNum">    2259 </span>            : }
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span>            : /*!
<span class="lineNum">    2262 </span>            :  * \brief Create and initialize the PJSIP multipart body structure for a resource list subscription
<span class="lineNum">    2263 </span>            :  *
<span class="lineNum">    2264 </span>            :  * \param pool
<a name="2265"><span class="lineNum">    2265 </span>            :  * \return The multipart message body</a>
<span class="lineNum">    2266 </span>            :  */
<span class="lineNum">    2267 </span><span class="lineCov">        160 : static pjsip_msg_body *create_multipart_body(pj_pool_t *pool)</span>
<span class="lineNum">    2268 </span>            : {
<span class="lineNum">    2269 </span>            :         pjsip_media_type media_type;
<span class="lineNum">    2270 </span>            :         pjsip_param *media_type_param;
<span class="lineNum">    2271 </span>            :         char boundary[6];
<span class="lineNum">    2272 </span>            :         pj_str_t pj_boundary;
<span class="lineNum">    2273 </span>            : 
<span class="lineNum">    2274 </span><span class="lineCov">        160 :         pjsip_media_type_init2(&amp;media_type, &quot;multipart&quot;, &quot;related&quot;);</span>
<span class="lineNum">    2275 </span>            : 
<span class="lineNum">    2276 </span><span class="lineCov">        160 :         media_type_param = pj_pool_alloc(pool, sizeof(*media_type_param));</span>
<span class="lineNum">    2277 </span><span class="lineCov">        160 :         pj_list_init(media_type_param);</span>
<span class="lineNum">    2278 </span>            : 
<span class="lineNum">    2279 </span><span class="lineCov">        160 :         pj_strdup2(pool, &amp;media_type_param-&gt;name, &quot;type&quot;);</span>
<span class="lineNum">    2280 </span><span class="lineCov">        160 :         pj_strdup2(pool, &amp;media_type_param-&gt;value, &quot;\&quot;application/rlmi+xml\&quot;&quot;);</span>
<span class="lineNum">    2281 </span>            : 
<span class="lineNum">    2282 </span><span class="lineCov">        160 :         pj_list_insert_before(&amp;media_type.param, media_type_param);</span>
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span><span class="lineCov">        160 :         pj_cstr(&amp;pj_boundary, ast_generate_random_string(boundary, sizeof(boundary)));</span>
<span class="lineNum">    2285 </span><span class="lineCov">        160 :         return pjsip_multipart_create(pool, &amp;media_type, &amp;pj_boundary);</span>
<span class="lineNum">    2286 </span>            : }
<span class="lineNum">    2287 </span>            : 
<span class="lineNum">    2288 </span>            : /*!
<span class="lineNum">    2289 </span>            :  * \brief Create a resource list body for NOTIFY requests
<span class="lineNum">    2290 </span>            :  *
<span class="lineNum">    2291 </span>            :  * Resource list bodies are multipart/related bodies. The first part of the multipart body
<span class="lineNum">    2292 </span>            :  * is an RLMI body that describes the rest of the parts to come. The other parts of the body
<span class="lineNum">    2293 </span>            :  * convey state of individual subscribed resources.
<span class="lineNum">    2294 </span>            :  *
<span class="lineNum">    2295 </span>            :  * \param pool PJLIB allocation pool
<span class="lineNum">    2296 </span>            :  * \param sub Subscription details from which to generate body
<span class="lineNum">    2297 </span>            :  * \param force_full_state If true, ignore resource list settings and send a full state notification
<a name="2298"><span class="lineNum">    2298 </span>            :  * \return The generated multipart/related body</a>
<span class="lineNum">    2299 </span>            :  */
<span class="lineNum">    2300 </span><span class="lineCov">        167 : static pjsip_msg_body *generate_list_body(pj_pool_t *pool, struct ast_sip_subscription *sub,</span>
<span class="lineNum">    2301 </span>            :                 unsigned int force_full_state)
<span class="lineNum">    2302 </span>            : {
<span class="lineNum">    2303 </span>            :         int i;
<span class="lineNum">    2304 </span>            :         pjsip_multipart_part *rlmi_part;
<span class="lineNum">    2305 </span>            :         pjsip_msg_body *multipart;
<span class="lineNum">    2306 </span>            :         struct body_part_list body_parts;
<span class="lineNum">    2307 </span><span class="lineCov">        167 :         unsigned int use_full_state = force_full_state ? 1 : sub-&gt;full_state;</span>
<span class="lineNum">    2308 </span>            : 
<span class="lineNum">    2309 </span><span class="lineCov">        167 :         if (AST_VECTOR_INIT(&amp;body_parts, AST_VECTOR_SIZE(&amp;sub-&gt;children))) {</span>
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    2311 </span>            :         }
<span class="lineNum">    2312 </span>            : 
<span class="lineNum">    2313 </span><span class="lineCov">        523 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;sub-&gt;children); ++i) {</span>
<span class="lineNum">    2314 </span><span class="lineCov">        356 :                 build_body_part(pool, AST_VECTOR_GET(&amp;sub-&gt;children, i), &amp;body_parts, use_full_state);</span>
<span class="lineNum">    2315 </span>            :         }
<span class="lineNum">    2316 </span>            : 
<span class="lineNum">    2317 </span>            :         /* This can happen if issuing partial state and no children of the list have changed state */
<span class="lineNum">    2318 </span><span class="lineCov">        167 :         if (AST_VECTOR_SIZE(&amp;body_parts) == 0) {</span>
<span class="lineNum">    2319 </span><span class="lineCov">          7 :                 free_body_parts(&amp;body_parts);</span>
<span class="lineNum">    2320 </span><span class="lineCov">          7 :                 return NULL;</span>
<span class="lineNum">    2321 </span>            :         }
<span class="lineNum">    2322 </span>            : 
<span class="lineNum">    2323 </span><span class="lineCov">        160 :         multipart = create_multipart_body(pool);</span>
<span class="lineNum">    2324 </span>            : 
<span class="lineNum">    2325 </span><span class="lineCov">        160 :         rlmi_part = build_rlmi_body(pool, sub, &amp;body_parts, use_full_state);</span>
<span class="lineNum">    2326 </span><span class="lineCov">        160 :         if (!rlmi_part) {</span>
<span class="lineNum">    2327 </span><span class="lineNoCov">          0 :                 free_body_parts(&amp;body_parts);</span>
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    2329 </span>            :         }
<span class="lineNum">    2330 </span><span class="lineCov">        160 :         pjsip_multipart_add_part(pool, multipart, rlmi_part);</span>
<span class="lineNum">    2331 </span>            : 
<span class="lineNum">    2332 </span><span class="lineCov">        449 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;body_parts); ++i) {</span>
<span class="lineNum">    2333 </span><span class="lineCov">        289 :                 pjsip_multipart_add_part(pool, multipart, AST_VECTOR_GET(&amp;body_parts, i)-&gt;part);</span>
<span class="lineNum">    2334 </span>            :         }
<span class="lineNum">    2335 </span>            : 
<span class="lineNum">    2336 </span><span class="lineCov">        160 :         free_body_parts(&amp;body_parts);</span>
<span class="lineNum">    2337 </span><span class="lineCov">        160 :         return multipart;</span>
<span class="lineNum">    2338 </span>            : }
<span class="lineNum">    2339 </span>            : 
<span class="lineNum">    2340 </span>            : /*!
<span class="lineNum">    2341 </span>            :  * \brief Create the body for a NOTIFY request.
<span class="lineNum">    2342 </span>            :  *
<span class="lineNum">    2343 </span>            :  * \param pool The pool used for allocations
<span class="lineNum">    2344 </span>            :  * \param root The root of the subscription tree
<a name="2345"><span class="lineNum">    2345 </span>            :  * \param force_full_state If true, ignore resource list settings and send a full state notification</a>
<span class="lineNum">    2346 </span>            :  */
<span class="lineNum">    2347 </span><span class="lineCov">        545 : static pjsip_msg_body *generate_notify_body(pj_pool_t *pool, struct ast_sip_subscription *root,</span>
<span class="lineNum">    2348 </span>            :                 unsigned int force_full_state)
<span class="lineNum">    2349 </span>            : {
<span class="lineNum">    2350 </span>            :         pjsip_msg_body *body;
<span class="lineNum">    2351 </span>            : 
<span class="lineNum">    2352 </span><span class="lineCov">        545 :         if (AST_VECTOR_SIZE(&amp;root-&gt;children) == 0) {</span>
<span class="lineNum">    2353 </span><span class="lineCov">        378 :                 if (force_full_state || root-&gt;body_changed) {</span>
<span class="lineNum">    2354 </span>            :                         /* Not a list. We've already generated the body and saved it on the subscription.
<span class="lineNum">    2355 </span>            :                          * Use that directly.
<span class="lineNum">    2356 </span>            :                          */
<span class="lineNum">    2357 </span>            :                         pj_str_t type;
<span class="lineNum">    2358 </span>            :                         pj_str_t subtype;
<span class="lineNum">    2359 </span>            :                         pj_str_t text;
<span class="lineNum">    2360 </span>            : 
<span class="lineNum">    2361 </span><span class="lineCov">        318 :                         pj_cstr(&amp;type, ast_sip_subscription_get_body_type(root));</span>
<span class="lineNum">    2362 </span><span class="lineCov">        318 :                         pj_cstr(&amp;subtype, ast_sip_subscription_get_body_subtype(root));</span>
<span class="lineNum">    2363 </span><span class="lineCov">        318 :                         pj_cstr(&amp;text, ast_str_buffer(root-&gt;body_text));</span>
<span class="lineNum">    2364 </span>            : 
<span class="lineNum">    2365 </span><span class="lineCov">        318 :                         body = pjsip_msg_body_create(pool, &amp;type, &amp;subtype, &amp;text);</span>
<span class="lineNum">    2366 </span><span class="lineCov">        318 :                         root-&gt;body_changed = 0;</span>
<span class="lineNum">    2367 </span>            :                 } else {
<span class="lineNum">    2368 </span><span class="lineCov">         60 :                         body = NULL;</span>
<span class="lineNum">    2369 </span>            :                 }
<span class="lineNum">    2370 </span>            :         } else {
<span class="lineNum">    2371 </span><span class="lineCov">        167 :                 body = generate_list_body(pool, root, force_full_state);</span>
<span class="lineNum">    2372 </span>            :         }
<span class="lineNum">    2373 </span>            : 
<span class="lineNum">    2374 </span><span class="lineCov">        545 :         return body;</span>
<span class="lineNum">    2375 </span>            : }
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span>            : /*!
<a name="2378"><span class="lineNum">    2378 </span>            :  * \brief Shortcut method to create a Require: eventlist header</a>
<span class="lineNum">    2379 </span>            :  */
<span class="lineNum">    2380 </span><span class="lineCov">        192 : static pjsip_require_hdr *create_require_eventlist(pj_pool_t *pool)</span>
<span class="lineNum">    2381 </span>            : {
<span class="lineNum">    2382 </span>            :         pjsip_require_hdr *require;
<span class="lineNum">    2383 </span>            : 
<span class="lineNum">    2384 </span><span class="lineCov">        192 :         require = pjsip_require_hdr_create(pool);</span>
<span class="lineNum">    2385 </span><span class="lineCov">        192 :         pj_strdup2(pool, &amp;require-&gt;values[0], &quot;eventlist&quot;);</span>
<span class="lineNum">    2386 </span><span class="lineCov">        192 :         require-&gt;count = 1;</span>
<span class="lineNum">    2387 </span>            : 
<span class="lineNum">    2388 </span><span class="lineCov">        192 :         return require;</span>
<span class="lineNum">    2389 </span>            : }
<span class="lineNum">    2390 </span>            : 
<span class="lineNum">    2391 </span>            : /*!
<span class="lineNum">    2392 </span>            :  * \brief Send a NOTIFY request to a subscriber
<span class="lineNum">    2393 </span>            :  *
<span class="lineNum">    2394 </span>            :  * \pre sub_tree-&gt;dlg is locked
<span class="lineNum">    2395 </span>            :  *
<span class="lineNum">    2396 </span>            :  * \param sub_tree The subscription tree representing the subscription
<span class="lineNum">    2397 </span>            :  * \param force_full_state If true, ignore resource list settings and send full resource list state.
<span class="lineNum">    2398 </span>            :  * \retval 0 Success
<a name="2399"><span class="lineNum">    2399 </span>            :  * \retval non-zero Failure</a>
<span class="lineNum">    2400 </span>            :  */
<span class="lineNum">    2401 </span><span class="lineCov">        203 : static int send_notify(struct sip_subscription_tree *sub_tree, unsigned int force_full_state)</span>
<span class="lineNum">    2402 </span>            : {
<span class="lineNum">    2403 </span><span class="lineCov">        203 :         pjsip_evsub *evsub = sub_tree-&gt;evsub;</span>
<span class="lineNum">    2404 </span>            :         pjsip_tx_data *tdata;
<span class="lineNum">    2405 </span>            : 
<span class="lineNum">    2406 </span><span class="lineCov">        203 :         if (ast_shutdown_final()</span>
<span class="lineNum">    2407 </span><span class="lineCov">         32 :                 &amp;&amp; sub_tree-&gt;root-&gt;subscription_state == PJSIP_EVSUB_STATE_TERMINATED</span>
<span class="lineNum">    2408 </span><span class="lineCov">         14 :                 &amp;&amp; sub_tree-&gt;persistence) {</span>
<span class="lineNum">    2409 </span><span class="lineCov">         14 :                 return 0;</span>
<span class="lineNum">    2410 </span>            :         }
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span><span class="lineCov">        189 :         if (pjsip_evsub_notify(evsub, sub_tree-&gt;root-&gt;subscription_state,</span>
<span class="lineNum">    2413 </span>            :                                 NULL, NULL, &amp;tdata) != PJ_SUCCESS) {
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2415 </span>            :         }
<span class="lineNum">    2416 </span>            : 
<span class="lineNum">    2417 </span><span class="lineCov">        189 :         tdata-&gt;msg-&gt;body = generate_notify_body(tdata-&gt;pool, sub_tree-&gt;root, force_full_state);</span>
<span class="lineNum">    2418 </span><span class="lineCov">        189 :         if (!tdata-&gt;msg-&gt;body) {</span>
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :                 pjsip_tx_data_dec_ref(tdata);</span>
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2421 </span>            :         }
<span class="lineNum">    2422 </span>            : 
<span class="lineNum">    2423 </span><span class="lineCov">        189 :         if (sub_tree-&gt;is_list) {</span>
<span class="lineNum">    2424 </span><span class="lineCov">        119 :                 pjsip_require_hdr *require = create_require_eventlist(tdata-&gt;pool);</span>
<span class="lineNum">    2425 </span><span class="lineCov">        119 :                 pjsip_msg_add_hdr(tdata-&gt;msg, (pjsip_hdr *) require);</span>
<span class="lineNum">    2426 </span>            :         }
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span><span class="lineCov">        189 :         if (sip_subscription_send_request(sub_tree, tdata)) {</span>
<span class="lineNum">    2429 </span>            :                 /* do not call pjsip_tx_data_dec_ref(tdata). The pjsip_dlg_send_request deletes the message on error */
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2431 </span>            :         }
<span class="lineNum">    2432 </span>            : 
<span class="lineNum">    2433 </span><span class="lineCov">        189 :         sub_tree-&gt;send_scheduled_notify = 0;</span>
<span class="lineNum">    2434 </span>            : 
<span class="lineNum">    2435 </span><span class="lineCov">        189 :         return 0;</span>
<a name="2436"><span class="lineNum">    2436 </span>            : }</a>
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span><span class="lineCov">         16 : static int serialized_send_notify(void *userdata)</span>
<span class="lineNum">    2439 </span>            : {
<span class="lineNum">    2440 </span><span class="lineCov">         16 :         struct sip_subscription_tree *sub_tree = userdata;</span>
<span class="lineNum">    2441 </span><span class="lineCov">         16 :         pjsip_dialog *dlg = sub_tree-&gt;dlg;</span>
<span class="lineNum">    2442 </span>            : 
<span class="lineNum">    2443 </span><span class="lineCov">         16 :         pjsip_dlg_inc_lock(dlg);</span>
<span class="lineNum">    2444 </span>            : 
<span class="lineNum">    2445 </span>            :         /* It's possible that between when the notification was scheduled
<span class="lineNum">    2446 </span>            :          * and now a new SUBSCRIBE arrived requiring full state to be
<span class="lineNum">    2447 </span>            :          * sent out in an immediate NOTIFY. It's also possible that we're
<span class="lineNum">    2448 </span>            :          * already processing a terminate.  If that has happened, we need to
<span class="lineNum">    2449 </span>            :          * bail out here instead of sending the batched NOTIFY.
<span class="lineNum">    2450 </span>            :          */
<span class="lineNum">    2451 </span>            : 
<span class="lineNum">    2452 </span><span class="lineCov">         16 :         if (sub_tree-&gt;state &gt;= SIP_SUB_TREE_TERMINATE_IN_PROGRESS</span>
<span class="lineNum">    2453 </span><span class="lineCov">         14 :                 || !sub_tree-&gt;send_scheduled_notify) {</span>
<span class="lineNum">    2454 </span><span class="lineCov">          4 :                 pjsip_dlg_dec_lock(dlg);</span>
<span class="lineNum">    2455 </span><span class="lineCov">          4 :                 ao2_cleanup(sub_tree);</span>
<span class="lineNum">    2456 </span><span class="lineCov">          4 :                 return 0;</span>
<span class="lineNum">    2457 </span>            :         }
<span class="lineNum">    2458 </span>            : 
<span class="lineNum">    2459 </span><span class="lineCov">         12 :         if (sub_tree-&gt;root-&gt;subscription_state == PJSIP_EVSUB_STATE_TERMINATED) {</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :                 sub_tree-&gt;state = SIP_SUB_TREE_TERMINATE_IN_PROGRESS;</span>
<span class="lineNum">    2461 </span>            :         }
<span class="lineNum">    2462 </span>            : 
<span class="lineNum">    2463 </span><span class="lineCov">         12 :         send_notify(sub_tree, 0);</span>
<span class="lineNum">    2464 </span>            : 
<span class="lineNum">    2465 </span><span class="lineCov">         12 :         ast_test_suite_event_notify(</span>
<span class="lineNum">    2466 </span>            :                 sub_tree-&gt;state == SIP_SUB_TREE_TERMINATED
<span class="lineNum">    2467 </span>            :                         ? &quot;SUBSCRIPTION_TERMINATED&quot; : &quot;SUBSCRIPTION_STATE_CHANGED&quot;,
<span class="lineNum">    2468 </span>            :                 &quot;Resource: %s&quot;, sub_tree-&gt;root-&gt;resource);
<span class="lineNum">    2469 </span>            : 
<span class="lineNum">    2470 </span><span class="lineCov">         12 :         sub_tree-&gt;notify_sched_id = -1;</span>
<span class="lineNum">    2471 </span><span class="lineCov">         12 :         pjsip_dlg_dec_lock(dlg);</span>
<span class="lineNum">    2472 </span><span class="lineCov">         12 :         ao2_cleanup(sub_tree);</span>
<span class="lineNum">    2473 </span><span class="lineCov">         12 :         return 0;</span>
<a name="2474"><span class="lineNum">    2474 </span>            : }</a>
<span class="lineNum">    2475 </span>            : 
<span class="lineNum">    2476 </span><span class="lineCov">         16 : static int sched_cb(const void *data)</span>
<span class="lineNum">    2477 </span>            : {
<span class="lineNum">    2478 </span><span class="lineCov">         16 :         struct sip_subscription_tree *sub_tree = (struct sip_subscription_tree *) data;</span>
<span class="lineNum">    2479 </span>            : 
<span class="lineNum">    2480 </span>            :         /* We don't need to bump the refcount of sub_tree since we bumped it when scheduling this task */
<span class="lineNum">    2481 </span><span class="lineCov">         16 :         if (ast_sip_push_task(sub_tree-&gt;serializer, serialized_send_notify, sub_tree)) {</span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :                 ao2_cleanup(sub_tree);</span>
<span class="lineNum">    2483 </span>            :         }
<span class="lineNum">    2484 </span>            : 
<span class="lineNum">    2485 </span><span class="lineCov">         16 :         return 0;</span>
<a name="2486"><span class="lineNum">    2486 </span>            : }</a>
<span class="lineNum">    2487 </span>            : 
<span class="lineNum">    2488 </span><span class="lineCov">         25 : static int schedule_notification(struct sip_subscription_tree *sub_tree)</span>
<span class="lineNum">    2489 </span>            : {
<span class="lineNum">    2490 </span>            :         /* There's already a notification scheduled */
<span class="lineNum">    2491 </span><span class="lineCov">         25 :         if (sub_tree-&gt;notify_sched_id &gt; -1) {</span>
<span class="lineNum">    2492 </span><span class="lineCov">          9 :                 return 0;</span>
<span class="lineNum">    2493 </span>            :         }
<span class="lineNum">    2494 </span>            : 
<span class="lineNum">    2495 </span><span class="lineCov">         16 :         sub_tree-&gt;send_scheduled_notify = 1;</span>
<span class="lineNum">    2496 </span><span class="lineCov">         16 :         sub_tree-&gt;notify_sched_id = ast_sched_add(sched, sub_tree-&gt;notification_batch_interval, sched_cb, ao2_bump(sub_tree));</span>
<span class="lineNum">    2497 </span><span class="lineCov">         16 :         if (sub_tree-&gt;notify_sched_id &lt; 0) {</span>
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :                 ao2_cleanup(sub_tree);</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2500 </span>            :         }
<span class="lineNum">    2501 </span>            : 
<span class="lineNum">    2502 </span><span class="lineCov">         16 :         return 0;</span>
<a name="2503"><span class="lineNum">    2503 </span>            : }</a>
<span class="lineNum">    2504 </span>            : 
<span class="lineNum">    2505 </span><span class="lineCov">        147 : int ast_sip_subscription_notify(struct ast_sip_subscription *sub, struct ast_sip_body_data *notify_data,</span>
<span class="lineNum">    2506 </span>            :                 int terminate)
<span class="lineNum">    2507 </span>            : {
<span class="lineNum">    2508 </span>            :         int res;
<span class="lineNum">    2509 </span><span class="lineCov">        147 :         pjsip_dialog *dlg = sub-&gt;tree-&gt;dlg;</span>
<span class="lineNum">    2510 </span>            : 
<span class="lineNum">    2511 </span><span class="lineCov">        147 :         pjsip_dlg_inc_lock(dlg);</span>
<span class="lineNum">    2512 </span>            : 
<span class="lineNum">    2513 </span><span class="lineCov">        147 :         if (sub-&gt;tree-&gt;state != SIP_SUB_TREE_NORMAL) {</span>
<span class="lineNum">    2514 </span><span class="lineCov">         44 :                 pjsip_dlg_dec_lock(dlg);</span>
<span class="lineNum">    2515 </span><span class="lineCov">         44 :                 return 0;</span>
<span class="lineNum">    2516 </span>            :         }
<span class="lineNum">    2517 </span>            : 
<span class="lineNum">    2518 </span><span class="lineCov">        103 :         if (ast_sip_pubsub_generate_body_content(ast_sip_subscription_get_body_type(sub),</span>
<span class="lineNum">    2519 </span>            :                                 ast_sip_subscription_get_body_subtype(sub), notify_data, &amp;sub-&gt;body_text)) {
<span class="lineNum">    2520 </span><span class="lineNoCov">          0 :                 pjsip_dlg_dec_lock(dlg);</span>
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2522 </span>            :         }
<span class="lineNum">    2523 </span>            : 
<span class="lineNum">    2524 </span><span class="lineCov">        103 :         sub-&gt;body_changed = 1;</span>
<span class="lineNum">    2525 </span><span class="lineCov">        103 :         if (terminate) {</span>
<span class="lineNum">    2526 </span><span class="lineCov">         33 :                 sub-&gt;subscription_state = PJSIP_EVSUB_STATE_TERMINATED;</span>
<span class="lineNum">    2527 </span><span class="lineCov">         33 :                 sub-&gt;tree-&gt;state = SIP_SUB_TREE_TERMINATE_PENDING;</span>
<span class="lineNum">    2528 </span>            :         }
<span class="lineNum">    2529 </span>            : 
<span class="lineNum">    2530 </span><span class="lineCov">        103 :         if (sub-&gt;tree-&gt;notification_batch_interval) {</span>
<span class="lineNum">    2531 </span><span class="lineCov">         25 :                 res = schedule_notification(sub-&gt;tree);</span>
<span class="lineNum">    2532 </span>            :         } else {
<span class="lineNum">    2533 </span>            :                 /* See the note in pubsub_on_rx_refresh() for why sub-&gt;tree is refbumped here */
<span class="lineNum">    2534 </span><span class="lineCov">         78 :                 ao2_ref(sub-&gt;tree, +1);</span>
<span class="lineNum">    2535 </span><span class="lineCov">         78 :                 if (terminate) {</span>
<span class="lineNum">    2536 </span><span class="lineCov">         32 :                         sub-&gt;tree-&gt;state = SIP_SUB_TREE_TERMINATE_IN_PROGRESS;</span>
<span class="lineNum">    2537 </span>            :                 }
<span class="lineNum">    2538 </span><span class="lineCov">         78 :                 res = send_notify(sub-&gt;tree, 0);</span>
<span class="lineNum">    2539 </span><span class="lineCov">         78 :                 ast_test_suite_event_notify(terminate ? &quot;SUBSCRIPTION_TERMINATED&quot; : &quot;SUBSCRIPTION_STATE_CHANGED&quot;,</span>
<span class="lineNum">    2540 </span>            :                                 &quot;Resource: %s&quot;,
<span class="lineNum">    2541 </span>            :                                 sub-&gt;tree-&gt;root-&gt;resource);
<span class="lineNum">    2542 </span><span class="lineCov">         78 :                 ao2_ref(sub-&gt;tree, -1);</span>
<span class="lineNum">    2543 </span>            :         }
<span class="lineNum">    2544 </span>            : 
<span class="lineNum">    2545 </span><span class="lineCov">        103 :         pjsip_dlg_dec_lock(dlg);</span>
<span class="lineNum">    2546 </span><span class="lineCov">        103 :         return res;</span>
<a name="2547"><span class="lineNum">    2547 </span>            : }</a>
<span class="lineNum">    2548 </span>            : 
<span class="lineNum">    2549 </span><span class="lineCov">         83 : pjsip_sip_uri *ast_sip_subscription_get_sip_uri(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    2550 </span>            : {
<span class="lineNum">    2551 </span><span class="lineCov">         83 :         return sub-&gt;uri;</span>
<a name="2552"><span class="lineNum">    2552 </span>            : }</a>
<span class="lineNum">    2553 </span>            : 
<span class="lineNum">    2554 </span><span class="lineCov">        382 : void ast_sip_subscription_get_local_uri(struct ast_sip_subscription *sub, char *buf, size_t size)</span>
<span class="lineNum">    2555 </span>            : {
<span class="lineNum">    2556 </span><span class="lineCov">        382 :         pjsip_uri_print(PJSIP_URI_IN_CONTACT_HDR, sub-&gt;uri, buf, size);</span>
<a name="2557"><span class="lineNum">    2557 </span><span class="lineCov">        382 : }</span></a>
<span class="lineNum">    2558 </span>            : 
<span class="lineNum">    2559 </span><span class="lineCov">        222 : void ast_sip_subscription_get_remote_uri(struct ast_sip_subscription *sub, char *buf, size_t size)</span>
<span class="lineNum">    2560 </span>            : {
<span class="lineNum">    2561 </span>            :         pjsip_dialog *dlg;
<span class="lineNum">    2562 </span>            :         pjsip_sip_uri *uri;
<span class="lineNum">    2563 </span>            : 
<span class="lineNum">    2564 </span><span class="lineCov">        222 :         dlg = sub-&gt;tree-&gt;dlg;</span>
<span class="lineNum">    2565 </span><span class="lineCov">        222 :         uri = pjsip_uri_get_uri(dlg-&gt;remote.info-&gt;uri);</span>
<span class="lineNum">    2566 </span>            : 
<span class="lineNum">    2567 </span><span class="lineCov">        222 :         if (pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR, uri, buf, size) &lt; 0) {</span>
<span class="lineNum">    2568 </span><span class="lineNoCov">          0 :                 *buf = '\0';</span>
<span class="lineNum">    2569 </span>            :         }
<a name="2570"><span class="lineNum">    2570 </span><span class="lineCov">        222 : }</span></a>
<span class="lineNum">    2571 </span>            : 
<span class="lineNum">    2572 </span><span class="lineCov">        424 : const char *ast_sip_subscription_get_resource_name(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    2573 </span>            : {
<span class="lineNum">    2574 </span><span class="lineCov">        424 :         return sub-&gt;resource;</span>
<a name="2575"><span class="lineNum">    2575 </span>            : }</a>
<span class="lineNum">    2576 </span>            : 
<span class="lineNum">    2577 </span><span class="lineCov">        126 : int ast_sip_subscription_is_terminated(const struct ast_sip_subscription *sub)</span>
<span class="lineNum">    2578 </span>            : {
<span class="lineNum">    2579 </span><span class="lineCov">        126 :         return sub-&gt;subscription_state == PJSIP_EVSUB_STATE_TERMINATED ? 1 : 0;</span>
<a name="2580"><span class="lineNum">    2580 </span>            : }</a>
<span class="lineNum">    2581 </span>            : 
<span class="lineNum">    2582 </span><span class="lineCov">         76 : static int sip_subscription_accept(struct sip_subscription_tree *sub_tree, pjsip_rx_data *rdata, int response)</span>
<span class="lineNum">    2583 </span>            : {
<span class="lineNum">    2584 </span>            :         pjsip_hdr res_hdr;
<span class="lineNum">    2585 </span>            : 
<span class="lineNum">    2586 </span>            :         /* If this is a persistence recreation the subscription has already been accepted */
<span class="lineNum">    2587 </span><span class="lineCov">         76 :         if (ast_sip_mod_data_get(rdata-&gt;endpt_info.mod_data, pubsub_module.id, MOD_DATA_PERSISTENCE)) {</span>
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    2589 </span>            :         }
<span class="lineNum">    2590 </span>            : 
<span class="lineNum">    2591 </span><span class="lineCov">         76 :         pj_list_init(&amp;res_hdr);</span>
<span class="lineNum">    2592 </span><span class="lineCov">         76 :         if (sub_tree-&gt;is_list) {</span>
<span class="lineNum">    2593 </span>            :                 /* If subscribing to a list, our response has to have a Require: eventlist header in it */
<span class="lineNum">    2594 </span><span class="lineCov">         49 :                 pj_list_insert_before(&amp;res_hdr, create_require_eventlist(rdata-&gt;tp_info.pool));</span>
<span class="lineNum">    2595 </span>            :         }
<span class="lineNum">    2596 </span>            : 
<span class="lineNum">    2597 </span><span class="lineCov">         76 :         return pjsip_evsub_accept(sub_tree-&gt;evsub, rdata, response, &amp;res_hdr) == PJ_SUCCESS ? 0 : -1;</span>
<a name="2598"><span class="lineNum">    2598 </span>            : }</a>
<span class="lineNum">    2599 </span>            : 
<span class="lineNum">    2600 </span><span class="lineCov">        159 : struct ast_datastore *ast_sip_subscription_alloc_datastore(const struct ast_datastore_info *info, const char *uid)</span>
<span class="lineNum">    2601 </span>            : {
<span class="lineNum">    2602 </span><span class="lineCov">        159 :         return ast_datastores_alloc_datastore(info, uid);</span>
<a name="2603"><span class="lineNum">    2603 </span>            : }</a>
<span class="lineNum">    2604 </span>            : 
<span class="lineNum">    2605 </span><span class="lineCov">        159 : int ast_sip_subscription_add_datastore(struct ast_sip_subscription *subscription, struct ast_datastore *datastore)</span>
<span class="lineNum">    2606 </span>            : {
<span class="lineNum">    2607 </span><span class="lineCov">        159 :         return ast_datastores_add(subscription-&gt;datastores, datastore);</span>
<a name="2608"><span class="lineNum">    2608 </span>            : }</a>
<span class="lineNum">    2609 </span>            : 
<span class="lineNum">    2610 </span><span class="lineCov">        196 : struct ast_datastore *ast_sip_subscription_get_datastore(struct ast_sip_subscription *subscription, const char *name)</span>
<span class="lineNum">    2611 </span>            : {
<span class="lineNum">    2612 </span><span class="lineCov">        196 :         return ast_datastores_find(subscription-&gt;datastores, name);</span>
<a name="2613"><span class="lineNum">    2613 </span>            : }</a>
<span class="lineNum">    2614 </span>            : 
<span class="lineNum">    2615 </span><span class="lineCov">         35 : void ast_sip_subscription_remove_datastore(struct ast_sip_subscription *subscription, const char *name)</span>
<span class="lineNum">    2616 </span>            : {
<span class="lineNum">    2617 </span><span class="lineCov">         35 :         ast_datastores_remove(subscription-&gt;datastores, name);</span>
<a name="2618"><span class="lineNum">    2618 </span><span class="lineCov">         35 : }</span></a>
<span class="lineNum">    2619 </span>            : 
<span class="lineNum">    2620 </span><span class="lineCov">        348 : struct ao2_container *ast_sip_subscription_get_datastores(const struct ast_sip_subscription *subscription)</span>
<span class="lineNum">    2621 </span>            : {
<span class="lineNum">    2622 </span><span class="lineCov">        348 :         return subscription-&gt;datastores;</span>
<a name="2623"><span class="lineNum">    2623 </span>            : }</a>
<span class="lineNum">    2624 </span>            : 
<span class="lineNum">    2625 </span><span class="lineNoCov">          0 : int ast_sip_publication_add_datastore(struct ast_sip_publication *publication, struct ast_datastore *datastore)</span>
<span class="lineNum">    2626 </span>            : {
<span class="lineNum">    2627 </span><span class="lineNoCov">          0 :         return ast_datastores_add(publication-&gt;datastores, datastore);</span>
<a name="2628"><span class="lineNum">    2628 </span>            : }</a>
<span class="lineNum">    2629 </span>            : 
<span class="lineNum">    2630 </span><span class="lineNoCov">          0 : struct ast_datastore *ast_sip_publication_get_datastore(struct ast_sip_publication *publication, const char *name)</span>
<span class="lineNum">    2631 </span>            : {
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :         return ast_datastores_find(publication-&gt;datastores, name);</span>
<a name="2633"><span class="lineNum">    2633 </span>            : }</a>
<span class="lineNum">    2634 </span>            : 
<span class="lineNum">    2635 </span><span class="lineNoCov">          0 : void ast_sip_publication_remove_datastore(struct ast_sip_publication *publication, const char *name)</span>
<span class="lineNum">    2636 </span>            : {
<span class="lineNum">    2637 </span><span class="lineNoCov">          0 :         ast_datastores_remove(publication-&gt;datastores, name);</span>
<a name="2638"><span class="lineNum">    2638 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2639 </span>            : 
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 : struct ao2_container *ast_sip_publication_get_datastores(const struct ast_sip_publication *publication)</span>
<span class="lineNum">    2641 </span>            : {
<span class="lineNum">    2642 </span><span class="lineNoCov">          0 :         return publication-&gt;datastores;</span>
<span class="lineNum">    2643 </span>            : }
<span class="lineNum">    2644 </span>            : 
<a name="2645"><span class="lineNum">    2645 </span>            : AST_RWLIST_HEAD_STATIC(publish_handlers, ast_sip_publish_handler);</a>
<span class="lineNum">    2646 </span>            : 
<span class="lineNum">    2647 </span><span class="lineCov">         16 : static int publication_hash_fn(const void *obj, const int flags)</span>
<span class="lineNum">    2648 </span>            : {
<span class="lineNum">    2649 </span><span class="lineCov">         16 :         const struct ast_sip_publication *publication = obj;</span>
<span class="lineNum">    2650 </span><span class="lineCov">         16 :         const int *entity_tag = obj;</span>
<span class="lineNum">    2651 </span>            : 
<span class="lineNum">    2652 </span><span class="lineCov">         16 :         return flags &amp; OBJ_KEY ? *entity_tag : publication-&gt;entity_tag;</span>
<a name="2653"><span class="lineNum">    2653 </span>            : }</a>
<span class="lineNum">    2654 </span>            : 
<span class="lineNum">    2655 </span><span class="lineCov">          8 : static int publication_cmp_fn(void *obj, void *arg, int flags)</span>
<span class="lineNum">    2656 </span>            : {
<span class="lineNum">    2657 </span><span class="lineCov">          8 :         const struct ast_sip_publication *publication1 = obj;</span>
<span class="lineNum">    2658 </span><span class="lineCov">          8 :         const struct ast_sip_publication *publication2 = arg;</span>
<span class="lineNum">    2659 </span><span class="lineCov">          8 :         const int *entity_tag = arg;</span>
<span class="lineNum">    2660 </span>            : 
<span class="lineNum">    2661 </span><span class="lineCov">          8 :         return (publication1-&gt;entity_tag == (flags &amp; OBJ_KEY ? *entity_tag : publication2-&gt;entity_tag) ?</span>
<span class="lineNum">    2662 </span><span class="lineCov">          8 :                 CMP_MATCH | CMP_STOP : 0);</span>
<a name="2663"><span class="lineNum">    2663 </span>            : }</a>
<span class="lineNum">    2664 </span>            : 
<span class="lineNum">    2665 </span><span class="lineCov">       1704 : static void publish_add_handler(struct ast_sip_publish_handler *handler)</span>
<span class="lineNum">    2666 </span>            : {
<span class="lineNum">    2667 </span><span class="lineCov">       1704 :         AST_RWLIST_WRLOCK(&amp;publish_handlers);</span>
<span class="lineNum">    2668 </span><span class="lineCov">       1704 :         AST_RWLIST_INSERT_TAIL(&amp;publish_handlers, handler, next);</span>
<span class="lineNum">    2669 </span><span class="lineCov">       1704 :         AST_RWLIST_UNLOCK(&amp;publish_handlers);</span>
<a name="2670"><span class="lineNum">    2670 </span><span class="lineCov">       1704 : }</span></a>
<span class="lineNum">    2671 </span>            : 
<span class="lineNum">    2672 </span><span class="lineCov">       1704 : int ast_sip_register_publish_handler(struct ast_sip_publish_handler *handler)</span>
<span class="lineNum">    2673 </span>            : {
<span class="lineNum">    2674 </span><span class="lineCov">       1704 :         if (ast_strlen_zero(handler-&gt;event_name)) {</span>
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;No event package specified for publish handler. Cannot register\n&quot;);</span>
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2677 </span>            :         }
<span class="lineNum">    2678 </span>            : 
<span class="lineNum">    2679 </span><span class="lineCov">       1704 :         if (!(handler-&gt;publications = ao2_container_alloc(PUBLICATIONS_BUCKETS,</span>
<span class="lineNum">    2680 </span>            :                 publication_hash_fn, publication_cmp_fn))) {
<span class="lineNum">    2681 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Could not allocate publications container for event '%s'\n&quot;,</span>
<span class="lineNum">    2682 </span>            :                         handler-&gt;event_name);
<span class="lineNum">    2683 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2684 </span>            :         }
<span class="lineNum">    2685 </span>            : 
<span class="lineNum">    2686 </span><span class="lineCov">       1704 :         publish_add_handler(handler);</span>
<span class="lineNum">    2687 </span>            : 
<span class="lineNum">    2688 </span><span class="lineCov">       1704 :         return 0;</span>
<a name="2689"><span class="lineNum">    2689 </span>            : }</a>
<span class="lineNum">    2690 </span>            : 
<span class="lineNum">    2691 </span><span class="lineCov">       1702 : void ast_sip_unregister_publish_handler(struct ast_sip_publish_handler *handler)</span>
<span class="lineNum">    2692 </span>            : {
<span class="lineNum">    2693 </span>            :         struct ast_sip_publish_handler *iter;
<span class="lineNum">    2694 </span>            : 
<span class="lineNum">    2695 </span><span class="lineCov">       1702 :         AST_RWLIST_WRLOCK(&amp;publish_handlers);</span>
<span class="lineNum">    2696 </span><span class="lineCov">       1702 :         AST_RWLIST_TRAVERSE_SAFE_BEGIN(&amp;publish_handlers, iter, next) {</span>
<span class="lineNum">    2697 </span><span class="lineCov">       1702 :                 if (handler == iter) {</span>
<span class="lineNum">    2698 </span><span class="lineCov">       1702 :                         AST_RWLIST_REMOVE_CURRENT(next);</span>
<span class="lineNum">    2699 </span><span class="lineCov">       1702 :                         ao2_cleanup(handler-&gt;publications);</span>
<span class="lineNum">    2700 </span><span class="lineCov">       1702 :                         break;</span>
<span class="lineNum">    2701 </span>            :                 }
<span class="lineNum">    2702 </span>            :         }
<span class="lineNum">    2703 </span>            :         AST_RWLIST_TRAVERSE_SAFE_END;
<span class="lineNum">    2704 </span><span class="lineCov">       1702 :         AST_RWLIST_UNLOCK(&amp;publish_handlers);</span>
<span class="lineNum">    2705 </span><span class="lineCov">       1702 : }</span>
<span class="lineNum">    2706 </span>            : 
<a name="2707"><span class="lineNum">    2707 </span>            : AST_RWLIST_HEAD_STATIC(subscription_handlers, ast_sip_subscription_handler);</a>
<span class="lineNum">    2708 </span>            : 
<span class="lineNum">    2709 </span><span class="lineCov">       2556 : static void sub_add_handler(struct ast_sip_subscription_handler *handler)</span>
<span class="lineNum">    2710 </span>            : {
<span class="lineNum">    2711 </span><span class="lineCov">       2556 :         AST_RWLIST_WRLOCK(&amp;subscription_handlers);</span>
<span class="lineNum">    2712 </span><span class="lineCov">       2556 :         AST_RWLIST_INSERT_TAIL(&amp;subscription_handlers, handler, next);</span>
<span class="lineNum">    2713 </span><span class="lineCov">       2556 :         AST_RWLIST_UNLOCK(&amp;subscription_handlers);</span>
<a name="2714"><span class="lineNum">    2714 </span><span class="lineCov">       2556 : }</span></a>
<span class="lineNum">    2715 </span>            : 
<span class="lineNum">    2716 </span><span class="lineCov">       2649 : static struct ast_sip_subscription_handler *find_sub_handler_for_event_name(const char *event_name)</span>
<span class="lineNum">    2717 </span>            : {
<span class="lineNum">    2718 </span>            :         struct ast_sip_subscription_handler *iter;
<span class="lineNum">    2719 </span>            : 
<span class="lineNum">    2720 </span><span class="lineCov">       2649 :         AST_RWLIST_RDLOCK(&amp;subscription_handlers);</span>
<span class="lineNum">    2721 </span><span class="lineCov">       5267 :         AST_RWLIST_TRAVERSE(&amp;subscription_handlers, iter, next) {</span>
<span class="lineNum">    2722 </span><span class="lineCov">       2710 :                 if (!strcmp(iter-&gt;event_name, event_name)) {</span>
<span class="lineNum">    2723 </span><span class="lineCov">         92 :                         break;</span>
<span class="lineNum">    2724 </span>            :                 }
<span class="lineNum">    2725 </span>            :         }
<span class="lineNum">    2726 </span><span class="lineCov">       2649 :         AST_RWLIST_UNLOCK(&amp;subscription_handlers);</span>
<span class="lineNum">    2727 </span><span class="lineCov">       2649 :         return iter;</span>
<a name="2728"><span class="lineNum">    2728 </span>            : }</a>
<span class="lineNum">    2729 </span>            : 
<span class="lineNum">    2730 </span><span class="lineCov">       2556 : int ast_sip_register_subscription_handler(struct ast_sip_subscription_handler *handler)</span>
<span class="lineNum">    2731 </span>            : {
<span class="lineNum">    2732 </span>            :         pj_str_t event;
<span class="lineNum">    2733 </span><span class="lineCov">       2556 :         pj_str_t accept[AST_SIP_MAX_ACCEPT] = { {0, }, };</span>
<span class="lineNum">    2734 </span>            :         struct ast_sip_subscription_handler *existing;
<span class="lineNum">    2735 </span><span class="lineCov">       2556 :         int i = 0;</span>
<span class="lineNum">    2736 </span>            : 
<span class="lineNum">    2737 </span><span class="lineCov">       2556 :         if (ast_strlen_zero(handler-&gt;event_name)) {</span>
<span class="lineNum">    2738 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;No event package specified for subscription handler. Cannot register\n&quot;);</span>
<span class="lineNum">    2739 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2740 </span>            :         }
<span class="lineNum">    2741 </span>            : 
<span class="lineNum">    2742 </span><span class="lineCov">       2556 :         existing = find_sub_handler_for_event_name(handler-&gt;event_name);</span>
<span class="lineNum">    2743 </span><span class="lineCov">       2556 :         if (existing) {</span>
<span class="lineNum">    2744 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR,</span>
<span class="lineNum">    2745 </span>            :                         &quot;Unable to register subscription handler for event %s.  A handler is already registered\n&quot;,
<span class="lineNum">    2746 </span>            :                         handler-&gt;event_name);
<span class="lineNum">    2747 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2748 </span>            :         }
<span class="lineNum">    2749 </span>            : 
<span class="lineNum">    2750 </span><span class="lineCov">       5112 :         for (i = 0; i &lt; AST_SIP_MAX_ACCEPT &amp;&amp; !ast_strlen_zero(handler-&gt;accept[i]); ++i) {</span>
<span class="lineNum">    2751 </span><span class="lineCov">       2556 :                 pj_cstr(&amp;accept[i], handler-&gt;accept[i]);</span>
<span class="lineNum">    2752 </span>            :         }
<span class="lineNum">    2753 </span>            : 
<span class="lineNum">    2754 </span><span class="lineCov">       2556 :         pj_cstr(&amp;event, handler-&gt;event_name);</span>
<span class="lineNum">    2755 </span>            : 
<span class="lineNum">    2756 </span><span class="lineCov">       2556 :         pjsip_evsub_register_pkg(&amp;pubsub_module, &amp;event, DEFAULT_EXPIRES, i, accept);</span>
<span class="lineNum">    2757 </span>            : 
<span class="lineNum">    2758 </span><span class="lineCov">       2556 :         sub_add_handler(handler);</span>
<span class="lineNum">    2759 </span>            : 
<span class="lineNum">    2760 </span><span class="lineCov">       2556 :         return 0;</span>
<a name="2761"><span class="lineNum">    2761 </span>            : }</a>
<span class="lineNum">    2762 </span>            : 
<span class="lineNum">    2763 </span><span class="lineCov">       2553 : void ast_sip_unregister_subscription_handler(struct ast_sip_subscription_handler *handler)</span>
<span class="lineNum">    2764 </span>            : {
<span class="lineNum">    2765 </span>            :         struct ast_sip_subscription_handler *iter;
<span class="lineNum">    2766 </span>            : 
<span class="lineNum">    2767 </span><span class="lineCov">       2553 :         AST_RWLIST_WRLOCK(&amp;subscription_handlers);</span>
<span class="lineNum">    2768 </span><span class="lineCov">       5106 :         AST_RWLIST_TRAVERSE_SAFE_BEGIN(&amp;subscription_handlers, iter, next) {</span>
<span class="lineNum">    2769 </span><span class="lineCov">       5106 :                 if (handler == iter) {</span>
<span class="lineNum">    2770 </span><span class="lineCov">       2553 :                         AST_RWLIST_REMOVE_CURRENT(next);</span>
<span class="lineNum">    2771 </span><span class="lineCov">       2553 :                         break;</span>
<span class="lineNum">    2772 </span>            :                 }
<span class="lineNum">    2773 </span>            :         }
<span class="lineNum">    2774 </span>            :         AST_RWLIST_TRAVERSE_SAFE_END;
<span class="lineNum">    2775 </span><span class="lineCov">       2553 :         AST_RWLIST_UNLOCK(&amp;subscription_handlers);</span>
<a name="2776"><span class="lineNum">    2776 </span><span class="lineCov">       2553 : }</span></a>
<span class="lineNum">    2777 </span>            : 
<span class="lineNum">    2778 </span><span class="lineCov">       4644 : static struct ast_sip_pubsub_body_generator *find_body_generator_type_subtype_nolock(const char *type, const char *subtype)</span>
<span class="lineNum">    2779 </span>            : {
<span class="lineNum">    2780 </span>            :         struct ast_sip_pubsub_body_generator *gen;
<span class="lineNum">    2781 </span>            : 
<span class="lineNum">    2782 </span><span class="lineCov">      14298 :         AST_LIST_TRAVERSE(&amp;body_generators, gen, list) {</span>
<span class="lineNum">    2783 </span><span class="lineCov">      10044 :                 if (!strcmp(gen-&gt;type, type)</span>
<span class="lineNum">    2784 </span><span class="lineCov">      10044 :                         &amp;&amp; !strcmp(gen-&gt;subtype, subtype)) {</span>
<span class="lineNum">    2785 </span><span class="lineCov">        390 :                         break;</span>
<span class="lineNum">    2786 </span>            :                 }
<span class="lineNum">    2787 </span>            :         }
<span class="lineNum">    2788 </span>            : 
<span class="lineNum">    2789 </span><span class="lineCov">       4644 :         return gen;</span>
<a name="2790"><span class="lineNum">    2790 </span>            : }</a>
<span class="lineNum">    2791 </span>            : 
<span class="lineNum">    2792 </span><span class="lineCov">        391 : static struct ast_sip_pubsub_body_generator *find_body_generator_type_subtype(const char *type, const char *subtype)</span>
<span class="lineNum">    2793 </span>            : {
<span class="lineNum">    2794 </span>            :         struct ast_sip_pubsub_body_generator *gen;
<span class="lineNum">    2795 </span>            : 
<span class="lineNum">    2796 </span><span class="lineCov">        391 :         AST_RWLIST_RDLOCK(&amp;body_generators);</span>
<span class="lineNum">    2797 </span><span class="lineCov">        391 :         gen = find_body_generator_type_subtype_nolock(type, subtype);</span>
<span class="lineNum">    2798 </span><span class="lineCov">        391 :         AST_RWLIST_UNLOCK(&amp;body_generators);</span>
<span class="lineNum">    2799 </span><span class="lineCov">        391 :         return gen;</span>
<a name="2800"><span class="lineNum">    2800 </span>            : }</a>
<span class="lineNum">    2801 </span>            : 
<span class="lineNum">    2802 </span><span class="lineCov">         93 : static struct ast_sip_pubsub_body_generator *find_body_generator_accept(const char *accept)</span>
<span class="lineNum">    2803 </span>            : {
<span class="lineNum">    2804 </span><span class="lineCov">         93 :         char *accept_copy = ast_strdupa(accept);</span>
<span class="lineNum">    2805 </span><span class="lineCov">         93 :         char *subtype = accept_copy;</span>
<span class="lineNum">    2806 </span><span class="lineCov">         93 :         char *type = strsep(&amp;subtype, &quot;/&quot;);</span>
<span class="lineNum">    2807 </span>            : 
<span class="lineNum">    2808 </span><span class="lineCov">         93 :         if (ast_strlen_zero(type) || ast_strlen_zero(subtype)) {</span>
<span class="lineNum">    2809 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    2810 </span>            :         }
<span class="lineNum">    2811 </span>            : 
<span class="lineNum">    2812 </span><span class="lineCov">         93 :         return find_body_generator_type_subtype(type, subtype);</span>
<a name="2813"><span class="lineNum">    2813 </span>            : }</a>
<span class="lineNum">    2814 </span>            : 
<span class="lineNum">    2815 </span><span class="lineCov">         92 : static struct ast_sip_pubsub_body_generator *find_body_generator(char accept[AST_SIP_MAX_ACCEPT][64],</span>
<span class="lineNum">    2816 </span>            :                 size_t num_accept, const char *body_type)
<span class="lineNum">    2817 </span>            : {
<span class="lineNum">    2818 </span>            :         int i;
<span class="lineNum">    2819 </span><span class="lineCov">         92 :         struct ast_sip_pubsub_body_generator *generator = NULL;</span>
<span class="lineNum">    2820 </span>            : 
<span class="lineNum">    2821 </span><span class="lineCov">        100 :         for (i = 0; i &lt; num_accept; ++i) {</span>
<span class="lineNum">    2822 </span><span class="lineCov">         93 :                 generator = find_body_generator_accept(accept[i]);</span>
<span class="lineNum">    2823 </span><span class="lineCov">         93 :                 if (generator) {</span>
<span class="lineNum">    2824 </span><span class="lineCov">         92 :                         ast_debug(3, &quot;Body generator %p found for accept type %s\n&quot;, generator, accept[i]);</span>
<span class="lineNum">    2825 </span><span class="lineCov">         92 :                         if (strcmp(generator-&gt;body_type, body_type)) {</span>
<span class="lineNum">    2826 </span><span class="lineCov">          7 :                                 ast_log(LOG_WARNING, &quot;Body generator '%s/%s'(%p) does not accept the type of data this event generates\n&quot;,</span>
<span class="lineNum">    2827 </span>            :                                                 generator-&gt;type, generator-&gt;subtype, generator);
<span class="lineNum">    2828 </span><span class="lineCov">          7 :                                 generator = NULL;</span>
<span class="lineNum">    2829 </span><span class="lineCov">          7 :                                 continue;</span>
<span class="lineNum">    2830 </span>            :                         }
<span class="lineNum">    2831 </span><span class="lineCov">         85 :                         break;</span>
<span class="lineNum">    2832 </span>            :                 } else {
<span class="lineNum">    2833 </span><span class="lineCov">          1 :                         ast_debug(3, &quot;No body generator found for accept type %s\n&quot;, accept[i]);</span>
<span class="lineNum">    2834 </span>            :                 }
<span class="lineNum">    2835 </span>            :         }
<span class="lineNum">    2836 </span>            : 
<span class="lineNum">    2837 </span><span class="lineCov">         92 :         return generator;</span>
<a name="2838"><span class="lineNum">    2838 </span>            : }</a>
<span class="lineNum">    2839 </span>            : 
<span class="lineNum">    2840 </span><span class="lineCov">        230 : static int generate_initial_notify(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    2841 </span>            : {
<span class="lineNum">    2842 </span>            :         void *notify_data;
<span class="lineNum">    2843 </span>            :         int res;
<span class="lineNum">    2844 </span><span class="lineCov">        460 :         struct ast_sip_body_data data = {</span>
<span class="lineNum">    2845 </span><span class="lineCov">        230 :                 .body_type = sub-&gt;handler-&gt;body_type,</span>
<span class="lineNum">    2846 </span>            :         };
<span class="lineNum">    2847 </span>            : 
<span class="lineNum">    2848 </span><span class="lineCov">        230 :         if (AST_VECTOR_SIZE(&amp;sub-&gt;children) &gt; 0) {</span>
<span class="lineNum">    2849 </span>            :                 int i;
<span class="lineNum">    2850 </span>            : 
<span class="lineNum">    2851 </span><span class="lineCov">        224 :                 for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;sub-&gt;children); ++i) {</span>
<span class="lineNum">    2852 </span><span class="lineCov">        153 :                         if (generate_initial_notify(AST_VECTOR_GET(&amp;sub-&gt;children, i))) {</span>
<span class="lineNum">    2853 </span><span class="lineNoCov">          0 :                                 return -1;</span>
<span class="lineNum">    2854 </span>            :                         }
<span class="lineNum">    2855 </span>            :                 }
<span class="lineNum">    2856 </span>            : 
<span class="lineNum">    2857 </span><span class="lineCov">         71 :                 return 0;</span>
<span class="lineNum">    2858 </span>            :         }
<span class="lineNum">    2859 </span>            : 
<span class="lineNum">    2860 </span>            :         /* We notify subscription establishment only on the tree leaves. */
<span class="lineNum">    2861 </span><span class="lineCov">        159 :         if (sub-&gt;handler-&gt;notifier-&gt;subscription_established(sub)) {</span>
<span class="lineNum">    2862 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2863 </span>            :         }
<span class="lineNum">    2864 </span>            : 
<span class="lineNum">    2865 </span><span class="lineCov">        159 :         notify_data = sub-&gt;handler-&gt;notifier-&gt;get_notify_data(sub);</span>
<span class="lineNum">    2866 </span><span class="lineCov">        159 :         if (!notify_data) {</span>
<span class="lineNum">    2867 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2868 </span>            :         }
<span class="lineNum">    2869 </span>            : 
<span class="lineNum">    2870 </span><span class="lineCov">        159 :         data.body_data = notify_data;</span>
<span class="lineNum">    2871 </span>            : 
<span class="lineNum">    2872 </span><span class="lineCov">        159 :         res = ast_sip_pubsub_generate_body_content(ast_sip_subscription_get_body_type(sub),</span>
<span class="lineNum">    2873 </span>            :                         ast_sip_subscription_get_body_subtype(sub), &amp;data, &amp;sub-&gt;body_text);
<span class="lineNum">    2874 </span>            : 
<span class="lineNum">    2875 </span><span class="lineCov">        159 :         ao2_cleanup(notify_data);</span>
<span class="lineNum">    2876 </span>            : 
<span class="lineNum">    2877 </span><span class="lineCov">        159 :         return res;</span>
<span class="lineNum">    2878 </span>            : }
<span class="lineNum">    2879 </span>            : 
<a name="2880"><span class="lineNum">    2880 </span>            : static int pubsub_on_refresh_timeout(void *userdata);</a>
<span class="lineNum">    2881 </span>            : 
<span class="lineNum">    2882 </span><span class="lineCov">         77 : static int initial_notify_task(void * obj)</span>
<span class="lineNum">    2883 </span>            : {
<span class="lineNum">    2884 </span><span class="lineCov">         77 :         struct initial_notify_data *ind = obj;</span>
<span class="lineNum">    2885 </span>            : 
<span class="lineNum">    2886 </span><span class="lineCov">         77 :         if (generate_initial_notify(ind-&gt;sub_tree-&gt;root)) {</span>
<span class="lineNum">    2887 </span><span class="lineNoCov">          0 :                 pjsip_evsub_terminate(ind-&gt;sub_tree-&gt;evsub, PJ_TRUE);</span>
<span class="lineNum">    2888 </span>            :         } else {
<span class="lineNum">    2889 </span><span class="lineCov">         77 :                 send_notify(ind-&gt;sub_tree, 1);</span>
<span class="lineNum">    2890 </span><span class="lineCov">         77 :                 ast_test_suite_event_notify(&quot;SUBSCRIPTION_ESTABLISHED&quot;,</span>
<span class="lineNum">    2891 </span>            :                         &quot;Resource: %s&quot;,
<span class="lineNum">    2892 </span>            :                         ind-&gt;sub_tree-&gt;root-&gt;resource);
<span class="lineNum">    2893 </span>            :         }
<span class="lineNum">    2894 </span>            : 
<span class="lineNum">    2895 </span><span class="lineCov">         77 :         if (ind-&gt;expires &gt; -1) {</span>
<span class="lineNum">    2896 </span><span class="lineCov">          1 :                 char *name = ast_alloca(strlen(&quot;-&gt;/ &quot;) +</span>
<span class="lineNum">    2897 </span>            :                         strlen(ind-&gt;sub_tree-&gt;persistence-&gt;endpoint) +
<span class="lineNum">    2898 </span>            :                         strlen(ind-&gt;sub_tree-&gt;root-&gt;resource) +
<span class="lineNum">    2899 </span>            :                         strlen(ind-&gt;sub_tree-&gt;root-&gt;handler-&gt;event_name) +
<span class="lineNum">    2900 </span>            :                         ind-&gt;sub_tree-&gt;dlg-&gt;call_id-&gt;id.slen + 1);
<span class="lineNum">    2901 </span>            : 
<span class="lineNum">    2902 </span><span class="lineCov">          4 :                 sprintf(name, &quot;%s-&gt;%s/%s %.*s&quot;, ind-&gt;sub_tree-&gt;persistence-&gt;endpoint,</span>
<span class="lineNum">    2903 </span><span class="lineCov">          2 :                         ind-&gt;sub_tree-&gt;root-&gt;resource, ind-&gt;sub_tree-&gt;root-&gt;handler-&gt;event_name,</span>
<span class="lineNum">    2904 </span><span class="lineCov">          2 :                         (int)ind-&gt;sub_tree-&gt;dlg-&gt;call_id-&gt;id.slen, ind-&gt;sub_tree-&gt;dlg-&gt;call_id-&gt;id.ptr);</span>
<span class="lineNum">    2905 </span>            : 
<span class="lineNum">    2906 </span><span class="lineCov">          1 :                 ast_debug(3, &quot;Scheduling timer: %s\n&quot;, name);</span>
<span class="lineNum">    2907 </span><span class="lineCov">          2 :                 ind-&gt;sub_tree-&gt;expiration_task = ast_sip_schedule_task(ind-&gt;sub_tree-&gt;serializer,</span>
<span class="lineNum">    2908 </span><span class="lineCov">          1 :                         ind-&gt;expires * 1000, pubsub_on_refresh_timeout, name,</span>
<span class="lineNum">    2909 </span><span class="lineCov">          1 :                         ind-&gt;sub_tree, AST_SIP_SCHED_TASK_FIXED | AST_SIP_SCHED_TASK_DATA_AO2);</span>
<span class="lineNum">    2910 </span><span class="lineCov">          1 :                 if (!ind-&gt;sub_tree-&gt;expiration_task) {</span>
<span class="lineNum">    2911 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR, &quot;Unable to create expiration timer of %d seconds for %s\n&quot;,</span>
<span class="lineNum">    2912 </span>            :                                 ind-&gt;expires, name);
<span class="lineNum">    2913 </span>            :                 }
<span class="lineNum">    2914 </span>            :         }
<span class="lineNum">    2915 </span>            : 
<span class="lineNum">    2916 </span><span class="lineCov">         77 :         ao2_ref(ind-&gt;sub_tree, -1);</span>
<span class="lineNum">    2917 </span><span class="lineCov">         77 :         ast_free(ind);</span>
<span class="lineNum">    2918 </span>            : 
<span class="lineNum">    2919 </span><span class="lineCov">         77 :         return 0;</span>
<a name="2920"><span class="lineNum">    2920 </span>            : }</a>
<span class="lineNum">    2921 </span>            : 
<span class="lineNum">    2922 </span><span class="lineCov">         95 : static pj_bool_t pubsub_on_rx_subscribe_request(pjsip_rx_data *rdata)</span>
<span class="lineNum">    2923 </span>            : {
<a name="2924"><span class="lineNum">    2924 </span>            :         pjsip_expires_hdr *expires_header;</a>
<span class="lineNum">    2925 </span>            :         struct ast_sip_subscription_handler *handler;
<span class="lineNum">    2926 </span><span class="lineCov">        190 :         RAII_VAR(struct ast_sip_endpoint *, endpoint, NULL, ao2_cleanup);</span>
<span class="lineNum">    2927 </span>            :         struct sip_subscription_tree *sub_tree;
<span class="lineNum">    2928 </span>            :         struct ast_sip_pubsub_body_generator *generator;
<span class="lineNum">    2929 </span>            :         char *resource;
<span class="lineNum">    2930 </span>            :         pjsip_uri *request_uri;
<span class="lineNum">    2931 </span>            :         pjsip_sip_uri *request_uri_sip;
<span class="lineNum">    2932 </span>            :         size_t resource_size;
<span class="lineNum">    2933 </span>            :         int resp;
<span class="lineNum">    2934 </span>            :         struct resource_tree tree;
<span class="lineNum">    2935 </span>            :         pj_status_t dlg_status;
<span class="lineNum">    2936 </span>            : 
<span class="lineNum">    2937 </span><span class="lineCov">         95 :         endpoint = ast_pjsip_rdata_get_endpoint(rdata);</span>
<span class="lineNum">    2938 </span><span class="lineCov">         95 :         ast_assert(endpoint != NULL);</span>
<span class="lineNum">    2939 </span>            : 
<span class="lineNum">    2940 </span><span class="lineCov">         95 :         if (!endpoint-&gt;subscription.allow) {</span>
<span class="lineNum">    2941 </span><span class="lineCov">          1 :                 ast_log(LOG_WARNING, &quot;Subscriptions not permitted for endpoint %s.\n&quot;, ast_sorcery_object_get_id(endpoint));</span>
<span class="lineNum">    2942 </span><span class="lineCov">          1 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 603, NULL, NULL, NULL);</span>
<span class="lineNum">    2943 </span><span class="lineCov">          1 :                 return PJ_TRUE;</span>
<span class="lineNum">    2944 </span>            :         }
<span class="lineNum">    2945 </span>            : 
<span class="lineNum">    2946 </span><span class="lineCov">         94 :         request_uri = rdata-&gt;msg_info.msg-&gt;line.req.uri;</span>
<span class="lineNum">    2947 </span>            : 
<span class="lineNum">    2948 </span><span class="lineCov">         94 :         if (!PJSIP_URI_SCHEME_IS_SIP(request_uri) &amp;&amp; !PJSIP_URI_SCHEME_IS_SIPS(request_uri)) {</span>
<span class="lineNum">    2949 </span>            :                 char uri_str[PJSIP_MAX_URL_SIZE];
<span class="lineNum">    2950 </span>            : 
<span class="lineNum">    2951 </span><span class="lineNoCov">          0 :                 pjsip_uri_print(PJSIP_URI_IN_REQ_URI, request_uri, uri_str, sizeof(uri_str));</span>
<span class="lineNum">    2952 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Request URI '%s' is not a sip: or sips: URI.\n&quot;, uri_str);</span>
<span class="lineNum">    2953 </span><span class="lineNoCov">          0 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 416, NULL, NULL, NULL);</span>
<span class="lineNum">    2954 </span><span class="lineNoCov">          0 :                 return PJ_TRUE;</span>
<span class="lineNum">    2955 </span>            :         }
<span class="lineNum">    2956 </span>            : 
<span class="lineNum">    2957 </span><span class="lineCov">         94 :         request_uri_sip = pjsip_uri_get_uri(request_uri);</span>
<span class="lineNum">    2958 </span><span class="lineCov">         94 :         resource_size = pj_strlen(&amp;request_uri_sip-&gt;user) + 1;</span>
<span class="lineNum">    2959 </span><span class="lineCov">         94 :         resource = ast_alloca(resource_size);</span>
<span class="lineNum">    2960 </span><span class="lineCov">         94 :         ast_copy_pj_str(resource, &amp;request_uri_sip-&gt;user, resource_size);</span>
<span class="lineNum">    2961 </span>            : 
<span class="lineNum">    2962 </span>            :         /*
<span class="lineNum">    2963 </span>            :          * We may want to match without any user options getting
<span class="lineNum">    2964 </span>            :          * in the way.
<span class="lineNum">    2965 </span>            :          */
<span class="lineNum">    2966 </span><span class="lineCov">         94 :         AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(resource);</span>
<span class="lineNum">    2967 </span>            : 
<span class="lineNum">    2968 </span><span class="lineCov">         94 :         expires_header = pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_EXPIRES, rdata-&gt;msg_info.msg-&gt;hdr.next);</span>
<span class="lineNum">    2969 </span><span class="lineCov">         94 :         if (expires_header) {</span>
<span class="lineNum">    2970 </span><span class="lineCov">         86 :                 if (expires_header-&gt;ivalue == 0) {</span>
<span class="lineNum">    2971 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Subscription request from endpoint %s rejected. Expiration of 0 is invalid\n&quot;,</span>
<span class="lineNum">    2972 </span>            :                                 ast_sorcery_object_get_id(endpoint));
<span class="lineNum">    2973 </span><span class="lineNoCov">          0 :                         pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 400, NULL, NULL, NULL);</span>
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 :                                 return PJ_TRUE;</span>
<span class="lineNum">    2975 </span>            :                 }
<span class="lineNum">    2976 </span><span class="lineCov">         86 :                 if (expires_header-&gt;ivalue &lt; endpoint-&gt;subscription.minexpiry) {</span>
<span class="lineNum">    2977 </span><span class="lineCov">          1 :                         ast_log(LOG_WARNING, &quot;Subscription expiration %d is too brief for endpoint %s. Minimum is %u\n&quot;,</span>
<span class="lineNum">    2978 </span><span class="lineCov">          1 :                                 expires_header-&gt;ivalue, ast_sorcery_object_get_id(endpoint), endpoint-&gt;subscription.minexpiry);</span>
<span class="lineNum">    2979 </span><span class="lineCov">          1 :                         pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 423, NULL, NULL, NULL);</span>
<span class="lineNum">    2980 </span><span class="lineCov">          1 :                         return PJ_TRUE;</span>
<span class="lineNum">    2981 </span>            :                 }
<span class="lineNum">    2982 </span>            :         }
<span class="lineNum">    2983 </span>            : 
<span class="lineNum">    2984 </span><span class="lineCov">         93 :         handler = subscription_get_handler_from_rdata(rdata);</span>
<span class="lineNum">    2985 </span><span class="lineCov">         93 :         if (!handler) {</span>
<span class="lineNum">    2986 </span><span class="lineCov">          2 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 489, NULL, NULL, NULL);</span>
<span class="lineNum">    2987 </span><span class="lineCov">          2 :                 return PJ_TRUE;</span>
<span class="lineNum">    2988 </span>            :         }
<span class="lineNum">    2989 </span>            : 
<span class="lineNum">    2990 </span><span class="lineCov">         91 :         generator = subscription_get_generator_from_rdata(rdata, handler);</span>
<span class="lineNum">    2991 </span><span class="lineCov">         91 :         if (!generator) {</span>
<span class="lineNum">    2992 </span><span class="lineCov">          7 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 489, NULL, NULL, NULL);</span>
<span class="lineNum">    2993 </span><span class="lineCov">          7 :                 return PJ_TRUE;</span>
<span class="lineNum">    2994 </span>            :         }
<span class="lineNum">    2995 </span>            : 
<span class="lineNum">    2996 </span><span class="lineCov">         84 :         memset(&amp;tree, 0, sizeof(tree));</span>
<span class="lineNum">    2997 </span><span class="lineCov">         84 :         resp = build_resource_tree(endpoint, handler, resource, &amp;tree,</span>
<span class="lineNum">    2998 </span>            :                 ast_sip_pubsub_has_eventlist_support(rdata));
<span class="lineNum">    2999 </span><span class="lineCov">         84 :         if (!PJSIP_IS_STATUS_IN_CLASS(resp, 200)) {</span>
<span class="lineNum">    3000 </span><span class="lineCov">          8 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, resp, NULL, NULL, NULL);</span>
<span class="lineNum">    3001 </span><span class="lineCov">          8 :                 resource_tree_destroy(&amp;tree);</span>
<span class="lineNum">    3002 </span><span class="lineCov">          8 :                 return PJ_TRUE;</span>
<span class="lineNum">    3003 </span>            :         }
<span class="lineNum">    3004 </span>            : 
<span class="lineNum">    3005 </span><span class="lineCov">         76 :         sub_tree = create_subscription_tree(handler, endpoint, rdata, resource, generator, &amp;tree, &amp;dlg_status);</span>
<span class="lineNum">    3006 </span><span class="lineCov">         76 :         if (!sub_tree) {</span>
<span class="lineNum">    3007 </span><span class="lineNoCov">          0 :                 if (dlg_status != PJ_EEXISTS) {</span>
<span class="lineNum">    3008 </span><span class="lineNoCov">          0 :                         pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 500, NULL, NULL, NULL);</span>
<span class="lineNum">    3009 </span>            :                 }
<span class="lineNum">    3010 </span>            :         } else {
<span class="lineNum">    3011 </span><span class="lineCov">         76 :                 struct initial_notify_data *ind = ast_malloc(sizeof(*ind));</span>
<span class="lineNum">    3012 </span>            : 
<span class="lineNum">    3013 </span><span class="lineCov">         76 :                 if (!ind) {</span>
<span class="lineNum">    3014 </span><span class="lineNoCov">          0 :                         pjsip_evsub_terminate(sub_tree-&gt;evsub, PJ_TRUE);</span>
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :                         resource_tree_destroy(&amp;tree);</span>
<span class="lineNum">    3016 </span><span class="lineNoCov">          0 :                         return PJ_TRUE;</span>
<span class="lineNum">    3017 </span>            :                 }
<span class="lineNum">    3018 </span>            : 
<span class="lineNum">    3019 </span><span class="lineCov">         76 :                 ind-&gt;sub_tree = ao2_bump(sub_tree);</span>
<span class="lineNum">    3020 </span>            :                 /* Since this is a normal subscribe, pjproject takes care of the timer */
<span class="lineNum">    3021 </span><span class="lineCov">         76 :                 ind-&gt;expires = -1;</span>
<span class="lineNum">    3022 </span>            : 
<span class="lineNum">    3023 </span><span class="lineCov">         76 :                 sub_tree-&gt;persistence = subscription_persistence_create(sub_tree);</span>
<span class="lineNum">    3024 </span><span class="lineCov">         76 :                 subscription_persistence_update(sub_tree, rdata, SUBSCRIPTION_PERSISTENCE_CREATED);</span>
<span class="lineNum">    3025 </span><span class="lineCov">         76 :                 sip_subscription_accept(sub_tree, rdata, resp);</span>
<span class="lineNum">    3026 </span><span class="lineCov">         76 :                 if (ast_sip_push_task(sub_tree-&gt;serializer, initial_notify_task, ind)) {</span>
<span class="lineNum">    3027 </span><span class="lineNoCov">          0 :                         pjsip_evsub_terminate(sub_tree-&gt;evsub, PJ_TRUE);</span>
<span class="lineNum">    3028 </span><span class="lineNoCov">          0 :                         ao2_ref(sub_tree, -1);</span>
<span class="lineNum">    3029 </span><span class="lineNoCov">          0 :                         ast_free(ind);</span>
<span class="lineNum">    3030 </span>            :                 }
<span class="lineNum">    3031 </span>            :         }
<span class="lineNum">    3032 </span>            : 
<span class="lineNum">    3033 </span><span class="lineCov">         76 :         resource_tree_destroy(&amp;tree);</span>
<span class="lineNum">    3034 </span><span class="lineCov">         76 :         return PJ_TRUE;</span>
<a name="3035"><span class="lineNum">    3035 </span>            : }</a>
<span class="lineNum">    3036 </span>            : 
<span class="lineNum">    3037 </span><span class="lineCov">         10 : static struct ast_sip_publish_handler *find_pub_handler(const char *event)</span>
<span class="lineNum">    3038 </span>            : {
<span class="lineNum">    3039 </span><span class="lineCov">         10 :         struct ast_sip_publish_handler *iter = NULL;</span>
<span class="lineNum">    3040 </span>            : 
<span class="lineNum">    3041 </span><span class="lineCov">         10 :         AST_RWLIST_RDLOCK(&amp;publish_handlers);</span>
<span class="lineNum">    3042 </span><span class="lineCov">         15 :         AST_RWLIST_TRAVERSE(&amp;publish_handlers, iter, next) {</span>
<span class="lineNum">    3043 </span><span class="lineCov">         15 :                 if (strcmp(event, iter-&gt;event_name)) {</span>
<span class="lineNum">    3044 </span><span class="lineCov">          5 :                         ast_debug(3, &quot;Event %s does not match %s\n&quot;, event, iter-&gt;event_name);</span>
<span class="lineNum">    3045 </span><span class="lineCov">          5 :                         continue;</span>
<span class="lineNum">    3046 </span>            :                 }
<span class="lineNum">    3047 </span><span class="lineCov">         10 :                 ast_debug(3, &quot;Event name match: %s = %s\n&quot;, event, iter-&gt;event_name);</span>
<span class="lineNum">    3048 </span><span class="lineCov">         10 :                 break;</span>
<span class="lineNum">    3049 </span>            :         }
<span class="lineNum">    3050 </span><span class="lineCov">         10 :         AST_RWLIST_UNLOCK(&amp;publish_handlers);</span>
<span class="lineNum">    3051 </span>            : 
<span class="lineNum">    3052 </span><span class="lineCov">         10 :         return iter;</span>
<a name="3053"><span class="lineNum">    3053 </span>            : }</a>
<span class="lineNum">    3054 </span>            : 
<span class="lineNum">    3055 </span><span class="lineCov">         10 : static enum sip_publish_type determine_sip_publish_type(pjsip_rx_data *rdata,</span>
<span class="lineNum">    3056 </span>            :         pjsip_generic_string_hdr *etag_hdr, int *expires, int *entity_id)
<span class="lineNum">    3057 </span>            : {
<span class="lineNum">    3058 </span><span class="lineCov">         10 :         pjsip_expires_hdr *expires_hdr = pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_EXPIRES, NULL);</span>
<span class="lineNum">    3059 </span>            : 
<span class="lineNum">    3060 </span><span class="lineCov">         10 :         if (etag_hdr) {</span>
<span class="lineNum">    3061 </span><span class="lineCov">          8 :                 char etag[pj_strlen(&amp;etag_hdr-&gt;hvalue) + 1];</span>
<span class="lineNum">    3062 </span>            : 
<span class="lineNum">    3063 </span><span class="lineCov">          8 :                 ast_copy_pj_str(etag, &amp;etag_hdr-&gt;hvalue, sizeof(etag));</span>
<span class="lineNum">    3064 </span>            : 
<span class="lineNum">    3065 </span><span class="lineCov">          8 :                 if (sscanf(etag, &quot;%30d&quot;, entity_id) != 1) {</span>
<span class="lineNum">    3066 </span><span class="lineNoCov">          0 :                         return SIP_PUBLISH_UNKNOWN;</span>
<span class="lineNum">    3067 </span>            :                 }
<span class="lineNum">    3068 </span>            :         }
<span class="lineNum">    3069 </span>            : 
<span class="lineNum">    3070 </span><span class="lineCov">         10 :         *expires = expires_hdr ? expires_hdr-&gt;ivalue : DEFAULT_PUBLISH_EXPIRES;</span>
<span class="lineNum">    3071 </span>            : 
<span class="lineNum">    3072 </span><span class="lineCov">         10 :         if (!(*expires)) {</span>
<span class="lineNum">    3073 </span><span class="lineCov">          2 :                 return SIP_PUBLISH_REMOVE;</span>
<span class="lineNum">    3074 </span><span class="lineCov">          8 :         } else if (!etag_hdr &amp;&amp; rdata-&gt;msg_info.msg-&gt;body) {</span>
<span class="lineNum">    3075 </span><span class="lineCov">          2 :                 return SIP_PUBLISH_INITIAL;</span>
<span class="lineNum">    3076 </span><span class="lineCov">          6 :         } else if (etag_hdr &amp;&amp; !rdata-&gt;msg_info.msg-&gt;body) {</span>
<span class="lineNum">    3077 </span><span class="lineNoCov">          0 :                 return SIP_PUBLISH_REFRESH;</span>
<span class="lineNum">    3078 </span><span class="lineCov">          6 :         } else if (etag_hdr &amp;&amp; rdata-&gt;msg_info.msg-&gt;body) {</span>
<span class="lineNum">    3079 </span><span class="lineCov">          6 :                 return SIP_PUBLISH_MODIFY;</span>
<span class="lineNum">    3080 </span>            :         }
<span class="lineNum">    3081 </span>            : 
<span class="lineNum">    3082 </span><span class="lineNoCov">          0 :         return SIP_PUBLISH_UNKNOWN;</span>
<span class="lineNum">    3083 </span>            : }
<a name="3084"><span class="lineNum">    3084 </span>            : </a>
<span class="lineNum">    3085 </span>            : /*! \brief Internal destructor for publications */
<span class="lineNum">    3086 </span><span class="lineCov">          2 : static void publication_destroy_fn(void *obj)</span>
<span class="lineNum">    3087 </span>            : {
<span class="lineNum">    3088 </span><span class="lineCov">          2 :         struct ast_sip_publication *publication = obj;</span>
<span class="lineNum">    3089 </span>            : 
<span class="lineNum">    3090 </span><span class="lineCov">          2 :         ast_debug(3, &quot;Destroying SIP publication\n&quot;);</span>
<span class="lineNum">    3091 </span>            : 
<span class="lineNum">    3092 </span><span class="lineCov">          2 :         ao2_cleanup(publication-&gt;datastores);</span>
<span class="lineNum">    3093 </span><span class="lineCov">          2 :         ao2_cleanup(publication-&gt;endpoint);</span>
<span class="lineNum">    3094 </span>            : 
<span class="lineNum">    3095 </span><span class="lineCov">          2 :         ast_module_unref(ast_module_info-&gt;self);</span>
<a name="3096"><span class="lineNum">    3096 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">    3097 </span>            : 
<span class="lineNum">    3098 </span><span class="lineCov">          2 : static struct ast_sip_publication *sip_create_publication(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata,</span>
<span class="lineNum">    3099 </span>            :         const char *resource, const char *event_configuration_name)
<span class="lineNum">    3100 </span>            : {
<span class="lineNum">    3101 </span>            :         struct ast_sip_publication *publication;
<span class="lineNum">    3102 </span><span class="lineCov">          2 :         pjsip_expires_hdr *expires_hdr = pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_EXPIRES, NULL);</span>
<span class="lineNum">    3103 </span><span class="lineCov">          2 :         size_t resource_len = strlen(resource) + 1, event_configuration_name_len = strlen(event_configuration_name) + 1;</span>
<span class="lineNum">    3104 </span>            :         char *dst;
<span class="lineNum">    3105 </span>            : 
<span class="lineNum">    3106 </span><span class="lineCov">          2 :         ast_assert(endpoint != NULL);</span>
<span class="lineNum">    3107 </span>            : 
<span class="lineNum">    3108 </span><span class="lineCov">          2 :         if (!(publication = ao2_alloc(sizeof(*publication) + resource_len + event_configuration_name_len, publication_destroy_fn))) {</span>
<span class="lineNum">    3109 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    3110 </span>            :         }
<span class="lineNum">    3111 </span>            : 
<span class="lineNum">    3112 </span><span class="lineCov">          2 :         ast_module_ref(ast_module_info-&gt;self);</span>
<span class="lineNum">    3113 </span>            : 
<span class="lineNum">    3114 </span><span class="lineCov">          2 :         if (!(publication-&gt;datastores = ast_datastores_alloc())) {</span>
<span class="lineNum">    3115 </span><span class="lineNoCov">          0 :                 ao2_ref(publication, -1);</span>
<span class="lineNum">    3116 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    3117 </span>            :         }
<span class="lineNum">    3118 </span>            : 
<span class="lineNum">    3119 </span><span class="lineCov">          2 :         publication-&gt;entity_tag = ast_atomic_fetchadd_int(&amp;esc_etag_counter, +1);</span>
<span class="lineNum">    3120 </span><span class="lineCov">          2 :         ao2_ref(endpoint, +1);</span>
<span class="lineNum">    3121 </span><span class="lineCov">          2 :         publication-&gt;endpoint = endpoint;</span>
<span class="lineNum">    3122 </span><span class="lineCov">          2 :         publication-&gt;expires = expires_hdr ? expires_hdr-&gt;ivalue : DEFAULT_PUBLISH_EXPIRES;</span>
<span class="lineNum">    3123 </span><span class="lineCov">          2 :         publication-&gt;sched_id = -1;</span>
<span class="lineNum">    3124 </span><span class="lineCov">          2 :         dst = publication-&gt;data;</span>
<span class="lineNum">    3125 </span><span class="lineCov">          2 :         publication-&gt;resource = strcpy(dst, resource);</span>
<span class="lineNum">    3126 </span><span class="lineCov">          2 :         dst += resource_len;</span>
<span class="lineNum">    3127 </span><span class="lineCov">          2 :         publication-&gt;event_configuration_name = strcpy(dst, event_configuration_name);</span>
<span class="lineNum">    3128 </span>            : 
<span class="lineNum">    3129 </span><span class="lineCov">          2 :         return publication;</span>
<a name="3130"><span class="lineNum">    3130 </span>            : }</a>
<span class="lineNum">    3131 </span>            : 
<span class="lineNum">    3132 </span><span class="lineCov">         10 : static int sip_publication_respond(struct ast_sip_publication *pub, int status_code,</span>
<span class="lineNum">    3133 </span>            :                 pjsip_rx_data *rdata)
<span class="lineNum">    3134 </span>            : {
<span class="lineNum">    3135 </span>            :         pjsip_tx_data *tdata;
<span class="lineNum">    3136 </span>            :         pjsip_transaction *tsx;
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span><span class="lineCov">         10 :         if (pjsip_endpt_create_response(ast_sip_get_pjsip_endpoint(), rdata, status_code, NULL, &amp;tdata) != PJ_SUCCESS) {</span>
<span class="lineNum">    3139 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3140 </span>            :         }
<span class="lineNum">    3141 </span>            : 
<span class="lineNum">    3142 </span><span class="lineCov">         10 :         if (PJSIP_IS_STATUS_IN_CLASS(status_code, 200)) {</span>
<span class="lineNum">    3143 </span>            :                 char buf[30];
<span class="lineNum">    3144 </span>            : 
<span class="lineNum">    3145 </span><span class="lineCov">         10 :                 snprintf(buf, sizeof(buf), &quot;%d&quot;, pub-&gt;entity_tag);</span>
<span class="lineNum">    3146 </span><span class="lineCov">         10 :                 ast_sip_add_header(tdata, &quot;SIP-ETag&quot;, buf);</span>
<span class="lineNum">    3147 </span>            : 
<span class="lineNum">    3148 </span><span class="lineCov">         10 :                 snprintf(buf, sizeof(buf), &quot;%d&quot;, pub-&gt;expires);</span>
<span class="lineNum">    3149 </span><span class="lineCov">         10 :                 ast_sip_add_header(tdata, &quot;Expires&quot;, buf);</span>
<span class="lineNum">    3150 </span>            :         }
<span class="lineNum">    3151 </span>            : 
<span class="lineNum">    3152 </span><span class="lineCov">         10 :         if (pjsip_tsx_create_uas(&amp;pubsub_module, rdata, &amp;tsx) != PJ_SUCCESS) {</span>
<span class="lineNum">    3153 </span><span class="lineNoCov">          0 :                 pjsip_tx_data_dec_ref(tdata);</span>
<span class="lineNum">    3154 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3155 </span>            :         }
<span class="lineNum">    3156 </span>            : 
<span class="lineNum">    3157 </span><span class="lineCov">         10 :         pjsip_tsx_recv_msg(tsx, rdata);</span>
<span class="lineNum">    3158 </span>            : 
<span class="lineNum">    3159 </span><span class="lineCov">         10 :         if (pjsip_tsx_send_msg(tsx, tdata) != PJ_SUCCESS) {</span>
<span class="lineNum">    3160 </span><span class="lineNoCov">          0 :                 pjsip_tx_data_dec_ref(tdata);</span>
<span class="lineNum">    3161 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3162 </span>            :         }
<span class="lineNum">    3163 </span>            : 
<span class="lineNum">    3164 </span><span class="lineCov">         10 :         return 0;</span>
<a name="3165"><span class="lineNum">    3165 </span>            : }</a>
<span class="lineNum">    3166 </span>            : 
<span class="lineNum">    3167 </span><span class="lineCov">          2 : static struct ast_sip_publication *publish_request_initial(struct ast_sip_endpoint *endpoint, pjsip_rx_data *rdata,</span>
<span class="lineNum">    3168 </span>            :         struct ast_sip_publish_handler *handler)
<span class="lineNum">    3169 </span>            : {
<span class="lineNum">    3170 </span>            :         struct ast_sip_publication *publication;
<a name="3171"><span class="lineNum">    3171 </span>            :         char *resource_name;</a>
<span class="lineNum">    3172 </span>            :         size_t resource_size;
<span class="lineNum">    3173 </span><span class="lineCov">          4 :         RAII_VAR(struct ast_sip_publication_resource *, resource, NULL, ao2_cleanup);</span>
<span class="lineNum">    3174 </span><span class="lineCov">          2 :         struct ast_variable *event_configuration_name = NULL;</span>
<span class="lineNum">    3175 </span>            :         pjsip_uri *request_uri;
<span class="lineNum">    3176 </span>            :         pjsip_sip_uri *request_uri_sip;
<span class="lineNum">    3177 </span>            :         int resp;
<span class="lineNum">    3178 </span>            : 
<span class="lineNum">    3179 </span><span class="lineCov">          2 :         request_uri = rdata-&gt;msg_info.msg-&gt;line.req.uri;</span>
<span class="lineNum">    3180 </span>            : 
<span class="lineNum">    3181 </span><span class="lineCov">          2 :         if (!PJSIP_URI_SCHEME_IS_SIP(request_uri) &amp;&amp; !PJSIP_URI_SCHEME_IS_SIPS(request_uri)) {</span>
<span class="lineNum">    3182 </span>            :                 char uri_str[PJSIP_MAX_URL_SIZE];
<span class="lineNum">    3183 </span>            : 
<span class="lineNum">    3184 </span><span class="lineNoCov">          0 :                 pjsip_uri_print(PJSIP_URI_IN_REQ_URI, request_uri, uri_str, sizeof(uri_str));</span>
<span class="lineNum">    3185 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Request URI '%s' is not a sip: or sips: URI.\n&quot;, uri_str);</span>
<span class="lineNum">    3186 </span><span class="lineNoCov">          0 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 416, NULL, NULL, NULL);</span>
<span class="lineNum">    3187 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    3188 </span>            :         }
<span class="lineNum">    3189 </span>            : 
<span class="lineNum">    3190 </span><span class="lineCov">          2 :         request_uri_sip = pjsip_uri_get_uri(request_uri);</span>
<span class="lineNum">    3191 </span><span class="lineCov">          2 :         resource_size = pj_strlen(&amp;request_uri_sip-&gt;user) + 1;</span>
<span class="lineNum">    3192 </span><span class="lineCov">          2 :         resource_name = ast_alloca(resource_size);</span>
<span class="lineNum">    3193 </span><span class="lineCov">          2 :         ast_copy_pj_str(resource_name, &amp;request_uri_sip-&gt;user, resource_size);</span>
<span class="lineNum">    3194 </span>            : 
<span class="lineNum">    3195 </span>            :         /*
<span class="lineNum">    3196 </span>            :          * We may want to match without any user options getting
<span class="lineNum">    3197 </span>            :          * in the way.
<span class="lineNum">    3198 </span>            :          */
<span class="lineNum">    3199 </span><span class="lineCov">          2 :         AST_SIP_USER_OPTIONS_TRUNCATE_CHECK(resource_name);</span>
<span class="lineNum">    3200 </span>            : 
<span class="lineNum">    3201 </span><span class="lineCov">          2 :         resource = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), &quot;inbound-publication&quot;, resource_name);</span>
<span class="lineNum">    3202 </span><span class="lineCov">          2 :         if (!resource) {</span>
<span class="lineNum">    3203 </span><span class="lineNoCov">          0 :                 ast_debug(1, &quot;No 'inbound-publication' defined for resource '%s'\n&quot;, resource_name);</span>
<span class="lineNum">    3204 </span><span class="lineNoCov">          0 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 404, NULL, NULL, NULL);</span>
<span class="lineNum">    3205 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    3206 </span>            :         }
<span class="lineNum">    3207 </span>            : 
<span class="lineNum">    3208 </span><span class="lineCov">          2 :         if (!ast_strlen_zero(resource-&gt;endpoint) &amp;&amp; strcmp(resource-&gt;endpoint, ast_sorcery_object_get_id(endpoint))) {</span>
<span class="lineNum">    3209 </span><span class="lineNoCov">          0 :                 ast_debug(1, &quot;Resource %s has a defined endpoint '%s', but does not match endpoint '%s' that received the request\n&quot;,</span>
<span class="lineNum">    3210 </span>            :                         resource_name, resource-&gt;endpoint, ast_sorcery_object_get_id(endpoint));
<span class="lineNum">    3211 </span><span class="lineNoCov">          0 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 403, NULL, NULL, NULL);</span>
<span class="lineNum">    3212 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    3213 </span>            :         }
<span class="lineNum">    3214 </span>            : 
<span class="lineNum">    3215 </span><span class="lineCov">          2 :         for (event_configuration_name = resource-&gt;events; event_configuration_name; event_configuration_name = event_configuration_name-&gt;next) {</span>
<span class="lineNum">    3216 </span><span class="lineCov">          2 :                 if (!strcmp(event_configuration_name-&gt;name, handler-&gt;event_name)) {</span>
<span class="lineNum">    3217 </span><span class="lineCov">          2 :                         break;</span>
<span class="lineNum">    3218 </span>            :                 }
<span class="lineNum">    3219 </span>            :         }
<span class="lineNum">    3220 </span>            : 
<span class="lineNum">    3221 </span><span class="lineCov">          2 :         if (!event_configuration_name) {</span>
<span class="lineNum">    3222 </span><span class="lineNoCov">          0 :                 ast_debug(1, &quot;Event '%s' is not configured for '%s'\n&quot;, handler-&gt;event_name, resource_name);</span>
<span class="lineNum">    3223 </span><span class="lineNoCov">          0 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 404, NULL, NULL, NULL);</span>
<span class="lineNum">    3224 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    3225 </span>            :         }
<span class="lineNum">    3226 </span>            : 
<span class="lineNum">    3227 </span><span class="lineCov">          2 :         resp = handler-&gt;new_publication(endpoint, resource_name, event_configuration_name-&gt;value);</span>
<span class="lineNum">    3228 </span>            : 
<span class="lineNum">    3229 </span><span class="lineCov">          2 :         if (!PJSIP_IS_STATUS_IN_CLASS(resp, 200)) {</span>
<span class="lineNum">    3230 </span><span class="lineNoCov">          0 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, resp, NULL, NULL, NULL);</span>
<span class="lineNum">    3231 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    3232 </span>            :         }
<span class="lineNum">    3233 </span>            : 
<span class="lineNum">    3234 </span><span class="lineCov">          2 :         publication = sip_create_publication(endpoint, rdata, S_OR(resource_name, &quot;&quot;), event_configuration_name-&gt;value);</span>
<span class="lineNum">    3235 </span>            : 
<span class="lineNum">    3236 </span><span class="lineCov">          2 :         if (!publication) {</span>
<span class="lineNum">    3237 </span><span class="lineNoCov">          0 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 503, NULL, NULL, NULL);</span>
<span class="lineNum">    3238 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    3239 </span>            :         }
<span class="lineNum">    3240 </span>            : 
<span class="lineNum">    3241 </span><span class="lineCov">          2 :         publication-&gt;handler = handler;</span>
<span class="lineNum">    3242 </span><span class="lineCov">          2 :         if (publication-&gt;handler-&gt;publication_state_change(publication, rdata-&gt;msg_info.msg-&gt;body,</span>
<span class="lineNum">    3243 </span>            :                         AST_SIP_PUBLISH_STATE_INITIALIZED)) {
<span class="lineNum">    3244 </span><span class="lineNoCov">          0 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 500, NULL, NULL, NULL);</span>
<span class="lineNum">    3245 </span><span class="lineNoCov">          0 :                 ao2_cleanup(publication);</span>
<span class="lineNum">    3246 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    3247 </span>            :         }
<span class="lineNum">    3248 </span>            : 
<span class="lineNum">    3249 </span><span class="lineCov">          2 :         sip_publication_respond(publication, resp, rdata);</span>
<span class="lineNum">    3250 </span>            : 
<span class="lineNum">    3251 </span><span class="lineCov">          2 :         return publication;</span>
<a name="3252"><span class="lineNum">    3252 </span>            : }</a>
<span class="lineNum">    3253 </span>            : 
<a name="3254"><span class="lineNum">    3254 </span><span class="lineNoCov">          0 : static int publish_expire_callback(void *data)</span></a>
<span class="lineNum">    3255 </span>            : {
<span class="lineNum">    3256 </span><span class="lineNoCov">          0 :         RAII_VAR(struct ast_sip_publication *, publication, data, ao2_cleanup);</span>
<span class="lineNum">    3257 </span>            : 
<span class="lineNum">    3258 </span><span class="lineNoCov">          0 :         if (publication-&gt;handler-&gt;publish_expire) {</span>
<span class="lineNum">    3259 </span><span class="lineNoCov">          0 :                 publication-&gt;handler-&gt;publish_expire(publication);</span>
<span class="lineNum">    3260 </span>            :         }
<span class="lineNum">    3261 </span>            : 
<span class="lineNum">    3262 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="3263"><span class="lineNum">    3263 </span>            : }</a>
<span class="lineNum">    3264 </span>            : 
<span class="lineNum">    3265 </span><span class="lineNoCov">          0 : static int publish_expire(const void *data)</span>
<span class="lineNum">    3266 </span>            : {
<span class="lineNum">    3267 </span><span class="lineNoCov">          0 :         struct ast_sip_publication *publication = (struct ast_sip_publication*)data;</span>
<span class="lineNum">    3268 </span>            : 
<span class="lineNum">    3269 </span><span class="lineNoCov">          0 :         ao2_unlink(publication-&gt;handler-&gt;publications, publication);</span>
<span class="lineNum">    3270 </span><span class="lineNoCov">          0 :         publication-&gt;sched_id = -1;</span>
<span class="lineNum">    3271 </span>            : 
<span class="lineNum">    3272 </span><span class="lineNoCov">          0 :         if (ast_sip_push_task(NULL, publish_expire_callback, publication)) {</span>
<span class="lineNum">    3273 </span><span class="lineNoCov">          0 :                 ao2_cleanup(publication);</span>
<span class="lineNum">    3274 </span>            :         }
<span class="lineNum">    3275 </span>            : 
<span class="lineNum">    3276 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="3277"><span class="lineNum">    3277 </span>            : }</a>
<span class="lineNum">    3278 </span>            : 
<span class="lineNum">    3279 </span><span class="lineCov">         10 : static pj_bool_t pubsub_on_rx_publish_request(pjsip_rx_data *rdata)</span>
<span class="lineNum">    3280 </span>            : {
<a name="3281"><span class="lineNum">    3281 </span>            :         pjsip_event_hdr *event_header;</a>
<span class="lineNum">    3282 </span>            :         struct ast_sip_publish_handler *handler;
<span class="lineNum">    3283 </span><span class="lineCov">         20 :         RAII_VAR(struct ast_sip_endpoint *, endpoint, NULL, ao2_cleanup);</span>
<span class="lineNum">    3284 </span>            :         char event[32];
<span class="lineNum">    3285 </span>            :         static const pj_str_t str_sip_if_match = { &quot;SIP-If-Match&quot;, 12 };
<a name="3286"><span class="lineNum">    3286 </span><span class="lineCov">         10 :         pjsip_generic_string_hdr *etag_hdr = pjsip_msg_find_hdr_by_name(rdata-&gt;msg_info.msg, &amp;str_sip_if_match, NULL);</span></a>
<span class="lineNum">    3287 </span>            :         enum sip_publish_type publish_type;
<span class="lineNum">    3288 </span><span class="lineCov">         20 :         RAII_VAR(struct ast_sip_publication *, publication, NULL, ao2_cleanup);</span>
<span class="lineNum">    3289 </span><span class="lineCov">         10 :         int expires = 0, entity_id, response = 0;</span>
<span class="lineNum">    3290 </span>            : 
<span class="lineNum">    3291 </span><span class="lineCov">         10 :         endpoint = ast_pjsip_rdata_get_endpoint(rdata);</span>
<span class="lineNum">    3292 </span><span class="lineCov">         10 :         ast_assert(endpoint != NULL);</span>
<span class="lineNum">    3293 </span>            : 
<span class="lineNum">    3294 </span><span class="lineCov">         10 :         event_header = pjsip_msg_find_hdr_by_name(rdata-&gt;msg_info.msg, &amp;str_event_name, rdata-&gt;msg_info.msg-&gt;hdr.next);</span>
<span class="lineNum">    3295 </span><span class="lineCov">         10 :         if (!event_header) {</span>
<span class="lineNum">    3296 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Incoming PUBLISH request with no Event header\n&quot;);</span>
<span class="lineNum">    3297 </span><span class="lineNoCov">          0 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 489, NULL, NULL, NULL);</span>
<span class="lineNum">    3298 </span><span class="lineNoCov">          0 :                 return PJ_TRUE;</span>
<span class="lineNum">    3299 </span>            :         }
<span class="lineNum">    3300 </span><span class="lineCov">         10 :         ast_copy_pj_str(event, &amp;event_header-&gt;event_type, sizeof(event));</span>
<span class="lineNum">    3301 </span>            : 
<span class="lineNum">    3302 </span><span class="lineCov">         10 :         handler = find_pub_handler(event);</span>
<span class="lineNum">    3303 </span><span class="lineCov">         10 :         if (!handler) {</span>
<span class="lineNum">    3304 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;No registered publish handler for event %s\n&quot;, event);</span>
<span class="lineNum">    3305 </span><span class="lineNoCov">          0 :                 pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 489, NULL, NULL, NULL);</span>
<span class="lineNum">    3306 </span><span class="lineNoCov">          0 :                 return PJ_TRUE;</span>
<span class="lineNum">    3307 </span>            :         }
<span class="lineNum">    3308 </span>            : 
<span class="lineNum">    3309 </span><span class="lineCov">         10 :         publish_type = determine_sip_publish_type(rdata, etag_hdr, &amp;expires, &amp;entity_id);</span>
<span class="lineNum">    3310 </span>            : 
<span class="lineNum">    3311 </span>            :         /* If this is not an initial publish ensure that a publication is present */
<span class="lineNum">    3312 </span><span class="lineCov">         10 :         if ((publish_type != SIP_PUBLISH_INITIAL) &amp;&amp; (publish_type != SIP_PUBLISH_UNKNOWN)) {</span>
<span class="lineNum">    3313 </span><span class="lineCov">          8 :                 if (!(publication = ao2_find(handler-&gt;publications, &amp;entity_id, OBJ_KEY | OBJ_UNLINK))) {</span>
<span class="lineNum">    3314 </span>            :                         static const pj_str_t str_conditional_request_failed = { &quot;Conditional Request Failed&quot;, 26 };
<span class="lineNum">    3315 </span>            : 
<span class="lineNum">    3316 </span><span class="lineNoCov">          0 :                         pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 412, &amp;str_conditional_request_failed,</span>
<span class="lineNum">    3317 </span>            :                                 NULL, NULL);
<span class="lineNum">    3318 </span><span class="lineNoCov">          0 :                         return PJ_TRUE;</span>
<span class="lineNum">    3319 </span>            :                 }
<span class="lineNum">    3320 </span>            : 
<span class="lineNum">    3321 </span>            :                 /* Per the RFC every response has to have a new entity tag */
<span class="lineNum">    3322 </span><span class="lineCov">          8 :                 publication-&gt;entity_tag = ast_atomic_fetchadd_int(&amp;esc_etag_counter, +1);</span>
<span class="lineNum">    3323 </span>            : 
<span class="lineNum">    3324 </span>            :                 /* Update the expires here so that the created responses will contain the correct value */
<span class="lineNum">    3325 </span><span class="lineCov">          8 :                 publication-&gt;expires = expires;</span>
<span class="lineNum">    3326 </span>            :         }
<span class="lineNum">    3327 </span>            : 
<span class="lineNum">    3328 </span><span class="lineCov">         10 :         switch (publish_type) {</span>
<span class="lineNum">    3329 </span><span class="lineCov">          2 :                 case SIP_PUBLISH_INITIAL:</span>
<span class="lineNum">    3330 </span><span class="lineCov">          2 :                         publication = publish_request_initial(endpoint, rdata, handler);</span>
<span class="lineNum">    3331 </span><span class="lineCov">          2 :                         break;</span>
<span class="lineNum">    3332 </span><span class="lineCov">          6 :                 case SIP_PUBLISH_REFRESH:</span>
<span class="lineNum">    3333 </span>            :                 case SIP_PUBLISH_MODIFY:
<span class="lineNum">    3334 </span><span class="lineCov">          6 :                         if (handler-&gt;publication_state_change(publication, rdata-&gt;msg_info.msg-&gt;body,</span>
<span class="lineNum">    3335 </span>            :                                                 AST_SIP_PUBLISH_STATE_ACTIVE)) {
<span class="lineNum">    3336 </span>            :                                 /* If an error occurs we want to terminate the publication */
<span class="lineNum">    3337 </span><span class="lineNoCov">          0 :                                 expires = 0;</span>
<span class="lineNum">    3338 </span>            :                         }
<span class="lineNum">    3339 </span><span class="lineCov">          6 :                         response = 200;</span>
<span class="lineNum">    3340 </span><span class="lineCov">          6 :                         break;</span>
<span class="lineNum">    3341 </span><span class="lineCov">          2 :                 case SIP_PUBLISH_REMOVE:</span>
<span class="lineNum">    3342 </span><span class="lineCov">          2 :                         handler-&gt;publication_state_change(publication, rdata-&gt;msg_info.msg-&gt;body,</span>
<span class="lineNum">    3343 </span>            :                                         AST_SIP_PUBLISH_STATE_TERMINATED);
<span class="lineNum">    3344 </span><span class="lineCov">          2 :                         response = 200;</span>
<span class="lineNum">    3345 </span><span class="lineCov">          2 :                         break;</span>
<span class="lineNum">    3346 </span><span class="lineNoCov">          0 :                 case SIP_PUBLISH_UNKNOWN:</span>
<span class="lineNum">    3347 </span>            :                 default:
<span class="lineNum">    3348 </span><span class="lineNoCov">          0 :                         pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, 400, NULL, NULL, NULL);</span>
<span class="lineNum">    3349 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    3350 </span>            :         }
<span class="lineNum">    3351 </span>            : 
<span class="lineNum">    3352 </span><span class="lineCov">         10 :         if (publication) {</span>
<span class="lineNum">    3353 </span><span class="lineCov">         10 :                 if (expires) {</span>
<span class="lineNum">    3354 </span><span class="lineCov">          8 :                         ao2_link(handler-&gt;publications, publication);</span>
<span class="lineNum">    3355 </span>            : 
<span class="lineNum">    3356 </span><span class="lineCov">          8 :                         AST_SCHED_REPLACE_UNREF(publication-&gt;sched_id, sched, expires * 1000, publish_expire, publication,</span>
<span class="lineNum">    3357 </span>            :                                                 ao2_ref(_data, -1), ao2_ref(publication, -1), ao2_ref(publication, +1));
<span class="lineNum">    3358 </span>            :                 } else {
<span class="lineNum">    3359 </span><span class="lineCov">          2 :                         AST_SCHED_DEL_UNREF(sched, publication-&gt;sched_id, ao2_ref(publication, -1));</span>
<span class="lineNum">    3360 </span>            :                 }
<span class="lineNum">    3361 </span>            :         }
<span class="lineNum">    3362 </span>            : 
<span class="lineNum">    3363 </span><span class="lineCov">         10 :         if (response) {</span>
<span class="lineNum">    3364 </span><span class="lineCov">          8 :                 sip_publication_respond(publication, response, rdata);</span>
<span class="lineNum">    3365 </span>            :         }
<span class="lineNum">    3366 </span>            : 
<span class="lineNum">    3367 </span><span class="lineCov">         10 :         return PJ_TRUE;</span>
<a name="3368"><span class="lineNum">    3368 </span>            : }</a>
<span class="lineNum">    3369 </span>            : 
<span class="lineNum">    3370 </span><span class="lineNoCov">          0 : struct ast_sip_endpoint *ast_sip_publication_get_endpoint(struct ast_sip_publication *pub)</span>
<span class="lineNum">    3371 </span>            : {
<span class="lineNum">    3372 </span><span class="lineNoCov">          0 :         return pub-&gt;endpoint;</span>
<a name="3373"><span class="lineNum">    3373 </span>            : }</a>
<span class="lineNum">    3374 </span>            : 
<span class="lineNum">    3375 </span><span class="lineNoCov">          0 : const char *ast_sip_publication_get_resource(const struct ast_sip_publication *pub)</span>
<span class="lineNum">    3376 </span>            : {
<span class="lineNum">    3377 </span><span class="lineNoCov">          0 :         return pub-&gt;resource;</span>
<a name="3378"><span class="lineNum">    3378 </span>            : }</a>
<span class="lineNum">    3379 </span>            : 
<span class="lineNum">    3380 </span><span class="lineCov">         10 : const char *ast_sip_publication_get_event_configuration(const struct ast_sip_publication *pub)</span>
<span class="lineNum">    3381 </span>            : {
<span class="lineNum">    3382 </span><span class="lineCov">         10 :         return pub-&gt;event_configuration_name;</span>
<a name="3383"><span class="lineNum">    3383 </span>            : }</a>
<span class="lineNum">    3384 </span>            : 
<span class="lineNum">    3385 </span><span class="lineCov">          3 : int ast_sip_pubsub_is_body_generator_registered(const char *type, const char *subtype)</span>
<span class="lineNum">    3386 </span>            : {
<span class="lineNum">    3387 </span><span class="lineCov">          3 :         return !!find_body_generator_type_subtype(type, subtype);</span>
<a name="3388"><span class="lineNum">    3388 </span>            : }</a>
<span class="lineNum">    3389 </span>            : 
<span class="lineNum">    3390 </span><span class="lineCov">       4253 : int ast_sip_pubsub_register_body_generator(struct ast_sip_pubsub_body_generator *generator)</span>
<span class="lineNum">    3391 </span>            : {
<span class="lineNum">    3392 </span>            :         struct ast_sip_pubsub_body_generator *existing;
<span class="lineNum">    3393 </span>            :         pj_str_t accept;
<span class="lineNum">    3394 </span>            :         pj_size_t accept_len;
<span class="lineNum">    3395 </span>            : 
<span class="lineNum">    3396 </span><span class="lineCov">       4253 :         AST_RWLIST_WRLOCK(&amp;body_generators);</span>
<span class="lineNum">    3397 </span><span class="lineCov">       4253 :         existing = find_body_generator_type_subtype_nolock(generator-&gt;type, generator-&gt;subtype);</span>
<span class="lineNum">    3398 </span><span class="lineCov">       4253 :         if (existing) {</span>
<span class="lineNum">    3399 </span><span class="lineNoCov">          0 :                 AST_RWLIST_UNLOCK(&amp;body_generators);</span>
<span class="lineNum">    3400 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;A body generator for %s/%s is already registered.\n&quot;,</span>
<span class="lineNum">    3401 </span>            :                         generator-&gt;type, generator-&gt;subtype);
<span class="lineNum">    3402 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3403 </span>            :         }
<span class="lineNum">    3404 </span><span class="lineCov">       4253 :         AST_LIST_INSERT_HEAD(&amp;body_generators, generator, list);</span>
<span class="lineNum">    3405 </span><span class="lineCov">       4253 :         AST_RWLIST_UNLOCK(&amp;body_generators);</span>
<span class="lineNum">    3406 </span>            : 
<span class="lineNum">    3407 </span>            :         /* Lengths of type and subtype plus a slash. */
<span class="lineNum">    3408 </span><span class="lineCov">       4253 :         accept_len = strlen(generator-&gt;type) + strlen(generator-&gt;subtype) + 1;</span>
<span class="lineNum">    3409 </span>            : 
<span class="lineNum">    3410 </span>            :         /* Add room for null terminator that sprintf() will set. */
<span class="lineNum">    3411 </span><span class="lineCov">       4253 :         pj_strset(&amp;accept, ast_alloca(accept_len + 1), accept_len);</span>
<span class="lineNum">    3412 </span><span class="lineCov">       4253 :         sprintf((char *) pj_strbuf(&amp;accept), &quot;%s/%s&quot;, generator-&gt;type, generator-&gt;subtype);/* Safe */</span>
<span class="lineNum">    3413 </span>            : 
<span class="lineNum">    3414 </span><span class="lineCov">       4253 :         pjsip_endpt_add_capability(ast_sip_get_pjsip_endpoint(), &amp;pubsub_module,</span>
<span class="lineNum">    3415 </span>            :                         PJSIP_H_ACCEPT, NULL, 1, &amp;accept);
<span class="lineNum">    3416 </span>            : 
<span class="lineNum">    3417 </span><span class="lineCov">       4253 :         return 0;</span>
<a name="3418"><span class="lineNum">    3418 </span>            : }</a>
<span class="lineNum">    3419 </span>            : 
<span class="lineNum">    3420 </span><span class="lineCov">       4248 : void ast_sip_pubsub_unregister_body_generator(struct ast_sip_pubsub_body_generator *generator)</span>
<span class="lineNum">    3421 </span>            : {
<span class="lineNum">    3422 </span>            :         struct ast_sip_pubsub_body_generator *iter;
<span class="lineNum">    3423 </span>            : 
<span class="lineNum">    3424 </span><span class="lineCov">       4248 :         AST_RWLIST_WRLOCK(&amp;body_generators);</span>
<span class="lineNum">    3425 </span><span class="lineCov">       4248 :         AST_RWLIST_TRAVERSE_SAFE_BEGIN(&amp;body_generators, iter, list) {</span>
<span class="lineNum">    3426 </span><span class="lineCov">       4248 :                 if (iter == generator) {</span>
<span class="lineNum">    3427 </span><span class="lineCov">       4248 :                         AST_LIST_REMOVE_CURRENT(list);</span>
<span class="lineNum">    3428 </span><span class="lineCov">       4248 :                         break;</span>
<span class="lineNum">    3429 </span>            :                 }
<span class="lineNum">    3430 </span>            :         }
<span class="lineNum">    3431 </span>            :         AST_RWLIST_TRAVERSE_SAFE_END;
<span class="lineNum">    3432 </span><span class="lineCov">       4248 :         AST_RWLIST_UNLOCK(&amp;body_generators);</span>
<a name="3433"><span class="lineNum">    3433 </span><span class="lineCov">       4248 : }</span></a>
<span class="lineNum">    3434 </span>            : 
<span class="lineNum">    3435 </span><span class="lineCov">       1704 : int ast_sip_pubsub_register_body_supplement(struct ast_sip_pubsub_body_supplement *supplement)</span>
<span class="lineNum">    3436 </span>            : {
<span class="lineNum">    3437 </span><span class="lineCov">       1704 :         AST_RWLIST_WRLOCK(&amp;body_supplements);</span>
<span class="lineNum">    3438 </span><span class="lineCov">       1704 :         AST_RWLIST_INSERT_TAIL(&amp;body_supplements, supplement, list);</span>
<span class="lineNum">    3439 </span><span class="lineCov">       1704 :         AST_RWLIST_UNLOCK(&amp;body_supplements);</span>
<span class="lineNum">    3440 </span>            : 
<span class="lineNum">    3441 </span><span class="lineCov">       1704 :         return 0;</span>
<a name="3442"><span class="lineNum">    3442 </span>            : }</a>
<span class="lineNum">    3443 </span>            : 
<span class="lineNum">    3444 </span><span class="lineCov">       1702 : void ast_sip_pubsub_unregister_body_supplement(struct ast_sip_pubsub_body_supplement *supplement)</span>
<span class="lineNum">    3445 </span>            : {
<span class="lineNum">    3446 </span>            :         struct ast_sip_pubsub_body_supplement *iter;
<span class="lineNum">    3447 </span>            : 
<span class="lineNum">    3448 </span><span class="lineCov">       1702 :         AST_RWLIST_WRLOCK(&amp;body_supplements);</span>
<span class="lineNum">    3449 </span><span class="lineCov">       2553 :         AST_RWLIST_TRAVERSE_SAFE_BEGIN(&amp;body_supplements, iter, list) {</span>
<span class="lineNum">    3450 </span><span class="lineCov">       2553 :                 if (iter == supplement) {</span>
<span class="lineNum">    3451 </span><span class="lineCov">       1702 :                         AST_LIST_REMOVE_CURRENT(list);</span>
<span class="lineNum">    3452 </span><span class="lineCov">       1702 :                         break;</span>
<span class="lineNum">    3453 </span>            :                 }
<span class="lineNum">    3454 </span>            :         }
<span class="lineNum">    3455 </span>            :         AST_RWLIST_TRAVERSE_SAFE_END;
<span class="lineNum">    3456 </span><span class="lineCov">       1702 :         AST_RWLIST_UNLOCK(&amp;body_supplements);</span>
<a name="3457"><span class="lineNum">    3457 </span><span class="lineCov">       1702 : }</span></a>
<span class="lineNum">    3458 </span>            : 
<span class="lineNum">    3459 </span><span class="lineCov">        580 : const char *ast_sip_subscription_get_body_type(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    3460 </span>            : {
<span class="lineNum">    3461 </span><span class="lineCov">        580 :         return sub-&gt;body_generator-&gt;type;</span>
<a name="3462"><span class="lineNum">    3462 </span>            : }</a>
<span class="lineNum">    3463 </span>            : 
<span class="lineNum">    3464 </span><span class="lineCov">        580 : const char *ast_sip_subscription_get_body_subtype(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    3465 </span>            : {
<span class="lineNum">    3466 </span><span class="lineCov">        580 :         return sub-&gt;body_generator-&gt;subtype;</span>
<a name="3467"><span class="lineNum">    3467 </span>            : }</a>
<span class="lineNum">    3468 </span>            : 
<span class="lineNum">    3469 </span><span class="lineCov">        295 : int ast_sip_pubsub_generate_body_content(const char *type, const char *subtype,</span>
<span class="lineNum">    3470 </span>            :                 struct ast_sip_body_data *data, struct ast_str **str)
<span class="lineNum">    3471 </span>            : {
<span class="lineNum">    3472 </span>            :         struct ast_sip_pubsub_body_supplement *supplement;
<span class="lineNum">    3473 </span>            :         struct ast_sip_pubsub_body_generator *generator;
<span class="lineNum">    3474 </span><span class="lineCov">        295 :         int res = 0;</span>
<span class="lineNum">    3475 </span>            :         void *body;
<span class="lineNum">    3476 </span>            : 
<span class="lineNum">    3477 </span><span class="lineCov">        295 :         generator = find_body_generator_type_subtype(type, subtype);</span>
<span class="lineNum">    3478 </span><span class="lineCov">        295 :         if (!generator) {</span>
<span class="lineNum">    3479 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unable to find a body generator for %s/%s\n&quot;,</span>
<span class="lineNum">    3480 </span>            :                                 type, subtype);
<span class="lineNum">    3481 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3482 </span>            :         }
<span class="lineNum">    3483 </span>            : 
<span class="lineNum">    3484 </span><span class="lineCov">        295 :         if (strcmp(data-&gt;body_type, generator-&gt;body_type)) {</span>
<span class="lineNum">    3485 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;%s/%s body generator does not accept the type of data provided\n&quot;,</span>
<span class="lineNum">    3486 </span>            :                         type, subtype);
<span class="lineNum">    3487 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3488 </span>            :         }
<span class="lineNum">    3489 </span>            : 
<span class="lineNum">    3490 </span><span class="lineCov">        295 :         body = generator-&gt;allocate_body(data-&gt;body_data);</span>
<span class="lineNum">    3491 </span><span class="lineCov">        295 :         if (!body) {</span>
<span class="lineNum">    3492 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;%s/%s body generator could not to allocate a body\n&quot;,</span>
<span class="lineNum">    3493 </span>            :                         type, subtype);
<span class="lineNum">    3494 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3495 </span>            :         }
<span class="lineNum">    3496 </span>            : 
<span class="lineNum">    3497 </span><span class="lineCov">        295 :         if (generator-&gt;generate_body_content(body, data-&gt;body_data)) {</span>
<span class="lineNum">    3498 </span><span class="lineNoCov">          0 :                 res = -1;</span>
<span class="lineNum">    3499 </span><span class="lineNoCov">          0 :                 goto end;</span>
<span class="lineNum">    3500 </span>            :         }
<span class="lineNum">    3501 </span>            : 
<span class="lineNum">    3502 </span><span class="lineCov">        295 :         AST_RWLIST_RDLOCK(&amp;body_supplements);</span>
<span class="lineNum">    3503 </span><span class="lineCov">        885 :         AST_RWLIST_TRAVERSE(&amp;body_supplements, supplement, list) {</span>
<span class="lineNum">    3504 </span><span class="lineCov">        590 :                 if (!strcmp(generator-&gt;type, supplement-&gt;type) &amp;&amp;</span>
<span class="lineNum">    3505 </span><span class="lineCov">        590 :                                 !strcmp(generator-&gt;subtype, supplement-&gt;subtype)) {</span>
<span class="lineNum">    3506 </span><span class="lineCov">        318 :                         res = supplement-&gt;supplement_body(body, data-&gt;body_data);</span>
<span class="lineNum">    3507 </span><span class="lineCov">        318 :                         if (res) {</span>
<span class="lineNum">    3508 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    3509 </span>            :                         }
<span class="lineNum">    3510 </span>            :                 }
<span class="lineNum">    3511 </span>            :         }
<span class="lineNum">    3512 </span><span class="lineCov">        295 :         AST_RWLIST_UNLOCK(&amp;body_supplements);</span>
<span class="lineNum">    3513 </span>            : 
<span class="lineNum">    3514 </span><span class="lineCov">        295 :         if (!res) {</span>
<span class="lineNum">    3515 </span><span class="lineCov">        295 :                 generator-&gt;to_string(body, str);</span>
<span class="lineNum">    3516 </span>            :         }
<span class="lineNum">    3517 </span>            : 
<span class="lineNum">    3518 </span><span class="lineNoCov">          0 : end:</span>
<span class="lineNum">    3519 </span><span class="lineCov">        295 :         if (generator-&gt;destroy_body) {</span>
<span class="lineNum">    3520 </span><span class="lineCov">        102 :                 generator-&gt;destroy_body(body);</span>
<span class="lineNum">    3521 </span>            :         }
<span class="lineNum">    3522 </span>            : 
<span class="lineNum">    3523 </span><span class="lineCov">        295 :         return res;</span>
<span class="lineNum">    3524 </span>            : }
<span class="lineNum">    3525 </span>            : 
<span class="lineNum">    3526 </span>            : struct simple_message_summary {
<span class="lineNum">    3527 </span>            :         int messages_waiting;
<span class="lineNum">    3528 </span>            :         int voice_messages_new;
<span class="lineNum">    3529 </span>            :         int voice_messages_old;
<span class="lineNum">    3530 </span>            :         int voice_messages_urgent_new;
<span class="lineNum">    3531 </span>            :         int voice_messages_urgent_old;
<span class="lineNum">    3532 </span>            :         char message_account[PJSIP_MAX_URL_SIZE];
<a name="3533"><span class="lineNum">    3533 </span>            : };</a>
<span class="lineNum">    3534 </span>            : 
<span class="lineNum">    3535 </span><span class="lineCov">          1 : static int parse_simple_message_summary(char *body,</span>
<span class="lineNum">    3536 </span>            :         struct simple_message_summary *summary)
<span class="lineNum">    3537 </span>            : {
<span class="lineNum">    3538 </span>            :         char *line;
<span class="lineNum">    3539 </span>            :         char *buffer;
<span class="lineNum">    3540 </span><span class="lineCov">          1 :         int found_counts = 0;</span>
<span class="lineNum">    3541 </span>            : 
<span class="lineNum">    3542 </span><span class="lineCov">          1 :         if (ast_strlen_zero(body) || !summary) {</span>
<span class="lineNum">    3543 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3544 </span>            :         }
<span class="lineNum">    3545 </span>            : 
<span class="lineNum">    3546 </span><span class="lineCov">          1 :         buffer = ast_strdupa(body);</span>
<span class="lineNum">    3547 </span><span class="lineCov">          1 :         memset(summary, 0, sizeof(*summary));</span>
<span class="lineNum">    3548 </span>            : 
<span class="lineNum">    3549 </span><span class="lineCov">          5 :         while ((line = ast_read_line_from_buffer(&amp;buffer))) {</span>
<span class="lineNum">    3550 </span><span class="lineCov">          4 :                 line = ast_str_to_lower(line);</span>
<span class="lineNum">    3551 </span>            : 
<span class="lineNum">    3552 </span><span class="lineCov">          4 :                 if (sscanf(line, &quot;voice-message: %d/%d (%d/%d)&quot;,</span>
<span class="lineNum">    3553 </span>            :                         &amp;summary-&gt;voice_messages_new, &amp;summary-&gt;voice_messages_old,
<span class="lineNum">    3554 </span>            :                         &amp;summary-&gt;voice_messages_urgent_new, &amp;summary-&gt;voice_messages_urgent_old)) {
<span class="lineNum">    3555 </span><span class="lineCov">          1 :                         found_counts = 1;</span>
<span class="lineNum">    3556 </span>            :                 } else {
<span class="lineNum">    3557 </span><span class="lineCov">          3 :                         sscanf(line, &quot;message-account: %s&quot;, summary-&gt;message_account);</span>
<span class="lineNum">    3558 </span>            :                 }
<span class="lineNum">    3559 </span>            :         }
<span class="lineNum">    3560 </span>            : 
<span class="lineNum">    3561 </span><span class="lineCov">          1 :         return !found_counts;</span>
<a name="3562"><span class="lineNum">    3562 </span>            : }</a>
<span class="lineNum">    3563 </span>            : 
<a name="3564"><span class="lineNum">    3564 </span><span class="lineCov">          2 : static pj_bool_t pubsub_on_rx_mwi_notify_request(pjsip_rx_data *rdata)</span></a>
<span class="lineNum">    3565 </span>            : {
<span class="lineNum">    3566 </span><span class="lineCov">          2 :         RAII_VAR(struct ast_sip_endpoint *, endpoint, NULL, ao2_cleanup);</span>
<span class="lineNum">    3567 </span>            :         struct simple_message_summary summary;
<span class="lineNum">    3568 </span>            :         const char *endpoint_name;
<span class="lineNum">    3569 </span>            :         char *atsign;
<span class="lineNum">    3570 </span>            :         char *context;
<span class="lineNum">    3571 </span>            :         char *body;
<span class="lineNum">    3572 </span>            :         char *mailbox;
<span class="lineNum">    3573 </span>            :         int rc;
<span class="lineNum">    3574 </span>            : 
<span class="lineNum">    3575 </span><span class="lineCov">          2 :         endpoint = ast_pjsip_rdata_get_endpoint(rdata);</span>
<span class="lineNum">    3576 </span><span class="lineCov">          2 :         if (!endpoint) {</span>
<span class="lineNum">    3577 </span><span class="lineNoCov">          0 :                 ast_debug(1, &quot;Incoming MWI: Endpoint not found in rdata (%p)\n&quot;, rdata);</span>
<span class="lineNum">    3578 </span><span class="lineNoCov">          0 :                 rc = 404;</span>
<span class="lineNum">    3579 </span><span class="lineNoCov">          0 :                 goto error;</span>
<span class="lineNum">    3580 </span>            :         }
<span class="lineNum">    3581 </span>            : 
<span class="lineNum">    3582 </span><span class="lineCov">          2 :         endpoint_name = ast_sorcery_object_get_id(endpoint);</span>
<span class="lineNum">    3583 </span><span class="lineCov">          2 :         ast_debug(1, &quot;Incoming MWI: Found endpoint: %s\n&quot;, endpoint_name);</span>
<span class="lineNum">    3584 </span><span class="lineCov">          2 :         if (ast_strlen_zero(endpoint-&gt;incoming_mwi_mailbox)) {</span>
<span class="lineNum">    3585 </span><span class="lineCov">          1 :                 ast_debug(1, &quot;Incoming MWI: No incoming mailbox specified for endpoint '%s'\n&quot;, endpoint_name);</span>
<span class="lineNum">    3586 </span><span class="lineCov">          1 :                 ast_test_suite_event_notify(&quot;PUBSUB_NO_INCOMING_MWI_MAILBOX&quot;,</span>
<span class="lineNum">    3587 </span>            :                         &quot;Endpoint: %s&quot;, endpoint_name);
<span class="lineNum">    3588 </span><span class="lineCov">          1 :                 rc = 404;</span>
<span class="lineNum">    3589 </span><span class="lineCov">          1 :                 goto error;</span>
<span class="lineNum">    3590 </span>            :         }
<span class="lineNum">    3591 </span>            : 
<span class="lineNum">    3592 </span><span class="lineCov">          1 :         mailbox = ast_strdupa(endpoint-&gt;incoming_mwi_mailbox);</span>
<span class="lineNum">    3593 </span><span class="lineCov">          1 :         atsign = strchr(mailbox, '@');</span>
<span class="lineNum">    3594 </span><span class="lineCov">          1 :         if (!atsign) {</span>
<span class="lineNum">    3595 </span><span class="lineNoCov">          0 :                 ast_debug(1, &quot;Incoming MWI: No '@' found in endpoint %s's incoming mailbox '%s'.  Can't parse context\n&quot;,</span>
<span class="lineNum">    3596 </span>            :                         endpoint_name, endpoint-&gt;incoming_mwi_mailbox);
<span class="lineNum">    3597 </span><span class="lineNoCov">          0 :                 rc = 404;</span>
<span class="lineNum">    3598 </span><span class="lineNoCov">          0 :                 goto error;</span>
<span class="lineNum">    3599 </span>            :         }
<span class="lineNum">    3600 </span>            : 
<span class="lineNum">    3601 </span><span class="lineCov">          1 :         *atsign = '\0';</span>
<span class="lineNum">    3602 </span><span class="lineCov">          1 :         context = atsign + 1;</span>
<span class="lineNum">    3603 </span>            : 
<span class="lineNum">    3604 </span><span class="lineCov">          1 :         body = ast_alloca(rdata-&gt;msg_info.msg-&gt;body-&gt;len + 1);</span>
<span class="lineNum">    3605 </span><span class="lineCov">          2 :         rdata-&gt;msg_info.msg-&gt;body-&gt;print_body(rdata-&gt;msg_info.msg-&gt;body, body,</span>
<span class="lineNum">    3606 </span><span class="lineCov">          1 :                 rdata-&gt;msg_info.msg-&gt;body-&gt;len + 1);</span>
<span class="lineNum">    3607 </span>            : 
<span class="lineNum">    3608 </span><span class="lineCov">          1 :         if (parse_simple_message_summary(body, &amp;summary) != 0) {</span>
<span class="lineNum">    3609 </span><span class="lineNoCov">          0 :                 ast_debug(1, &quot;Incoming MWI: Endpoint: '%s' There was an issue getting message info from body '%s'\n&quot;,</span>
<span class="lineNum">    3610 </span>            :                         ast_sorcery_object_get_id(endpoint), body);
<span class="lineNum">    3611 </span><span class="lineNoCov">          0 :                 rc = 404;</span>
<span class="lineNum">    3612 </span><span class="lineNoCov">          0 :                 goto error;</span>
<span class="lineNum">    3613 </span>            :         }
<span class="lineNum">    3614 </span>            : 
<span class="lineNum">    3615 </span><span class="lineCov">          1 :         if (ast_publish_mwi_state(mailbox, context,</span>
<span class="lineNum">    3616 </span>            :                 summary.voice_messages_new, summary.voice_messages_old)) {
<span class="lineNum">    3617 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Incoming MWI: Endpoint: '%s' Could not publish MWI to stasis.  &quot;</span>
<span class="lineNum">    3618 </span>            :                         &quot;Mailbox: %s Message-Account: %s Voice-Messages: %d/%d (%d/%d)\n&quot;,
<span class="lineNum">    3619 </span><span class="lineNoCov">          0 :                         endpoint_name, endpoint-&gt;incoming_mwi_mailbox, summary.message_account,</span>
<span class="lineNum">    3620 </span>            :                         summary.voice_messages_new, summary.voice_messages_old,
<span class="lineNum">    3621 </span>            :                         summary.voice_messages_urgent_new, summary.voice_messages_urgent_old);
<span class="lineNum">    3622 </span><span class="lineNoCov">          0 :                 rc = 404;</span>
<span class="lineNum">    3623 </span>            :         } else {
<span class="lineNum">    3624 </span><span class="lineCov">          1 :                 ast_debug(1, &quot;Incoming MWI: Endpoint: '%s' Mailbox: %s Message-Account: %s Voice-Messages: %d/%d (%d/%d)\n&quot;,</span>
<span class="lineNum">    3625 </span>            :                         endpoint_name, endpoint-&gt;incoming_mwi_mailbox, summary.message_account,
<span class="lineNum">    3626 </span>            :                         summary.voice_messages_new, summary.voice_messages_old,
<span class="lineNum">    3627 </span>            :                         summary.voice_messages_urgent_new, summary.voice_messages_urgent_old);
<span class="lineNum">    3628 </span><span class="lineCov">          1 :                 ast_test_suite_event_notify(&quot;PUBSUB_INCOMING_MWI_PUBLISH&quot;,</span>
<span class="lineNum">    3629 </span>            :                         &quot;Endpoint: %s\r\n&quot;
<span class="lineNum">    3630 </span>            :                         &quot;Mailbox: %s\r\n&quot;
<span class="lineNum">    3631 </span>            :                         &quot;MessageAccount: %s\r\n&quot;
<span class="lineNum">    3632 </span>            :                         &quot;VoiceMessagesNew: %d\r\n&quot;
<span class="lineNum">    3633 </span>            :                         &quot;VoiceMessagesOld: %d\r\n&quot;
<span class="lineNum">    3634 </span>            :                         &quot;VoiceMessagesUrgentNew: %d\r\n&quot;
<span class="lineNum">    3635 </span>            :                         &quot;VoiceMessagesUrgentOld: %d&quot;,
<span class="lineNum">    3636 </span>            :                                 endpoint_name, endpoint-&gt;incoming_mwi_mailbox, summary.message_account,
<span class="lineNum">    3637 </span>            :                                 summary.voice_messages_new, summary.voice_messages_old,
<span class="lineNum">    3638 </span>            :                                 summary.voice_messages_urgent_new, summary.voice_messages_urgent_old);
<span class="lineNum">    3639 </span><span class="lineCov">          1 :                 rc = 200;</span>
<span class="lineNum">    3640 </span>            :         }
<span class="lineNum">    3641 </span>            : 
<span class="lineNum">    3642 </span><span class="lineCov">          2 : error:</span>
<span class="lineNum">    3643 </span><span class="lineCov">          2 :         pjsip_endpt_respond_stateless(ast_sip_get_pjsip_endpoint(), rdata, rc, NULL, NULL, NULL);</span>
<span class="lineNum">    3644 </span><span class="lineCov">          2 :         return PJ_TRUE;</span>
<a name="3645"><span class="lineNum">    3645 </span>            : }</a>
<span class="lineNum">    3646 </span>            : 
<span class="lineNum">    3647 </span><span class="lineCov">          2 : static pj_bool_t pubsub_on_rx_notify_request(pjsip_rx_data *rdata)</span>
<span class="lineNum">    3648 </span>            : {
<span class="lineNum">    3649 </span><span class="lineCov">          4 :         if (rdata-&gt;msg_info.msg-&gt;body &amp;&amp;</span>
<span class="lineNum">    3650 </span><span class="lineCov">          2 :                 ast_sip_is_content_type(&amp;rdata-&gt;msg_info.msg-&gt;body-&gt;content_type,</span>
<span class="lineNum">    3651 </span>            :                                                                 &quot;application&quot;, &quot;simple-message-summary&quot;)) {
<span class="lineNum">    3652 </span><span class="lineCov">          2 :                 return pubsub_on_rx_mwi_notify_request(rdata);</span>
<span class="lineNum">    3653 </span>            :         }
<span class="lineNum">    3654 </span><span class="lineNoCov">          0 :         return PJ_FALSE;</span>
<a name="3655"><span class="lineNum">    3655 </span>            : }</a>
<span class="lineNum">    3656 </span>            : 
<span class="lineNum">    3657 </span><span class="lineCov">        731 : static pj_bool_t pubsub_on_rx_request(pjsip_rx_data *rdata)</span>
<span class="lineNum">    3658 </span>            : {
<span class="lineNum">    3659 </span><span class="lineCov">        731 :         if (!pjsip_method_cmp(&amp;rdata-&gt;msg_info.msg-&gt;line.req.method, pjsip_get_subscribe_method())) {</span>
<span class="lineNum">    3660 </span><span class="lineCov">         95 :                 return pubsub_on_rx_subscribe_request(rdata);</span>
<span class="lineNum">    3661 </span><span class="lineCov">        636 :         } else if (!pjsip_method_cmp(&amp;rdata-&gt;msg_info.msg-&gt;line.req.method, &amp;pjsip_publish_method)) {</span>
<span class="lineNum">    3662 </span><span class="lineCov">         10 :                 return pubsub_on_rx_publish_request(rdata);</span>
<span class="lineNum">    3663 </span><span class="lineCov">        626 :         } else if (!pjsip_method_cmp(&amp;rdata-&gt;msg_info.msg-&gt;line.req.method, &amp;pjsip_notify_method)) {</span>
<span class="lineNum">    3664 </span><span class="lineCov">          2 :                 return pubsub_on_rx_notify_request(rdata);</span>
<span class="lineNum">    3665 </span>            :         }
<span class="lineNum">    3666 </span>            : 
<span class="lineNum">    3667 </span><span class="lineCov">        624 :         return PJ_FALSE;</span>
<a name="3668"><span class="lineNum">    3668 </span>            : }</a>
<span class="lineNum">    3669 </span>            : 
<span class="lineNum">    3670 </span><span class="lineCov">         49 : static void set_state_terminated(struct ast_sip_subscription *sub)</span>
<span class="lineNum">    3671 </span>            : {
<span class="lineNum">    3672 </span>            :         int i;
<span class="lineNum">    3673 </span>            : 
<span class="lineNum">    3674 </span><span class="lineCov">         49 :         sub-&gt;subscription_state = PJSIP_EVSUB_STATE_TERMINATED;</span>
<span class="lineNum">    3675 </span><span class="lineCov">         77 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;sub-&gt;children); ++i) {</span>
<span class="lineNum">    3676 </span><span class="lineCov">         28 :                 set_state_terminated(AST_VECTOR_GET(&amp;sub-&gt;children, i));</span>
<span class="lineNum">    3677 </span>            :         }
<span class="lineNum">    3678 </span><span class="lineCov">         49 : }</span>
<span class="lineNum">    3679 </span>            : 
<span class="lineNum">    3680 </span>            : /*!
<span class="lineNum">    3681 </span>            :  * \brief Callback sequence for subscription terminate:
<span class="lineNum">    3682 </span>            :  *
<span class="lineNum">    3683 </span>            :  * * Client initiated:
<span class="lineNum">    3684 </span>            :  *     pjproject receives SUBSCRIBE on the subscription's serializer thread
<span class="lineNum">    3685 </span>            :  *         calls pubsub_on_rx_refresh with dialog locked
<span class="lineNum">    3686 </span>            :  *             pubsub_on_rx_refresh sets TERMINATE_PENDING
<span class="lineNum">    3687 </span>            :  *             pushes serialized_pubsub_on_refresh_timeout
<span class="lineNum">    3688 </span>            :  *             returns to pjproject
<span class="lineNum">    3689 </span>            :  *         pjproject calls pubsub_on_evsub_state
<span class="lineNum">    3690 </span>            :  *             pubsub_evsub_set_state checks state == TERMINATE_IN_PROGRESS (no)
<span class="lineNum">    3691 </span>            :  *             ignore and return
<span class="lineNum">    3692 </span>            :  *         pjproject unlocks dialog
<span class="lineNum">    3693 </span>            :  *     serialized_pubsub_on_refresh_timeout starts (1)
<span class="lineNum">    3694 </span>            :  *       locks dialog
<span class="lineNum">    3695 </span>            :  *       checks state == TERMINATE_PENDING
<span class="lineNum">    3696 </span>            :  *       sets TERMINATE_IN_PROGRESS
<span class="lineNum">    3697 </span>            :  *       calls send_notify (2)
<span class="lineNum">    3698 </span>            :  *           send_notify ultimately calls pjsip_evsub_send_request
<span class="lineNum">    3699 </span>            :  *               pjsip_evsub_send_request calls evsub's set_state
<span class="lineNum">    3700 </span>            :  *                   set_state calls pubsub_evsub_set_state
<span class="lineNum">    3701 </span>            :  *                       pubsub_on_evsub_state checks state == TERMINATE_IN_PROGRESS
<span class="lineNum">    3702 </span>            :  *                       removes the subscriptions
<span class="lineNum">    3703 </span>            :  *                       cleans up references to evsub
<span class="lineNum">    3704 </span>            :  *                       sets state = TERMINATED
<span class="lineNum">    3705 </span>            :  *       serialized_pubsub_on_refresh_timeout unlocks dialog
<span class="lineNum">    3706 </span>            :  *
<span class="lineNum">    3707 </span>            :  * * Subscription timer expires:
<span class="lineNum">    3708 </span>            :  *     pjproject timer expires
<span class="lineNum">    3709 </span>            :  *         locks dialog
<span class="lineNum">    3710 </span>            :  *         calls pubsub_on_server_timeout
<span class="lineNum">    3711 </span>            :  *             pubsub_on_server_timeout checks state == NORMAL
<span class="lineNum">    3712 </span>            :  *             sets TERMINATE_PENDING
<span class="lineNum">    3713 </span>            :  *             pushes serialized_pubsub_on_refresh_timeout
<span class="lineNum">    3714 </span>            :  *             returns to pjproject
<span class="lineNum">    3715 </span>            :  *         pjproject unlocks dialog
<span class="lineNum">    3716 </span>            :  *     serialized_pubsub_on_refresh_timeout starts
<span class="lineNum">    3717 </span>            :  *         See (1) Above
<span class="lineNum">    3718 </span>            :  *
<span class="lineNum">    3719 </span>            :  * * Transmission failure sending NOTIFY or error response from client
<span class="lineNum">    3720 </span>            :  *     pjproject transaction timer expires or non OK response
<span class="lineNum">    3721 </span>            :  *         pjproject locks dialog
<span class="lineNum">    3722 </span>            :  *         calls pubsub_on_evsub_state with event TSX_STATE
<span class="lineNum">    3723 </span>            :  *             pubsub_on_evsub_state checks event == TSX_STATE
<span class="lineNum">    3724 </span>            :  *             removes the subscriptions
<span class="lineNum">    3725 </span>            :  *             cleans up references to evsub
<span class="lineNum">    3726 </span>            :  *             sets state = TERMINATED
<span class="lineNum">    3727 </span>            :  *         pjproject unlocks dialog
<span class="lineNum">    3728 </span>            :  *
<span class="lineNum">    3729 </span>            :  * * ast_sip_subscription_notify is called
<span class="lineNum">    3730 </span>            :  *       checks state == NORMAL
<span class="lineNum">    3731 </span>            :  *       if not batched...
<span class="lineNum">    3732 </span>            :  *           sets TERMINATE_IN_PROGRESS (if terminate is requested)
<span class="lineNum">    3733 </span>            :  *           calls send_notify
<span class="lineNum">    3734 </span>            :  *               See (2) Above
<span class="lineNum">    3735 </span>            :  *       if batched...
<span class="lineNum">    3736 </span>            :  *           sets TERMINATE_PENDING
<span class="lineNum">    3737 </span>            :  *           schedules task
<span class="lineNum">    3738 </span>            :  *       scheduler runs sched_task
<span class="lineNum">    3739 </span>            :  *           sched_task pushes serialized_send_notify
<span class="lineNum">    3740 </span>            :  *       serialized_send_notify starts
<span class="lineNum">    3741 </span>            :  *           checks state &lt;= TERMINATE_PENDING
<span class="lineNum">    3742 </span>            :  *           if state == TERMINATE_PENDING set state = TERMINATE_IN_PROGRESS
<span class="lineNum">    3743 </span>            :  *           call send_notify
<span class="lineNum">    3744 </span>            :  *               See (2) Above
<span class="lineNum">    3745 </span>            :  *
<span class="lineNum">    3746 </span>            :  */
<span class="lineNum">    3747 </span>            : 
<span class="lineNum">    3748 </span>            : /*!
<span class="lineNum">    3749 </span>            :  * \brief PJSIP callback when underlying SIP subscription changes state
<span class="lineNum">    3750 </span>            :  *
<span class="lineNum">    3751 </span>            :  * Although this function is called for every state change, we only care
<span class="lineNum">    3752 </span>            :  * about the TERMINATED state, and only when we're actually processing the final
<span class="lineNum">    3753 </span>            :  * notify (SIP_SUB_TREE_TERMINATE_IN_PROGRESS) OR when a transmission failure
<span class="lineNum">    3754 </span>            :  * occurs (PJSIP_EVENT_TSX_STATE).  In this case, we do all the subscription tree
<a name="3755"><span class="lineNum">    3755 </span>            :  * cleanup tasks and decrement the evsub reference.</a>
<span class="lineNum">    3756 </span>            :  */
<span class="lineNum">    3757 </span><span class="lineCov">        210 : static void pubsub_on_evsub_state(pjsip_evsub *evsub, pjsip_event *event)</span>
<span class="lineNum">    3758 </span>            : {
<span class="lineNum">    3759 </span>            :         struct sip_subscription_tree *sub_tree =
<span class="lineNum">    3760 </span><span class="lineCov">        210 :                 pjsip_evsub_get_mod_data(evsub, pubsub_module.id);</span>
<span class="lineNum">    3761 </span>            : 
<span class="lineNum">    3762 </span><span class="lineCov">        210 :         ast_debug(3, &quot;evsub %p state %s event %s sub_tree %p sub_tree state %s\n&quot;, evsub,</span>
<span class="lineNum">    3763 </span>            :                 pjsip_evsub_get_state_name(evsub), pjsip_event_str(event-&gt;type), sub_tree,
<span class="lineNum">    3764 </span>            :                 (sub_tree ? sub_tree_state_description[sub_tree-&gt;state] : &quot;UNKNOWN&quot;));
<span class="lineNum">    3765 </span>            : 
<span class="lineNum">    3766 </span><span class="lineCov">        210 :         if (!sub_tree || pjsip_evsub_get_state(evsub) != PJSIP_EVSUB_STATE_TERMINATED) {</span>
<span class="lineNum">    3767 </span><span class="lineCov">        168 :                 return;</span>
<span class="lineNum">    3768 </span>            :         }
<span class="lineNum">    3769 </span>            : 
<span class="lineNum">    3770 </span>            :         /* It's easier to write this as what we WANT to process, then negate it. */
<span class="lineNum">    3771 </span><span class="lineCov">         42 :         if (!(sub_tree-&gt;state == SIP_SUB_TREE_TERMINATE_IN_PROGRESS</span>
<span class="lineNum">    3772 </span><span class="lineCov">         21 :                 || (event-&gt;type == PJSIP_EVENT_TSX_STATE &amp;&amp; sub_tree-&gt;state == SIP_SUB_TREE_NORMAL)</span>
<span class="lineNum">    3773 </span>            :                 )) {
<span class="lineNum">    3774 </span><span class="lineCov">         21 :                 ast_debug(3, &quot;Do nothing.\n&quot;);</span>
<span class="lineNum">    3775 </span><span class="lineCov">         21 :                 return;</span>
<span class="lineNum">    3776 </span>            :         }
<span class="lineNum">    3777 </span>            : 
<span class="lineNum">    3778 </span><span class="lineCov">         21 :         if (sub_tree-&gt;expiration_task) {</span>
<span class="lineNum">    3779 </span>            :                 char task_name[256];
<span class="lineNum">    3780 </span>            : 
<span class="lineNum">    3781 </span><span class="lineNoCov">          0 :                 ast_sip_sched_task_get_name(sub_tree-&gt;expiration_task, task_name, sizeof(task_name));</span>
<span class="lineNum">    3782 </span><span class="lineNoCov">          0 :                 ast_debug(3, &quot;Cancelling timer: %s\n&quot;, task_name);</span>
<span class="lineNum">    3783 </span><span class="lineNoCov">          0 :                 ast_sip_sched_task_cancel(sub_tree-&gt;expiration_task);</span>
<span class="lineNum">    3784 </span><span class="lineNoCov">          0 :                 ao2_cleanup(sub_tree-&gt;expiration_task);</span>
<span class="lineNum">    3785 </span><span class="lineNoCov">          0 :                 sub_tree-&gt;expiration_task = NULL;</span>
<span class="lineNum">    3786 </span>            :         }
<span class="lineNum">    3787 </span>            : 
<span class="lineNum">    3788 </span><span class="lineCov">         21 :         remove_subscription(sub_tree);</span>
<span class="lineNum">    3789 </span>            : 
<span class="lineNum">    3790 </span><span class="lineCov">         21 :         pjsip_evsub_set_mod_data(evsub, pubsub_module.id, NULL);</span>
<span class="lineNum">    3791 </span>            : 
<span class="lineNum">    3792 </span>            : #ifdef HAVE_PJSIP_EVSUB_GRP_LOCK
<span class="lineNum">    3793 </span><span class="lineCov">         21 :         pjsip_evsub_dec_ref(sub_tree-&gt;evsub);</span>
<span class="lineNum">    3794 </span>            : #endif
<span class="lineNum">    3795 </span>            : 
<span class="lineNum">    3796 </span><span class="lineCov">         21 :         sub_tree-&gt;evsub = NULL;</span>
<span class="lineNum">    3797 </span>            : 
<span class="lineNum">    3798 </span><span class="lineCov">         21 :         ast_sip_dialog_set_serializer(sub_tree-&gt;dlg, NULL);</span>
<span class="lineNum">    3799 </span><span class="lineCov">         21 :         ast_sip_dialog_set_endpoint(sub_tree-&gt;dlg, NULL);</span>
<span class="lineNum">    3800 </span>            : 
<span class="lineNum">    3801 </span><span class="lineCov">         21 :         subscription_persistence_remove(sub_tree);</span>
<span class="lineNum">    3802 </span><span class="lineCov">         21 :         shutdown_subscriptions(sub_tree-&gt;root);</span>
<span class="lineNum">    3803 </span>            : 
<span class="lineNum">    3804 </span><span class="lineCov">         21 :         sub_tree-&gt;state = SIP_SUB_TREE_TERMINATED;</span>
<span class="lineNum">    3805 </span>            :         /* Remove evsub's reference to the sub_tree */
<span class="lineNum">    3806 </span><span class="lineCov">         21 :         ao2_ref(sub_tree, -1);</span>
<a name="3807"><span class="lineNum">    3807 </span>            : }</a>
<span class="lineNum">    3808 </span>            : 
<span class="lineNum">    3809 </span><span class="lineCov">         36 : static int pubsub_on_refresh_timeout(void *userdata)</span>
<span class="lineNum">    3810 </span>            : {
<span class="lineNum">    3811 </span><span class="lineCov">         36 :         struct sip_subscription_tree *sub_tree = userdata;</span>
<span class="lineNum">    3812 </span><span class="lineCov">         36 :         pjsip_dialog *dlg = sub_tree-&gt;dlg;</span>
<span class="lineNum">    3813 </span>            : 
<span class="lineNum">    3814 </span><span class="lineCov">         36 :         ast_debug(3, &quot;sub_tree %p sub_tree state %s\n&quot;, sub_tree,</span>
<span class="lineNum">    3815 </span>            :                 (sub_tree ? sub_tree_state_description[sub_tree-&gt;state] : &quot;UNKNOWN&quot;));
<span class="lineNum">    3816 </span>            : 
<span class="lineNum">    3817 </span><span class="lineCov">         36 :         pjsip_dlg_inc_lock(dlg);</span>
<span class="lineNum">    3818 </span><span class="lineCov">         36 :         if (sub_tree-&gt;state &gt;= SIP_SUB_TREE_TERMINATE_IN_PROGRESS) {</span>
<span class="lineNum">    3819 </span><span class="lineNoCov">          0 :                 pjsip_dlg_dec_lock(dlg);</span>
<span class="lineNum">    3820 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    3821 </span>            :         }
<span class="lineNum">    3822 </span>            : 
<span class="lineNum">    3823 </span><span class="lineCov">         36 :         if (sub_tree-&gt;state == SIP_SUB_TREE_TERMINATE_PENDING) {</span>
<span class="lineNum">    3824 </span><span class="lineCov">         21 :                 sub_tree-&gt;state = SIP_SUB_TREE_TERMINATE_IN_PROGRESS;</span>
<span class="lineNum">    3825 </span><span class="lineCov">         21 :                 set_state_terminated(sub_tree-&gt;root);</span>
<span class="lineNum">    3826 </span>            :         }
<span class="lineNum">    3827 </span>            : 
<span class="lineNum">    3828 </span><span class="lineCov">         36 :         send_notify(sub_tree, 1);</span>
<span class="lineNum">    3829 </span>            : 
<span class="lineNum">    3830 </span><span class="lineCov">         36 :         ast_test_suite_event_notify(sub_tree-&gt;root-&gt;subscription_state == PJSIP_EVSUB_STATE_TERMINATED ?</span>
<span class="lineNum">    3831 </span>            :                                 &quot;SUBSCRIPTION_TERMINATED&quot; : &quot;SUBSCRIPTION_REFRESHED&quot;,
<span class="lineNum">    3832 </span>            :                                 &quot;Resource: %s&quot;, sub_tree-&gt;root-&gt;resource);
<span class="lineNum">    3833 </span>            : 
<span class="lineNum">    3834 </span><span class="lineCov">         36 :         pjsip_dlg_dec_lock(dlg);</span>
<span class="lineNum">    3835 </span>            : 
<span class="lineNum">    3836 </span><span class="lineCov">         36 :         return 0;</span>
<a name="3837"><span class="lineNum">    3837 </span>            : }</a>
<span class="lineNum">    3838 </span>            : 
<span class="lineNum">    3839 </span><span class="lineCov">         36 : static int serialized_pubsub_on_refresh_timeout(void *userdata)</span>
<span class="lineNum">    3840 </span>            : {
<span class="lineNum">    3841 </span><span class="lineCov">         36 :         struct sip_subscription_tree *sub_tree = userdata;</span>
<span class="lineNum">    3842 </span>            : 
<span class="lineNum">    3843 </span><span class="lineCov">         36 :         ast_debug(3, &quot;sub_tree %p sub_tree state %s\n&quot;, sub_tree,</span>
<span class="lineNum">    3844 </span>            :                 (sub_tree ? sub_tree_state_description[sub_tree-&gt;state] : &quot;UNKNOWN&quot;));
<span class="lineNum">    3845 </span>            : 
<span class="lineNum">    3846 </span><span class="lineCov">         36 :         pubsub_on_refresh_timeout(userdata);</span>
<span class="lineNum">    3847 </span><span class="lineCov">         36 :         ao2_cleanup(sub_tree);</span>
<span class="lineNum">    3848 </span>            : 
<span class="lineNum">    3849 </span><span class="lineCov">         36 :         return 0;</span>
<span class="lineNum">    3850 </span>            : }
<span class="lineNum">    3851 </span>            : 
<span class="lineNum">    3852 </span>            : /*!
<span class="lineNum">    3853 </span>            :  * \brief Called whenever an in-dialog SUBSCRIBE is received
<span class="lineNum">    3854 </span>            :  *
<span class="lineNum">    3855 </span>            :  * This includes both SUBSCRIBE requests that actually refresh the subscription
<span class="lineNum">    3856 </span>            :  * as well as SUBSCRIBE requests that end the subscription.
<span class="lineNum">    3857 </span>            :  *
<span class="lineNum">    3858 </span>            :  * In either case we push serialized_pubsub_on_refresh_timeout to send an
<a name="3859"><span class="lineNum">    3859 </span>            :  * appropriate NOTIFY request.</a>
<span class="lineNum">    3860 </span>            :  */
<span class="lineNum">    3861 </span><span class="lineCov">         36 : static void pubsub_on_rx_refresh(pjsip_evsub *evsub, pjsip_rx_data *rdata,</span>
<span class="lineNum">    3862 </span>            :                 int *p_st_code, pj_str_t **p_st_text, pjsip_hdr *res_hdr, pjsip_msg_body **p_body)
<span class="lineNum">    3863 </span>            : {
<span class="lineNum">    3864 </span>            :         struct sip_subscription_tree *sub_tree;
<span class="lineNum">    3865 </span>            : 
<span class="lineNum">    3866 </span><span class="lineCov">         36 :         sub_tree = pjsip_evsub_get_mod_data(evsub, pubsub_module.id);</span>
<span class="lineNum">    3867 </span><span class="lineCov">         36 :         ast_debug(3, &quot;evsub %p sub_tree %p sub_tree state %s\n&quot;, evsub, sub_tree,</span>
<span class="lineNum">    3868 </span>            :                 (sub_tree ? sub_tree_state_description[sub_tree-&gt;state] : &quot;UNKNOWN&quot;));
<span class="lineNum">    3869 </span>            : 
<span class="lineNum">    3870 </span><span class="lineCov">         36 :         if (!sub_tree || sub_tree-&gt;state != SIP_SUB_TREE_NORMAL) {</span>
<span class="lineNum">    3871 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    3872 </span>            :         }
<span class="lineNum">    3873 </span>            : 
<span class="lineNum">    3874 </span><span class="lineCov">         36 :         if (sub_tree-&gt;expiration_task) {</span>
<span class="lineNum">    3875 </span>            :                 char task_name[256];
<span class="lineNum">    3876 </span>            : 
<span class="lineNum">    3877 </span><span class="lineCov">          1 :                 ast_sip_sched_task_get_name(sub_tree-&gt;expiration_task, task_name, sizeof(task_name));</span>
<span class="lineNum">    3878 </span><span class="lineCov">          1 :                 ast_debug(3, &quot;Cancelling timer: %s\n&quot;, task_name);</span>
<span class="lineNum">    3879 </span><span class="lineCov">          1 :                 ast_sip_sched_task_cancel(sub_tree-&gt;expiration_task);</span>
<span class="lineNum">    3880 </span><span class="lineCov">          1 :                 ao2_cleanup(sub_tree-&gt;expiration_task);</span>
<span class="lineNum">    3881 </span><span class="lineCov">          1 :                 sub_tree-&gt;expiration_task = NULL;</span>
<span class="lineNum">    3882 </span>            :         }
<span class="lineNum">    3883 </span>            : 
<span class="lineNum">    3884 </span>            :         /* PJSIP will set the evsub's state to terminated before calling into this function
<span class="lineNum">    3885 </span>            :          * if the Expires value of the incoming SUBSCRIBE is 0.
<span class="lineNum">    3886 </span>            :          */
<span class="lineNum">    3887 </span>            : 
<span class="lineNum">    3888 </span><span class="lineCov">         36 :         if (pjsip_evsub_get_state(sub_tree-&gt;evsub) == PJSIP_EVSUB_STATE_TERMINATED) {</span>
<span class="lineNum">    3889 </span><span class="lineCov">         21 :                 sub_tree-&gt;state = SIP_SUB_TREE_TERMINATE_PENDING;</span>
<span class="lineNum">    3890 </span>            :         }
<span class="lineNum">    3891 </span>            : 
<span class="lineNum">    3892 </span><span class="lineCov">         36 :         subscription_persistence_update(sub_tree, rdata, SUBSCRIPTION_PERSISTENCE_REFRESHED);</span>
<span class="lineNum">    3893 </span>            : 
<span class="lineNum">    3894 </span><span class="lineCov">         36 :         if (ast_sip_push_task(sub_tree-&gt;serializer, serialized_pubsub_on_refresh_timeout, ao2_bump(sub_tree))) {</span>
<span class="lineNum">    3895 </span>            :                 /* If we can't push the NOTIFY refreshing task...we'll just go with it. */
<span class="lineNum">    3896 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Failed to push task to send NOTIFY.\n&quot;);</span>
<span class="lineNum">    3897 </span><span class="lineNoCov">          0 :                 sub_tree-&gt;state = SIP_SUB_TREE_NORMAL;</span>
<span class="lineNum">    3898 </span><span class="lineNoCov">          0 :                 ao2_ref(sub_tree, -1);</span>
<span class="lineNum">    3899 </span>            :         }
<span class="lineNum">    3900 </span>            : 
<span class="lineNum">    3901 </span><span class="lineCov">         36 :         if (sub_tree-&gt;is_list) {</span>
<span class="lineNum">    3902 </span><span class="lineCov">         24 :                 pj_list_insert_before(res_hdr, create_require_eventlist(rdata-&gt;tp_info.pool));</span>
<span class="lineNum">    3903 </span>            :         }
<a name="3904"><span class="lineNum">    3904 </span>            : }</a>
<span class="lineNum">    3905 </span>            : 
<span class="lineNum">    3906 </span><span class="lineNoCov">          0 : static void pubsub_on_rx_notify(pjsip_evsub *evsub, pjsip_rx_data *rdata, int *p_st_code,</span>
<span class="lineNum">    3907 </span>            :                 pj_str_t **p_st_text, pjsip_hdr *res_hdr, pjsip_msg_body **p_body)
<span class="lineNum">    3908 </span>            : {
<span class="lineNum">    3909 </span>            :         struct ast_sip_subscription *sub;
<span class="lineNum">    3910 </span>            : 
<span class="lineNum">    3911 </span><span class="lineNoCov">          0 :         if (!(sub = pjsip_evsub_get_mod_data(evsub, pubsub_module.id))) {</span>
<span class="lineNum">    3912 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    3913 </span>            :         }
<span class="lineNum">    3914 </span>            : 
<span class="lineNum">    3915 </span><span class="lineNoCov">          0 :         sub-&gt;handler-&gt;subscriber-&gt;state_change(sub, rdata-&gt;msg_info.msg-&gt;body,</span>
<span class="lineNum">    3916 </span>            :                         pjsip_evsub_get_state(evsub));
<a name="3917"><span class="lineNum">    3917 </span>            : }</a>
<span class="lineNum">    3918 </span>            : 
<span class="lineNum">    3919 </span><span class="lineNoCov">          0 : static int serialized_pubsub_on_client_refresh(void *userdata)</span>
<span class="lineNum">    3920 </span>            : {
<span class="lineNum">    3921 </span><span class="lineNoCov">          0 :         struct sip_subscription_tree *sub_tree = userdata;</span>
<span class="lineNum">    3922 </span>            :         pjsip_tx_data *tdata;
<span class="lineNum">    3923 </span>            : 
<span class="lineNum">    3924 </span><span class="lineNoCov">          0 :         if (!sub_tree-&gt;evsub) {</span>
<span class="lineNum">    3925 </span><span class="lineNoCov">          0 :                 ao2_cleanup(sub_tree);</span>
<span class="lineNum">    3926 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    3927 </span>            :         }
<span class="lineNum">    3928 </span>            : 
<span class="lineNum">    3929 </span><span class="lineNoCov">          0 :         if (pjsip_evsub_initiate(sub_tree-&gt;evsub, NULL, -1, &amp;tdata) == PJ_SUCCESS) {</span>
<span class="lineNum">    3930 </span><span class="lineNoCov">          0 :                 pjsip_evsub_send_request(sub_tree-&gt;evsub, tdata);</span>
<span class="lineNum">    3931 </span>            :         } else {
<span class="lineNum">    3932 </span><span class="lineNoCov">          0 :                 pjsip_evsub_terminate(sub_tree-&gt;evsub, PJ_TRUE);</span>
<span class="lineNum">    3933 </span>            :         }
<span class="lineNum">    3934 </span>            : 
<span class="lineNum">    3935 </span><span class="lineNoCov">          0 :         ao2_cleanup(sub_tree);</span>
<span class="lineNum">    3936 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="3937"><span class="lineNum">    3937 </span>            : }</a>
<span class="lineNum">    3938 </span>            : 
<span class="lineNum">    3939 </span><span class="lineNoCov">          0 : static void pubsub_on_client_refresh(pjsip_evsub *evsub)</span>
<span class="lineNum">    3940 </span>            : {
<span class="lineNum">    3941 </span>            :         struct sip_subscription_tree *sub_tree;
<span class="lineNum">    3942 </span>            : 
<span class="lineNum">    3943 </span><span class="lineNoCov">          0 :         if (!(sub_tree = pjsip_evsub_get_mod_data(evsub, pubsub_module.id))) {</span>
<span class="lineNum">    3944 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    3945 </span>            :         }
<span class="lineNum">    3946 </span>            : 
<span class="lineNum">    3947 </span><span class="lineNoCov">          0 :         if (ast_sip_push_task(sub_tree-&gt;serializer, serialized_pubsub_on_client_refresh, ao2_bump(sub_tree))) {</span>
<span class="lineNum">    3948 </span><span class="lineNoCov">          0 :                 ao2_cleanup(sub_tree);</span>
<span class="lineNum">    3949 </span>            :         }
<a name="3950"><span class="lineNum">    3950 </span>            : }</a>
<span class="lineNum">    3951 </span>            : 
<span class="lineNum">    3952 </span><span class="lineNoCov">          0 : static void pubsub_on_server_timeout(pjsip_evsub *evsub)</span>
<span class="lineNum">    3953 </span>            : {
<span class="lineNum">    3954 </span>            :         struct sip_subscription_tree *sub_tree;
<span class="lineNum">    3955 </span>            : 
<span class="lineNum">    3956 </span>            :         /* PJSIP does not terminate the server timeout timer when a SUBSCRIBE
<span class="lineNum">    3957 </span>            :          * with Expires: 0 arrives to end a subscription, nor does it terminate
<span class="lineNum">    3958 </span>            :          * this timer when we send a NOTIFY request in response to receiving such
<span class="lineNum">    3959 </span>            :          * a SUBSCRIBE. PJSIP does not stop the server timeout timer until the
<span class="lineNum">    3960 </span>            :          * NOTIFY transaction has finished (either through receiving a response
<span class="lineNum">    3961 </span>            :          * or through a transaction timeout).
<span class="lineNum">    3962 </span>            :          *
<span class="lineNum">    3963 </span>            :          * Therefore, it is possible that we can be told that a server timeout
<span class="lineNum">    3964 </span>            :          * occurred after we already thought that the subscription had been
<span class="lineNum">    3965 </span>            :          * terminated. In such a case, we will have already removed the sub_tree
<span class="lineNum">    3966 </span>            :          * from the evsub's mod_data array.
<span class="lineNum">    3967 </span>            :          */
<span class="lineNum">    3968 </span>            : 
<span class="lineNum">    3969 </span><span class="lineNoCov">          0 :         sub_tree = pjsip_evsub_get_mod_data(evsub, pubsub_module.id);</span>
<span class="lineNum">    3970 </span><span class="lineNoCov">          0 :         if (!sub_tree || sub_tree-&gt;state != SIP_SUB_TREE_NORMAL) {</span>
<span class="lineNum">    3971 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    3972 </span>            :         }
<span class="lineNum">    3973 </span>            : 
<span class="lineNum">    3974 </span><span class="lineNoCov">          0 :         sub_tree-&gt;state = SIP_SUB_TREE_TERMINATE_PENDING;</span>
<span class="lineNum">    3975 </span><span class="lineNoCov">          0 :         if (ast_sip_push_task(sub_tree-&gt;serializer, serialized_pubsub_on_refresh_timeout, ao2_bump(sub_tree))) {</span>
<span class="lineNum">    3976 </span><span class="lineNoCov">          0 :                 sub_tree-&gt;state = SIP_SUB_TREE_NORMAL;</span>
<span class="lineNum">    3977 </span><span class="lineNoCov">          0 :                 ao2_cleanup(sub_tree);</span>
<span class="lineNum">    3978 </span>            :         }
<a name="3979"><span class="lineNum">    3979 </span>            : }</a>
<span class="lineNum">    3980 </span>            : 
<span class="lineNum">    3981 </span><span class="lineCov">          2 : static int ami_subscription_detail(struct sip_subscription_tree *sub_tree,</span>
<span class="lineNum">    3982 </span>            :                                    struct ast_sip_ami *ami,
<span class="lineNum">    3983 </span>            :                                    const char *event)
<span class="lineNum">    3984 </span>            : {
<span class="lineNum">    3985 </span>            :         struct ast_str *buf;
<span class="lineNum">    3986 </span>            : 
<span class="lineNum">    3987 </span><span class="lineCov">          2 :         buf = ast_sip_create_ami_event(event, ami);</span>
<span class="lineNum">    3988 </span><span class="lineCov">          2 :         if (!buf) {</span>
<span class="lineNum">    3989 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3990 </span>            :         }
<span class="lineNum">    3991 </span>            : 
<span class="lineNum">    3992 </span><span class="lineCov">          2 :         sip_subscription_to_ami(sub_tree, &amp;buf);</span>
<span class="lineNum">    3993 </span><span class="lineCov">          2 :         astman_append(ami-&gt;s, &quot;%s\r\n&quot;, ast_str_buffer(buf));</span>
<span class="lineNum">    3994 </span><span class="lineCov">          2 :         ast_free(buf);</span>
<span class="lineNum">    3995 </span>            : 
<span class="lineNum">    3996 </span><span class="lineCov">          2 :         ++ami-&gt;count;</span>
<span class="lineNum">    3997 </span><span class="lineCov">          2 :         return 0;</span>
<a name="3998"><span class="lineNum">    3998 </span>            : }</a>
<span class="lineNum">    3999 </span>            : 
<span class="lineNum">    4000 </span><span class="lineCov">          2 : static int ami_subscription_detail_inbound(struct sip_subscription_tree *sub_tree, void *arg)</span>
<span class="lineNum">    4001 </span>            : {
<span class="lineNum">    4002 </span><span class="lineCov">          2 :         return sub_tree-&gt;role == AST_SIP_NOTIFIER ? ami_subscription_detail(</span>
<span class="lineNum">    4003 </span><span class="lineCov">          4 :                 sub_tree, arg, &quot;InboundSubscriptionDetail&quot;) : 0;</span>
<a name="4004"><span class="lineNum">    4004 </span>            : }</a>
<span class="lineNum">    4005 </span>            : 
<span class="lineNum">    4006 </span><span class="lineNoCov">          0 : static int ami_subscription_detail_outbound(struct sip_subscription_tree *sub_tree, void *arg)</span>
<span class="lineNum">    4007 </span>            : {
<span class="lineNum">    4008 </span><span class="lineNoCov">          0 :         return sub_tree-&gt;role == AST_SIP_SUBSCRIBER ? ami_subscription_detail(</span>
<span class="lineNum">    4009 </span><span class="lineNoCov">          0 :                 sub_tree, arg, &quot;OutboundSubscriptionDetail&quot;) : 0;</span>
<a name="4010"><span class="lineNum">    4010 </span>            : }</a>
<span class="lineNum">    4011 </span>            : 
<span class="lineNum">    4012 </span><span class="lineCov">          1 : static int ami_show_subscriptions_inbound(struct mansession *s, const struct message *m)</span>
<span class="lineNum">    4013 </span>            : {
<span class="lineNum">    4014 </span><span class="lineCov">          1 :         struct ast_sip_ami ami = { .s = s, .m = m, .action_id = astman_get_header(m, &quot;ActionID&quot;), };</span>
<span class="lineNum">    4015 </span>            : 
<span class="lineNum">    4016 </span><span class="lineCov">          1 :         astman_send_listack(s, m, &quot;Following are Events for each inbound Subscription&quot;,</span>
<span class="lineNum">    4017 </span>            :                 &quot;start&quot;);
<span class="lineNum">    4018 </span>            : 
<span class="lineNum">    4019 </span><span class="lineCov">          1 :         for_each_subscription(ami_subscription_detail_inbound, &amp;ami);</span>
<span class="lineNum">    4020 </span>            : 
<span class="lineNum">    4021 </span><span class="lineCov">          1 :         astman_send_list_complete_start(s, m, &quot;InboundSubscriptionDetailComplete&quot;, ami.count);</span>
<span class="lineNum">    4022 </span><span class="lineCov">          1 :         astman_send_list_complete_end(s);</span>
<span class="lineNum">    4023 </span><span class="lineCov">          1 :         return 0;</span>
<a name="4024"><span class="lineNum">    4024 </span>            : }</a>
<span class="lineNum">    4025 </span>            : 
<span class="lineNum">    4026 </span><span class="lineNoCov">          0 : static int ami_show_subscriptions_outbound(struct mansession *s, const struct message *m)</span>
<span class="lineNum">    4027 </span>            : {
<span class="lineNum">    4028 </span><span class="lineNoCov">          0 :         struct ast_sip_ami ami = { .s = s, .m = m, .action_id = astman_get_header(m, &quot;ActionID&quot;), };</span>
<span class="lineNum">    4029 </span>            : 
<span class="lineNum">    4030 </span><span class="lineNoCov">          0 :         astman_send_listack(s, m, &quot;Following are Events for each outbound Subscription&quot;,</span>
<span class="lineNum">    4031 </span>            :                 &quot;start&quot;);
<span class="lineNum">    4032 </span>            : 
<span class="lineNum">    4033 </span><span class="lineNoCov">          0 :         for_each_subscription(ami_subscription_detail_outbound, &amp;ami);</span>
<span class="lineNum">    4034 </span>            : 
<span class="lineNum">    4035 </span><span class="lineNoCov">          0 :         astman_send_list_complete_start(s, m, &quot;OutboundSubscriptionDetailComplete&quot;, ami.count);</span>
<span class="lineNum">    4036 </span><span class="lineNoCov">          0 :         astman_send_list_complete_end(s);</span>
<span class="lineNum">    4037 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="4038"><span class="lineNum">    4038 </span>            : }</a>
<span class="lineNum">    4039 </span>            : 
<span class="lineNum">    4040 </span><span class="lineNoCov">          0 : static int format_ami_resource_lists(void *obj, void *arg, int flags)</span>
<span class="lineNum">    4041 </span>            : {
<span class="lineNum">    4042 </span><span class="lineNoCov">          0 :         struct resource_list *list = obj;</span>
<span class="lineNum">    4043 </span><span class="lineNoCov">          0 :         struct ast_sip_ami *ami = arg;</span>
<span class="lineNum">    4044 </span>            :         struct ast_str *buf;
<span class="lineNum">    4045 </span>            : 
<span class="lineNum">    4046 </span><span class="lineNoCov">          0 :         buf = ast_sip_create_ami_event(&quot;ResourceListDetail&quot;, ami);</span>
<span class="lineNum">    4047 </span><span class="lineNoCov">          0 :         if (!buf) {</span>
<span class="lineNum">    4048 </span><span class="lineNoCov">          0 :                 return CMP_STOP;</span>
<span class="lineNum">    4049 </span>            :         }
<span class="lineNum">    4050 </span>            : 
<span class="lineNum">    4051 </span><span class="lineNoCov">          0 :         if (ast_sip_sorcery_object_to_ami(list, &amp;buf)) {</span>
<span class="lineNum">    4052 </span><span class="lineNoCov">          0 :                 ast_free(buf);</span>
<span class="lineNum">    4053 </span><span class="lineNoCov">          0 :                 return CMP_STOP;</span>
<span class="lineNum">    4054 </span>            :         }
<span class="lineNum">    4055 </span><span class="lineNoCov">          0 :         astman_append(ami-&gt;s, &quot;%s\r\n&quot;, ast_str_buffer(buf));</span>
<span class="lineNum">    4056 </span><span class="lineNoCov">          0 :         ast_free(buf);</span>
<span class="lineNum">    4057 </span>            : 
<span class="lineNum">    4058 </span><span class="lineNoCov">          0 :         ++ami-&gt;count;</span>
<span class="lineNum">    4059 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="4060"><span class="lineNum">    4060 </span>            : }</a>
<span class="lineNum">    4061 </span>            : 
<span class="lineNum">    4062 </span><span class="lineNoCov">          0 : static int ami_show_resource_lists(struct mansession *s, const struct message *m)</span>
<span class="lineNum">    4063 </span>            : {
<span class="lineNum">    4064 </span><span class="lineNoCov">          0 :         struct ast_sip_ami ami = { .s = s, .m = m, .action_id = astman_get_header(m, &quot;ActionID&quot;), };</span>
<span class="lineNum">    4065 </span>            :         struct ao2_container *lists;
<span class="lineNum">    4066 </span>            : 
<span class="lineNum">    4067 </span><span class="lineNoCov">          0 :         lists = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(), &quot;resource_list&quot;,</span>
<span class="lineNum">    4068 </span>            :                         AST_RETRIEVE_FLAG_MULTIPLE | AST_RETRIEVE_FLAG_ALL, NULL);
<span class="lineNum">    4069 </span>            : 
<span class="lineNum">    4070 </span><span class="lineNoCov">          0 :         if (!lists || !ao2_container_count(lists)) {</span>
<span class="lineNum">    4071 </span><span class="lineNoCov">          0 :                 astman_send_error(s, m, &quot;No resource lists found\n&quot;);</span>
<span class="lineNum">    4072 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    4073 </span>            :         }
<span class="lineNum">    4074 </span>            : 
<span class="lineNum">    4075 </span><span class="lineNoCov">          0 :         astman_send_listack(s, m, &quot;A listing of resource lists follows, presented as ResourceListDetail events&quot;,</span>
<span class="lineNum">    4076 </span>            :                 &quot;start&quot;);
<span class="lineNum">    4077 </span>            : 
<span class="lineNum">    4078 </span><span class="lineNoCov">          0 :         ao2_callback(lists, OBJ_NODATA, format_ami_resource_lists, &amp;ami);</span>
<span class="lineNum">    4079 </span>            : 
<span class="lineNum">    4080 </span><span class="lineNoCov">          0 :         astman_send_list_complete_start(s, m, &quot;ResourceListDetailComplete&quot;, ami.count);</span>
<span class="lineNum">    4081 </span><span class="lineNoCov">          0 :         astman_send_list_complete_end(s);</span>
<span class="lineNum">    4082 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    4083 </span>            : }
<span class="lineNum">    4084 </span>            : 
<span class="lineNum">    4085 </span>            : #define AMI_SHOW_SUBSCRIPTIONS_INBOUND &quot;PJSIPShowSubscriptionsInbound&quot;
<span class="lineNum">    4086 </span>            : #define AMI_SHOW_SUBSCRIPTIONS_OUTBOUND &quot;PJSIPShowSubscriptionsOutbound&quot;
<span class="lineNum">    4087 </span>            : 
<span class="lineNum">    4088 </span>            : #define MAX_REGEX_ERROR_LEN 128
<span class="lineNum">    4089 </span>            : 
<span class="lineNum">    4090 </span>            : struct cli_sub_parms {
<span class="lineNum">    4091 </span>            :         /*! CLI handler entry e parameter */
<span class="lineNum">    4092 </span>            :         struct ast_cli_entry *e;
<span class="lineNum">    4093 </span>            :         /*! CLI handler entry a parameter */
<span class="lineNum">    4094 </span>            :         struct ast_cli_args *a;
<span class="lineNum">    4095 </span>            :         /*! CLI subscription entry output line(s) */
<span class="lineNum">    4096 </span>            :         struct ast_str *buf;
<span class="lineNum">    4097 </span>            :         /*! Compiled regular expression to select if buf is written to CLI when not NULL. */
<span class="lineNum">    4098 </span>            :         regex_t *like;
<span class="lineNum">    4099 </span>            :         int count;
<span class="lineNum">    4100 </span>            : };
<span class="lineNum">    4101 </span>            : 
<span class="lineNum">    4102 </span>            : struct cli_sub_complete_parms {
<span class="lineNum">    4103 </span>            :         struct ast_cli_args *a;
<span class="lineNum">    4104 </span>            :         /*! Found callid for search position */
<span class="lineNum">    4105 </span>            :         char *callid;
<span class="lineNum">    4106 </span>            :         int wordlen;
<span class="lineNum">    4107 </span>            :         int which;
<a name="4108"><span class="lineNum">    4108 </span>            : };</a>
<span class="lineNum">    4109 </span>            : 
<span class="lineNum">    4110 </span><span class="lineNoCov">          0 : static int cli_complete_subscription_common(struct sip_subscription_tree *sub_tree, struct cli_sub_complete_parms *cli)</span>
<span class="lineNum">    4111 </span>            : {
<span class="lineNum">    4112 </span>            :         pj_str_t *callid;
<span class="lineNum">    4113 </span>            : 
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 :         if (!sub_tree-&gt;dlg) {</span>
<span class="lineNum">    4115 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    4116 </span>            :         }
<span class="lineNum">    4117 </span>            : 
<span class="lineNum">    4118 </span><span class="lineNoCov">          0 :         callid = &amp;sub_tree-&gt;dlg-&gt;call_id-&gt;id;</span>
<span class="lineNum">    4119 </span><span class="lineNoCov">          0 :         if (cli-&gt;wordlen &lt;= pj_strlen(callid)</span>
<span class="lineNum">    4120 </span><span class="lineNoCov">          0 :                 &amp;&amp; !strncasecmp(cli-&gt;a-&gt;word, pj_strbuf(callid), cli-&gt;wordlen)</span>
<span class="lineNum">    4121 </span><span class="lineNoCov">          0 :                 &amp;&amp; (++cli-&gt;which &gt; cli-&gt;a-&gt;n)) {</span>
<span class="lineNum">    4122 </span><span class="lineNoCov">          0 :                 cli-&gt;callid = ast_malloc(pj_strlen(callid) + 1);</span>
<span class="lineNum">    4123 </span><span class="lineNoCov">          0 :                 if (cli-&gt;callid) {</span>
<span class="lineNum">    4124 </span><span class="lineNoCov">          0 :                         ast_copy_pj_str(cli-&gt;callid, callid, pj_strlen(callid) + 1);</span>
<span class="lineNum">    4125 </span>            :                 }
<span class="lineNum">    4126 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    4127 </span>            :         }
<span class="lineNum">    4128 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="4129"><span class="lineNum">    4129 </span>            : }</a>
<span class="lineNum">    4130 </span>            : 
<span class="lineNum">    4131 </span><span class="lineNoCov">          0 : static int cli_complete_subscription_inbound(struct sip_subscription_tree *sub_tree, void *arg)</span>
<span class="lineNum">    4132 </span>            : {
<span class="lineNum">    4133 </span><span class="lineNoCov">          0 :         return sub_tree-&gt;role == AST_SIP_NOTIFIER</span>
<span class="lineNum">    4134 </span><span class="lineNoCov">          0 :                 ? cli_complete_subscription_common(sub_tree, arg) : 0;</span>
<a name="4135"><span class="lineNum">    4135 </span>            : }</a>
<span class="lineNum">    4136 </span>            : 
<span class="lineNum">    4137 </span><span class="lineNoCov">          0 : static int cli_complete_subscription_outbound(struct sip_subscription_tree *sub_tree, void *arg)</span>
<span class="lineNum">    4138 </span>            : {
<span class="lineNum">    4139 </span><span class="lineNoCov">          0 :         return sub_tree-&gt;role == AST_SIP_SUBSCRIBER</span>
<span class="lineNum">    4140 </span><span class="lineNoCov">          0 :                 ? cli_complete_subscription_common(sub_tree, arg) : 0;</span>
<a name="4141"><span class="lineNum">    4141 </span>            : }</a>
<span class="lineNum">    4142 </span>            : 
<span class="lineNum">    4143 </span><span class="lineNoCov">          0 : static char *cli_complete_subscription_callid(struct ast_cli_args *a)</span>
<span class="lineNum">    4144 </span>            : {
<span class="lineNum">    4145 </span>            :         struct cli_sub_complete_parms cli;
<span class="lineNum">    4146 </span>            :         on_subscription_t on_subscription;
<span class="lineNum">    4147 </span>            : 
<span class="lineNum">    4148 </span><span class="lineNoCov">          0 :         if (a-&gt;pos != 4) {</span>
<span class="lineNum">    4149 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    4150 </span>            :         }
<span class="lineNum">    4151 </span>            : 
<span class="lineNum">    4152 </span><span class="lineNoCov">          0 :         if (!strcasecmp(a-&gt;argv[3], &quot;inbound&quot;)) {</span>
<span class="lineNum">    4153 </span><span class="lineNoCov">          0 :                 on_subscription = cli_complete_subscription_inbound;</span>
<span class="lineNum">    4154 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(a-&gt;argv[3], &quot;outbound&quot;)) {</span>
<span class="lineNum">    4155 </span><span class="lineNoCov">          0 :                 on_subscription = cli_complete_subscription_outbound;</span>
<span class="lineNum">    4156 </span>            :         } else {
<span class="lineNum">    4157 </span>            :                 /* Should never get here */
<span class="lineNum">    4158 </span><span class="lineNoCov">          0 :                 ast_assert(0);</span>
<span class="lineNum">    4159 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    4160 </span>            :         }
<span class="lineNum">    4161 </span>            : 
<span class="lineNum">    4162 </span><span class="lineNoCov">          0 :         cli.a = a;</span>
<span class="lineNum">    4163 </span><span class="lineNoCov">          0 :         cli.callid = NULL;</span>
<span class="lineNum">    4164 </span><span class="lineNoCov">          0 :         cli.wordlen = strlen(a-&gt;word);</span>
<span class="lineNum">    4165 </span><span class="lineNoCov">          0 :         cli.which = 0;</span>
<span class="lineNum">    4166 </span><span class="lineNoCov">          0 :         for_each_subscription(on_subscription, &amp;cli);</span>
<span class="lineNum">    4167 </span>            : 
<span class="lineNum">    4168 </span><span class="lineNoCov">          0 :         return cli.callid;</span>
<a name="4169"><span class="lineNum">    4169 </span>            : }</a>
<span class="lineNum">    4170 </span>            : 
<span class="lineNum">    4171 </span><span class="lineNoCov">          0 : static int cli_subscription_expiry(struct sip_subscription_tree *sub_tree)</span>
<span class="lineNum">    4172 </span>            : {
<span class="lineNum">    4173 </span>            :         int expiry;
<span class="lineNum">    4174 </span>            : 
<span class="lineNum">    4175 </span><span class="lineNoCov">          0 :         expiry = sub_tree-&gt;persistence</span>
<span class="lineNum">    4176 </span><span class="lineNoCov">          0 :                 ? ast_tvdiff_ms(sub_tree-&gt;persistence-&gt;expires, ast_tvnow()) / 1000</span>
<span class="lineNum">    4177 </span>            :                 : 0;
<span class="lineNum">    4178 </span><span class="lineNoCov">          0 :         if (expiry &lt; 0) {</span>
<span class="lineNum">    4179 </span>            :                 /* Subscription expired */
<span class="lineNum">    4180 </span><span class="lineNoCov">          0 :                 expiry = 0;</span>
<span class="lineNum">    4181 </span>            :         }
<span class="lineNum">    4182 </span><span class="lineNoCov">          0 :         return expiry;</span>
<a name="4183"><span class="lineNum">    4183 </span>            : }</a>
<span class="lineNum">    4184 </span>            : 
<span class="lineNum">    4185 </span><span class="lineNoCov">          0 : static int cli_show_subscription_common(struct sip_subscription_tree *sub_tree, struct cli_sub_parms *cli)</span>
<span class="lineNum">    4186 </span>            : {
<span class="lineNum">    4187 </span><span class="lineNoCov">          0 :         const char *callid = (const char *) cli-&gt;buf;/* Member repurposed to pass in callid */</span>
<span class="lineNum">    4188 </span>            :         pj_str_t *sub_callid;
<span class="lineNum">    4189 </span>            :         struct ast_str *buf;
<span class="lineNum">    4190 </span>            :         char *src;
<span class="lineNum">    4191 </span>            :         char *dest;
<span class="lineNum">    4192 </span>            :         char *key;
<span class="lineNum">    4193 </span>            :         char *value;
<span class="lineNum">    4194 </span>            :         char *value_end;
<span class="lineNum">    4195 </span>            :         int key_len;
<span class="lineNum">    4196 </span>            :         int key_filler_width;
<span class="lineNum">    4197 </span>            :         int value_len;
<span class="lineNum">    4198 </span>            : 
<span class="lineNum">    4199 </span><span class="lineNoCov">          0 :         if (!sub_tree-&gt;dlg) {</span>
<span class="lineNum">    4200 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    4201 </span>            :         }
<span class="lineNum">    4202 </span><span class="lineNoCov">          0 :         sub_callid = &amp;sub_tree-&gt;dlg-&gt;call_id-&gt;id;</span>
<span class="lineNum">    4203 </span><span class="lineNoCov">          0 :         if (pj_strcmp2(sub_callid, callid)) {</span>
<span class="lineNum">    4204 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    4205 </span>            :         }
<span class="lineNum">    4206 </span>            : 
<span class="lineNum">    4207 </span><span class="lineNoCov">          0 :         buf = ast_str_create(512);</span>
<span class="lineNum">    4208 </span><span class="lineNoCov">          0 :         if (!buf) {</span>
<span class="lineNum">    4209 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    4210 </span>            :         }
<span class="lineNum">    4211 </span>            : 
<span class="lineNum">    4212 </span><span class="lineNoCov">          0 :         ast_cli(cli-&gt;a-&gt;fd,</span>
<span class="lineNum">    4213 </span>            :                 &quot;%-20s: %s\n&quot;
<span class="lineNum">    4214 </span>            :                 &quot;===========================================================================\n&quot;,
<span class="lineNum">    4215 </span>            :                 &quot;ParameterName&quot;, &quot;ParameterValue&quot;);
<span class="lineNum">    4216 </span>            : 
<span class="lineNum">    4217 </span><span class="lineNoCov">          0 :         ast_str_append(&amp;buf, 0, &quot;Resource: %s\n&quot;, sub_tree-&gt;root-&gt;resource);</span>
<span class="lineNum">    4218 </span><span class="lineNoCov">          0 :         ast_str_append(&amp;buf, 0, &quot;Event: %s\n&quot;, sub_tree-&gt;root-&gt;handler-&gt;event_name);</span>
<span class="lineNum">    4219 </span><span class="lineNoCov">          0 :         ast_str_append(&amp;buf, 0, &quot;Expiry: %d\n&quot;, cli_subscription_expiry(sub_tree));</span>
<span class="lineNum">    4220 </span>            : 
<span class="lineNum">    4221 </span><span class="lineNoCov">          0 :         sip_subscription_to_ami(sub_tree, &amp;buf);</span>
<span class="lineNum">    4222 </span>            : 
<span class="lineNum">    4223 </span>            :         /* Convert AMI \r\n to \n line terminators. */
<span class="lineNum">    4224 </span><span class="lineNoCov">          0 :         src = strchr(ast_str_buffer(buf), '\r');</span>
<span class="lineNum">    4225 </span><span class="lineNoCov">          0 :         if (src) {</span>
<span class="lineNum">    4226 </span><span class="lineNoCov">          0 :                 dest = src;</span>
<span class="lineNum">    4227 </span><span class="lineNoCov">          0 :                 ++src;</span>
<span class="lineNum">    4228 </span><span class="lineNoCov">          0 :                 while (*src) {</span>
<span class="lineNum">    4229 </span><span class="lineNoCov">          0 :                         if (*src == '\r') {</span>
<span class="lineNum">    4230 </span><span class="lineNoCov">          0 :                                 ++src;</span>
<span class="lineNum">    4231 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    4232 </span>            :                         }
<span class="lineNum">    4233 </span><span class="lineNoCov">          0 :                         *dest++ = *src++;</span>
<span class="lineNum">    4234 </span>            :                 }
<span class="lineNum">    4235 </span><span class="lineNoCov">          0 :                 *dest = '\0';</span>
<span class="lineNum">    4236 </span><span class="lineNoCov">          0 :                 ast_str_update(buf);</span>
<span class="lineNum">    4237 </span>            :         }
<span class="lineNum">    4238 </span>            : 
<span class="lineNum">    4239 </span>            :         /* Reformat AMI key value pairs to pretty columns */
<span class="lineNum">    4240 </span><span class="lineNoCov">          0 :         key = ast_str_buffer(buf);</span>
<span class="lineNum">    4241 </span>            :         do {
<span class="lineNum">    4242 </span><span class="lineNoCov">          0 :                 value = strchr(key, ':');</span>
<span class="lineNum">    4243 </span><span class="lineNoCov">          0 :                 if (!value) {</span>
<span class="lineNum">    4244 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    4245 </span>            :                 }
<span class="lineNum">    4246 </span><span class="lineNoCov">          0 :                 value_end = strchr(value, '\n');</span>
<span class="lineNum">    4247 </span><span class="lineNoCov">          0 :                 if (!value_end) {</span>
<span class="lineNum">    4248 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    4249 </span>            :                 }
<span class="lineNum">    4250 </span>            : 
<span class="lineNum">    4251 </span>            :                 /* Calculate field lengths */
<span class="lineNum">    4252 </span><span class="lineNoCov">          0 :                 key_len = value - key;</span>
<span class="lineNum">    4253 </span><span class="lineNoCov">          0 :                 key_filler_width = 20 - key_len;</span>
<span class="lineNum">    4254 </span><span class="lineNoCov">          0 :                 if (key_filler_width &lt; 0) {</span>
<span class="lineNum">    4255 </span><span class="lineNoCov">          0 :                         key_filler_width = 0;</span>
<span class="lineNum">    4256 </span>            :                 }
<span class="lineNum">    4257 </span><span class="lineNoCov">          0 :                 value_len = value_end - value;</span>
<span class="lineNum">    4258 </span>            : 
<span class="lineNum">    4259 </span><span class="lineNoCov">          0 :                 ast_cli(cli-&gt;a-&gt;fd, &quot;%.*s%*s%.*s\n&quot;,</span>
<span class="lineNum">    4260 </span>            :                         key_len, key, key_filler_width, &quot;&quot;,
<span class="lineNum">    4261 </span>            :                         value_len, value);
<span class="lineNum">    4262 </span>            : 
<span class="lineNum">    4263 </span><span class="lineNoCov">          0 :                 key = value_end + 1;</span>
<span class="lineNum">    4264 </span><span class="lineNoCov">          0 :         } while (*key);</span>
<span class="lineNum">    4265 </span><span class="lineNoCov">          0 :         ast_cli(cli-&gt;a-&gt;fd, &quot;\n&quot;);</span>
<span class="lineNum">    4266 </span>            : 
<span class="lineNum">    4267 </span><span class="lineNoCov">          0 :         ast_free(buf);</span>
<span class="lineNum">    4268 </span>            : 
<span class="lineNum">    4269 </span><span class="lineNoCov">          0 :         return -1;</span>
<a name="4270"><span class="lineNum">    4270 </span>            : }</a>
<span class="lineNum">    4271 </span>            : 
<span class="lineNum">    4272 </span><span class="lineNoCov">          0 : static int cli_show_subscription_inbound(struct sip_subscription_tree *sub_tree, void *arg)</span>
<span class="lineNum">    4273 </span>            : {
<span class="lineNum">    4274 </span><span class="lineNoCov">          0 :         return sub_tree-&gt;role == AST_SIP_NOTIFIER</span>
<span class="lineNum">    4275 </span><span class="lineNoCov">          0 :                 ? cli_show_subscription_common(sub_tree, arg) : 0;</span>
<a name="4276"><span class="lineNum">    4276 </span>            : }</a>
<span class="lineNum">    4277 </span>            : 
<span class="lineNum">    4278 </span><span class="lineNoCov">          0 : static int cli_show_subscription_outbound(struct sip_subscription_tree *sub_tree, void *arg)</span>
<span class="lineNum">    4279 </span>            : {
<span class="lineNum">    4280 </span><span class="lineNoCov">          0 :         return sub_tree-&gt;role == AST_SIP_SUBSCRIBER</span>
<span class="lineNum">    4281 </span><span class="lineNoCov">          0 :                 ? cli_show_subscription_common(sub_tree, arg) : 0;</span>
<a name="4282"><span class="lineNum">    4282 </span>            : }</a>
<span class="lineNum">    4283 </span>            : 
<span class="lineNum">    4284 </span><span class="lineCov">        852 : static char *cli_show_subscription_inout(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)</span>
<span class="lineNum">    4285 </span>            : {
<span class="lineNum">    4286 </span>            :         on_subscription_t on_subscription;
<span class="lineNum">    4287 </span>            :         struct cli_sub_parms cli;
<span class="lineNum">    4288 </span>            : 
<span class="lineNum">    4289 </span><span class="lineCov">        852 :         switch (cmd) {</span>
<span class="lineNum">    4290 </span><span class="lineCov">        852 :         case CLI_INIT:</span>
<span class="lineNum">    4291 </span><span class="lineCov">        852 :                 e-&gt;command = &quot;pjsip show subscription {inbound|outbound}&quot;;</span>
<span class="lineNum">    4292 </span><span class="lineCov">        852 :                 e-&gt;usage = &quot;Usage:\n&quot;</span>
<span class="lineNum">    4293 </span>            :                                    &quot;   pjsip show subscription inbound &lt;call-id&gt;\n&quot;
<span class="lineNum">    4294 </span>            :                                    &quot;   pjsip show subscription outbound &lt;call-id&gt;\n&quot;
<span class="lineNum">    4295 </span>            :                                    &quot;      Show active subscription with the dialog call-id\n&quot;;
<span class="lineNum">    4296 </span><span class="lineCov">        852 :                 return NULL;</span>
<span class="lineNum">    4297 </span><span class="lineNoCov">          0 :         case CLI_GENERATE:</span>
<span class="lineNum">    4298 </span><span class="lineNoCov">          0 :                 return cli_complete_subscription_callid(a);</span>
<span class="lineNum">    4299 </span>            :         }
<span class="lineNum">    4300 </span>            : 
<span class="lineNum">    4301 </span><span class="lineNoCov">          0 :         if (a-&gt;argc != 5) {</span>
<span class="lineNum">    4302 </span><span class="lineNoCov">          0 :                 return CLI_SHOWUSAGE;</span>
<span class="lineNum">    4303 </span>            :         }
<span class="lineNum">    4304 </span>            : 
<span class="lineNum">    4305 </span><span class="lineNoCov">          0 :         if (!strcasecmp(a-&gt;argv[3], &quot;inbound&quot;)) {</span>
<span class="lineNum">    4306 </span><span class="lineNoCov">          0 :                 on_subscription = cli_show_subscription_inbound;</span>
<span class="lineNum">    4307 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(a-&gt;argv[3], &quot;outbound&quot;)) {</span>
<span class="lineNum">    4308 </span><span class="lineNoCov">          0 :                 on_subscription = cli_show_subscription_outbound;</span>
<span class="lineNum">    4309 </span>            :         } else {
<span class="lineNum">    4310 </span>            :                 /* Should never get here */
<span class="lineNum">    4311 </span><span class="lineNoCov">          0 :                 ast_assert(0);</span>
<span class="lineNum">    4312 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    4313 </span>            :         }
<span class="lineNum">    4314 </span>            : 
<span class="lineNum">    4315 </span>            :         /* Find the subscription with the specified call-id */
<span class="lineNum">    4316 </span><span class="lineNoCov">          0 :         cli.a = a;</span>
<span class="lineNum">    4317 </span><span class="lineNoCov">          0 :         cli.e = e;</span>
<span class="lineNum">    4318 </span><span class="lineNoCov">          0 :         cli.buf = (void *) a-&gt;argv[4];/* Repurpose the buf member to pass in callid */</span>
<span class="lineNum">    4319 </span><span class="lineNoCov">          0 :         for_each_subscription(on_subscription, &amp;cli);</span>
<span class="lineNum">    4320 </span>            : 
<span class="lineNum">    4321 </span><span class="lineNoCov">          0 :         return CLI_SUCCESS;</span>
<span class="lineNum">    4322 </span>            : }
<span class="lineNum">    4323 </span>            : 
<span class="lineNum">    4324 </span>            : #define CLI_SHOW_SUB_FORMAT_HEADER \
<span class="lineNum">    4325 </span>            :         &quot;Endpoint: &lt;Endpoint/Caller-ID.............................................&gt;\n&quot; \
<span class="lineNum">    4326 </span>            :         &quot;Resource: &lt;Resource/Event.................................................&gt;\n&quot; \
<span class="lineNum">    4327 </span>            :         &quot;  Expiry: &lt;Expiry&gt;  &lt;Call-id..............................................&gt;\n&quot; \
<span class="lineNum">    4328 </span>            :         &quot;===========================================================================\n\n&quot;
<span class="lineNum">    4329 </span>            : #define CLI_SHOW_SUB_FORMAT_ENTRY  \
<span class="lineNum">    4330 </span>            :         &quot;Endpoint: %s/%s\n&quot; \
<span class="lineNum">    4331 </span>            :         &quot;Resource: %s/%s\n&quot; \
<a name="4332"><span class="lineNum">    4332 </span>            :         &quot;  Expiry: %8d  %s\n\n&quot;</a>
<span class="lineNum">    4333 </span>            : 
<span class="lineNum">    4334 </span><span class="lineNoCov">          0 : static int cli_show_subscriptions_detail(struct sip_subscription_tree *sub_tree, struct cli_sub_parms *cli)</span>
<span class="lineNum">    4335 </span>            : {
<span class="lineNum">    4336 </span>            :         char caller_id[256];
<span class="lineNum">    4337 </span>            :         char callid[256];
<span class="lineNum">    4338 </span>            : 
<span class="lineNum">    4339 </span><span class="lineNoCov">          0 :         ast_callerid_merge(caller_id, sizeof(caller_id),</span>
<span class="lineNum">    4340 </span><span class="lineNoCov">          0 :                 S_COR(sub_tree-&gt;endpoint-&gt;id.self.name.valid,</span>
<span class="lineNum">    4341 </span>            :                         sub_tree-&gt;endpoint-&gt;id.self.name.str, NULL),
<span class="lineNum">    4342 </span><span class="lineNoCov">          0 :                 S_COR(sub_tree-&gt;endpoint-&gt;id.self.number.valid,</span>
<span class="lineNum">    4343 </span>            :                         sub_tree-&gt;endpoint-&gt;id.self.number.str, NULL),
<span class="lineNum">    4344 </span>            :                 &quot;&lt;none&gt;&quot;);
<span class="lineNum">    4345 </span>            : 
<span class="lineNum">    4346 </span>            :         /* Call-id */
<span class="lineNum">    4347 </span><span class="lineNoCov">          0 :         if (sub_tree-&gt;dlg) {</span>
<span class="lineNum">    4348 </span><span class="lineNoCov">          0 :                 ast_copy_pj_str(callid, &amp;sub_tree-&gt;dlg-&gt;call_id-&gt;id, sizeof(callid));</span>
<span class="lineNum">    4349 </span>            :         } else {
<span class="lineNum">    4350 </span><span class="lineNoCov">          0 :                 ast_copy_string(callid, &quot;&lt;unknown&gt;&quot;, sizeof(callid));</span>
<span class="lineNum">    4351 </span>            :         }
<span class="lineNum">    4352 </span>            : 
<span class="lineNum">    4353 </span><span class="lineNoCov">          0 :         ast_str_set(&amp;cli-&gt;buf, 0, CLI_SHOW_SUB_FORMAT_ENTRY,</span>
<span class="lineNum">    4354 </span><span class="lineNoCov">          0 :                 ast_sorcery_object_get_id(sub_tree-&gt;endpoint), caller_id,</span>
<span class="lineNum">    4355 </span><span class="lineNoCov">          0 :                 sub_tree-&gt;root-&gt;resource, sub_tree-&gt;root-&gt;handler-&gt;event_name,</span>
<span class="lineNum">    4356 </span>            :                 cli_subscription_expiry(sub_tree), callid);
<span class="lineNum">    4357 </span>            : 
<span class="lineNum">    4358 </span><span class="lineNoCov">          0 :         if (cli-&gt;like) {</span>
<span class="lineNum">    4359 </span><span class="lineNoCov">          0 :                 if (regexec(cli-&gt;like, ast_str_buffer(cli-&gt;buf), 0, NULL, 0)) {</span>
<span class="lineNum">    4360 </span>            :                         /* Output line did not match the regex */
<span class="lineNum">    4361 </span><span class="lineNoCov">          0 :                         return 0;</span>
<span class="lineNum">    4362 </span>            :                 }
<span class="lineNum">    4363 </span>            :         }
<span class="lineNum">    4364 </span>            : 
<span class="lineNum">    4365 </span><span class="lineNoCov">          0 :         ast_cli(cli-&gt;a-&gt;fd, &quot;%s&quot;, ast_str_buffer(cli-&gt;buf));</span>
<span class="lineNum">    4366 </span><span class="lineNoCov">          0 :         ++cli-&gt;count;</span>
<span class="lineNum">    4367 </span>            : 
<span class="lineNum">    4368 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="4369"><span class="lineNum">    4369 </span>            : }</a>
<span class="lineNum">    4370 </span>            : 
<span class="lineNum">    4371 </span><span class="lineNoCov">          0 : static int cli_show_subscriptions_inbound(struct sip_subscription_tree *sub_tree, void *arg)</span>
<span class="lineNum">    4372 </span>            : {
<span class="lineNum">    4373 </span><span class="lineNoCov">          0 :         return sub_tree-&gt;role == AST_SIP_NOTIFIER</span>
<span class="lineNum">    4374 </span><span class="lineNoCov">          0 :                 ? cli_show_subscriptions_detail(sub_tree, arg) : 0;</span>
<a name="4375"><span class="lineNum">    4375 </span>            : }</a>
<span class="lineNum">    4376 </span>            : 
<span class="lineNum">    4377 </span><span class="lineNoCov">          0 : static int cli_show_subscriptions_outbound(struct sip_subscription_tree *sub_tree, void *arg)</span>
<span class="lineNum">    4378 </span>            : {
<span class="lineNum">    4379 </span><span class="lineNoCov">          0 :         return sub_tree-&gt;role == AST_SIP_SUBSCRIBER</span>
<span class="lineNum">    4380 </span><span class="lineNoCov">          0 :                 ? cli_show_subscriptions_detail(sub_tree, arg) : 0;</span>
<a name="4381"><span class="lineNum">    4381 </span>            : }</a>
<span class="lineNum">    4382 </span>            : 
<span class="lineNum">    4383 </span><span class="lineCov">        852 : static char *cli_show_subscriptions_inout(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)</span>
<span class="lineNum">    4384 </span>            : {
<span class="lineNum">    4385 </span>            :         on_subscription_t on_subscription;
<span class="lineNum">    4386 </span>            :         struct cli_sub_parms cli;
<span class="lineNum">    4387 </span>            :         regex_t like;
<span class="lineNum">    4388 </span>            :         const char *regex;
<span class="lineNum">    4389 </span>            : 
<span class="lineNum">    4390 </span><span class="lineCov">        852 :         switch (cmd) {</span>
<span class="lineNum">    4391 </span><span class="lineCov">        852 :         case CLI_INIT:</span>
<span class="lineNum">    4392 </span><span class="lineCov">        852 :                 e-&gt;command = &quot;pjsip show subscriptions {inbound|outbound} [like]&quot;;</span>
<span class="lineNum">    4393 </span><span class="lineCov">        852 :                 e-&gt;usage = &quot;Usage:\n&quot;</span>
<span class="lineNum">    4394 </span>            :                                    &quot;   pjsip show subscriptions inbound [like &lt;regex&gt;]\n&quot;
<span class="lineNum">    4395 </span>            :                                    &quot;      Show active inbound subscriptions\n&quot;
<span class="lineNum">    4396 </span>            :                                    &quot;   pjsip show subscriptions outbound [like &lt;regex&gt;]\n&quot;
<span class="lineNum">    4397 </span>            :                                    &quot;      Show active outbound subscriptions\n&quot;
<span class="lineNum">    4398 </span>            :                                    &quot;\n&quot;
<span class="lineNum">    4399 </span>            :                                    &quot;   The regex selects a subscriptions output that matches.\n&quot;
<span class="lineNum">    4400 </span>            :                                    &quot;   i.e.,  All output lines for a subscription are checked\n&quot;
<span class="lineNum">    4401 </span>            :                                    &quot;   as a block by the regex.\n&quot;;
<span class="lineNum">    4402 </span><span class="lineCov">        852 :                 return NULL;</span>
<span class="lineNum">    4403 </span><span class="lineNoCov">          0 :         case CLI_GENERATE:</span>
<span class="lineNum">    4404 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    4405 </span>            :         }
<span class="lineNum">    4406 </span>            : 
<span class="lineNum">    4407 </span><span class="lineNoCov">          0 :         if (a-&gt;argc != 4 &amp;&amp; a-&gt;argc != 6) {</span>
<span class="lineNum">    4408 </span><span class="lineNoCov">          0 :                 return CLI_SHOWUSAGE;</span>
<span class="lineNum">    4409 </span>            :         }
<span class="lineNum">    4410 </span><span class="lineNoCov">          0 :         if (!strcasecmp(a-&gt;argv[3], &quot;inbound&quot;)) {</span>
<span class="lineNum">    4411 </span><span class="lineNoCov">          0 :                 on_subscription = cli_show_subscriptions_inbound;</span>
<span class="lineNum">    4412 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(a-&gt;argv[3], &quot;outbound&quot;)) {</span>
<span class="lineNum">    4413 </span><span class="lineNoCov">          0 :                 on_subscription = cli_show_subscriptions_outbound;</span>
<span class="lineNum">    4414 </span>            :         } else {
<span class="lineNum">    4415 </span>            :                 /* Should never get here */
<span class="lineNum">    4416 </span><span class="lineNoCov">          0 :                 ast_assert(0);</span>
<span class="lineNum">    4417 </span><span class="lineNoCov">          0 :                 return CLI_SHOWUSAGE;</span>
<span class="lineNum">    4418 </span>            :         }
<span class="lineNum">    4419 </span><span class="lineNoCov">          0 :         if (a-&gt;argc == 6) {</span>
<span class="lineNum">    4420 </span>            :                 int rc;
<span class="lineNum">    4421 </span>            : 
<span class="lineNum">    4422 </span><span class="lineNoCov">          0 :                 if (strcasecmp(a-&gt;argv[4], &quot;like&quot;)) {</span>
<span class="lineNum">    4423 </span><span class="lineNoCov">          0 :                         return CLI_SHOWUSAGE;</span>
<span class="lineNum">    4424 </span>            :                 }
<span class="lineNum">    4425 </span>            : 
<span class="lineNum">    4426 </span>            :                 /* Setup regular expression */
<span class="lineNum">    4427 </span><span class="lineNoCov">          0 :                 memset(&amp;like, 0, sizeof(like));</span>
<span class="lineNum">    4428 </span><span class="lineNoCov">          0 :                 cli.like = &amp;like;</span>
<span class="lineNum">    4429 </span><span class="lineNoCov">          0 :                 regex = a-&gt;argv[5];</span>
<span class="lineNum">    4430 </span><span class="lineNoCov">          0 :                 rc = regcomp(cli.like, regex, REG_EXTENDED | REG_NOSUB);</span>
<span class="lineNum">    4431 </span><span class="lineNoCov">          0 :                 if (rc) {</span>
<span class="lineNum">    4432 </span><span class="lineNoCov">          0 :                         char *regerr = ast_alloca(MAX_REGEX_ERROR_LEN);</span>
<span class="lineNum">    4433 </span>            : 
<span class="lineNum">    4434 </span><span class="lineNoCov">          0 :                         regerror(rc, cli.like, regerr, MAX_REGEX_ERROR_LEN);</span>
<span class="lineNum">    4435 </span><span class="lineNoCov">          0 :                         ast_cli(a-&gt;fd, &quot;Regular expression '%s' failed to compile: %s\n&quot;,</span>
<span class="lineNum">    4436 </span>            :                                 regex, regerr);
<span class="lineNum">    4437 </span><span class="lineNoCov">          0 :                         return CLI_FAILURE;</span>
<span class="lineNum">    4438 </span>            :                 }
<span class="lineNum">    4439 </span>            :         } else {
<span class="lineNum">    4440 </span><span class="lineNoCov">          0 :                 cli.like = NULL;</span>
<span class="lineNum">    4441 </span><span class="lineNoCov">          0 :                 regex = NULL;</span>
<span class="lineNum">    4442 </span>            :         }
<span class="lineNum">    4443 </span>            : 
<span class="lineNum">    4444 </span><span class="lineNoCov">          0 :         cli.a = a;</span>
<span class="lineNum">    4445 </span><span class="lineNoCov">          0 :         cli.e = e;</span>
<span class="lineNum">    4446 </span><span class="lineNoCov">          0 :         cli.count = 0;</span>
<span class="lineNum">    4447 </span><span class="lineNoCov">          0 :         cli.buf = ast_str_create(256);</span>
<span class="lineNum">    4448 </span><span class="lineNoCov">          0 :         if (!cli.buf) {</span>
<span class="lineNum">    4449 </span><span class="lineNoCov">          0 :                 if (cli.like) {</span>
<span class="lineNum">    4450 </span><span class="lineNoCov">          0 :                         regfree(cli.like);</span>
<span class="lineNum">    4451 </span>            :                 }
<span class="lineNum">    4452 </span><span class="lineNoCov">          0 :                 return CLI_FAILURE;</span>
<span class="lineNum">    4453 </span>            :         }
<span class="lineNum">    4454 </span>            : 
<span class="lineNum">    4455 </span><span class="lineNoCov">          0 :         ast_cli(a-&gt;fd, CLI_SHOW_SUB_FORMAT_HEADER);</span>
<span class="lineNum">    4456 </span><span class="lineNoCov">          0 :         for_each_subscription(on_subscription, &amp;cli);</span>
<span class="lineNum">    4457 </span><span class="lineNoCov">          0 :         ast_cli(a-&gt;fd, &quot;%d active subscriptions%s%s%s\n&quot;,</span>
<span class="lineNum">    4458 </span>            :                 cli.count,
<span class="lineNum">    4459 </span>            :                 regex ? &quot; matched \&quot;&quot; : &quot;&quot;,
<span class="lineNum">    4460 </span><span class="lineNoCov">          0 :                 regex ?: &quot;&quot;,</span>
<span class="lineNum">    4461 </span>            :                 regex ? &quot;\&quot;&quot; : &quot;&quot;);
<span class="lineNum">    4462 </span>            : 
<span class="lineNum">    4463 </span><span class="lineNoCov">          0 :         ast_free(cli.buf);</span>
<span class="lineNum">    4464 </span><span class="lineNoCov">          0 :         if (cli.like) {</span>
<span class="lineNum">    4465 </span><span class="lineNoCov">          0 :                 regfree(cli.like);</span>
<span class="lineNum">    4466 </span>            :         }
<span class="lineNum">    4467 </span>            : 
<span class="lineNum">    4468 </span><span class="lineNoCov">          0 :         return CLI_SUCCESS;</span>
<span class="lineNum">    4469 </span>            : }
<span class="lineNum">    4470 </span>            : 
<span class="lineNum">    4471 </span>            : #define CLI_LIST_SUB_FORMAT_HEADER &quot;%-30.30s %-30.30s %6.6s %s\n&quot;
<a name="4472"><span class="lineNum">    4472 </span>            : #define CLI_LIST_SUB_FORMAT_ENTRY  &quot;%-30.30s %-30.30s %6d %s\n&quot;</a>
<span class="lineNum">    4473 </span>            : 
<span class="lineNum">    4474 </span><span class="lineNoCov">          0 : static int cli_list_subscriptions_detail(struct sip_subscription_tree *sub_tree, struct cli_sub_parms *cli)</span>
<span class="lineNum">    4475 </span>            : {
<span class="lineNum">    4476 </span>            :         char ep_cid_buf[50];
<span class="lineNum">    4477 </span>            :         char res_evt_buf[50];
<span class="lineNum">    4478 </span>            :         char callid[256];
<span class="lineNum">    4479 </span>            : 
<span class="lineNum">    4480 </span>            :         /* Endpoint/CID column */
<span class="lineNum">    4481 </span><span class="lineNoCov">          0 :         snprintf(ep_cid_buf, sizeof(ep_cid_buf), &quot;%s/%s&quot;,</span>
<span class="lineNum">    4482 </span><span class="lineNoCov">          0 :                 ast_sorcery_object_get_id(sub_tree-&gt;endpoint),</span>
<span class="lineNum">    4483 </span><span class="lineNoCov">          0 :                 S_COR(sub_tree-&gt;endpoint-&gt;id.self.name.valid, sub_tree-&gt;endpoint-&gt;id.self.name.str,</span>
<span class="lineNum">    4484 </span>            :                         S_COR(sub_tree-&gt;endpoint-&gt;id.self.number.valid,
<span class="lineNum">    4485 </span>            :                                 sub_tree-&gt;endpoint-&gt;id.self.number.str, &quot;&lt;none&gt;&quot;)));
<span class="lineNum">    4486 </span>            : 
<span class="lineNum">    4487 </span>            :         /* Resource/Event column */
<span class="lineNum">    4488 </span><span class="lineNoCov">          0 :         snprintf(res_evt_buf, sizeof(res_evt_buf), &quot;%s/%s&quot;,</span>
<span class="lineNum">    4489 </span><span class="lineNoCov">          0 :                 sub_tree-&gt;root-&gt;resource,</span>
<span class="lineNum">    4490 </span><span class="lineNoCov">          0 :                 sub_tree-&gt;root-&gt;handler-&gt;event_name);</span>
<span class="lineNum">    4491 </span>            : 
<span class="lineNum">    4492 </span>            :         /* Call-id column */
<span class="lineNum">    4493 </span><span class="lineNoCov">          0 :         if (sub_tree-&gt;dlg) {</span>
<span class="lineNum">    4494 </span><span class="lineNoCov">          0 :                 ast_copy_pj_str(callid, &amp;sub_tree-&gt;dlg-&gt;call_id-&gt;id, sizeof(callid));</span>
<span class="lineNum">    4495 </span>            :         } else {
<span class="lineNum">    4496 </span><span class="lineNoCov">          0 :                 ast_copy_string(callid, &quot;&lt;unknown&gt;&quot;, sizeof(callid));</span>
<span class="lineNum">    4497 </span>            :         }
<span class="lineNum">    4498 </span>            : 
<span class="lineNum">    4499 </span><span class="lineNoCov">          0 :         ast_str_set(&amp;cli-&gt;buf, 0, CLI_LIST_SUB_FORMAT_ENTRY,</span>
<span class="lineNum">    4500 </span>            :                 ep_cid_buf,
<span class="lineNum">    4501 </span>            :                 res_evt_buf,
<span class="lineNum">    4502 </span>            :                 cli_subscription_expiry(sub_tree),
<span class="lineNum">    4503 </span>            :                 callid);
<span class="lineNum">    4504 </span>            : 
<span class="lineNum">    4505 </span><span class="lineNoCov">          0 :         if (cli-&gt;like) {</span>
<span class="lineNum">    4506 </span><span class="lineNoCov">          0 :                 if (regexec(cli-&gt;like, ast_str_buffer(cli-&gt;buf), 0, NULL, 0)) {</span>
<span class="lineNum">    4507 </span>            :                         /* Output line did not match the regex */
<span class="lineNum">    4508 </span><span class="lineNoCov">          0 :                         return 0;</span>
<span class="lineNum">    4509 </span>            :                 }
<span class="lineNum">    4510 </span>            :         }
<span class="lineNum">    4511 </span>            : 
<span class="lineNum">    4512 </span><span class="lineNoCov">          0 :         ast_cli(cli-&gt;a-&gt;fd, &quot;%s&quot;, ast_str_buffer(cli-&gt;buf));</span>
<span class="lineNum">    4513 </span><span class="lineNoCov">          0 :         ++cli-&gt;count;</span>
<span class="lineNum">    4514 </span>            : 
<span class="lineNum">    4515 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="4516"><span class="lineNum">    4516 </span>            : }</a>
<span class="lineNum">    4517 </span>            : 
<span class="lineNum">    4518 </span><span class="lineNoCov">          0 : static int cli_list_subscriptions_inbound(struct sip_subscription_tree *sub_tree, void *arg)</span>
<span class="lineNum">    4519 </span>            : {
<span class="lineNum">    4520 </span><span class="lineNoCov">          0 :         return sub_tree-&gt;role == AST_SIP_NOTIFIER</span>
<span class="lineNum">    4521 </span><span class="lineNoCov">          0 :                 ? cli_list_subscriptions_detail(sub_tree, arg) : 0;</span>
<a name="4522"><span class="lineNum">    4522 </span>            : }</a>
<span class="lineNum">    4523 </span>            : 
<span class="lineNum">    4524 </span><span class="lineNoCov">          0 : static int cli_list_subscriptions_outbound(struct sip_subscription_tree *sub_tree, void *arg)</span>
<span class="lineNum">    4525 </span>            : {
<span class="lineNum">    4526 </span><span class="lineNoCov">          0 :         return sub_tree-&gt;role == AST_SIP_SUBSCRIBER</span>
<span class="lineNum">    4527 </span><span class="lineNoCov">          0 :                 ? cli_list_subscriptions_detail(sub_tree, arg) : 0;</span>
<a name="4528"><span class="lineNum">    4528 </span>            : }</a>
<span class="lineNum">    4529 </span>            : 
<span class="lineNum">    4530 </span><span class="lineCov">        852 : static char *cli_list_subscriptions_inout(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)</span>
<span class="lineNum">    4531 </span>            : {
<span class="lineNum">    4532 </span>            :         on_subscription_t on_subscription;
<span class="lineNum">    4533 </span>            :         struct cli_sub_parms cli;
<span class="lineNum">    4534 </span>            :         regex_t like;
<span class="lineNum">    4535 </span>            :         const char *regex;
<span class="lineNum">    4536 </span>            : 
<span class="lineNum">    4537 </span><span class="lineCov">        852 :         switch (cmd) {</span>
<span class="lineNum">    4538 </span><span class="lineCov">        852 :         case CLI_INIT:</span>
<span class="lineNum">    4539 </span><span class="lineCov">        852 :                 e-&gt;command = &quot;pjsip list subscriptions {inbound|outbound} [like]&quot;;</span>
<span class="lineNum">    4540 </span><span class="lineCov">        852 :                 e-&gt;usage = &quot;Usage:\n&quot;</span>
<span class="lineNum">    4541 </span>            :                                    &quot;   pjsip list subscriptions inbound [like &lt;regex&gt;]\n&quot;
<span class="lineNum">    4542 </span>            :                                    &quot;      List active inbound subscriptions\n&quot;
<span class="lineNum">    4543 </span>            :                                    &quot;   pjsip list subscriptions outbound [like &lt;regex&gt;]\n&quot;
<span class="lineNum">    4544 </span>            :                                    &quot;      List active outbound subscriptions\n&quot;
<span class="lineNum">    4545 </span>            :                                    &quot;\n&quot;
<span class="lineNum">    4546 </span>            :                                    &quot;   The regex selects output lines that match.\n&quot;;
<span class="lineNum">    4547 </span><span class="lineCov">        852 :                 return NULL;</span>
<span class="lineNum">    4548 </span><span class="lineNoCov">          0 :         case CLI_GENERATE:</span>
<span class="lineNum">    4549 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    4550 </span>            :         }
<span class="lineNum">    4551 </span>            : 
<span class="lineNum">    4552 </span><span class="lineNoCov">          0 :         if (a-&gt;argc != 4 &amp;&amp; a-&gt;argc != 6) {</span>
<span class="lineNum">    4553 </span><span class="lineNoCov">          0 :                 return CLI_SHOWUSAGE;</span>
<span class="lineNum">    4554 </span>            :         }
<span class="lineNum">    4555 </span><span class="lineNoCov">          0 :         if (!strcasecmp(a-&gt;argv[3], &quot;inbound&quot;)) {</span>
<span class="lineNum">    4556 </span><span class="lineNoCov">          0 :                 on_subscription = cli_list_subscriptions_inbound;</span>
<span class="lineNum">    4557 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(a-&gt;argv[3], &quot;outbound&quot;)) {</span>
<span class="lineNum">    4558 </span><span class="lineNoCov">          0 :                 on_subscription = cli_list_subscriptions_outbound;</span>
<span class="lineNum">    4559 </span>            :         } else {
<span class="lineNum">    4560 </span>            :                 /* Should never get here */
<span class="lineNum">    4561 </span><span class="lineNoCov">          0 :                 ast_assert(0);</span>
<span class="lineNum">    4562 </span><span class="lineNoCov">          0 :                 return CLI_SHOWUSAGE;</span>
<span class="lineNum">    4563 </span>            :         }
<span class="lineNum">    4564 </span><span class="lineNoCov">          0 :         if (a-&gt;argc == 6) {</span>
<span class="lineNum">    4565 </span>            :                 int rc;
<span class="lineNum">    4566 </span>            : 
<span class="lineNum">    4567 </span><span class="lineNoCov">          0 :                 if (strcasecmp(a-&gt;argv[4], &quot;like&quot;)) {</span>
<span class="lineNum">    4568 </span><span class="lineNoCov">          0 :                         return CLI_SHOWUSAGE;</span>
<span class="lineNum">    4569 </span>            :                 }
<span class="lineNum">    4570 </span>            : 
<span class="lineNum">    4571 </span>            :                 /* Setup regular expression */
<span class="lineNum">    4572 </span><span class="lineNoCov">          0 :                 memset(&amp;like, 0, sizeof(like));</span>
<span class="lineNum">    4573 </span><span class="lineNoCov">          0 :                 cli.like = &amp;like;</span>
<span class="lineNum">    4574 </span><span class="lineNoCov">          0 :                 regex = a-&gt;argv[5];</span>
<span class="lineNum">    4575 </span><span class="lineNoCov">          0 :                 rc = regcomp(cli.like, regex, REG_EXTENDED | REG_NOSUB);</span>
<span class="lineNum">    4576 </span><span class="lineNoCov">          0 :                 if (rc) {</span>
<span class="lineNum">    4577 </span><span class="lineNoCov">          0 :                         char *regerr = ast_alloca(MAX_REGEX_ERROR_LEN);</span>
<span class="lineNum">    4578 </span>            : 
<span class="lineNum">    4579 </span><span class="lineNoCov">          0 :                         regerror(rc, cli.like, regerr, MAX_REGEX_ERROR_LEN);</span>
<span class="lineNum">    4580 </span><span class="lineNoCov">          0 :                         ast_cli(a-&gt;fd, &quot;Regular expression '%s' failed to compile: %s\n&quot;,</span>
<span class="lineNum">    4581 </span>            :                                 regex, regerr);
<span class="lineNum">    4582 </span><span class="lineNoCov">          0 :                         return CLI_FAILURE;</span>
<span class="lineNum">    4583 </span>            :                 }
<span class="lineNum">    4584 </span>            :         } else {
<span class="lineNum">    4585 </span><span class="lineNoCov">          0 :                 cli.like = NULL;</span>
<span class="lineNum">    4586 </span><span class="lineNoCov">          0 :                 regex = NULL;</span>
<span class="lineNum">    4587 </span>            :         }
<span class="lineNum">    4588 </span>            : 
<span class="lineNum">    4589 </span><span class="lineNoCov">          0 :         cli.a = a;</span>
<span class="lineNum">    4590 </span><span class="lineNoCov">          0 :         cli.e = e;</span>
<span class="lineNum">    4591 </span><span class="lineNoCov">          0 :         cli.count = 0;</span>
<span class="lineNum">    4592 </span><span class="lineNoCov">          0 :         cli.buf = ast_str_create(256);</span>
<span class="lineNum">    4593 </span><span class="lineNoCov">          0 :         if (!cli.buf) {</span>
<span class="lineNum">    4594 </span><span class="lineNoCov">          0 :                 if (cli.like) {</span>
<span class="lineNum">    4595 </span><span class="lineNoCov">          0 :                         regfree(cli.like);</span>
<span class="lineNum">    4596 </span>            :                 }
<span class="lineNum">    4597 </span><span class="lineNoCov">          0 :                 return CLI_FAILURE;</span>
<span class="lineNum">    4598 </span>            :         }
<span class="lineNum">    4599 </span>            : 
<span class="lineNum">    4600 </span><span class="lineNoCov">          0 :         ast_cli(a-&gt;fd, CLI_LIST_SUB_FORMAT_HEADER,</span>
<span class="lineNum">    4601 </span>            :                 &quot;Endpoint/CLI&quot;, &quot;Resource/Event&quot;, &quot;Expiry&quot;, &quot;Call-id&quot;);
<span class="lineNum">    4602 </span><span class="lineNoCov">          0 :         for_each_subscription(on_subscription, &amp;cli);</span>
<span class="lineNum">    4603 </span><span class="lineNoCov">          0 :         ast_cli(a-&gt;fd, &quot;\n%d active subscriptions%s%s%s\n&quot;,</span>
<span class="lineNum">    4604 </span>            :                 cli.count,
<span class="lineNum">    4605 </span>            :                 regex ? &quot; matched \&quot;&quot; : &quot;&quot;,
<span class="lineNum">    4606 </span><span class="lineNoCov">          0 :                 regex ?: &quot;&quot;,</span>
<span class="lineNum">    4607 </span>            :                 regex ? &quot;\&quot;&quot; : &quot;&quot;);
<span class="lineNum">    4608 </span>            : 
<span class="lineNum">    4609 </span><span class="lineNoCov">          0 :         ast_free(cli.buf);</span>
<span class="lineNum">    4610 </span><span class="lineNoCov">          0 :         if (cli.like) {</span>
<span class="lineNum">    4611 </span><span class="lineNoCov">          0 :                 regfree(cli.like);</span>
<span class="lineNum">    4612 </span>            :         }
<span class="lineNum">    4613 </span>            : 
<span class="lineNum">    4614 </span><span class="lineNoCov">          0 :         return CLI_SUCCESS;</span>
<span class="lineNum">    4615 </span>            : }
<span class="lineNum">    4616 </span>            : 
<span class="lineNum">    4617 </span>            : static struct ast_cli_entry cli_commands[] = {
<span class="lineNum">    4618 </span>            :         AST_CLI_DEFINE(cli_list_subscriptions_inout, &quot;List active inbound/outbound subscriptions&quot;),
<span class="lineNum">    4619 </span>            :         AST_CLI_DEFINE(cli_show_subscription_inout, &quot;Show active subscription details&quot;),
<span class="lineNum">    4620 </span>            :         AST_CLI_DEFINE(cli_show_subscriptions_inout, &quot;Show active inbound/outbound subscriptions&quot;),
<a name="4621"><span class="lineNum">    4621 </span>            : };</a>
<span class="lineNum">    4622 </span>            : 
<span class="lineNum">    4623 </span><span class="lineCov">          1 : static int persistence_endpoint_str2struct(const struct aco_option *opt, struct ast_variable *var, void *obj)</span>
<span class="lineNum">    4624 </span>            : {
<span class="lineNum">    4625 </span><span class="lineCov">          1 :         struct subscription_persistence *persistence = obj;</span>
<span class="lineNum">    4626 </span>            : 
<span class="lineNum">    4627 </span><span class="lineCov">          1 :         persistence-&gt;endpoint = ast_strdup(var-&gt;value);</span>
<span class="lineNum">    4628 </span><span class="lineCov">          1 :         return 0;</span>
<a name="4629"><span class="lineNum">    4629 </span>            : }</a>
<span class="lineNum">    4630 </span>            : 
<span class="lineNum">    4631 </span><span class="lineCov">        357 : static int persistence_endpoint_struct2str(const void *obj, const intptr_t *args, char **buf)</span>
<span class="lineNum">    4632 </span>            : {
<span class="lineNum">    4633 </span><span class="lineCov">        357 :         const struct subscription_persistence *persistence = obj;</span>
<span class="lineNum">    4634 </span>            : 
<span class="lineNum">    4635 </span><span class="lineCov">        357 :         *buf = ast_strdup(persistence-&gt;endpoint);</span>
<span class="lineNum">    4636 </span><span class="lineCov">        357 :         return 0;</span>
<a name="4637"><span class="lineNum">    4637 </span>            : }</a>
<span class="lineNum">    4638 </span>            : 
<span class="lineNum">    4639 </span><span class="lineCov">          1 : static int persistence_tag_str2struct(const struct aco_option *opt, struct ast_variable *var, void *obj)</span>
<span class="lineNum">    4640 </span>            : {
<span class="lineNum">    4641 </span><span class="lineCov">          1 :         struct subscription_persistence *persistence = obj;</span>
<span class="lineNum">    4642 </span>            : 
<span class="lineNum">    4643 </span><span class="lineCov">          1 :         persistence-&gt;tag = ast_strdup(var-&gt;value);</span>
<span class="lineNum">    4644 </span><span class="lineCov">          1 :         return 0;</span>
<a name="4645"><span class="lineNum">    4645 </span>            : }</a>
<span class="lineNum">    4646 </span>            : 
<span class="lineNum">    4647 </span><span class="lineCov">        357 : static int persistence_tag_struct2str(const void *obj, const intptr_t *args, char **buf)</span>
<span class="lineNum">    4648 </span>            : {
<span class="lineNum">    4649 </span><span class="lineCov">        357 :         const struct subscription_persistence *persistence = obj;</span>
<span class="lineNum">    4650 </span>            : 
<span class="lineNum">    4651 </span><span class="lineCov">        357 :         *buf = ast_strdup(persistence-&gt;tag);</span>
<span class="lineNum">    4652 </span><span class="lineCov">        357 :         return 0;</span>
<a name="4653"><span class="lineNum">    4653 </span>            : }</a>
<span class="lineNum">    4654 </span>            : 
<span class="lineNum">    4655 </span><span class="lineCov">          1 : static int persistence_expires_str2struct(const struct aco_option *opt, struct ast_variable *var, void *obj)</span>
<span class="lineNum">    4656 </span>            : {
<span class="lineNum">    4657 </span><span class="lineCov">          1 :         struct subscription_persistence *persistence = obj;</span>
<span class="lineNum">    4658 </span><span class="lineCov">          1 :         return ast_get_timeval(var-&gt;value, &amp;persistence-&gt;expires, ast_tv(0, 0), NULL);</span>
<a name="4659"><span class="lineNum">    4659 </span>            : }</a>
<span class="lineNum">    4660 </span>            : 
<span class="lineNum">    4661 </span><span class="lineCov">        357 : static int persistence_expires_struct2str(const void *obj, const intptr_t *args, char **buf)</span>
<span class="lineNum">    4662 </span>            : {
<span class="lineNum">    4663 </span><span class="lineCov">        357 :         const struct subscription_persistence *persistence = obj;</span>
<span class="lineNum">    4664 </span><span class="lineCov">        357 :         return (ast_asprintf(buf, &quot;%ld&quot;, persistence-&gt;expires.tv_sec) &lt; 0) ? -1 : 0;</span>
<span class="lineNum">    4665 </span>            : }
<span class="lineNum">    4666 </span>            : 
<a name="4667"><span class="lineNum">    4667 </span>            : #define RESOURCE_LIST_INIT_SIZE 4</a>
<span class="lineNum">    4668 </span>            : 
<span class="lineNum">    4669 </span><span class="lineCov">         17 : static void resource_list_destructor(void *obj)</span>
<span class="lineNum">    4670 </span>            : {
<span class="lineNum">    4671 </span><span class="lineCov">         17 :         struct resource_list *list = obj;</span>
<span class="lineNum">    4672 </span>            :         int i;
<span class="lineNum">    4673 </span>            : 
<span class="lineNum">    4674 </span><span class="lineCov">         69 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;list-&gt;items); ++i) {</span>
<span class="lineNum">    4675 </span><span class="lineCov">         52 :                 ast_free((char *) AST_VECTOR_GET(&amp;list-&gt;items, i));</span>
<span class="lineNum">    4676 </span>            :         }
<span class="lineNum">    4677 </span>            : 
<span class="lineNum">    4678 </span><span class="lineCov">         17 :         AST_VECTOR_FREE(&amp;list-&gt;items);</span>
<a name="4679"><span class="lineNum">    4679 </span><span class="lineCov">         17 : }</span></a>
<span class="lineNum">    4680 </span>            : 
<span class="lineNum">    4681 </span><span class="lineCov">         92 : static void *resource_list_alloc(const char *name)</span>
<span class="lineNum">    4682 </span>            : {
<span class="lineNum">    4683 </span>            :         struct resource_list *list;
<span class="lineNum">    4684 </span>            : 
<span class="lineNum">    4685 </span><span class="lineCov">         92 :         list = ast_sorcery_generic_alloc(sizeof(*list), resource_list_destructor);</span>
<span class="lineNum">    4686 </span><span class="lineCov">         92 :         if (!list) {</span>
<span class="lineNum">    4687 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    4688 </span>            :         }
<span class="lineNum">    4689 </span>            : 
<span class="lineNum">    4690 </span><span class="lineCov">         92 :         if (AST_VECTOR_INIT(&amp;list-&gt;items, RESOURCE_LIST_INIT_SIZE)) {</span>
<span class="lineNum">    4691 </span><span class="lineNoCov">          0 :                 ao2_cleanup(list);</span>
<span class="lineNum">    4692 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    4693 </span>            :         }
<span class="lineNum">    4694 </span>            : 
<span class="lineNum">    4695 </span><span class="lineCov">         92 :         return list;</span>
<a name="4696"><span class="lineNum">    4696 </span>            : }</a>
<span class="lineNum">    4697 </span>            : 
<span class="lineNum">    4698 </span><span class="lineCov">        176 : static int item_in_vector(const struct resource_list *list, const char *item)</span>
<span class="lineNum">    4699 </span>            : {
<span class="lineNum">    4700 </span>            :         int i;
<span class="lineNum">    4701 </span>            : 
<span class="lineNum">    4702 </span><span class="lineCov">        461 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;list-&gt;items); ++i) {</span>
<span class="lineNum">    4703 </span><span class="lineCov">        287 :                 if (!strcmp(item, AST_VECTOR_GET(&amp;list-&gt;items, i))) {</span>
<span class="lineNum">    4704 </span><span class="lineCov">          2 :                         return 1;</span>
<span class="lineNum">    4705 </span>            :                 }
<span class="lineNum">    4706 </span>            :         }
<span class="lineNum">    4707 </span>            : 
<span class="lineNum">    4708 </span><span class="lineCov">        174 :         return 0;</span>
<a name="4709"><span class="lineNum">    4709 </span>            : }</a>
<span class="lineNum">    4710 </span>            : 
<span class="lineNum">    4711 </span><span class="lineCov">        176 : static int list_item_handler(const struct aco_option *opt,</span>
<span class="lineNum">    4712 </span>            :                 struct ast_variable *var, void *obj)
<span class="lineNum">    4713 </span>            : {
<span class="lineNum">    4714 </span><span class="lineCov">        176 :         struct resource_list *list = obj;</span>
<span class="lineNum">    4715 </span><span class="lineCov">        176 :         char *items = ast_strdupa(var-&gt;value);</span>
<span class="lineNum">    4716 </span>            :         char *item;
<span class="lineNum">    4717 </span>            : 
<span class="lineNum">    4718 </span><span class="lineCov">        352 :         while ((item = ast_strip(strsep(&amp;items, &quot;,&quot;)))) {</span>
<span class="lineNum">    4719 </span><span class="lineCov">        176 :                 if (ast_strlen_zero(item)) {</span>
<span class="lineNum">    4720 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    4721 </span>            :                 }
<span class="lineNum">    4722 </span>            : 
<span class="lineNum">    4723 </span><span class="lineCov">        176 :                 if (item_in_vector(list, item)) {</span>
<span class="lineNum">    4724 </span><span class="lineCov">          2 :                         ast_log(LOG_WARNING, &quot;Ignoring duplicated list item '%s'\n&quot;, item);</span>
<span class="lineNum">    4725 </span><span class="lineCov">          2 :                         continue;</span>
<span class="lineNum">    4726 </span>            :                 }
<span class="lineNum">    4727 </span>            : 
<span class="lineNum">    4728 </span><span class="lineCov">        174 :                 item = ast_strdup(item);</span>
<span class="lineNum">    4729 </span><span class="lineCov">        174 :                 if (!item || AST_VECTOR_APPEND(&amp;list-&gt;items, item)) {</span>
<span class="lineNum">    4730 </span><span class="lineNoCov">          0 :                         ast_free(item);</span>
<span class="lineNum">    4731 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    4732 </span>            :                 }
<span class="lineNum">    4733 </span>            :         }
<span class="lineNum">    4734 </span>            : 
<span class="lineNum">    4735 </span><span class="lineCov">        176 :         return 0;</span>
<a name="4736"><span class="lineNum">    4736 </span>            : }</a>
<span class="lineNum">    4737 </span>            : 
<span class="lineNum">    4738 </span><span class="lineNoCov">          0 : static int list_item_to_str(const void *obj, const intptr_t *args, char **buf)</span>
<span class="lineNum">    4739 </span>            : {
<span class="lineNum">    4740 </span><span class="lineNoCov">          0 :         const struct resource_list *list = obj;</span>
<span class="lineNum">    4741 </span>            :         int i;
<span class="lineNum">    4742 </span><span class="lineNoCov">          0 :         struct ast_str *str = ast_str_create(32);</span>
<span class="lineNum">    4743 </span>            : 
<span class="lineNum">    4744 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;list-&gt;items); ++i) {</span>
<span class="lineNum">    4745 </span><span class="lineNoCov">          0 :                 ast_str_append(&amp;str, 0, &quot;%s,&quot;, AST_VECTOR_GET(&amp;list-&gt;items, i));</span>
<span class="lineNum">    4746 </span>            :         }
<span class="lineNum">    4747 </span>            : 
<span class="lineNum">    4748 </span>            :         /* Chop off trailing comma */
<span class="lineNum">    4749 </span><span class="lineNoCov">          0 :         ast_str_truncate(str, -1);</span>
<span class="lineNum">    4750 </span><span class="lineNoCov">          0 :         *buf = ast_strdup(ast_str_buffer(str));</span>
<span class="lineNum">    4751 </span><span class="lineNoCov">          0 :         ast_free(str);</span>
<span class="lineNum">    4752 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="4753"><span class="lineNum">    4753 </span>            : }</a>
<span class="lineNum">    4754 </span>            : 
<span class="lineNum">    4755 </span><span class="lineCov">         81 : static int resource_list_apply_handler(const struct ast_sorcery *sorcery, void *obj)</span>
<span class="lineNum">    4756 </span>            : {
<span class="lineNum">    4757 </span><span class="lineCov">         81 :         struct resource_list *list = obj;</span>
<span class="lineNum">    4758 </span>            : 
<span class="lineNum">    4759 </span><span class="lineCov">         81 :         if (ast_strlen_zero(list-&gt;event)) {</span>
<span class="lineNum">    4760 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Resource list '%s' has no event set\n&quot;,</span>
<span class="lineNum">    4761 </span>            :                                 ast_sorcery_object_get_id(list));
<span class="lineNum">    4762 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    4763 </span>            :         }
<span class="lineNum">    4764 </span>            : 
<span class="lineNum">    4765 </span><span class="lineCov">         81 :         if (AST_VECTOR_SIZE(&amp;list-&gt;items) == 0) {</span>
<span class="lineNum">    4766 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Resource list '%s' has no list items\n&quot;,</span>
<span class="lineNum">    4767 </span>            :                                 ast_sorcery_object_get_id(list));
<span class="lineNum">    4768 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    4769 </span>            :         }
<span class="lineNum">    4770 </span>            : 
<span class="lineNum">    4771 </span><span class="lineCov">         81 :         return 0;</span>
<a name="4772"><span class="lineNum">    4772 </span>            : }</a>
<span class="lineNum">    4773 </span>            : 
<span class="lineNum">    4774 </span><span class="lineCov">        852 : static int apply_list_configuration(struct ast_sorcery *sorcery)</span>
<span class="lineNum">    4775 </span>            : {
<span class="lineNum">    4776 </span><span class="lineCov">        852 :         ast_sorcery_apply_default(sorcery, &quot;resource_list&quot;, &quot;config&quot;,</span>
<span class="lineNum">    4777 </span>            :                         &quot;pjsip.conf,criteria=type=resource_list&quot;);
<span class="lineNum">    4778 </span><span class="lineCov">        852 :         if (ast_sorcery_object_register(sorcery, &quot;resource_list&quot;, resource_list_alloc,</span>
<span class="lineNum">    4779 </span>            :                                 NULL, resource_list_apply_handler)) {
<span class="lineNum">    4780 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    4781 </span>            :         }
<span class="lineNum">    4782 </span>            : 
<span class="lineNum">    4783 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;resource_list&quot;, &quot;type&quot;, &quot;&quot;,</span>
<span class="lineNum">    4784 </span>            :                         OPT_NOOP_T, 0, 0);
<span class="lineNum">    4785 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;resource_list&quot;, &quot;event&quot;, &quot;&quot;,</span>
<span class="lineNum">    4786 </span>            :                         OPT_CHAR_ARRAY_T, 1, CHARFLDSET(struct resource_list, event));
<span class="lineNum">    4787 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;resource_list&quot;, &quot;full_state&quot;, &quot;no&quot;,</span>
<span class="lineNum">    4788 </span>            :                         OPT_BOOL_T, 1, FLDSET(struct resource_list, full_state));
<span class="lineNum">    4789 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;resource_list&quot;, &quot;notification_batch_interval&quot;,</span>
<span class="lineNum">    4790 </span>            :                         &quot;0&quot;, OPT_UINT_T, 0, FLDSET(struct resource_list, notification_batch_interval));
<span class="lineNum">    4791 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register_custom(sorcery, &quot;resource_list&quot;, &quot;list_item&quot;,</span>
<span class="lineNum">    4792 </span>            :                         &quot;&quot;, list_item_handler, list_item_to_str, NULL, 0, 0);
<span class="lineNum">    4793 </span>            : 
<span class="lineNum">    4794 </span><span class="lineCov">        852 :         ast_sorcery_reload_object(sorcery, &quot;resource_list&quot;);</span>
<span class="lineNum">    4795 </span>            : 
<span class="lineNum">    4796 </span><span class="lineCov">        852 :         return 0;</span>
<span class="lineNum">    4797 </span>            : }
<span class="lineNum">    4798 </span>            : 
<span class="lineNum">    4799 </span>            : #ifdef TEST_FRAMEWORK
<span class="lineNum">    4800 </span>            : 
<span class="lineNum">    4801 </span>            : /*!
<span class="lineNum">    4802 </span>            :  * \brief &quot;bad&quot; resources
<span class="lineNum">    4803 </span>            :  *
<span class="lineNum">    4804 </span>            :  * These are resources that the test handler will reject subscriptions to.
<span class="lineNum">    4805 </span>            :  */
<span class="lineNum">    4806 </span>            : const char *bad_resources[] = {
<span class="lineNum">    4807 </span>            :         &quot;coconut&quot;,
<span class="lineNum">    4808 </span>            :         &quot;cilantro&quot;,
<span class="lineNum">    4809 </span>            :         &quot;olive&quot;,
<span class="lineNum">    4810 </span>            :         &quot;cheese&quot;,
<span class="lineNum">    4811 </span>            : };
<span class="lineNum">    4812 </span>            : 
<span class="lineNum">    4813 </span>            : /*!
<span class="lineNum">    4814 </span>            :  * \brief new_subscribe callback for unit tests
<span class="lineNum">    4815 </span>            :  *
<a name="4816"><span class="lineNum">    4816 </span>            :  * Will give a 200 OK response to any resource except the &quot;bad&quot; ones.</a>
<span class="lineNum">    4817 </span>            :  */
<span class="lineNum">    4818 </span><span class="lineCov">         31 : static int test_new_subscribe(struct ast_sip_endpoint *endpoint, const char *resource)</span>
<span class="lineNum">    4819 </span>            : {
<span class="lineNum">    4820 </span>            :         int i;
<span class="lineNum">    4821 </span>            : 
<span class="lineNum">    4822 </span><span class="lineCov">        141 :         for (i = 0; i &lt; ARRAY_LEN(bad_resources); ++i) {</span>
<span class="lineNum">    4823 </span><span class="lineCov">        115 :                 if (!strcmp(resource, bad_resources[i])) {</span>
<span class="lineNum">    4824 </span><span class="lineCov">          5 :                         return 400;</span>
<span class="lineNum">    4825 </span>            :                 }
<span class="lineNum">    4826 </span>            :         }
<span class="lineNum">    4827 </span>            : 
<span class="lineNum">    4828 </span><span class="lineCov">         26 :         return 200;</span>
<span class="lineNum">    4829 </span>            : }
<span class="lineNum">    4830 </span>            : 
<span class="lineNum">    4831 </span>            : /*!
<span class="lineNum">    4832 </span>            :  * \brief Subscription notifier for unit tests.
<span class="lineNum">    4833 </span>            :  *
<span class="lineNum">    4834 </span>            :  * Since unit tests are only concerned with building a resource tree,
<span class="lineNum">    4835 </span>            :  * only the new_subscribe callback needs to be defined.
<span class="lineNum">    4836 </span>            :  */
<span class="lineNum">    4837 </span>            : struct ast_sip_notifier test_notifier = {
<span class="lineNum">    4838 </span>            :         .new_subscribe = test_new_subscribe,
<span class="lineNum">    4839 </span>            : };
<span class="lineNum">    4840 </span>            : 
<span class="lineNum">    4841 </span>            : /*!
<span class="lineNum">    4842 </span>            :  * \brief Subscription handler for unit tests.
<span class="lineNum">    4843 </span>            :  */
<span class="lineNum">    4844 </span>            : struct ast_sip_subscription_handler test_handler = {
<span class="lineNum">    4845 </span>            :         .event_name = &quot;test&quot;,
<span class="lineNum">    4846 </span>            :         .notifier = &amp;test_notifier,
<span class="lineNum">    4847 </span>            : };
<span class="lineNum">    4848 </span>            : 
<span class="lineNum">    4849 </span>            : /*!
<span class="lineNum">    4850 </span>            :  * \brief Set properties on an allocated resource list
<span class="lineNum">    4851 </span>            :  *
<span class="lineNum">    4852 </span>            :  * \param list The list to set details on.
<span class="lineNum">    4853 </span>            :  * \param event The list's event.
<span class="lineNum">    4854 </span>            :  * \param resources Array of resources to add to the list.
<span class="lineNum">    4855 </span>            :  * \param num_resources Number of resources in the array.
<span class="lineNum">    4856 </span>            :  * \retval 0 Success
<a name="4857"><span class="lineNum">    4857 </span>            :  * \retval non-zero Failure</a>
<span class="lineNum">    4858 </span>            :  */
<span class="lineNum">    4859 </span><span class="lineCov">         11 : static int populate_list(struct resource_list *list, const char *event, const char **resources, size_t num_resources)</span>
<span class="lineNum">    4860 </span>            : {
<span class="lineNum">    4861 </span>            :         int i;
<span class="lineNum">    4862 </span>            : 
<span class="lineNum">    4863 </span><span class="lineCov">         11 :         ast_copy_string(list-&gt;event, event, sizeof(list-&gt;event));</span>
<span class="lineNum">    4864 </span>            : 
<span class="lineNum">    4865 </span><span class="lineCov">         52 :         for (i = 0; i &lt; num_resources; ++i) {</span>
<span class="lineNum">    4866 </span><span class="lineCov">         41 :                 char *resource = ast_strdup(resources[i]);</span>
<span class="lineNum">    4867 </span>            : 
<span class="lineNum">    4868 </span><span class="lineCov">         41 :                 if (!resource || AST_VECTOR_APPEND(&amp;list-&gt;items, resource)) {</span>
<span class="lineNum">    4869 </span><span class="lineNoCov">          0 :                         ast_free(resource);</span>
<span class="lineNum">    4870 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    4871 </span>            :                 }
<span class="lineNum">    4872 </span>            :         }
<span class="lineNum">    4873 </span><span class="lineCov">         11 :         return 0;</span>
<span class="lineNum">    4874 </span>            : }
<span class="lineNum">    4875 </span>            : 
<span class="lineNum">    4876 </span>            : /*!
<a name="4877"><span class="lineNum">    4877 </span>            :  * \brief RAII callback to destroy a resource list</a>
<span class="lineNum">    4878 </span>            :  */
<span class="lineNum">    4879 </span><span class="lineCov">       9383 : static void cleanup_resource_list(struct resource_list *list)</span>
<span class="lineNum">    4880 </span>            : {
<span class="lineNum">    4881 </span><span class="lineCov">       9383 :         if (!list) {</span>
<span class="lineNum">    4882 </span><span class="lineCov">       9372 :                 return;</span>
<span class="lineNum">    4883 </span>            :         }
<span class="lineNum">    4884 </span>            : 
<span class="lineNum">    4885 </span><span class="lineCov">         11 :         ast_sorcery_delete(ast_sip_get_sorcery(), list);</span>
<span class="lineNum">    4886 </span><span class="lineCov">         11 :         ao2_cleanup(list);</span>
<span class="lineNum">    4887 </span>            : }
<span class="lineNum">    4888 </span>            : 
<span class="lineNum">    4889 </span>            : /*!
<span class="lineNum">    4890 </span>            :  * \brief allocate a resource list, store it in sorcery, and set its details
<span class="lineNum">    4891 </span>            :  *
<span class="lineNum">    4892 </span>            :  * \param test The unit test. Used for logging status messages.
<span class="lineNum">    4893 </span>            :  * \param list_name The name of the list to create.
<span class="lineNum">    4894 </span>            :  * \param event The event the list services
<span class="lineNum">    4895 </span>            :  * \param resources Array of resources to apply to the list
<span class="lineNum">    4896 </span>            :  * \param num_resources The number of resources in the array
<span class="lineNum">    4897 </span>            :  * \retval NULL Failed to allocate or populate list
<a name="4898"><span class="lineNum">    4898 </span>            :  * \retval non-NULL The created list</a>
<span class="lineNum">    4899 </span>            :  */
<span class="lineNum">    4900 </span><span class="lineCov">         11 : static struct resource_list *create_resource_list(struct ast_test *test,</span>
<span class="lineNum">    4901 </span>            :                 const char *list_name, const char *event, const char **resources, size_t num_resources)
<span class="lineNum">    4902 </span>            : {
<span class="lineNum">    4903 </span>            :         struct resource_list *list;
<span class="lineNum">    4904 </span>            : 
<span class="lineNum">    4905 </span><span class="lineCov">         11 :         list = ast_sorcery_alloc(ast_sip_get_sorcery(), &quot;resource_list&quot;, list_name);</span>
<span class="lineNum">    4906 </span><span class="lineCov">         11 :         if (!list) {</span>
<span class="lineNum">    4907 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Could not allocate resource list in sorcery\n&quot;);</span>
<span class="lineNum">    4908 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    4909 </span>            :         }
<span class="lineNum">    4910 </span>            : 
<span class="lineNum">    4911 </span><span class="lineCov">         11 :         if (ast_sorcery_create(ast_sip_get_sorcery(), list)) {</span>
<span class="lineNum">    4912 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Could not store the resource list in sorcery\n&quot;);</span>
<span class="lineNum">    4913 </span><span class="lineNoCov">          0 :                 ao2_cleanup(list);</span>
<span class="lineNum">    4914 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    4915 </span>            :         }
<span class="lineNum">    4916 </span>            : 
<span class="lineNum">    4917 </span><span class="lineCov">         11 :         if (populate_list(list, event, resources, num_resources)) {</span>
<span class="lineNum">    4918 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Could not add resources to the resource list\n&quot;);</span>
<span class="lineNum">    4919 </span><span class="lineNoCov">          0 :                 cleanup_resource_list(list);</span>
<span class="lineNum">    4920 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    4921 </span>            :         }
<span class="lineNum">    4922 </span>            : 
<span class="lineNum">    4923 </span><span class="lineCov">         11 :         return list;</span>
<span class="lineNum">    4924 </span>            : }
<span class="lineNum">    4925 </span>            : 
<span class="lineNum">    4926 </span>            : /*!
<span class="lineNum">    4927 </span>            :  * \brief Check the integrity of a tree node against a set of resources.
<span class="lineNum">    4928 </span>            :  *
<span class="lineNum">    4929 </span>            :  * The tree node's resources must be in the same order as the resources in
<span class="lineNum">    4930 </span>            :  * the supplied resources array. Because of this constraint, tests can misrepresent
<span class="lineNum">    4931 </span>            :  * the size of the resources array as being smaller than it really is if resources
<span class="lineNum">    4932 </span>            :  * at the end of the array should not be present in the tree node.
<span class="lineNum">    4933 </span>            :  *
<span class="lineNum">    4934 </span>            :  * \param test The unit test. Used for printing status messages.
<span class="lineNum">    4935 </span>            :  * \param node The constructed tree node whose integrity is under question.
<span class="lineNum">    4936 </span>            :  * \param resources Array of expected resource values
<a name="4937"><span class="lineNum">    4937 </span>            :  * \param num_resources The number of resources to check in the array.</a>
<span class="lineNum">    4938 </span>            :  */
<span class="lineNum">    4939 </span><span class="lineCov">          7 : static int check_node(struct ast_test *test, struct tree_node *node,</span>
<span class="lineNum">    4940 </span>            :                 const char **resources, size_t num_resources)
<span class="lineNum">    4941 </span>            : {
<span class="lineNum">    4942 </span>            :         int i;
<span class="lineNum">    4943 </span>            : 
<span class="lineNum">    4944 </span><span class="lineCov">          7 :         if (AST_VECTOR_SIZE(&amp;node-&gt;children) != num_resources) {</span>
<span class="lineNum">    4945 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Unexpected number of resources in tree. Expected %zu, got %zu\n&quot;,</span>
<span class="lineNum">    4946 </span>            :                                 num_resources, AST_VECTOR_SIZE(&amp;node-&gt;children));
<span class="lineNum">    4947 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    4948 </span>            :         }
<span class="lineNum">    4949 </span>            : 
<span class="lineNum">    4950 </span><span class="lineCov">         34 :         for (i = 0; i &lt; num_resources; ++i) {</span>
<span class="lineNum">    4951 </span><span class="lineCov">         27 :                 if (strcmp(resources[i], AST_VECTOR_GET(&amp;node-&gt;children, i)-&gt;resource)) {</span>
<span class="lineNum">    4952 </span><span class="lineNoCov">          0 :                         ast_test_status_update(test, &quot;Mismatched resources. Expected '%s' but got '%s'\n&quot;,</span>
<span class="lineNum">    4953 </span>            :                                         resources[i], AST_VECTOR_GET(&amp;node-&gt;children, i)-&gt;resource);
<span class="lineNum">    4954 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    4955 </span>            :                 }
<span class="lineNum">    4956 </span>            :         }
<span class="lineNum">    4957 </span>            : 
<span class="lineNum">    4958 </span><span class="lineCov">          7 :         return 0;</span>
<span class="lineNum">    4959 </span>            : }
<span class="lineNum">    4960 </span>            : 
<span class="lineNum">    4961 </span>            : /*!
<a name="4962"><span class="lineNum">    4962 </span>            :  * \brief RAII_VAR callback to destroy an allocated resource tree</a>
<span class="lineNum">    4963 </span>            :  */
<span class="lineNum">    4964 </span><span class="lineCov">       5971 : static void test_resource_tree_destroy(struct resource_tree *tree)</span>
<span class="lineNum">    4965 </span>            : {
<span class="lineNum">    4966 </span><span class="lineCov">       5971 :         resource_tree_destroy(tree);</span>
<span class="lineNum">    4967 </span><span class="lineCov">       5971 :         ast_free(tree);</span>
<a name="4968"><span class="lineNum">    4968 </span><span class="lineCov">       5971 : }</span></a>
<span class="lineNum">    4969 </span>            : 
<span class="lineNum">    4970 </span><span class="lineCov">          7 : static int ineligible_configuration(void)</span>
<span class="lineNum">    4971 </span>            : {
<span class="lineNum">    4972 </span>            :         struct ast_config *config;
<span class="lineNum">    4973 </span><span class="lineCov">          7 :         struct ast_flags flags = {0,};</span>
<span class="lineNum">    4974 </span>            :         const char *value;
<span class="lineNum">    4975 </span>            : 
<span class="lineNum">    4976 </span><span class="lineCov">          7 :         config = ast_config_load(&quot;sorcery.conf&quot;, flags);</span>
<span class="lineNum">    4977 </span><span class="lineCov">          7 :         if (!config) {</span>
<span class="lineNum">    4978 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">    4979 </span>            :         }
<span class="lineNum">    4980 </span>            : 
<span class="lineNum">    4981 </span><span class="lineCov">          7 :         value = ast_variable_retrieve(config, &quot;res_pjsip_pubsub&quot;, &quot;resource_list&quot;);</span>
<span class="lineNum">    4982 </span><span class="lineCov">          7 :         if (ast_strlen_zero(value)) {</span>
<span class="lineNum">    4983 </span><span class="lineNoCov">          0 :                 ast_config_destroy(config);</span>
<span class="lineNum">    4984 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">    4985 </span>            :         }
<span class="lineNum">    4986 </span>            : 
<span class="lineNum">    4987 </span><span class="lineCov">          7 :         if (strcasecmp(value, &quot;memory&quot;) &amp;&amp; strcasecmp(value, &quot;astdb&quot;)) {</span>
<span class="lineNum">    4988 </span><span class="lineNoCov">          0 :                 ast_config_destroy(config);</span>
<span class="lineNum">    4989 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">    4990 </span>            :         }
<span class="lineNum">    4991 </span>            : 
<span class="lineNum">    4992 </span><span class="lineCov">          7 :         return 0;</span>
<a name="4993"><span class="lineNum">    4993 </span>            : }</a>
<span class="lineNum">    4994 </span>            : 
<a name="4995"><span class="lineNum">    4995 </span><span class="lineCov">        853 : AST_TEST_DEFINE(resource_tree)</span></a>
<a name="4996"><span class="lineNum">    4996 </span>            : {</a>
<span class="lineNum">    4997 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list, NULL, cleanup_resource_list);</span>
<span class="lineNum">    4998 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_tree *, tree, NULL, test_resource_tree_destroy);</span>
<span class="lineNum">    4999 </span><span class="lineCov">        853 :         const char *resources[] = {</span>
<span class="lineNum">    5000 </span>            :                 &quot;huey&quot;,
<span class="lineNum">    5001 </span>            :                 &quot;dewey&quot;,
<span class="lineNum">    5002 </span>            :                 &quot;louie&quot;,
<span class="lineNum">    5003 </span>            :         };
<span class="lineNum">    5004 </span>            :         int resp;
<span class="lineNum">    5005 </span>            : 
<span class="lineNum">    5006 </span><span class="lineCov">        853 :         switch (cmd) {</span>
<span class="lineNum">    5007 </span><span class="lineCov">        852 :         case TEST_INIT:</span>
<span class="lineNum">    5008 </span><span class="lineCov">        852 :                 info-&gt;name = &quot;resource_tree&quot;;</span>
<span class="lineNum">    5009 </span><span class="lineCov">        852 :                 info-&gt;category = &quot;/res/res_pjsip_pubsub/&quot;;</span>
<span class="lineNum">    5010 </span><span class="lineCov">        852 :                 info-&gt;summary = &quot;Basic resource tree integrity check&quot;;</span>
<span class="lineNum">    5011 </span><span class="lineCov">        852 :                 info-&gt;description =</span>
<span class="lineNum">    5012 </span>            :                         &quot;Create a resource list and ensure that our attempt to build a tree works as expected.&quot;;
<span class="lineNum">    5013 </span><span class="lineCov">        852 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5014 </span><span class="lineCov">          1 :         case TEST_EXECUTE:</span>
<span class="lineNum">    5015 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    5016 </span>            :         }
<span class="lineNum">    5017 </span>            : 
<span class="lineNum">    5018 </span><span class="lineCov">          1 :         if (ineligible_configuration()) {</span>
<span class="lineNum">    5019 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Ineligible configuration for this test. Please add a &quot;</span>
<span class="lineNum">    5020 </span>            :                                 &quot;'res_pjsip_pubsub' section to sorcery.conf, and set 'resource_list=memory'\n&quot;);
<span class="lineNum">    5021 </span><span class="lineNoCov">          0 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5022 </span>            :         }
<span class="lineNum">    5023 </span>            : 
<span class="lineNum">    5024 </span><span class="lineCov">          1 :         list = create_resource_list(test, &quot;foo&quot;, &quot;test&quot;, resources, ARRAY_LEN(resources));</span>
<span class="lineNum">    5025 </span><span class="lineCov">          1 :         if (!list) {</span>
<span class="lineNum">    5026 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5027 </span>            :         }
<span class="lineNum">    5028 </span>            : 
<span class="lineNum">    5029 </span><span class="lineCov">          1 :         tree = ast_calloc(1, sizeof(*tree));</span>
<span class="lineNum">    5030 </span><span class="lineCov">          1 :         resp = build_resource_tree(NULL, &amp;test_handler, &quot;foo&quot;, tree, 1);</span>
<span class="lineNum">    5031 </span><span class="lineCov">          1 :         if (resp != 200) {</span>
<span class="lineNum">    5032 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Unexpected response %d when building resource tree\n&quot;, resp);</span>
<span class="lineNum">    5033 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5034 </span>            :         }
<span class="lineNum">    5035 </span>            : 
<span class="lineNum">    5036 </span><span class="lineCov">          1 :         if (!tree-&gt;root) {</span>
<span class="lineNum">    5037 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Resource tree has no root\n&quot;);</span>
<span class="lineNum">    5038 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5039 </span>            :         }
<span class="lineNum">    5040 </span>            : 
<span class="lineNum">    5041 </span><span class="lineCov">          1 :         if (check_node(test, tree-&gt;root, resources, ARRAY_LEN(resources))) {</span>
<span class="lineNum">    5042 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5043 </span>            :         }
<span class="lineNum">    5044 </span>            : 
<span class="lineNum">    5045 </span><span class="lineCov">          1 :         return AST_TEST_PASS;</span>
<a name="5046"><span class="lineNum">    5046 </span>            : }</a>
<span class="lineNum">    5047 </span>            : 
<a name="5048"><span class="lineNum">    5048 </span><span class="lineCov">        853 : AST_TEST_DEFINE(complex_resource_tree)</span></a>
<a name="5049"><span class="lineNum">    5049 </span>            : {</a>
<a name="5050"><span class="lineNum">    5050 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list_1, NULL, cleanup_resource_list);</span></a>
<span class="lineNum">    5051 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list_2, NULL, cleanup_resource_list);</span>
<span class="lineNum">    5052 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_tree *, tree, NULL, test_resource_tree_destroy);</span>
<span class="lineNum">    5053 </span><span class="lineCov">        853 :         const char *resources_1[] = {</span>
<span class="lineNum">    5054 </span>            :                 &quot;huey&quot;,
<span class="lineNum">    5055 </span>            :                 &quot;dewey&quot;,
<span class="lineNum">    5056 </span>            :                 &quot;louie&quot;,
<span class="lineNum">    5057 </span>            :                 &quot;dwarves&quot;,
<span class="lineNum">    5058 </span>            :         };
<span class="lineNum">    5059 </span><span class="lineCov">        853 :         const char *resources_2[] = {</span>
<span class="lineNum">    5060 </span>            :                 &quot;happy&quot;,
<span class="lineNum">    5061 </span>            :                 &quot;grumpy&quot;,
<span class="lineNum">    5062 </span>            :                 &quot;doc&quot;,
<span class="lineNum">    5063 </span>            :                 &quot;bashful&quot;,
<span class="lineNum">    5064 </span>            :                 &quot;dopey&quot;,
<span class="lineNum">    5065 </span>            :                 &quot;sneezy&quot;,
<span class="lineNum">    5066 </span>            :                 &quot;sleepy&quot;,
<span class="lineNum">    5067 </span>            :         };
<span class="lineNum">    5068 </span>            :         int resp;
<span class="lineNum">    5069 </span>            :         struct tree_node *node;
<span class="lineNum">    5070 </span>            : 
<span class="lineNum">    5071 </span><span class="lineCov">        853 :         switch (cmd) {</span>
<span class="lineNum">    5072 </span><span class="lineCov">        852 :         case TEST_INIT:</span>
<span class="lineNum">    5073 </span><span class="lineCov">        852 :                 info-&gt;name = &quot;complex_resource_tree&quot;;</span>
<span class="lineNum">    5074 </span><span class="lineCov">        852 :                 info-&gt;category = &quot;/res/res_pjsip_pubsub/&quot;;</span>
<span class="lineNum">    5075 </span><span class="lineCov">        852 :                 info-&gt;summary = &quot;Complex resource tree integrity check&quot;;</span>
<span class="lineNum">    5076 </span><span class="lineCov">        852 :                 info-&gt;description =</span>
<span class="lineNum">    5077 </span>            :                         &quot;Create a complex resource list and ensure that our attempt to build a tree works as expected.&quot;;
<span class="lineNum">    5078 </span><span class="lineCov">        852 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5079 </span><span class="lineCov">          1 :         case TEST_EXECUTE:</span>
<span class="lineNum">    5080 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    5081 </span>            :         }
<span class="lineNum">    5082 </span>            : 
<span class="lineNum">    5083 </span><span class="lineCov">          1 :         if (ineligible_configuration()) {</span>
<span class="lineNum">    5084 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Ineligible configuration for this test. Please add a &quot;</span>
<span class="lineNum">    5085 </span>            :                                 &quot;'res_pjsip_pubsub' section to sorcery.conf, and set 'resource_list=memory'\n&quot;);
<span class="lineNum">    5086 </span><span class="lineNoCov">          0 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5087 </span>            :         }
<span class="lineNum">    5088 </span>            : 
<span class="lineNum">    5089 </span><span class="lineCov">          1 :         list_1 = create_resource_list(test, &quot;foo&quot;, &quot;test&quot;, resources_1, ARRAY_LEN(resources_1));</span>
<span class="lineNum">    5090 </span><span class="lineCov">          1 :         if (!list_1) {</span>
<span class="lineNum">    5091 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5092 </span>            :         }
<span class="lineNum">    5093 </span>            : 
<span class="lineNum">    5094 </span><span class="lineCov">          1 :         list_2 = create_resource_list(test, &quot;dwarves&quot;, &quot;test&quot;, resources_2, ARRAY_LEN(resources_2));</span>
<span class="lineNum">    5095 </span><span class="lineCov">          1 :         if (!list_2) {</span>
<span class="lineNum">    5096 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5097 </span>            :         }
<span class="lineNum">    5098 </span>            : 
<span class="lineNum">    5099 </span><span class="lineCov">          1 :         tree = ast_calloc(1, sizeof(*tree));</span>
<span class="lineNum">    5100 </span><span class="lineCov">          1 :         resp = build_resource_tree(NULL, &amp;test_handler, &quot;foo&quot;, tree, 1);</span>
<span class="lineNum">    5101 </span><span class="lineCov">          1 :         if (resp != 200) {</span>
<span class="lineNum">    5102 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Unexpected response %d when building resource tree\n&quot;, resp);</span>
<span class="lineNum">    5103 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5104 </span>            :         }
<span class="lineNum">    5105 </span>            : 
<span class="lineNum">    5106 </span><span class="lineCov">          1 :         if (!tree-&gt;root) {</span>
<span class="lineNum">    5107 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Resource tree has no root\n&quot;);</span>
<span class="lineNum">    5108 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5109 </span>            :         }
<span class="lineNum">    5110 </span>            : 
<span class="lineNum">    5111 </span><span class="lineCov">          1 :         node = tree-&gt;root;</span>
<span class="lineNum">    5112 </span><span class="lineCov">          1 :         if (check_node(test, node, resources_1, ARRAY_LEN(resources_1))) {</span>
<span class="lineNum">    5113 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5114 </span>            :         }
<span class="lineNum">    5115 </span>            : 
<span class="lineNum">    5116 </span>            :         /* The embedded list is at index 3 in the root node's children */
<span class="lineNum">    5117 </span><span class="lineCov">          1 :         node = AST_VECTOR_GET(&amp;node-&gt;children, 3);</span>
<span class="lineNum">    5118 </span><span class="lineCov">          1 :         if (check_node(test, node, resources_2, ARRAY_LEN(resources_2))) {</span>
<span class="lineNum">    5119 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5120 </span>            :         }
<span class="lineNum">    5121 </span>            : 
<span class="lineNum">    5122 </span><span class="lineCov">          1 :         return AST_TEST_PASS;</span>
<a name="5123"><span class="lineNum">    5123 </span>            : }</a>
<span class="lineNum">    5124 </span>            : 
<a name="5125"><span class="lineNum">    5125 </span><span class="lineCov">        853 : AST_TEST_DEFINE(bad_resource)</span></a>
<a name="5126"><span class="lineNum">    5126 </span>            : {</a>
<span class="lineNum">    5127 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list, NULL, cleanup_resource_list);</span>
<span class="lineNum">    5128 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_tree *, tree, NULL, test_resource_tree_destroy);</span>
<span class="lineNum">    5129 </span><span class="lineCov">        853 :         const char *resources[] = {</span>
<span class="lineNum">    5130 </span>            :                 &quot;huey&quot;,
<span class="lineNum">    5131 </span>            :                 &quot;dewey&quot;,
<span class="lineNum">    5132 </span>            :                 &quot;louie&quot;,
<span class="lineNum">    5133 </span>            :                 &quot;coconut&quot;, /* A &quot;bad&quot; resource */
<span class="lineNum">    5134 </span>            :         };
<span class="lineNum">    5135 </span>            :         int resp;
<span class="lineNum">    5136 </span>            : 
<span class="lineNum">    5137 </span><span class="lineCov">        853 :         switch (cmd) {</span>
<span class="lineNum">    5138 </span><span class="lineCov">        852 :         case TEST_INIT:</span>
<span class="lineNum">    5139 </span><span class="lineCov">        852 :                 info-&gt;name = &quot;bad_resource&quot;;</span>
<span class="lineNum">    5140 </span><span class="lineCov">        852 :                 info-&gt;category = &quot;/res/res_pjsip_pubsub/&quot;;</span>
<span class="lineNum">    5141 </span><span class="lineCov">        852 :                 info-&gt;summary = &quot;Ensure bad resources do not end up in the tree&quot;;</span>
<span class="lineNum">    5142 </span><span class="lineCov">        852 :                 info-&gt;description =</span>
<span class="lineNum">    5143 </span>            :                         &quot;Create a resource list with a single bad resource. Ensure the bad resource does not end up in the tree.&quot;;
<span class="lineNum">    5144 </span><span class="lineCov">        852 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5145 </span><span class="lineCov">          1 :         case TEST_EXECUTE:</span>
<span class="lineNum">    5146 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    5147 </span>            :         }
<span class="lineNum">    5148 </span>            : 
<span class="lineNum">    5149 </span><span class="lineCov">          1 :         if (ineligible_configuration()) {</span>
<span class="lineNum">    5150 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Ineligible configuration for this test. Please add a &quot;</span>
<span class="lineNum">    5151 </span>            :                                 &quot;'res_pjsip_pubsub' section to sorcery.conf, and set 'resource_list=memory'\n&quot;);
<span class="lineNum">    5152 </span><span class="lineNoCov">          0 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5153 </span>            :         }
<span class="lineNum">    5154 </span>            : 
<span class="lineNum">    5155 </span><span class="lineCov">          1 :         list = create_resource_list(test, &quot;foo&quot;, &quot;test&quot;, resources, ARRAY_LEN(resources));</span>
<span class="lineNum">    5156 </span><span class="lineCov">          1 :         if (!list) {</span>
<span class="lineNum">    5157 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5158 </span>            :         }
<span class="lineNum">    5159 </span>            : 
<span class="lineNum">    5160 </span><span class="lineCov">          1 :         tree = ast_calloc(1, sizeof(*tree));</span>
<span class="lineNum">    5161 </span><span class="lineCov">          1 :         resp = build_resource_tree(NULL, &amp;test_handler, &quot;foo&quot;, tree, 1);</span>
<span class="lineNum">    5162 </span><span class="lineCov">          1 :         if (resp != 200) {</span>
<span class="lineNum">    5163 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Unexpected response %d when building resource tree\n&quot;, resp);</span>
<span class="lineNum">    5164 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5165 </span>            :         }
<span class="lineNum">    5166 </span>            : 
<span class="lineNum">    5167 </span><span class="lineCov">          1 :         if (!tree-&gt;root) {</span>
<span class="lineNum">    5168 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Resource tree has no root\n&quot;);</span>
<span class="lineNum">    5169 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5170 </span>            :         }
<span class="lineNum">    5171 </span>            : 
<span class="lineNum">    5172 </span>            :         /* We check against all but the final resource since we expect it not to be in the tree */
<span class="lineNum">    5173 </span><span class="lineCov">          1 :         if (check_node(test, tree-&gt;root, resources, ARRAY_LEN(resources) - 1)) {</span>
<span class="lineNum">    5174 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5175 </span>            :         }
<span class="lineNum">    5176 </span>            : 
<span class="lineNum">    5177 </span><span class="lineCov">          1 :         return AST_TEST_PASS;</span>
<span class="lineNum">    5178 </span>            : 
<a name="5179"><span class="lineNum">    5179 </span>            : }</a>
<span class="lineNum">    5180 </span>            : 
<a name="5181"><span class="lineNum">    5181 </span><span class="lineCov">        853 : AST_TEST_DEFINE(bad_branch)</span></a>
<a name="5182"><span class="lineNum">    5182 </span>            : {</a>
<a name="5183"><span class="lineNum">    5183 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list_1, NULL, cleanup_resource_list);</span></a>
<span class="lineNum">    5184 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list_2, NULL, cleanup_resource_list);</span>
<span class="lineNum">    5185 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_tree *, tree, NULL, test_resource_tree_destroy);</span>
<span class="lineNum">    5186 </span><span class="lineCov">        853 :         const char *resources_1[] = {</span>
<span class="lineNum">    5187 </span>            :                 &quot;huey&quot;,
<span class="lineNum">    5188 </span>            :                 &quot;dewey&quot;,
<span class="lineNum">    5189 </span>            :                 &quot;louie&quot;,
<span class="lineNum">    5190 </span>            :                 &quot;gross&quot;,
<span class="lineNum">    5191 </span>            :         };
<span class="lineNum">    5192 </span>            :         /* This list has nothing but bad resources */
<span class="lineNum">    5193 </span><span class="lineCov">        853 :         const char *resources_2[] = {</span>
<span class="lineNum">    5194 </span>            :                 &quot;coconut&quot;,
<span class="lineNum">    5195 </span>            :                 &quot;cilantro&quot;,
<span class="lineNum">    5196 </span>            :                 &quot;olive&quot;,
<span class="lineNum">    5197 </span>            :                 &quot;cheese&quot;,
<span class="lineNum">    5198 </span>            :         };
<span class="lineNum">    5199 </span>            :         int resp;
<span class="lineNum">    5200 </span>            : 
<span class="lineNum">    5201 </span><span class="lineCov">        853 :         switch (cmd) {</span>
<span class="lineNum">    5202 </span><span class="lineCov">        852 :         case TEST_INIT:</span>
<span class="lineNum">    5203 </span><span class="lineCov">        852 :                 info-&gt;name = &quot;bad_branch&quot;;</span>
<span class="lineNum">    5204 </span><span class="lineCov">        852 :                 info-&gt;category = &quot;/res/res_pjsip_pubsub/&quot;;</span>
<span class="lineNum">    5205 </span><span class="lineCov">        852 :                 info-&gt;summary = &quot;Ensure bad branches are pruned from the tree&quot;;</span>
<span class="lineNum">    5206 </span><span class="lineCov">        852 :                 info-&gt;description =</span>
<span class="lineNum">    5207 </span>            :                         &quot;Create a resource list that makes a tree with an entire branch of bad resources.\n&quot;
<span class="lineNum">    5208 </span>            :                         &quot;Ensure the bad branch is pruned from the tree.&quot;;
<span class="lineNum">    5209 </span><span class="lineCov">        852 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5210 </span><span class="lineCov">          1 :         case TEST_EXECUTE:</span>
<span class="lineNum">    5211 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    5212 </span>            :         }
<span class="lineNum">    5213 </span>            : 
<span class="lineNum">    5214 </span><span class="lineCov">          1 :         if (ineligible_configuration()) {</span>
<span class="lineNum">    5215 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Ineligible configuration for this test. Please add a &quot;</span>
<span class="lineNum">    5216 </span>            :                                 &quot;'res_pjsip_pubsub' section to sorcery.conf, and set 'resource_list=memory'\n&quot;);
<span class="lineNum">    5217 </span><span class="lineNoCov">          0 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5218 </span>            :         }
<span class="lineNum">    5219 </span>            : 
<span class="lineNum">    5220 </span><span class="lineCov">          1 :         list_1 = create_resource_list(test, &quot;foo&quot;, &quot;test&quot;, resources_1, ARRAY_LEN(resources_1));</span>
<span class="lineNum">    5221 </span><span class="lineCov">          1 :         if (!list_1) {</span>
<span class="lineNum">    5222 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5223 </span>            :         }
<span class="lineNum">    5224 </span><span class="lineCov">          1 :         list_2 = create_resource_list(test, &quot;gross&quot;, &quot;test&quot;, resources_2, ARRAY_LEN(resources_2));</span>
<span class="lineNum">    5225 </span><span class="lineCov">          1 :         if (!list_2) {</span>
<span class="lineNum">    5226 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5227 </span>            :         }
<span class="lineNum">    5228 </span>            : 
<span class="lineNum">    5229 </span><span class="lineCov">          1 :         tree = ast_calloc(1, sizeof(*tree));</span>
<span class="lineNum">    5230 </span><span class="lineCov">          1 :         resp = build_resource_tree(NULL, &amp;test_handler, &quot;foo&quot;, tree, 1);</span>
<span class="lineNum">    5231 </span><span class="lineCov">          1 :         if (resp != 200) {</span>
<span class="lineNum">    5232 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Unexpected response %d when building resource tree\n&quot;, resp);</span>
<span class="lineNum">    5233 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5234 </span>            :         }
<span class="lineNum">    5235 </span>            : 
<span class="lineNum">    5236 </span><span class="lineCov">          1 :         if (!tree-&gt;root) {</span>
<span class="lineNum">    5237 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Resource tree has no root\n&quot;);</span>
<span class="lineNum">    5238 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5239 </span>            :         }
<span class="lineNum">    5240 </span>            : 
<span class="lineNum">    5241 </span>            :         /* We check against all but the final resource of the list since the entire branch should
<span class="lineNum">    5242 </span>            :          * be pruned from the tree
<span class="lineNum">    5243 </span>            :          */
<span class="lineNum">    5244 </span><span class="lineCov">          1 :         if (check_node(test, tree-&gt;root, resources_1, ARRAY_LEN(resources_1) - 1)) {</span>
<span class="lineNum">    5245 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5246 </span>            :         }
<span class="lineNum">    5247 </span>            : 
<span class="lineNum">    5248 </span><span class="lineCov">          1 :         return AST_TEST_PASS;</span>
<span class="lineNum">    5249 </span>            : 
<a name="5250"><span class="lineNum">    5250 </span>            : }</a>
<span class="lineNum">    5251 </span>            : 
<a name="5252"><span class="lineNum">    5252 </span><span class="lineCov">        853 : AST_TEST_DEFINE(duplicate_resource)</span></a>
<a name="5253"><span class="lineNum">    5253 </span>            : {</a>
<a name="5254"><span class="lineNum">    5254 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list_1, NULL, cleanup_resource_list);</span></a>
<span class="lineNum">    5255 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list_2, NULL, cleanup_resource_list);</span>
<span class="lineNum">    5256 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_tree *, tree, NULL, test_resource_tree_destroy);</span>
<span class="lineNum">    5257 </span><span class="lineCov">        853 :         const char *resources_1[] = {</span>
<span class="lineNum">    5258 </span>            :                 &quot;huey&quot;,
<span class="lineNum">    5259 </span>            :                 &quot;ducks&quot;,
<span class="lineNum">    5260 </span>            :                 &quot;dewey&quot;,
<span class="lineNum">    5261 </span>            :                 &quot;louie&quot;,
<span class="lineNum">    5262 </span>            :         };
<span class="lineNum">    5263 </span><span class="lineCov">        853 :         const char *resources_2[] = {</span>
<span class="lineNum">    5264 </span>            :                 &quot;donald&quot;,
<span class="lineNum">    5265 </span>            :                 &quot;daisy&quot;,
<span class="lineNum">    5266 </span>            :                 &quot;scrooge&quot;,
<span class="lineNum">    5267 </span>            :                 &quot;dewey&quot;,
<span class="lineNum">    5268 </span>            :                 &quot;louie&quot;,
<span class="lineNum">    5269 </span>            :                 &quot;huey&quot;,
<span class="lineNum">    5270 </span>            :         };
<span class="lineNum">    5271 </span>            :         int resp;
<span class="lineNum">    5272 </span>            :         struct tree_node *node;
<span class="lineNum">    5273 </span>            : 
<span class="lineNum">    5274 </span><span class="lineCov">        853 :         switch (cmd) {</span>
<span class="lineNum">    5275 </span><span class="lineCov">        852 :         case TEST_INIT:</span>
<span class="lineNum">    5276 </span><span class="lineCov">        852 :                 info-&gt;name = &quot;duplicate_resource&quot;;</span>
<span class="lineNum">    5277 </span><span class="lineCov">        852 :                 info-&gt;category = &quot;/res/res_pjsip_pubsub/&quot;;</span>
<span class="lineNum">    5278 </span><span class="lineCov">        852 :                 info-&gt;summary = &quot;Ensure duplicated resources do not end up in the tree&quot;;</span>
<span class="lineNum">    5279 </span><span class="lineCov">        852 :                 info-&gt;description =</span>
<span class="lineNum">    5280 </span>            :                         &quot;Create a resource list with a single duplicated resource. Ensure the duplicated resource does not end up in the tree.&quot;;
<span class="lineNum">    5281 </span><span class="lineCov">        852 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5282 </span><span class="lineCov">          1 :         case TEST_EXECUTE:</span>
<span class="lineNum">    5283 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    5284 </span>            :         }
<span class="lineNum">    5285 </span>            : 
<span class="lineNum">    5286 </span><span class="lineCov">          1 :         if (ineligible_configuration()) {</span>
<span class="lineNum">    5287 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Ineligible configuration for this test. Please add a &quot;</span>
<span class="lineNum">    5288 </span>            :                                 &quot;'res_pjsip_pubsub' section to sorcery.conf, and set 'resource_list=memory'\n&quot;);
<span class="lineNum">    5289 </span><span class="lineNoCov">          0 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5290 </span>            :         }
<span class="lineNum">    5291 </span>            : 
<span class="lineNum">    5292 </span><span class="lineCov">          1 :         list_1 = create_resource_list(test, &quot;foo&quot;, &quot;test&quot;, resources_1, ARRAY_LEN(resources_1));</span>
<span class="lineNum">    5293 </span><span class="lineCov">          1 :         if (!list_1) {</span>
<span class="lineNum">    5294 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5295 </span>            :         }
<span class="lineNum">    5296 </span>            : 
<span class="lineNum">    5297 </span><span class="lineCov">          1 :         list_2 = create_resource_list(test, &quot;ducks&quot;, &quot;test&quot;, resources_2, ARRAY_LEN(resources_2));</span>
<span class="lineNum">    5298 </span><span class="lineCov">          1 :         if (!list_2) {</span>
<span class="lineNum">    5299 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5300 </span>            :         }
<span class="lineNum">    5301 </span>            : 
<span class="lineNum">    5302 </span><span class="lineCov">          1 :         tree = ast_calloc(1, sizeof(*tree));</span>
<span class="lineNum">    5303 </span><span class="lineCov">          1 :         resp = build_resource_tree(NULL, &amp;test_handler, &quot;foo&quot;, tree, 1);</span>
<span class="lineNum">    5304 </span><span class="lineCov">          1 :         if (resp != 200) {</span>
<span class="lineNum">    5305 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Unexpected response %d when building resource tree\n&quot;, resp);</span>
<span class="lineNum">    5306 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5307 </span>            :         }
<span class="lineNum">    5308 </span>            : 
<span class="lineNum">    5309 </span><span class="lineCov">          1 :         if (!tree-&gt;root) {</span>
<span class="lineNum">    5310 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Resource tree has no root\n&quot;);</span>
<span class="lineNum">    5311 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5312 </span>            :         }
<span class="lineNum">    5313 </span>            : 
<span class="lineNum">    5314 </span><span class="lineCov">          1 :         node = tree-&gt;root;</span>
<span class="lineNum">    5315 </span>            :         /* This node should have &quot;huey&quot; and &quot;ducks&quot;. &quot;dewey&quot; and &quot;louie&quot; should not
<span class="lineNum">    5316 </span>            :          * be present since they were found in the &quot;ducks&quot; list.
<span class="lineNum">    5317 </span>            :          */
<span class="lineNum">    5318 </span><span class="lineCov">          1 :         if (check_node(test, node, resources_1, ARRAY_LEN(resources_1) - 2)) {</span>
<span class="lineNum">    5319 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5320 </span>            :         }
<span class="lineNum">    5321 </span>            : 
<span class="lineNum">    5322 </span>            :         /* This node should have &quot;donald&quot;, &quot;daisy&quot;, &quot;scrooge&quot;, &quot;dewey&quot;, and &quot;louie&quot;.
<span class="lineNum">    5323 </span>            :          * &quot;huey&quot; is not here since that was already encountered in the parent list
<span class="lineNum">    5324 </span>            :          */
<span class="lineNum">    5325 </span><span class="lineCov">          1 :         node = AST_VECTOR_GET(&amp;node-&gt;children, 1);</span>
<span class="lineNum">    5326 </span><span class="lineCov">          1 :         if (check_node(test, node, resources_2, ARRAY_LEN(resources_2) - 1)) {</span>
<span class="lineNum">    5327 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5328 </span>            :         }
<span class="lineNum">    5329 </span>            : 
<span class="lineNum">    5330 </span><span class="lineCov">          1 :         return AST_TEST_PASS;</span>
<a name="5331"><span class="lineNum">    5331 </span>            : }</a>
<span class="lineNum">    5332 </span>            : 
<a name="5333"><span class="lineNum">    5333 </span><span class="lineCov">        853 : AST_TEST_DEFINE(loop)</span></a>
<a name="5334"><span class="lineNum">    5334 </span>            : {</a>
<a name="5335"><span class="lineNum">    5335 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list_1, NULL, cleanup_resource_list);</span></a>
<span class="lineNum">    5336 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list_2, NULL, cleanup_resource_list);</span>
<span class="lineNum">    5337 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_tree *, tree, NULL, test_resource_tree_destroy);</span>
<span class="lineNum">    5338 </span><span class="lineCov">        853 :         const char *resources_1[] = {</span>
<span class="lineNum">    5339 </span>            :                 &quot;derp&quot;,
<span class="lineNum">    5340 </span>            :         };
<span class="lineNum">    5341 </span><span class="lineCov">        853 :         const char *resources_2[] = {</span>
<span class="lineNum">    5342 </span>            :                 &quot;herp&quot;,
<span class="lineNum">    5343 </span>            :         };
<span class="lineNum">    5344 </span>            :         int resp;
<span class="lineNum">    5345 </span>            : 
<span class="lineNum">    5346 </span><span class="lineCov">        853 :         switch (cmd) {</span>
<span class="lineNum">    5347 </span><span class="lineCov">        852 :         case TEST_INIT:</span>
<span class="lineNum">    5348 </span><span class="lineCov">        852 :                 info-&gt;name = &quot;loop&quot;;</span>
<span class="lineNum">    5349 </span><span class="lineCov">        852 :                 info-&gt;category = &quot;/res/res_pjsip_pubsub/&quot;;</span>
<span class="lineNum">    5350 </span><span class="lineCov">        852 :                 info-&gt;summary = &quot;Test that loops are properly detected.&quot;;</span>
<span class="lineNum">    5351 </span><span class="lineCov">        852 :                 info-&gt;description =</span>
<span class="lineNum">    5352 </span>            :                         &quot;Create two resource lists that refer to each other. Ensure that attempting to build a tree\n&quot;
<span class="lineNum">    5353 </span>            :                         &quot;results in an empty tree.&quot;;
<span class="lineNum">    5354 </span><span class="lineCov">        852 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5355 </span><span class="lineCov">          1 :         case TEST_EXECUTE:</span>
<span class="lineNum">    5356 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    5357 </span>            :         }
<span class="lineNum">    5358 </span>            : 
<span class="lineNum">    5359 </span><span class="lineCov">          1 :         if (ineligible_configuration()) {</span>
<span class="lineNum">    5360 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Ineligible configuration for this test. Please add a &quot;</span>
<span class="lineNum">    5361 </span>            :                                 &quot;'res_pjsip_pubsub' section to sorcery.conf, and set 'resource_list=memory'\n&quot;);
<span class="lineNum">    5362 </span><span class="lineNoCov">          0 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5363 </span>            :         }
<span class="lineNum">    5364 </span>            : 
<span class="lineNum">    5365 </span><span class="lineCov">          1 :         list_1 = create_resource_list(test, &quot;herp&quot;, &quot;test&quot;, resources_1, ARRAY_LEN(resources_1));</span>
<span class="lineNum">    5366 </span><span class="lineCov">          1 :         if (!list_1) {</span>
<span class="lineNum">    5367 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5368 </span>            :         }
<span class="lineNum">    5369 </span><span class="lineCov">          1 :         list_2 = create_resource_list(test, &quot;derp&quot;, &quot;test&quot;, resources_2, ARRAY_LEN(resources_2));</span>
<span class="lineNum">    5370 </span><span class="lineCov">          1 :         if (!list_2) {</span>
<span class="lineNum">    5371 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5372 </span>            :         }
<span class="lineNum">    5373 </span>            : 
<span class="lineNum">    5374 </span><span class="lineCov">          1 :         tree = ast_calloc(1, sizeof(*tree));</span>
<span class="lineNum">    5375 </span><span class="lineCov">          1 :         resp = build_resource_tree(NULL, &amp;test_handler, &quot;herp&quot;, tree, 1);</span>
<span class="lineNum">    5376 </span><span class="lineCov">          1 :         if (resp == 200) {</span>
<span class="lineNum">    5377 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Unexpected response %d when building resource tree\n&quot;, resp);</span>
<span class="lineNum">    5378 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5379 </span>            :         }
<span class="lineNum">    5380 </span>            : 
<span class="lineNum">    5381 </span><span class="lineCov">          1 :         return AST_TEST_PASS;</span>
<a name="5382"><span class="lineNum">    5382 </span>            : }</a>
<span class="lineNum">    5383 </span>            : 
<a name="5384"><span class="lineNum">    5384 </span><span class="lineCov">        853 : AST_TEST_DEFINE(bad_event)</span></a>
<a name="5385"><span class="lineNum">    5385 </span>            : {</a>
<span class="lineNum">    5386 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_list *, list, NULL, cleanup_resource_list);</span>
<span class="lineNum">    5387 </span><span class="lineCov">       1706 :         RAII_VAR(struct resource_tree *, tree, NULL, test_resource_tree_destroy);</span>
<span class="lineNum">    5388 </span><span class="lineCov">        853 :         const char *resources[] = {</span>
<span class="lineNum">    5389 </span>            :                 &quot;huey&quot;,
<span class="lineNum">    5390 </span>            :                 &quot;dewey&quot;,
<span class="lineNum">    5391 </span>            :                 &quot;louie&quot;,
<span class="lineNum">    5392 </span>            :         };
<span class="lineNum">    5393 </span>            :         int resp;
<span class="lineNum">    5394 </span>            : 
<span class="lineNum">    5395 </span><span class="lineCov">        853 :         switch (cmd) {</span>
<span class="lineNum">    5396 </span><span class="lineCov">        852 :         case TEST_INIT:</span>
<span class="lineNum">    5397 </span><span class="lineCov">        852 :                 info-&gt;name = &quot;bad_event&quot;;</span>
<span class="lineNum">    5398 </span><span class="lineCov">        852 :                 info-&gt;category = &quot;/res/res_pjsip_pubsub/&quot;;</span>
<span class="lineNum">    5399 </span><span class="lineCov">        852 :                 info-&gt;summary = &quot;Ensure that list with wrong event specified is not retrieved&quot;;</span>
<span class="lineNum">    5400 </span><span class="lineCov">        852 :                 info-&gt;description =</span>
<span class="lineNum">    5401 </span>            :                         &quot;Create a simple resource list for event 'tsetse'. Ensure that trying to retrieve the list for event 'test' fails.&quot;;
<span class="lineNum">    5402 </span><span class="lineCov">        852 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5403 </span><span class="lineCov">          1 :         case TEST_EXECUTE:</span>
<span class="lineNum">    5404 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    5405 </span>            :         }
<span class="lineNum">    5406 </span>            : 
<span class="lineNum">    5407 </span><span class="lineCov">          1 :         if (ineligible_configuration()) {</span>
<span class="lineNum">    5408 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Ineligible configuration for this test. Please add a &quot;</span>
<span class="lineNum">    5409 </span>            :                                 &quot;'res_pjsip_pubsub' section to sorcery.conf, and set 'resource_list=memory'\n&quot;);
<span class="lineNum">    5410 </span><span class="lineNoCov">          0 :                 return AST_TEST_NOT_RUN;</span>
<span class="lineNum">    5411 </span>            :         }
<span class="lineNum">    5412 </span>            : 
<span class="lineNum">    5413 </span><span class="lineCov">          1 :         list = create_resource_list(test, &quot;foo&quot;, &quot;tsetse&quot;, resources, ARRAY_LEN(resources));</span>
<span class="lineNum">    5414 </span><span class="lineCov">          1 :         if (!list) {</span>
<span class="lineNum">    5415 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5416 </span>            :         }
<span class="lineNum">    5417 </span>            : 
<span class="lineNum">    5418 </span><span class="lineCov">          1 :         tree = ast_calloc(1, sizeof(*tree));</span>
<span class="lineNum">    5419 </span>            :         /* Since the test_handler is for event &quot;test&quot;, this should not build a list, but
<span class="lineNum">    5420 </span>            :          * instead result in a single resource being created, called &quot;foo&quot;
<span class="lineNum">    5421 </span>            :          */
<span class="lineNum">    5422 </span><span class="lineCov">          1 :         resp = build_resource_tree(NULL, &amp;test_handler, &quot;foo&quot;, tree, 1);</span>
<span class="lineNum">    5423 </span><span class="lineCov">          1 :         if (resp != 200) {</span>
<span class="lineNum">    5424 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Unexpected response %d when building resource tree\n&quot;, resp);</span>
<span class="lineNum">    5425 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5426 </span>            :         }
<span class="lineNum">    5427 </span>            : 
<span class="lineNum">    5428 </span><span class="lineCov">          1 :         if (!tree-&gt;root) {</span>
<span class="lineNum">    5429 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Resource tree has no root\n&quot;);</span>
<span class="lineNum">    5430 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5431 </span>            :         }
<span class="lineNum">    5432 </span>            : 
<span class="lineNum">    5433 </span><span class="lineCov">          1 :         if (strcmp(tree-&gt;root-&gt;resource, &quot;foo&quot;)) {</span>
<span class="lineNum">    5434 </span><span class="lineNoCov">          0 :                 ast_test_status_update(test, &quot;Unexpected resource %s found in tree\n&quot;, tree-&gt;root-&gt;resource);</span>
<span class="lineNum">    5435 </span><span class="lineNoCov">          0 :                 return AST_TEST_FAIL;</span>
<span class="lineNum">    5436 </span>            :         }
<span class="lineNum">    5437 </span>            : 
<span class="lineNum">    5438 </span><span class="lineCov">          1 :         return AST_TEST_PASS;</span>
<span class="lineNum">    5439 </span>            : }
<span class="lineNum">    5440 </span>            : 
<a name="5441"><span class="lineNum">    5441 </span>            : #endif</a>
<span class="lineNum">    5442 </span>            : 
<span class="lineNum">    5443 </span><span class="lineNoCov">          0 : static int resource_endpoint_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)</span>
<span class="lineNum">    5444 </span>            : {
<span class="lineNum">    5445 </span><span class="lineNoCov">          0 :         struct ast_sip_publication_resource *resource = obj;</span>
<span class="lineNum">    5446 </span>            : 
<span class="lineNum">    5447 </span><span class="lineNoCov">          0 :         ast_free(resource-&gt;endpoint);</span>
<span class="lineNum">    5448 </span><span class="lineNoCov">          0 :         resource-&gt;endpoint = ast_strdup(var-&gt;value);</span>
<span class="lineNum">    5449 </span>            : 
<span class="lineNum">    5450 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="5451"><span class="lineNum">    5451 </span>            : }</a>
<span class="lineNum">    5452 </span>            : 
<span class="lineNum">    5453 </span><span class="lineCov">          2 : static int resource_event_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)</span>
<span class="lineNum">    5454 </span>            : {
<span class="lineNum">    5455 </span><span class="lineCov">          2 :         struct ast_sip_publication_resource *resource = obj;</span>
<span class="lineNum">    5456 </span>            :         /* The event configuration name starts with 'event_' so skip past it to get the real name */
<span class="lineNum">    5457 </span><span class="lineCov">          2 :         const char *event = var-&gt;name + 6;</span>
<span class="lineNum">    5458 </span>            :         struct ast_variable *item;
<span class="lineNum">    5459 </span>            : 
<span class="lineNum">    5460 </span><span class="lineCov">          2 :         if (ast_strlen_zero(event) || ast_strlen_zero(var-&gt;value)) {</span>
<span class="lineNum">    5461 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    5462 </span>            :         }
<span class="lineNum">    5463 </span>            : 
<span class="lineNum">    5464 </span><span class="lineCov">          2 :         item = ast_variable_new(event, var-&gt;value, &quot;&quot;);</span>
<span class="lineNum">    5465 </span><span class="lineCov">          2 :         if (!item) {</span>
<span class="lineNum">    5466 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    5467 </span>            :         }
<span class="lineNum">    5468 </span>            : 
<span class="lineNum">    5469 </span><span class="lineCov">          2 :         if (resource-&gt;events) {</span>
<span class="lineNum">    5470 </span><span class="lineNoCov">          0 :                 item-&gt;next = resource-&gt;events;</span>
<span class="lineNum">    5471 </span>            :         }
<span class="lineNum">    5472 </span><span class="lineCov">          2 :         resource-&gt;events = item;</span>
<span class="lineNum">    5473 </span>            : 
<span class="lineNum">    5474 </span><span class="lineCov">          2 :         return 0;</span>
<a name="5475"><span class="lineNum">    5475 </span>            : }</a>
<span class="lineNum">    5476 </span>            : 
<span class="lineNum">    5477 </span><span class="lineCov">        852 : static int load_module(void)</span>
<span class="lineNum">    5478 </span>            : {
<span class="lineNum">    5479 </span>            :         static const pj_str_t str_PUBLISH = { &quot;PUBLISH&quot;, 7 };
<span class="lineNum">    5480 </span>            :         struct ast_sorcery *sorcery;
<span class="lineNum">    5481 </span>            : 
<span class="lineNum">    5482 </span><span class="lineCov">        852 :         sorcery = ast_sip_get_sorcery();</span>
<span class="lineNum">    5483 </span>            : 
<span class="lineNum">    5484 </span><span class="lineCov">        852 :         if (!(sched = ast_sched_context_create())) {</span>
<span class="lineNum">    5485 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Could not create scheduler for publication expiration\n&quot;);</span>
<span class="lineNum">    5486 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    5487 </span>            :         }
<span class="lineNum">    5488 </span>            : 
<span class="lineNum">    5489 </span><span class="lineCov">        852 :         if (ast_sched_start_thread(sched)) {</span>
<span class="lineNum">    5490 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Could not start scheduler thread for publication expiration\n&quot;);</span>
<span class="lineNum">    5491 </span><span class="lineNoCov">          0 :                 ast_sched_context_destroy(sched);</span>
<span class="lineNum">    5492 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    5493 </span>            :         }
<span class="lineNum">    5494 </span>            : 
<span class="lineNum">    5495 </span><span class="lineCov">        852 :         ast_sorcery_apply_config(sorcery, &quot;res_pjsip_pubsub&quot;);</span>
<span class="lineNum">    5496 </span><span class="lineCov">        852 :         ast_sorcery_apply_default(sorcery, &quot;subscription_persistence&quot;, &quot;astdb&quot;, &quot;subscription_persistence&quot;);</span>
<span class="lineNum">    5497 </span><span class="lineCov">        852 :         if (ast_sorcery_object_register(sorcery, &quot;subscription_persistence&quot;, subscription_persistence_alloc,</span>
<span class="lineNum">    5498 </span>            :                 NULL, NULL)) {
<span class="lineNum">    5499 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Could not register subscription persistence object support\n&quot;);</span>
<span class="lineNum">    5500 </span><span class="lineNoCov">          0 :                 ast_sched_context_destroy(sched);</span>
<span class="lineNum">    5501 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    5502 </span>            :         }
<span class="lineNum">    5503 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;subscription_persistence&quot;, &quot;packet&quot;, &quot;&quot;, OPT_CHAR_ARRAY_T, 0,</span>
<span class="lineNum">    5504 </span>            :                 CHARFLDSET(struct subscription_persistence, packet));
<span class="lineNum">    5505 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;subscription_persistence&quot;, &quot;src_name&quot;, &quot;&quot;, OPT_CHAR_ARRAY_T, 0,</span>
<span class="lineNum">    5506 </span>            :                 CHARFLDSET(struct subscription_persistence, src_name));
<span class="lineNum">    5507 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;subscription_persistence&quot;, &quot;src_port&quot;, &quot;0&quot;, OPT_UINT_T, 0,</span>
<span class="lineNum">    5508 </span>            :                 FLDSET(struct subscription_persistence, src_port));
<span class="lineNum">    5509 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;subscription_persistence&quot;, &quot;transport_key&quot;, &quot;0&quot;, OPT_CHAR_ARRAY_T, 0,</span>
<span class="lineNum">    5510 </span>            :                 CHARFLDSET(struct subscription_persistence, transport_key));
<span class="lineNum">    5511 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;subscription_persistence&quot;, &quot;local_name&quot;, &quot;&quot;, OPT_CHAR_ARRAY_T, 0,</span>
<span class="lineNum">    5512 </span>            :                 CHARFLDSET(struct subscription_persistence, local_name));
<span class="lineNum">    5513 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;subscription_persistence&quot;, &quot;local_port&quot;, &quot;0&quot;, OPT_UINT_T, 0,</span>
<span class="lineNum">    5514 </span>            :                 FLDSET(struct subscription_persistence, local_port));
<span class="lineNum">    5515 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;subscription_persistence&quot;, &quot;cseq&quot;, &quot;0&quot;, OPT_UINT_T, 0,</span>
<span class="lineNum">    5516 </span>            :                 FLDSET(struct subscription_persistence, cseq));
<span class="lineNum">    5517 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register_custom(sorcery, &quot;subscription_persistence&quot;, &quot;endpoint&quot;, &quot;&quot;,</span>
<span class="lineNum">    5518 </span>            :                 persistence_endpoint_str2struct, persistence_endpoint_struct2str, NULL, 0, 0);
<span class="lineNum">    5519 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register_custom(sorcery, &quot;subscription_persistence&quot;, &quot;tag&quot;, &quot;&quot;,</span>
<span class="lineNum">    5520 </span>            :                 persistence_tag_str2struct, persistence_tag_struct2str, NULL, 0, 0);
<span class="lineNum">    5521 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register_custom(sorcery, &quot;subscription_persistence&quot;, &quot;expires&quot;, &quot;&quot;,</span>
<span class="lineNum">    5522 </span>            :                 persistence_expires_str2struct, persistence_expires_struct2str, NULL, 0, 0);
<span class="lineNum">    5523 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;subscription_persistence&quot;, &quot;contact_uri&quot;, &quot;&quot;, OPT_CHAR_ARRAY_T, 0,</span>
<span class="lineNum">    5524 </span>            :                 CHARFLDSET(struct subscription_persistence, contact_uri));
<span class="lineNum">    5525 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;subscription_persistence&quot;, &quot;prune_on_boot&quot;, &quot;0&quot;, OPT_UINT_T, 0,</span>
<span class="lineNum">    5526 </span>            :                 FLDSET(struct subscription_persistence, prune_on_boot));
<span class="lineNum">    5527 </span>            : 
<span class="lineNum">    5528 </span><span class="lineCov">        852 :         if (apply_list_configuration(sorcery)) {</span>
<span class="lineNum">    5529 </span><span class="lineNoCov">          0 :                 ast_sched_context_destroy(sched);</span>
<span class="lineNum">    5530 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    5531 </span>            :         }
<span class="lineNum">    5532 </span>            : 
<span class="lineNum">    5533 </span><span class="lineCov">        852 :         ast_sorcery_apply_default(sorcery, &quot;inbound-publication&quot;, &quot;config&quot;, &quot;pjsip.conf,criteria=type=inbound-publication&quot;);</span>
<span class="lineNum">    5534 </span><span class="lineCov">        852 :         if (ast_sorcery_object_register(sorcery, &quot;inbound-publication&quot;, publication_resource_alloc,</span>
<span class="lineNum">    5535 </span>            :                 NULL, NULL)) {
<span class="lineNum">    5536 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Could not register subscription persistence object support\n&quot;);</span>
<span class="lineNum">    5537 </span><span class="lineNoCov">          0 :                 ast_sched_context_destroy(sched);</span>
<span class="lineNum">    5538 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    5539 </span>            :         }
<span class="lineNum">    5540 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register(sorcery, &quot;inbound-publication&quot;, &quot;type&quot;, &quot;&quot;, OPT_NOOP_T, 0, 0);</span>
<span class="lineNum">    5541 </span><span class="lineCov">        852 :         ast_sorcery_object_field_register_custom(sorcery, &quot;inbound-publication&quot;, &quot;endpoint&quot;, &quot;&quot;,</span>
<span class="lineNum">    5542 </span>            :                 resource_endpoint_handler, NULL, NULL, 0, 0);
<span class="lineNum">    5543 </span><span class="lineCov">        852 :         ast_sorcery_object_fields_register(sorcery, &quot;inbound-publication&quot;, &quot;^event_&quot;, resource_event_handler, NULL);</span>
<span class="lineNum">    5544 </span><span class="lineCov">        852 :         ast_sorcery_reload_object(sorcery, &quot;inbound-publication&quot;);</span>
<span class="lineNum">    5545 </span>            : 
<span class="lineNum">    5546 </span><span class="lineCov">        852 :         if (ast_sip_register_service(&amp;pubsub_module)) {</span>
<span class="lineNum">    5547 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Could not register pubsub service\n&quot;);</span>
<span class="lineNum">    5548 </span><span class="lineNoCov">          0 :                 ast_sched_context_destroy(sched);</span>
<span class="lineNum">    5549 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    5550 </span>            :         }
<span class="lineNum">    5551 </span>            : 
<span class="lineNum">    5552 </span><span class="lineCov">        852 :         if (pjsip_evsub_init_module(ast_sip_get_pjsip_endpoint()) != PJ_SUCCESS) {</span>
<span class="lineNum">    5553 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Could not initialize pjsip evsub module.\n&quot;);</span>
<span class="lineNum">    5554 </span><span class="lineNoCov">          0 :                 ast_sip_unregister_service(&amp;pubsub_module);</span>
<span class="lineNum">    5555 </span><span class="lineNoCov">          0 :                 ast_sched_context_destroy(sched);</span>
<span class="lineNum">    5556 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    5557 </span>            :         }
<span class="lineNum">    5558 </span>            : 
<span class="lineNum">    5559 </span>            :         /* Once pjsip_evsub_init_module succeeds we cannot unload.
<span class="lineNum">    5560 </span>            :          * Keep all module_load errors above this point. */
<span class="lineNum">    5561 </span><span class="lineCov">        852 :         ast_module_shutdown_ref(ast_module_info-&gt;self);</span>
<span class="lineNum">    5562 </span>            : 
<span class="lineNum">    5563 </span><span class="lineCov">        852 :         pjsip_media_type_init2(&amp;rlmi_media_type, &quot;application&quot;, &quot;rlmi+xml&quot;);</span>
<span class="lineNum">    5564 </span>            : 
<span class="lineNum">    5565 </span><span class="lineCov">        852 :         pjsip_endpt_add_capability(ast_sip_get_pjsip_endpoint(), NULL, PJSIP_H_ALLOW, NULL, 1, &amp;str_PUBLISH);</span>
<span class="lineNum">    5566 </span>            : 
<span class="lineNum">    5567 </span><span class="lineCov">        852 :         if (ast_test_flag(&amp;ast_options, AST_OPT_FLAG_FULLY_BOOTED)) {</span>
<span class="lineNum">    5568 </span><span class="lineNoCov">          0 :                 ast_sip_push_task(NULL, subscription_persistence_load, NULL);</span>
<span class="lineNum">    5569 </span>            :         } else {
<span class="lineNum">    5570 </span><span class="lineCov">        852 :                 stasis_subscribe_pool(ast_manager_get_topic(), subscription_persistence_event_cb, NULL);</span>
<span class="lineNum">    5571 </span>            :         }
<span class="lineNum">    5572 </span>            : 
<span class="lineNum">    5573 </span><span class="lineCov">        852 :         ast_manager_register_xml(AMI_SHOW_SUBSCRIPTIONS_INBOUND, EVENT_FLAG_SYSTEM,</span>
<span class="lineNum">    5574 </span>            :                                  ami_show_subscriptions_inbound);
<span class="lineNum">    5575 </span><span class="lineCov">        852 :         ast_manager_register_xml(AMI_SHOW_SUBSCRIPTIONS_OUTBOUND, EVENT_FLAG_SYSTEM,</span>
<span class="lineNum">    5576 </span>            :                                  ami_show_subscriptions_outbound);
<span class="lineNum">    5577 </span><span class="lineCov">        852 :         ast_manager_register_xml(&quot;PJSIPShowResourceLists&quot;, EVENT_FLAG_SYSTEM,</span>
<span class="lineNum">    5578 </span>            :                         ami_show_resource_lists);
<span class="lineNum">    5579 </span>            : 
<span class="lineNum">    5580 </span><span class="lineCov">        852 :         ast_cli_register_multiple(cli_commands, ARRAY_LEN(cli_commands));</span>
<span class="lineNum">    5581 </span>            : 
<span class="lineNum">    5582 </span><span class="lineCov">        852 :         AST_TEST_REGISTER(resource_tree);</span>
<span class="lineNum">    5583 </span><span class="lineCov">        852 :         AST_TEST_REGISTER(complex_resource_tree);</span>
<span class="lineNum">    5584 </span><span class="lineCov">        852 :         AST_TEST_REGISTER(bad_resource);</span>
<span class="lineNum">    5585 </span><span class="lineCov">        852 :         AST_TEST_REGISTER(bad_branch);</span>
<span class="lineNum">    5586 </span><span class="lineCov">        852 :         AST_TEST_REGISTER(duplicate_resource);</span>
<span class="lineNum">    5587 </span><span class="lineCov">        852 :         AST_TEST_REGISTER(loop);</span>
<span class="lineNum">    5588 </span><span class="lineCov">        852 :         AST_TEST_REGISTER(bad_event);</span>
<span class="lineNum">    5589 </span>            : 
<span class="lineNum">    5590 </span><span class="lineCov">        852 :         return AST_MODULE_LOAD_SUCCESS;</span>
<a name="5591"><span class="lineNum">    5591 </span>            : }</a>
<span class="lineNum">    5592 </span>            : 
<span class="lineNum">    5593 </span><span class="lineCov">        786 : static int unload_module(void)</span>
<span class="lineNum">    5594 </span>            : {
<span class="lineNum">    5595 </span><span class="lineCov">        786 :         AST_TEST_UNREGISTER(resource_tree);</span>
<span class="lineNum">    5596 </span><span class="lineCov">        786 :         AST_TEST_UNREGISTER(complex_resource_tree);</span>
<span class="lineNum">    5597 </span><span class="lineCov">        786 :         AST_TEST_UNREGISTER(bad_resource);</span>
<span class="lineNum">    5598 </span><span class="lineCov">        786 :         AST_TEST_UNREGISTER(bad_branch);</span>
<span class="lineNum">    5599 </span><span class="lineCov">        786 :         AST_TEST_UNREGISTER(duplicate_resource);</span>
<span class="lineNum">    5600 </span><span class="lineCov">        786 :         AST_TEST_UNREGISTER(loop);</span>
<span class="lineNum">    5601 </span><span class="lineCov">        786 :         AST_TEST_UNREGISTER(bad_event);</span>
<span class="lineNum">    5602 </span>            : 
<span class="lineNum">    5603 </span><span class="lineCov">        786 :         ast_sip_transport_monitor_unregister_all(sub_tree_transport_cb, NULL, NULL);</span>
<span class="lineNum">    5604 </span>            : 
<span class="lineNum">    5605 </span><span class="lineCov">        786 :         ast_cli_unregister_multiple(cli_commands, ARRAY_LEN(cli_commands));</span>
<span class="lineNum">    5606 </span>            : 
<span class="lineNum">    5607 </span><span class="lineCov">        786 :         ast_manager_unregister(AMI_SHOW_SUBSCRIPTIONS_OUTBOUND);</span>
<span class="lineNum">    5608 </span><span class="lineCov">        786 :         ast_manager_unregister(AMI_SHOW_SUBSCRIPTIONS_INBOUND);</span>
<span class="lineNum">    5609 </span><span class="lineCov">        786 :         ast_manager_unregister(&quot;PJSIPShowResourceLists&quot;);</span>
<span class="lineNum">    5610 </span>            : 
<span class="lineNum">    5611 </span><span class="lineCov">        786 :         ast_sip_unregister_service(&amp;pubsub_module);</span>
<span class="lineNum">    5612 </span><span class="lineCov">        786 :         if (sched) {</span>
<span class="lineNum">    5613 </span><span class="lineCov">        786 :                 ast_sched_context_destroy(sched);</span>
<span class="lineNum">    5614 </span>            :         }
<span class="lineNum">    5615 </span>            : 
<span class="lineNum">    5616 </span><span class="lineCov">        786 :         return 0;</span>
<a name="5617"><span class="lineNum">    5617 </span>            : }</a>
<span class="lineNum">    5618 </span>            : 
<span class="lineNum">    5619 </span><span class="lineCov">       6856 : AST_MODULE_INFO(ASTERISK_GPL_KEY, AST_MODFLAG_GLOBAL_SYMBOLS | AST_MODFLAG_LOAD_ORDER, &quot;PJSIP event resource&quot;,</span>
<span class="lineNum">    5620 </span>            :         .support_level = AST_MODULE_SUPPORT_CORE,
<span class="lineNum">    5621 </span>            :         .load = load_module,
<span class="lineNum">    5622 </span>            :         .unload = unload_module,
<span class="lineNum">    5623 </span>            :         .load_pri = AST_MODPRI_CHANNEL_DEPEND,
<span class="lineNum">    5624 </span>            :         .requires = &quot;res_pjsip&quot;,
<span class="lineNum">    5625 </span>            : );
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
