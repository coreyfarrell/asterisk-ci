<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Asterisk GIT-16-9767e98486 - main/loader.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">main</a> - loader.c<span style="font-size: 80%;"> (source / <a href="loader.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Asterisk GIT-16-9767e98486</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">636</td>
            <td class="headerCovTableEntry">911</td>
            <td class="headerCovTableEntryLo">69.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-07-22 22:16:30</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">59</td>
            <td class="headerCovTableEntry">67</td>
            <td class="headerCovTableEntryMed">88.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Asterisk -- An open source telephony toolkit.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (C) 1999 - 2006, Digium, Inc.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Mark Spencer &lt;markster@digium.com&gt;
<span class="lineNum">       7 </span>            :  * Kevin P. Fleming &lt;kpfleming@digium.com&gt;
<span class="lineNum">       8 </span>            :  * Luigi Rizzo &lt;rizzo@icir.org&gt;
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * See http://www.asterisk.org for more information about
<span class="lineNum">      11 </span>            :  * the Asterisk project. Please do not directly contact
<span class="lineNum">      12 </span>            :  * any of the maintainers of this project for assistance;
<span class="lineNum">      13 </span>            :  * the project provides a web site, mailing lists and IRC
<span class="lineNum">      14 </span>            :  * channels for your use.
<span class="lineNum">      15 </span>            :  *
<span class="lineNum">      16 </span>            :  * This program is free software, distributed under the terms of
<span class="lineNum">      17 </span>            :  * the GNU General Public License Version 2. See the LICENSE file
<span class="lineNum">      18 </span>            :  * at the top of the source tree.
<span class="lineNum">      19 </span>            :  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : /*! \file
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  * \brief Module Loader
<span class="lineNum">      24 </span>            :  * \author Mark Spencer &lt;markster@digium.com&gt;
<span class="lineNum">      25 </span>            :  * \author Kevin P. Fleming &lt;kpfleming@digium.com&gt;
<span class="lineNum">      26 </span>            :  * \author Luigi Rizzo &lt;rizzo@icir.org&gt;
<span class="lineNum">      27 </span>            :  * - See ModMngMnt
<span class="lineNum">      28 </span>            :  */
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : /*** MODULEINFO
<span class="lineNum">      31 </span>            :         &lt;support_level&gt;core&lt;/support_level&gt;
<span class="lineNum">      32 </span>            :  ***/
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #include &quot;asterisk.h&quot;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : #include &quot;asterisk/_private.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;asterisk/paths.h&quot;   /* use ast_config_AST_MODULE_DIR */
<span class="lineNum">      38 </span>            : #include &lt;dirent.h&gt;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #include &quot;asterisk/dlinkedlists.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;asterisk/module.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;asterisk/config.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;asterisk/channel.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;asterisk/term.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;asterisk/manager.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;asterisk/io.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;asterisk/lock.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;asterisk/vector.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;asterisk/app.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;asterisk/test.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;asterisk/cli.h&quot;
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : #include &lt;dlfcn.h&gt;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : #include &quot;asterisk/md5.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;asterisk/utils.h&quot;
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : /*** DOCUMENTATION
<span class="lineNum">      59 </span>            :         &lt;managerEvent language=&quot;en_US&quot; name=&quot;Reload&quot;&gt;
<span class="lineNum">      60 </span>            :                 &lt;managerEventInstance class=&quot;EVENT_FLAG_SYSTEM&quot;&gt;
<span class="lineNum">      61 </span>            :                         &lt;synopsis&gt;Raised when a module has been reloaded in Asterisk.&lt;/synopsis&gt;
<span class="lineNum">      62 </span>            :                         &lt;syntax&gt;
<span class="lineNum">      63 </span>            :                                 &lt;parameter name=&quot;Module&quot;&gt;
<span class="lineNum">      64 </span>            :                                         &lt;para&gt;The name of the module that was reloaded, or
<span class="lineNum">      65 </span>            :                                         &lt;literal&gt;All&lt;/literal&gt; if all modules were reloaded&lt;/para&gt;
<span class="lineNum">      66 </span>            :                                 &lt;/parameter&gt;
<span class="lineNum">      67 </span>            :                                 &lt;parameter name=&quot;Status&quot;&gt;
<span class="lineNum">      68 </span>            :                                         &lt;para&gt;The numeric status code denoting the success or failure
<span class="lineNum">      69 </span>            :                                         of the reload request.&lt;/para&gt;
<span class="lineNum">      70 </span>            :                                         &lt;enumlist&gt;
<span class="lineNum">      71 </span>            :                                                 &lt;enum name=&quot;0&quot;&gt;&lt;para&gt;Success&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">      72 </span>            :                                                 &lt;enum name=&quot;1&quot;&gt;&lt;para&gt;Request queued&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">      73 </span>            :                                                 &lt;enum name=&quot;2&quot;&gt;&lt;para&gt;Module not found&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">      74 </span>            :                                                 &lt;enum name=&quot;3&quot;&gt;&lt;para&gt;Error&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">      75 </span>            :                                                 &lt;enum name=&quot;4&quot;&gt;&lt;para&gt;Reload already in progress&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">      76 </span>            :                                                 &lt;enum name=&quot;5&quot;&gt;&lt;para&gt;Module uninitialized&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">      77 </span>            :                                                 &lt;enum name=&quot;6&quot;&gt;&lt;para&gt;Reload not supported&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">      78 </span>            :                                         &lt;/enumlist&gt;
<span class="lineNum">      79 </span>            :                                 &lt;/parameter&gt;
<span class="lineNum">      80 </span>            :                         &lt;/syntax&gt;
<span class="lineNum">      81 </span>            :                 &lt;/managerEventInstance&gt;
<span class="lineNum">      82 </span>            :         &lt;/managerEvent&gt;
<span class="lineNum">      83 </span>            :         &lt;managerEvent language=&quot;en_US&quot; name=&quot;Load&quot;&gt;
<span class="lineNum">      84 </span>            :                 &lt;managerEventInstance class=&quot;EVENT_FLAG_SYSTEM&quot;&gt;
<span class="lineNum">      85 </span>            :                         &lt;synopsis&gt;Raised when a module has been loaded in Asterisk.&lt;/synopsis&gt;
<span class="lineNum">      86 </span>            :                         &lt;syntax&gt;
<span class="lineNum">      87 </span>            :                                 &lt;parameter name=&quot;Module&quot;&gt;
<span class="lineNum">      88 </span>            :                                         &lt;para&gt;The name of the module that was loaded&lt;/para&gt;
<span class="lineNum">      89 </span>            :                                 &lt;/parameter&gt;
<span class="lineNum">      90 </span>            :                                 &lt;parameter name=&quot;Status&quot;&gt;
<span class="lineNum">      91 </span>            :                                         &lt;para&gt;The result of the load request.&lt;/para&gt;
<span class="lineNum">      92 </span>            :                                         &lt;enumlist&gt;
<span class="lineNum">      93 </span>            :                                                 &lt;enum name=&quot;Failure&quot;&gt;&lt;para&gt;Module could not be loaded properly&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">      94 </span>            :                                                 &lt;enum name=&quot;Success&quot;&gt;&lt;para&gt;Module loaded and configured&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">      95 </span>            :                                                 &lt;enum name=&quot;Decline&quot;&gt;&lt;para&gt;Module is not configured&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">      96 </span>            :                                         &lt;/enumlist&gt;
<span class="lineNum">      97 </span>            :                                 &lt;/parameter&gt;
<span class="lineNum">      98 </span>            :                         &lt;/syntax&gt;
<span class="lineNum">      99 </span>            :                 &lt;/managerEventInstance&gt;
<span class="lineNum">     100 </span>            :         &lt;/managerEvent&gt;
<span class="lineNum">     101 </span>            :         &lt;managerEvent language=&quot;en_US&quot; name=&quot;Unload&quot;&gt;
<span class="lineNum">     102 </span>            :                 &lt;managerEventInstance class=&quot;EVENT_FLAG_SYSTEM&quot;&gt;
<span class="lineNum">     103 </span>            :                         &lt;synopsis&gt;Raised when a module has been unloaded in Asterisk.&lt;/synopsis&gt;
<span class="lineNum">     104 </span>            :                         &lt;syntax&gt;
<span class="lineNum">     105 </span>            :                                 &lt;parameter name=&quot;Module&quot;&gt;
<span class="lineNum">     106 </span>            :                                         &lt;para&gt;The name of the module that was unloaded&lt;/para&gt;
<span class="lineNum">     107 </span>            :                                 &lt;/parameter&gt;
<span class="lineNum">     108 </span>            :                                 &lt;parameter name=&quot;Status&quot;&gt;
<span class="lineNum">     109 </span>            :                                         &lt;para&gt;The result of the unload request.&lt;/para&gt;
<span class="lineNum">     110 </span>            :                                         &lt;enumlist&gt;
<span class="lineNum">     111 </span>            :                                                 &lt;enum name=&quot;Success&quot;&gt;&lt;para&gt;Module unloaded successfully&lt;/para&gt;&lt;/enum&gt;
<span class="lineNum">     112 </span>            :                                         &lt;/enumlist&gt;
<span class="lineNum">     113 </span>            :                                 &lt;/parameter&gt;
<span class="lineNum">     114 </span>            :                         &lt;/syntax&gt;
<span class="lineNum">     115 </span>            :                 &lt;/managerEventInstance&gt;
<span class="lineNum">     116 </span>            :         &lt;/managerEvent&gt;
<span class="lineNum">     117 </span>            :  ***/
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : #ifndef RTLD_NOW
<span class="lineNum">     120 </span>            : #define RTLD_NOW 0
<span class="lineNum">     121 </span>            : #endif
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : #ifndef RTLD_LOCAL
<span class="lineNum">     124 </span>            : #define RTLD_LOCAL 0
<span class="lineNum">     125 </span>            : #endif
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : struct ast_module_user {
<span class="lineNum">     128 </span>            :         struct ast_channel *chan;
<span class="lineNum">     129 </span>            :         AST_LIST_ENTRY(ast_module_user) entry;
<span class="lineNum">     130 </span>            : };
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : AST_DLLIST_HEAD(module_user_list, ast_module_user);
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : static const unsigned char expected_key[] =
<span class="lineNum">     135 </span>            : { 0x87, 0x76, 0x79, 0x35, 0x23, 0xea, 0x3a, 0xd3,
<span class="lineNum">     136 </span>            :   0x25, 0x2a, 0xbb, 0x35, 0x87, 0xe4, 0x22, 0x24 };
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : static char buildopt_sum[33] = AST_BUILDOPT_SUM;
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : AST_VECTOR(module_vector, struct ast_module *);
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : /* Built-in module registrations need special handling at startup */
<span class="lineNum">     143 </span>            : static unsigned int loader_ready;
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : /*!
<span class="lineNum">     146 </span>            :  * \brief Internal flag to indicate all modules have been initially loaded.
<span class="lineNum">     147 </span>            :  */
<span class="lineNum">     148 </span>            : static int modules_loaded;
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            : struct ast_module {
<span class="lineNum">     151 </span>            :         const struct ast_module_info *info;
<span class="lineNum">     152 </span>            :         /*! Used to get module references into refs log */
<span class="lineNum">     153 </span>            :         void *ref_debug;
<span class="lineNum">     154 </span>            :         /*! The shared lib. */
<span class="lineNum">     155 </span>            :         void *lib;
<span class="lineNum">     156 </span>            :         /*! Number of 'users' and other references currently holding the module. */
<span class="lineNum">     157 </span>            :         int usecount;
<span class="lineNum">     158 </span>            :         /*! List of users holding the module. */
<span class="lineNum">     159 </span>            :         struct module_user_list users;
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :         /*! List of required module names. */
<span class="lineNum">     162 </span>            :         struct ast_vector_string requires;
<span class="lineNum">     163 </span>            :         /*! List of optional api modules. */
<span class="lineNum">     164 </span>            :         struct ast_vector_string optional_modules;
<span class="lineNum">     165 </span>            :         /*! List of modules this enhances. */
<span class="lineNum">     166 </span>            :         struct ast_vector_string enhances;
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :         /*!
<span class="lineNum">     169 </span>            :          * \brief Vector holding pointers to modules we have a reference to.
<span class="lineNum">     170 </span>            :          *
<span class="lineNum">     171 </span>            :          * When one module requires another, the required module gets added
<span class="lineNum">     172 </span>            :          * to this list with a reference.
<span class="lineNum">     173 </span>            :          */
<span class="lineNum">     174 </span>            :         struct module_vector reffed_deps;
<span class="lineNum">     175 </span>            :         struct {
<span class="lineNum">     176 </span>            :                 /*! The module running and ready to accept requests. */
<span class="lineNum">     177 </span>            :                 unsigned int running:1;
<span class="lineNum">     178 </span>            :                 /*! The module has declined to start. */
<span class="lineNum">     179 </span>            :                 unsigned int declined:1;
<span class="lineNum">     180 </span>            :                 /*! This module is being held open until it's time to shutdown. */
<span class="lineNum">     181 </span>            :                 unsigned int keepuntilshutdown:1;
<span class="lineNum">     182 </span>            :                 /*! The module is built-in. */
<span class="lineNum">     183 </span>            :                 unsigned int builtin:1;
<span class="lineNum">     184 </span>            :                 /*! The admin has declared this module is required. */
<span class="lineNum">     185 </span>            :                 unsigned int required:1;
<span class="lineNum">     186 </span>            :                 /*! This module is marked for preload. */
<span class="lineNum">     187 </span>            :                 unsigned int preload:1;
<span class="lineNum">     188 </span>            :         } flags;
<span class="lineNum">     189 </span>            :         AST_DLLIST_ENTRY(ast_module) entry;
<span class="lineNum">     190 </span>            :         char resource[0];
<span class="lineNum">     191 </span>            : };
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : static AST_DLLIST_HEAD_STATIC(module_list, ast_module);
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            : struct load_results_map {
<span class="lineNum">     197 </span>            :         int result;
<span class="lineNum">     198 </span>            :         const char *name;
<span class="lineNum">     199 </span>            : };
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : static const struct load_results_map load_results[] = {
<span class="lineNum">     202 </span>            :         { AST_MODULE_LOAD_SUCCESS, &quot;Success&quot; },
<span class="lineNum">     203 </span>            :         { AST_MODULE_LOAD_DECLINE, &quot;Decline&quot; },
<span class="lineNum">     204 </span>            :         { AST_MODULE_LOAD_SKIP, &quot;Skip&quot; },
<span class="lineNum">     205 </span>            :         { AST_MODULE_LOAD_PRIORITY, &quot;Priority&quot; },
<span class="lineNum">     206 </span>            :         { AST_MODULE_LOAD_FAILURE, &quot;Failure&quot; },
<span class="lineNum">     207 </span>            : };
<span class="lineNum">     208 </span>            : #define AST_MODULE_LOAD_UNKNOWN_STRING          &quot;Unknown&quot;             /* Status string for unknown load status */
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            : static void publish_load_message_type(const char* type, const char *name, const char *status);
<span class="lineNum">     211 </span>            : static void publish_reload_message(const char *name, enum ast_module_reload_result result);
<span class="lineNum">     212 </span>            : static void publish_load_message(const char *name, enum ast_module_load_result result);
<span class="lineNum">     213 </span>            : static void publish_unload_message(const char *name, const char* status);
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            : /*
<span class="lineNum">     217 </span>            :  * module_list is cleared by its constructor possibly after
<span class="lineNum">     218 </span>            :  * we start accumulating built-in modules, so we need to
<span class="lineNum">     219 </span>            :  * use another list (without the lock) to accumulate them.
<span class="lineNum">     220 </span>            :  */
<a name="221"><span class="lineNum">     221 </span>            : static struct module_list builtin_module_list;</a>
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span><span class="lineCov">      59687 : static int module_vector_strcasecmp(struct ast_module *a, struct ast_module *b)</span>
<span class="lineNum">     224 </span>            : {
<span class="lineNum">     225 </span><span class="lineCov">      59687 :         return strcasecmp(a-&gt;resource, b-&gt;resource);</span>
<a name="226"><span class="lineNum">     226 </span>            : }</a>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span><span class="lineCov">   20810678 : static int module_vector_cmp(struct ast_module *a, struct ast_module *b)</span>
<span class="lineNum">     229 </span>            : {
<span class="lineNum">     230 </span><span class="lineCov">   20810678 :         int preload_diff = (int)b-&gt;flags.preload - (int)a-&gt;flags.preload;</span>
<span class="lineNum">     231 </span>            :         /* if load_pri is not set, default is 128.  Lower is better */
<span class="lineNum">     232 </span><span class="lineCov">   41621356 :         int a_pri = ast_test_flag(a-&gt;info, AST_MODFLAG_LOAD_ORDER)</span>
<span class="lineNum">     233 </span><span class="lineCov">   20810678 :                 ? a-&gt;info-&gt;load_pri : AST_MODPRI_DEFAULT;</span>
<span class="lineNum">     234 </span><span class="lineCov">   41621356 :         int b_pri = ast_test_flag(b-&gt;info, AST_MODFLAG_LOAD_ORDER)</span>
<span class="lineNum">     235 </span><span class="lineCov">   20810678 :                 ? b-&gt;info-&gt;load_pri : AST_MODPRI_DEFAULT;</span>
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineCov">   20810678 :         if (preload_diff) {</span>
<span class="lineNum">     238 </span>            :                 /* -1 preload a but not b */
<span class="lineNum">     239 </span>            :                 /*  0 preload both or neither */
<span class="lineNum">     240 </span>            :                 /*  1 preload b but not a */
<span class="lineNum">     241 </span><span class="lineCov">         80 :                 return preload_diff;</span>
<span class="lineNum">     242 </span>            :         }
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :         /*
<span class="lineNum">     245 </span>            :          * Returns comparison values for a vector sorted by priority.
<span class="lineNum">     246 </span>            :          * &lt;0 a_pri &lt; b_pri
<span class="lineNum">     247 </span>            :          * =0 a_pri == b_pri
<span class="lineNum">     248 </span>            :          * &gt;0 a_pri &gt; b_pri
<span class="lineNum">     249 </span>            :          */
<span class="lineNum">     250 </span><span class="lineCov">   20810598 :         return a_pri - b_pri;</span>
<span class="lineNum">     251 </span>            : }
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : static struct ast_module *find_resource(const char *resource, int do_lock);
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : /*!
<span class="lineNum">     256 </span>            :  * \internal
<span class="lineNum">     257 </span>            :  * \brief Add a reference from mod to dep.
<span class="lineNum">     258 </span>            :  *
<span class="lineNum">     259 </span>            :  * \param mod Owner of the new reference.
<span class="lineNum">     260 </span>            :  * \param dep Module to reference
<span class="lineNum">     261 </span>            :  * \param missing Vector to store name of \a dep if it is not running.
<span class="lineNum">     262 </span>            :  *
<span class="lineNum">     263 </span>            :  * This function returns failure if \a dep is not running and \a missing
<span class="lineNum">     264 </span>            :  * is NULL.  If \a missing is not NULL errors will only be returned for
<span class="lineNum">     265 </span>            :  * allocation failures.
<span class="lineNum">     266 </span>            :  *
<span class="lineNum">     267 </span>            :  * \retval 0 Success
<span class="lineNum">     268 </span>            :  * \retval -1 Failure
<span class="lineNum">     269 </span>            :  *
<span class="lineNum">     270 </span>            :  * \note Adding a second reference to the same dep will return success
<a name="271"><span class="lineNum">     271 </span>            :  *       without doing anything.</a>
<span class="lineNum">     272 </span>            :  */
<span class="lineNum">     273 </span><span class="lineCov">     367197 : static int module_reffed_deps_add(struct ast_module *mod, struct ast_module *dep,</span>
<span class="lineNum">     274 </span>            :         struct ast_vector_const_string *missing)
<span class="lineNum">     275 </span>            : {
<span class="lineNum">     276 </span><span class="lineCov">     367197 :         if (!dep-&gt;flags.running) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :                 return !missing ? -1 : AST_VECTOR_APPEND(missing, dep-&gt;info-&gt;name);</span>
<span class="lineNum">     278 </span>            :         }
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineCov">     640209 :         if (AST_VECTOR_GET_CMP(&amp;mod-&gt;reffed_deps, dep, AST_VECTOR_ELEM_DEFAULT_CMP)) {</span>
<span class="lineNum">     281 </span>            :                 /* Skip duplicate. */
<span class="lineNum">     282 </span><span class="lineCov">     185876 :                 return 0;</span>
<span class="lineNum">     283 </span>            :         }
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span><span class="lineCov">     181321 :         if (AST_VECTOR_APPEND(&amp;mod-&gt;reffed_deps, dep)) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     287 </span>            :         }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineCov">     181321 :         ast_module_ref(dep);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineCov">     181321 :         return 0;</span>
<span class="lineNum">     292 </span>            : }
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : /*!
<span class="lineNum">     295 </span>            :  * \internal
<span class="lineNum">     296 </span>            :  * \brief Add references for modules that enhance a dependency.
<span class="lineNum">     297 </span>            :  *
<span class="lineNum">     298 </span>            :  * \param mod Owner of the new references.
<span class="lineNum">     299 </span>            :  * \param dep Module to check for enhancers.
<span class="lineNum">     300 </span>            :  * \param missing Vector to store name of any enhancer that is not running or declined.
<span class="lineNum">     301 </span>            :  *
<span class="lineNum">     302 </span>            :  * \retval 0 Success
<a name="303"><span class="lineNum">     303 </span>            :  * \retval -1 Failure</a>
<span class="lineNum">     304 </span>            :  */
<span class="lineNum">     305 </span><span class="lineCov">     364951 : static int module_reffed_deps_add_dep_enhancers(struct ast_module *mod,</span>
<span class="lineNum">     306 </span>            :         struct ast_module *dep, struct ast_vector_const_string *missing)
<span class="lineNum">     307 </span>            : {
<span class="lineNum">     308 </span>            :         struct ast_module *cur;
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineCov">  124790117 :         AST_DLLIST_TRAVERSE(&amp;module_list, cur, entry) {</span>
<span class="lineNum">     311 </span><span class="lineCov">  124425166 :                 if (cur-&gt;flags.declined) {</span>
<span class="lineNum">     312 </span><span class="lineCov">     596578 :                         continue;</span>
<span class="lineNum">     313 </span>            :                 }
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineCov">  124193437 :                 if (!AST_VECTOR_GET_CMP(&amp;cur-&gt;enhances, dep-&gt;info-&gt;name, !strcasecmp)) {</span>
<span class="lineNum">     316 </span>            :                         /* dep is not enhanced by cur. */
<span class="lineNum">     317 </span><span class="lineCov">  123828588 :                         continue;</span>
<span class="lineNum">     318 </span>            :                 }
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :                 /* dep is enhanced by cur, therefore mod requires cur. */
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :                 if (module_reffed_deps_add(mod, cur, missing)) {</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">     323 </span>            :                 }
<span class="lineNum">     324 </span>            :         }
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineCov">     364951 :         return 0;</span>
<span class="lineNum">     327 </span>            : }
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : /*!
<span class="lineNum">     330 </span>            :  * \internal
<span class="lineNum">     331 </span>            :  * \brief Add references to a list of dependencies.
<span class="lineNum">     332 </span>            :  *
<span class="lineNum">     333 </span>            :  * \param mod Owner of the new references.
<span class="lineNum">     334 </span>            :  * \param vec List of required modules to process
<span class="lineNum">     335 </span>            :  * \param missing Vector to store names of modules that are not running.
<span class="lineNum">     336 </span>            :  * \param ref_enhancers Reference all enhancers of each required module.
<span class="lineNum">     337 </span>            :  * \param isoptional Modules that are not loaded can be ignored.
<span class="lineNum">     338 </span>            :  *
<span class="lineNum">     339 </span>            :  * \retval 0 Success
<a name="340"><span class="lineNum">     340 </span>            :  * \retval -1 Failure</a>
<span class="lineNum">     341 </span>            :  */
<span class="lineNum">     342 </span><span class="lineCov">    2299923 : static int module_deps_process_reqlist(struct ast_module *mod,</span>
<span class="lineNum">     343 </span>            :         struct ast_vector_string *vec, struct ast_vector_const_string *missing,
<span class="lineNum">     344 </span>            :         int ref_enhancers, int isoptional)
<span class="lineNum">     345 </span>            : {
<span class="lineNum">     346 </span>            :         int idx;
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineCov">    2675846 :         for (idx = 0; idx &lt; AST_VECTOR_SIZE(vec); idx++) {</span>
<span class="lineNum">     349 </span><span class="lineCov">     379031 :                 const char *depname = AST_VECTOR_GET(vec, idx);</span>
<span class="lineNum">     350 </span><span class="lineCov">     379031 :                 struct ast_module *dep = find_resource(depname, 0);</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineCov">     379031 :                 if (!dep || !dep-&gt;flags.running) {</span>
<span class="lineNum">     353 </span><span class="lineCov">      11834 :                         if (isoptional &amp;&amp; !dep) {</span>
<span class="lineNum">     354 </span><span class="lineCov">       4492 :                                 continue;</span>
<span class="lineNum">     355 </span>            :                         }
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineCov">       7342 :                         if (missing &amp;&amp; !AST_VECTOR_APPEND(missing, depname)) {</span>
<span class="lineNum">     358 </span><span class="lineCov">       4234 :                                 continue;</span>
<span class="lineNum">     359 </span>            :                         }
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineCov">       3108 :                         return -1;</span>
<span class="lineNum">     362 </span>            :                 }
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineCov">     367197 :                 if (module_reffed_deps_add(mod, dep, missing)) {</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">     366 </span>            :                 }
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineCov">     367197 :                 if (ref_enhancers &amp;&amp; module_reffed_deps_add_dep_enhancers(mod, dep, missing)) {</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">     370 </span>            :                 }
<span class="lineNum">     371 </span>            :         }
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineCov">    2296815 :         return 0;</span>
<span class="lineNum">     374 </span>            : }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : /*!
<span class="lineNum">     377 </span>            :  * \internal
<span class="lineNum">     378 </span>            :  * \brief Grab all references required to start the module.
<span class="lineNum">     379 </span>            :  *
<span class="lineNum">     380 </span>            :  * \param mod The module we're trying to start.
<span class="lineNum">     381 </span>            :  * \param missing Vector to store a list of missing dependencies.
<span class="lineNum">     382 </span>            :  *
<span class="lineNum">     383 </span>            :  * \retval 0 Success
<span class="lineNum">     384 </span>            :  * \retval -1 Failure
<span class="lineNum">     385 </span>            :  *
<span class="lineNum">     386 </span>            :  * \note module_list must be locked.
<span class="lineNum">     387 </span>            :  *
<span class="lineNum">     388 </span>            :  * \note Caller is responsible for initializing and freeing the vector.
<a name="389"><span class="lineNum">     389 </span>            :  *       Elements are safely read only while module_list remains locked.</a>
<span class="lineNum">     390 </span>            :  */
<span class="lineNum">     391 </span><span class="lineCov">     766641 : static int module_deps_reference(struct ast_module *mod, struct ast_vector_const_string *missing)</span>
<span class="lineNum">     392 </span>            : {
<span class="lineNum">     393 </span><span class="lineCov">     766641 :         int res = 0;</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :         /* Grab references to modules we enhance but not other enhancements. */
<span class="lineNum">     396 </span><span class="lineCov">     766641 :         res |= module_deps_process_reqlist(mod, &amp;mod-&gt;enhances, missing, 0, 0);</span>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :         /* Grab references to modules we require plus enhancements. */
<span class="lineNum">     399 </span><span class="lineCov">     766641 :         res |= module_deps_process_reqlist(mod, &amp;mod-&gt;requires, missing, 1, 0);</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :         /* Grab references to optional modules including enhancements. */
<span class="lineNum">     402 </span><span class="lineCov">     766641 :         res |= module_deps_process_reqlist(mod, &amp;mod-&gt;optional_modules, missing, 1, 1);</span>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineCov">     766641 :         return res;</span>
<span class="lineNum">     405 </span>            : }
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            : /*!
<span class="lineNum">     408 </span>            :  * \brief Recursively find required dependencies that are not running.
<span class="lineNum">     409 </span>            :  *
<span class="lineNum">     410 </span>            :  * \param mod Module to scan for dependencies.
<span class="lineNum">     411 </span>            :  * \param missingdeps Vector listing modules that must be started first.
<span class="lineNum">     412 </span>            :  *
<span class="lineNum">     413 </span>            :  * \retval 0 All dependencies resolved.
<span class="lineNum">     414 </span>            :  * \retval -1 Failed to resolve some dependencies.
<span class="lineNum">     415 </span>            :  *
<span class="lineNum">     416 </span>            :  * An error from this function usually means a required module is not even
<span class="lineNum">     417 </span>            :  * loaded.  This function is safe from infinite recursion, but dependency
<span class="lineNum">     418 </span>            :  * loops are not reported as an error from here.  On success missingdeps
<span class="lineNum">     419 </span>            :  * will contain a list of every module that needs to be running before this
<span class="lineNum">     420 </span>            :  * module can start.  missingdeps is sorted by load priority so any missing
<a name="421"><span class="lineNum">     421 </span>            :  * dependencies can be started if needed.</a>
<span class="lineNum">     422 </span>            :  */
<span class="lineNum">     423 </span><span class="lineCov">       7341 : static int module_deps_missing_recursive(struct ast_module *mod, struct module_vector *missingdeps)</span>
<span class="lineNum">     424 </span>            : {
<span class="lineNum">     425 </span><span class="lineCov">       7341 :         int i = 0;</span>
<span class="lineNum">     426 </span><span class="lineCov">       7341 :         int res = -1;</span>
<span class="lineNum">     427 </span>            :         struct ast_vector_const_string localdeps;
<span class="lineNum">     428 </span>            :         struct ast_module *dep;
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :         /*
<span class="lineNum">     431 </span>            :          * localdeps stores a copy of all dependencies that mod could not reference.
<span class="lineNum">     432 </span>            :          * First we discard modules that we've already found. We add all newly found
<span class="lineNum">     433 </span>            :          * modules to the missingdeps vector then scan them recursively.  This will
<span class="lineNum">     434 </span>            :          * ensure we quickly run out of stuff to do.
<span class="lineNum">     435 </span>            :          */
<span class="lineNum">     436 </span><span class="lineCov">       7341 :         AST_VECTOR_INIT(&amp;localdeps, 0);</span>
<span class="lineNum">     437 </span><span class="lineCov">       7341 :         if (module_deps_reference(mod, &amp;localdeps)) {</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :                 goto clean_return;</span>
<span class="lineNum">     439 </span>            :         }
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineCov">      11575 :         while (i &lt; AST_VECTOR_SIZE(&amp;localdeps)) {</span>
<span class="lineNum">     442 </span><span class="lineCov">       4234 :                 dep = find_resource(AST_VECTOR_GET(&amp;localdeps, i), 0);</span>
<span class="lineNum">     443 </span><span class="lineCov">       4234 :                 if (!dep) {</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :                         goto clean_return;</span>
<span class="lineNum">     445 </span>            :                 }
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineCov">       5361 :                 if (AST_VECTOR_GET_CMP(missingdeps, dep, AST_VECTOR_ELEM_DEFAULT_CMP)) {</span>
<span class="lineNum">     448 </span>            :                         /* Skip common dependency.  We have already searched it. */
<span class="lineNum">     449 </span><span class="lineCov">          1 :                         AST_VECTOR_REMOVE(&amp;localdeps, i, 0);</span>
<span class="lineNum">     450 </span>            :                 } else {
<span class="lineNum">     451 </span>            :                         /* missingdeps is the real list so keep it sorted. */
<span class="lineNum">     452 </span><span class="lineCov">       4233 :                         if (AST_VECTOR_ADD_SORTED(missingdeps, dep, module_vector_cmp)) {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                                 goto clean_return;</span>
<span class="lineNum">     454 </span>            :                         }
<span class="lineNum">     455 </span><span class="lineCov">       4233 :                         i++;</span>
<span class="lineNum">     456 </span>            :                 }
<span class="lineNum">     457 </span>            :         }
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineCov">       7341 :         res = 0;</span>
<span class="lineNum">     460 </span><span class="lineCov">      11574 :         for (i = 0; !res &amp;&amp; i &lt; AST_VECTOR_SIZE(&amp;localdeps); i++) {</span>
<span class="lineNum">     461 </span><span class="lineCov">       4233 :                 dep = find_resource(AST_VECTOR_GET(&amp;localdeps, i), 0);</span>
<span class="lineNum">     462 </span>            :                 /* We've already confirmed dep is loaded in the first loop. */
<span class="lineNum">     463 </span><span class="lineCov">       4233 :                 res = module_deps_missing_recursive(dep, missingdeps);</span>
<span class="lineNum">     464 </span>            :         }
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineCov">       7341 : clean_return:</span>
<span class="lineNum">     467 </span><span class="lineCov">       7341 :         AST_VECTOR_FREE(&amp;localdeps);</span>
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineCov">       7341 :         return res;</span>
<a name="470"><span class="lineNum">     470 </span>            : }</a>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineCov">    1491211 : const char *ast_module_name(const struct ast_module *mod)</span>
<span class="lineNum">     473 </span>            : {
<span class="lineNum">     474 </span><span class="lineCov">    1491211 :         if (!mod || !mod-&gt;info) {</span>
<span class="lineNum">     475 </span><span class="lineCov">     213560 :                 return NULL;</span>
<span class="lineNum">     476 </span>            :         }
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">    1277651 :         return mod-&gt;info-&gt;name;</span>
<span class="lineNum">     479 </span>            : }
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : struct loadupdate {
<span class="lineNum">     482 </span>            :         int (*updater)(void);
<span class="lineNum">     483 </span>            :         AST_LIST_ENTRY(loadupdate) entry;
<span class="lineNum">     484 </span>            : };
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : static AST_DLLIST_HEAD_STATIC(updaters, loadupdate);
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            : AST_MUTEX_DEFINE_STATIC(reloadlock);
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            : struct reload_queue_item {
<span class="lineNum">     491 </span>            :         AST_LIST_ENTRY(reload_queue_item) entry;
<span class="lineNum">     492 </span>            :         char module[0];
<span class="lineNum">     493 </span>            : };
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : static int do_full_reload = 0;
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            : static AST_DLLIST_HEAD_STATIC(reload_queue, reload_queue_item);
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            : /*!
<span class="lineNum">     500 </span>            :  * \internal
<span class="lineNum">     501 </span>            :  *
<span class="lineNum">     502 </span>            :  * This variable is set by load_dynamic_module so ast_module_register
<span class="lineNum">     503 </span>            :  * can know what pointer is being registered.
<span class="lineNum">     504 </span>            :  *
<span class="lineNum">     505 </span>            :  * This is protected by the module_list lock.
<span class="lineNum">     506 </span>            :  */
<span class="lineNum">     507 </span>            : static struct ast_module * volatile resource_being_loaded;
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            : /*!
<span class="lineNum">     510 </span>            :  * \internal
<span class="lineNum">     511 </span>            :  * \brief Used by AST_MODULE_INFO to register with the module loader.
<span class="lineNum">     512 </span>            :  *
<span class="lineNum">     513 </span>            :  * This function is automatically called when each module is opened.
<a name="514"><span class="lineNum">     514 </span>            :  * It must never be used from outside AST_MODULE_INFO.</a>
<span class="lineNum">     515 </span>            :  */
<span class="lineNum">     516 </span><span class="lineCov">     498132 : void ast_module_register(const struct ast_module_info *info)</span>
<span class="lineNum">     517 </span>            : {
<span class="lineNum">     518 </span>            :         struct ast_module *mod;
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span><span class="lineCov">     498132 :         if (!loader_ready) {</span>
<span class="lineNum">     521 </span><span class="lineCov">      73168 :                 mod = ast_std_calloc(1, sizeof(*mod) + strlen(info-&gt;name) + 1);</span>
<span class="lineNum">     522 </span><span class="lineCov">      73168 :                 if (!mod) {</span>
<span class="lineNum">     523 </span>            :                         /* We haven't even reached main() yet, if we can't
<span class="lineNum">     524 </span>            :                          * allocate memory at this point just give up. */
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :                         fprintf(stderr, &quot;Allocation failure during startup.\n&quot;);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :                         exit(2);</span>
<span class="lineNum">     527 </span>            :                 }
<span class="lineNum">     528 </span><span class="lineCov">      73168 :                 strcpy(mod-&gt;resource, info-&gt;name); /* safe */</span>
<span class="lineNum">     529 </span><span class="lineCov">      73168 :                 mod-&gt;info = info;</span>
<span class="lineNum">     530 </span><span class="lineCov">      73168 :                 mod-&gt;flags.builtin = 1;</span>
<span class="lineNum">     531 </span><span class="lineCov">      73168 :                 AST_DLLIST_INSERT_TAIL(&amp;builtin_module_list, mod, entry);</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :                 /* ast_module_register for built-in modules is run again during module preload. */
<span class="lineNum">     534 </span><span class="lineCov">      73168 :                 return;</span>
<span class="lineNum">     535 </span>            :         }
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :         /*
<span class="lineNum">     538 </span>            :          * This lock protects resource_being_loaded as well as the module
<span class="lineNum">     539 </span>            :          * list.  Normally we already have a lock on module_list when we
<span class="lineNum">     540 </span>            :          * begin the load but locking again from here prevents corruption
<span class="lineNum">     541 </span>            :          * if an asterisk module is dlopen'ed from outside the module loader.
<span class="lineNum">     542 </span>            :          */
<span class="lineNum">     543 </span><span class="lineCov">     424964 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">     544 </span><span class="lineCov">     424964 :         mod = resource_being_loaded;</span>
<span class="lineNum">     545 </span><span class="lineCov">     424964 :         if (!mod) {</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :                 AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     548 </span>            :         }
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineCov">     424964 :         ast_debug(5, &quot;Registering module %s\n&quot;, info-&gt;name);</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            :         /* This tells load_dynamic_module that we're registered. */
<span class="lineNum">     553 </span><span class="lineCov">     424964 :         resource_being_loaded = NULL;</span>
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineCov">     424964 :         mod-&gt;info = info;</span>
<span class="lineNum">     556 </span><span class="lineCov">     424964 :         if (ast_opt_ref_debug) {</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :                 mod-&gt;ref_debug = ao2_t_alloc(0, NULL, info-&gt;name);</span>
<span class="lineNum">     558 </span>            :         }
<span class="lineNum">     559 </span><span class="lineCov">     424964 :         AST_LIST_HEAD_INIT(&amp;mod-&gt;users);</span>
<span class="lineNum">     560 </span><span class="lineCov">     424964 :         AST_VECTOR_INIT(&amp;mod-&gt;requires, 0);</span>
<span class="lineNum">     561 </span><span class="lineCov">     424964 :         AST_VECTOR_INIT(&amp;mod-&gt;optional_modules, 0);</span>
<span class="lineNum">     562 </span><span class="lineCov">     424964 :         AST_VECTOR_INIT(&amp;mod-&gt;enhances, 0);</span>
<span class="lineNum">     563 </span><span class="lineCov">     424964 :         AST_VECTOR_INIT(&amp;mod-&gt;reffed_deps, 0);</span>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span><span class="lineCov">     424964 :         AST_DLLIST_INSERT_TAIL(&amp;module_list, mod, entry);</span>
<span class="lineNum">     566 </span><span class="lineCov">     424964 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :         /* give the module a copy of its own handle, for later use in registrations and the like */
<span class="lineNum">     569 </span><span class="lineCov">     424964 :         *((struct ast_module **) &amp;(info-&gt;self)) = mod;</span>
<a name="570"><span class="lineNum">     570 </span>            : }</a>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineCov">     424085 : static void module_destroy(struct ast_module *mod)</span>
<span class="lineNum">     573 </span>            : {
<span class="lineNum">     574 </span><span class="lineCov">     591158 :         AST_VECTOR_CALLBACK_VOID(&amp;mod-&gt;requires, ast_free);</span>
<span class="lineNum">     575 </span><span class="lineCov">     424085 :         AST_VECTOR_FREE(&amp;mod-&gt;requires);</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineCov">     439139 :         AST_VECTOR_CALLBACK_VOID(&amp;mod-&gt;optional_modules, ast_free);</span>
<span class="lineNum">     578 </span><span class="lineCov">     424085 :         AST_VECTOR_FREE(&amp;mod-&gt;optional_modules);</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineCov">     425206 :         AST_VECTOR_CALLBACK_VOID(&amp;mod-&gt;enhances, ast_free);</span>
<span class="lineNum">     581 </span><span class="lineCov">     424085 :         AST_VECTOR_FREE(&amp;mod-&gt;enhances);</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :         /* Release references to all dependencies. */
<span class="lineNum">     584 </span><span class="lineCov">     605091 :         AST_VECTOR_CALLBACK_VOID(&amp;mod-&gt;reffed_deps, ast_module_unref);</span>
<span class="lineNum">     585 </span><span class="lineCov">     424085 :         AST_VECTOR_FREE(&amp;mod-&gt;reffed_deps);</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineCov">     424085 :         AST_LIST_HEAD_DESTROY(&amp;mod-&gt;users);</span>
<span class="lineNum">     588 </span><span class="lineCov">     424085 :         ao2_cleanup(mod-&gt;ref_debug);</span>
<span class="lineNum">     589 </span><span class="lineCov">     424085 :         if (mod-&gt;flags.builtin) {</span>
<span class="lineNum">     590 </span><span class="lineCov">      17927 :                 ast_std_free(mod);</span>
<span class="lineNum">     591 </span>            :         } else {
<span class="lineNum">     592 </span><span class="lineCov">     406158 :                 ast_free(mod);</span>
<span class="lineNum">     593 </span>            :         }
<a name="594"><span class="lineNum">     594 </span><span class="lineCov">     424085 : }</span></a>
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineCov">     119919 : void ast_module_unregister(const struct ast_module_info *info)</span>
<span class="lineNum">     597 </span>            : {
<span class="lineNum">     598 </span><span class="lineCov">     119919 :         struct ast_module *mod = NULL;</span>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            :         /* it is assumed that the users list in the module structure
<span class="lineNum">     601 </span>            :            will already be empty, or we cannot have gotten to this
<span class="lineNum">     602 </span>            :            point
<span class="lineNum">     603 </span>            :         */
<span class="lineNum">     604 </span><span class="lineCov">     119919 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">     605 </span><span class="lineCov">     132445 :         AST_DLLIST_TRAVERSE_BACKWARDS_SAFE_BEGIN(&amp;module_list, mod, entry) {</span>
<span class="lineNum">     606 </span><span class="lineCov">      59429 :                 if (mod-&gt;info == info) {</span>
<span class="lineNum">     607 </span><span class="lineCov">      46903 :                         AST_DLLIST_REMOVE_CURRENT(entry);</span>
<span class="lineNum">     608 </span><span class="lineCov">      46903 :                         break;</span>
<span class="lineNum">     609 </span>            :                 }
<span class="lineNum">     610 </span>            :         }
<span class="lineNum">     611 </span>            :         AST_DLLIST_TRAVERSE_BACKWARDS_SAFE_END;
<span class="lineNum">     612 </span><span class="lineCov">     119919 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span><span class="lineCov">     119919 :         if (mod &amp;&amp; !mod-&gt;usecount) {</span>
<span class="lineNum">     615 </span>            :                 /*
<span class="lineNum">     616 </span>            :                  * We are intentionally leaking mod if usecount is not zero.
<span class="lineNum">     617 </span>            :                  * This is necessary if the module is being forcefully unloaded.
<span class="lineNum">     618 </span>            :                  * In addition module_destroy is not safe to run after exit()
<span class="lineNum">     619 </span>            :                  * is called.  ast_module_unregister is run during cleanup of
<span class="lineNum">     620 </span>            :                  * the process when libc releases each module's shared object
<span class="lineNum">     621 </span>            :                  * library.
<span class="lineNum">     622 </span>            :                  */
<span class="lineNum">     623 </span><span class="lineCov">      46847 :                 ast_debug(5, &quot;Unregistering module %s\n&quot;, info-&gt;name);</span>
<span class="lineNum">     624 </span><span class="lineCov">      46847 :                 module_destroy(mod);</span>
<span class="lineNum">     625 </span>            :         }
<a name="626"><span class="lineNum">     626 </span><span class="lineCov">     119919 : }</span></a>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineCov">     847026 : struct ast_module_user *__ast_module_user_add(struct ast_module *mod, struct ast_channel *chan)</span>
<span class="lineNum">     629 </span>            : {
<span class="lineNum">     630 </span>            :         struct ast_module_user *u;
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span><span class="lineCov">     847026 :         u = ast_calloc(1, sizeof(*u));</span>
<span class="lineNum">     633 </span><span class="lineCov">     847026 :         if (!u) {</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     635 </span>            :         }
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span><span class="lineCov">     847026 :         u-&gt;chan = chan;</span>
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineCov">     847026 :         AST_LIST_LOCK(&amp;mod-&gt;users);</span>
<span class="lineNum">     640 </span><span class="lineCov">     847026 :         AST_LIST_INSERT_HEAD(&amp;mod-&gt;users, u, entry);</span>
<span class="lineNum">     641 </span><span class="lineCov">     847026 :         AST_LIST_UNLOCK(&amp;mod-&gt;users);</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineCov">     847026 :         if (mod-&gt;ref_debug) {</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :                 ao2_ref(mod-&gt;ref_debug, +1);</span>
<span class="lineNum">     645 </span>            :         }
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineCov">     847026 :         ast_atomic_fetchadd_int(&amp;mod-&gt;usecount, +1);</span>
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span><span class="lineCov">     847026 :         ast_update_use_count();</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span><span class="lineCov">     847026 :         return u;</span>
<a name="652"><span class="lineNum">     652 </span>            : }</a>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineCov">     847026 : void __ast_module_user_remove(struct ast_module *mod, struct ast_module_user *u)</span>
<span class="lineNum">     655 </span>            : {
<span class="lineNum">     656 </span><span class="lineCov">     847026 :         if (!u) {</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     658 </span>            :         }
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineCov">     847026 :         AST_LIST_LOCK(&amp;mod-&gt;users);</span>
<span class="lineNum">     661 </span><span class="lineCov">     857075 :         u = AST_LIST_REMOVE(&amp;mod-&gt;users, u, entry);</span>
<span class="lineNum">     662 </span><span class="lineCov">     847026 :         AST_LIST_UNLOCK(&amp;mod-&gt;users);</span>
<span class="lineNum">     663 </span><span class="lineCov">     847026 :         if (!u) {</span>
<span class="lineNum">     664 </span>            :                 /*
<span class="lineNum">     665 </span>            :                  * Was not in the list.  Either a bad pointer or
<span class="lineNum">     666 </span>            :                  * __ast_module_user_hangup_all() has been called.
<span class="lineNum">     667 </span>            :                  */
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     669 </span>            :         }
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span><span class="lineCov">     847026 :         if (mod-&gt;ref_debug) {</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :                 ao2_ref(mod-&gt;ref_debug, -1);</span>
<span class="lineNum">     673 </span>            :         }
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span><span class="lineCov">     847026 :         ast_atomic_fetchadd_int(&amp;mod-&gt;usecount, -1);</span>
<span class="lineNum">     676 </span><span class="lineCov">     847026 :         ast_free(u);</span>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineCov">     847026 :         ast_update_use_count();</span>
<a name="679"><span class="lineNum">     679 </span>            : }</a>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineCov">          2 : void __ast_module_user_hangup_all(struct ast_module *mod)</span>
<span class="lineNum">     682 </span>            : {
<span class="lineNum">     683 </span>            :         struct ast_module_user *u;
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineCov">          2 :         AST_LIST_LOCK(&amp;mod-&gt;users);</span>
<span class="lineNum">     686 </span><span class="lineCov">          2 :         while ((u = AST_LIST_REMOVE_HEAD(&amp;mod-&gt;users, entry))) {</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :                 if (u-&gt;chan) {</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :                         ast_softhangup(u-&gt;chan, AST_SOFTHANGUP_APPUNLOAD);</span>
<span class="lineNum">     689 </span>            :                 }
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :                 if (mod-&gt;ref_debug) {</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :                         ao2_ref(mod-&gt;ref_debug, -1);</span>
<span class="lineNum">     693 </span>            :                 }
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :                 ast_atomic_fetchadd_int(&amp;mod-&gt;usecount, -1);</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :                 ast_free(u);</span>
<span class="lineNum">     697 </span>            :         }
<span class="lineNum">     698 </span><span class="lineCov">          2 :         AST_LIST_UNLOCK(&amp;mod-&gt;users);</span>
<span class="lineNum">     699 </span>            : 
<span class="lineNum">     700 </span><span class="lineCov">          2 :         ast_update_use_count();</span>
<a name="701"><span class="lineNum">     701 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span><span class="lineNoCov">          0 : static int printdigest(const unsigned char *d)</span>
<span class="lineNum">     704 </span>            : {
<span class="lineNum">     705 </span>            :         int x, pos;
<span class="lineNum">     706 </span>            :         char buf[256]; /* large enough so we don't have to worry */
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :         for (pos = 0, x = 0; x &lt; 16; x++)</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :                 pos += sprintf(buf + pos, &quot; %02hhx&quot;, *d++);</span>
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :         ast_debug(1, &quot;Unexpected signature:%s\n&quot;, buf);</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="714"><span class="lineNum">     714 </span>            : }</a>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineCov">     378118 : static int key_matches(const unsigned char *key1, const unsigned char *key2)</span>
<span class="lineNum">     717 </span>            : {
<span class="lineNum">     718 </span>            :         int x;
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span><span class="lineCov">    6428006 :         for (x = 0; x &lt; 16; x++) {</span>
<span class="lineNum">     721 </span><span class="lineCov">    6049888 :                 if (key1[x] != key2[x])</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :                         return 0;</span>
<span class="lineNum">     723 </span>            :         }
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineCov">     378118 :         return 1;</span>
<a name="726"><span class="lineNum">     726 </span>            : }</a>
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span><span class="lineCov">     378118 : static int verify_key(const unsigned char *key)</span>
<span class="lineNum">     729 </span>            : {
<span class="lineNum">     730 </span>            :         struct MD5Context c;
<span class="lineNum">     731 </span>            :         unsigned char digest[16];
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineCov">     378118 :         MD5Init(&amp;c);</span>
<span class="lineNum">     734 </span><span class="lineCov">     378118 :         MD5Update(&amp;c, key, strlen((char *)key));</span>
<span class="lineNum">     735 </span><span class="lineCov">     378118 :         MD5Final(digest, &amp;c);</span>
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span><span class="lineCov">     378118 :         if (key_matches(expected_key, digest))</span>
<span class="lineNum">     738 </span><span class="lineCov">     378118 :                 return 0;</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :         printdigest(digest);</span>
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :         return -1;</span>
<a name="743"><span class="lineNum">     743 </span>            : }</a>
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span><span class="lineCov">  255485485 : static size_t resource_name_baselen(const char *name)</span>
<span class="lineNum">     746 </span>            : {
<span class="lineNum">     747 </span><span class="lineCov">  255485485 :         size_t len = strlen(name);</span>
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span><span class="lineCov">  255485485 :         if (len &gt; 3 &amp;&amp; !strcasecmp(name + len - 3, &quot;.so&quot;)) {</span>
<span class="lineNum">     750 </span><span class="lineCov">  229338390 :                 return len - 3;</span>
<span class="lineNum">     751 </span>            :         }
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span><span class="lineCov">   26147095 :         return len;</span>
<a name="754"><span class="lineNum">     754 </span>            : }</a>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineCov">  253808784 : static int resource_name_match(const char *name1, size_t baselen1, const char *name2)</span>
<span class="lineNum">     757 </span>            : {
<span class="lineNum">     758 </span><span class="lineCov">  253808784 :         if (baselen1 != resource_name_baselen(name2)) {</span>
<span class="lineNum">     759 </span><span class="lineCov">  240812682 :                 return -1;</span>
<span class="lineNum">     760 </span>            :         }
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span><span class="lineCov">   12996102 :         return strncasecmp(name1, name2, baselen1);</span>
<a name="763"><span class="lineNum">     763 </span>            : }</a>
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span><span class="lineCov">    1279159 : static struct ast_module *find_resource(const char *resource, int do_lock)</span>
<span class="lineNum">     766 </span>            : {
<span class="lineNum">     767 </span>            :         struct ast_module *cur;
<span class="lineNum">     768 </span><span class="lineCov">    1279159 :         size_t resource_baselen = resource_name_baselen(resource);</span>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span><span class="lineCov">    1279159 :         if (do_lock) {</span>
<span class="lineNum">     771 </span><span class="lineCov">         14 :                 AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">     772 </span>            :         }
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span><span class="lineCov">  184551399 :         AST_DLLIST_TRAVERSE(&amp;module_list, cur, entry) {</span>
<span class="lineNum">     775 </span><span class="lineCov">  183673237 :                 if (!resource_name_match(resource, resource_baselen, cur-&gt;resource)) {</span>
<span class="lineNum">     776 </span><span class="lineCov">     400997 :                         break;</span>
<span class="lineNum">     777 </span>            :                 }
<span class="lineNum">     778 </span>            :         }
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span><span class="lineCov">    1279159 :         if (do_lock) {</span>
<span class="lineNum">     781 </span><span class="lineCov">         14 :                 AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">     782 </span>            :         }
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span><span class="lineCov">    1279159 :         return cur;</span>
<span class="lineNum">     785 </span>            : }
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            : /*!
<a name="788"><span class="lineNum">     788 </span>            :  * \brief dlclose(), with failure logging.</a>
<span class="lineNum">     789 </span>            :  */
<span class="lineNum">     790 </span><span class="lineCov">      46847 : static void logged_dlclose(const char *name, void *lib)</span>
<span class="lineNum">     791 </span>            : {
<span class="lineNum">     792 </span>            :         char *error;
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span><span class="lineCov">      46847 :         if (!lib) {</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">     796 </span>            :         }
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :         /* Clear any existing error */
<span class="lineNum">     799 </span><span class="lineCov">      46847 :         dlerror();</span>
<span class="lineNum">     800 </span><span class="lineCov">      46847 :         if (dlclose(lib)) {</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :                 error = dlerror();</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :                 ast_log(AST_LOG_ERROR, &quot;Failure in dlclose for module '%s': %s\n&quot;,</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :                         S_OR(name, &quot;unknown&quot;), S_OR(error, &quot;Unknown error&quot;));</span>
<span class="lineNum">     804 </span>            :         }
<span class="lineNum">     805 </span>            : }
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            : #if defined(HAVE_RTLD_NOLOAD)
<span class="lineNum">     808 </span>            : /*!
<span class="lineNum">     809 </span>            :  * \brief Check to see if the given resource is loaded.
<span class="lineNum">     810 </span>            :  *
<span class="lineNum">     811 </span>            :  * \param resource_name Name of the resource, including .so suffix.
<span class="lineNum">     812 </span>            :  * \return False (0) if module is not loaded.
<a name="813"><span class="lineNum">     813 </span>            :  * \return True (non-zero) if module is loaded.</a>
<span class="lineNum">     814 </span>            :  */
<span class="lineNum">     815 </span><span class="lineCov">          1 : static int is_module_loaded(const char *resource_name)</span>
<span class="lineNum">     816 </span>            : {
<span class="lineNum">     817 </span><span class="lineCov">          1 :         char fn[PATH_MAX] = &quot;&quot;;</span>
<span class="lineNum">     818 </span>            :         void *lib;
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineCov">          1 :         snprintf(fn, sizeof(fn), &quot;%s/%s&quot;, ast_config_AST_MODULE_DIR,</span>
<span class="lineNum">     821 </span>            :                 resource_name);
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineCov">          1 :         lib = dlopen(fn, RTLD_LAZY | RTLD_NOLOAD);</span>
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineCov">          1 :         if (lib) {</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :                 logged_dlclose(resource_name, lib);</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     828 </span>            :         }
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineCov">          1 :         return 0;</span>
<span class="lineNum">     831 </span>            : }
<a name="832"><span class="lineNum">     832 </span>            : #endif</a>
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span><span class="lineCov">          1 : static void unload_dynamic_module(struct ast_module *mod)</span>
<span class="lineNum">     835 </span>            : {
<span class="lineNum">     836 </span>            : #if defined(HAVE_RTLD_NOLOAD)
<span class="lineNum">     837 </span><span class="lineCov">          1 :         char *name = ast_strdupa(ast_module_name(mod));</span>
<span class="lineNum">     838 </span>            : #endif
<span class="lineNum">     839 </span><span class="lineCov">          1 :         void *lib = mod-&gt;lib;</span>
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span>            :         /* WARNING: the structure pointed to by mod is going to
<span class="lineNum">     842 </span>            :            disappear when this operation succeeds, so we can't
<span class="lineNum">     843 </span>            :            dereference it */
<span class="lineNum">     844 </span><span class="lineCov">          1 :         logged_dlclose(ast_module_name(mod), lib);</span>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :         /* There are several situations where the module might still be resident
<span class="lineNum">     847 </span>            :          * in memory.
<span class="lineNum">     848 </span>            :          *
<span class="lineNum">     849 </span>            :          * If somehow there was another dlopen() on the same module (unlikely,
<span class="lineNum">     850 </span>            :          * since that all is supposed to happen in loader.c).
<span class="lineNum">     851 </span>            :          *
<span class="lineNum">     852 </span>            :          * Avoid the temptation of repeating the dlclose(). The other code that
<span class="lineNum">     853 </span>            :          * dlopened the module still has its module reference, and should close
<span class="lineNum">     854 </span>            :          * it itself. In other situations, dlclose() will happily return success
<span class="lineNum">     855 </span>            :          * for as many times as you wish to call it.
<span class="lineNum">     856 </span>            :          */
<span class="lineNum">     857 </span>            : #if defined(HAVE_RTLD_NOLOAD)
<span class="lineNum">     858 </span><span class="lineCov">          1 :         if (is_module_loaded(name)) {</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Module '%s' could not be completely unloaded\n&quot;, name);</span>
<span class="lineNum">     860 </span>            :         }
<span class="lineNum">     861 </span>            : #endif
<span class="lineNum">     862 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : /*!
<span class="lineNum">     865 </span>            :  * \internal
<span class="lineNum">     866 </span>            :  * \brief Attempt to dlopen a module.
<span class="lineNum">     867 </span>            :  *
<span class="lineNum">     868 </span>            :  * \param resource_in The module name to load.
<span class="lineNum">     869 </span>            :  * \param so_ext &quot;.so&quot; or blank if &quot;.so&quot; is already part of resource_in.
<span class="lineNum">     870 </span>            :  * \param filename Passed directly to dlopen.
<span class="lineNum">     871 </span>            :  * \param flags Passed directly to dlopen.
<span class="lineNum">     872 </span>            :  * \param suppress_logging Do not log any error from dlopen.
<span class="lineNum">     873 </span>            :  *
<span class="lineNum">     874 </span>            :  * \return Pointer to opened module, NULL on error.
<span class="lineNum">     875 </span>            :  *
<a name="876"><span class="lineNum">     876 </span>            :  * \warning module_list must be locked before calling this function.</a>
<span class="lineNum">     877 </span>            :  */
<span class="lineNum">     878 </span><span class="lineCov">     546548 : static struct ast_module *load_dlopen(const char *resource_in, const char *so_ext,</span>
<span class="lineNum">     879 </span>            :         const char *filename, int flags, unsigned int suppress_logging)
<span class="lineNum">     880 </span>            : {
<span class="lineNum">     881 </span>            :         struct ast_module *mod;
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span><span class="lineCov">     546548 :         ast_assert(!resource_being_loaded);</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineCov">     546548 :         mod = ast_calloc(1, sizeof(*mod) + strlen(resource_in) + strlen(so_ext) + 1);</span>
<span class="lineNum">     886 </span><span class="lineCov">     546548 :         if (!mod) {</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">     888 </span>            :         }
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineCov">     546548 :         sprintf(mod-&gt;resource, &quot;%s%s&quot;, resource_in, so_ext); /* safe */</span>
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span><span class="lineCov">     546548 :         resource_being_loaded = mod;</span>
<span class="lineNum">     893 </span><span class="lineCov">     546548 :         mod-&gt;lib = dlopen(filename, flags);</span>
<span class="lineNum">     894 </span><span class="lineCov">     546548 :         if (resource_being_loaded) {</span>
<span class="lineNum">     895 </span><span class="lineCov">     139568 :                 resource_being_loaded = NULL;</span>
<span class="lineNum">     896 </span><span class="lineCov">     139568 :                 if (mod-&gt;lib) {</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR, &quot;Module '%s' did not register itself during load\n&quot;, resource_in);</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :                         logged_dlclose(resource_in, mod-&gt;lib);</span>
<span class="lineNum">     899 </span><span class="lineCov">     139568 :                 } else if (!suppress_logging) {</span>
<span class="lineNum">     900 </span><span class="lineCov">      11667 :                         ast_log(LOG_WARNING, &quot;Error loading module '%s': %s\n&quot;, resource_in, dlerror());</span>
<span class="lineNum">     901 </span>            :                 }
<span class="lineNum">     902 </span><span class="lineCov">     139568 :                 ast_free(mod);</span>
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span><span class="lineCov">     139568 :                 return NULL;</span>
<span class="lineNum">     905 </span>            :         }
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineCov">     406980 :         return mod;</span>
<a name="908"><span class="lineNum">     908 </span>            : }</a>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineCov">     499702 : static struct ast_module *load_dynamic_module(const char *resource_in, unsigned int suppress_logging)</span>
<span class="lineNum">     911 </span>            : {
<span class="lineNum">     912 </span>            :         char fn[PATH_MAX];
<span class="lineNum">     913 </span>            :         struct ast_module *mod;
<span class="lineNum">     914 </span><span class="lineCov">     499702 :         size_t resource_in_len = strlen(resource_in);</span>
<span class="lineNum">     915 </span><span class="lineCov">     499702 :         const char *so_ext = &quot;&quot;;</span>
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span><span class="lineCov">     499702 :         if (resource_in_len &lt; 4 || strcasecmp(resource_in + resource_in_len - 3, &quot;.so&quot;)) {</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                 so_ext = &quot;.so&quot;;</span>
<span class="lineNum">     919 </span>            :         }
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span><span class="lineCov">     499702 :         snprintf(fn, sizeof(fn), &quot;%s/%s%s&quot;, ast_config_AST_MODULE_DIR, resource_in, so_ext);</span>
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            :         /* Try loading in quiet mode first with RTLD_LOCAL.  The majority of modules do not
<span class="lineNum">     924 </span>            :          * export symbols so this allows the least number of calls to dlopen. */
<span class="lineNum">     925 </span><span class="lineCov">     499702 :         mod = load_dlopen(resource_in, so_ext, fn, RTLD_NOW | RTLD_LOCAL, suppress_logging);</span>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span><span class="lineCov">     499702 :         if (!mod || !ast_test_flag(mod-&gt;info, AST_MODFLAG_GLOBAL_SYMBOLS)) {</span>
<span class="lineNum">     928 </span><span class="lineCov">     452856 :                 return mod;</span>
<span class="lineNum">     929 </span>            :         }
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :         /* Close the module so we can reopen with correct flags. */
<span class="lineNum">     932 </span><span class="lineCov">      46846 :         logged_dlclose(resource_in, mod-&gt;lib);</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineCov">      46846 :         return load_dlopen(resource_in, so_ext, fn, RTLD_NOW | RTLD_GLOBAL, 0);</span>
<a name="935"><span class="lineNum">     935 </span>            : }</a>
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span><span class="lineCov">       1122 : int modules_shutdown(void)</span>
<span class="lineNum">     938 </span>            : {
<span class="lineNum">     939 </span>            :         struct ast_module *mod;
<span class="lineNum">     940 </span>            :         int somethingchanged;
<span class="lineNum">     941 </span>            :         int res;
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span><span class="lineCov">       1122 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :         /*!\note Some resources, like timers, are started up dynamically, and thus
<span class="lineNum">     946 </span>            :          * may be still in use, even if all channels are dead.  We must therefore
<span class="lineNum">     947 </span>            :          * check the usecount before asking modules to unload. */
<span class="lineNum">     948 </span>            :         do {
<span class="lineNum">     949 </span>            :                 /* Reset flag before traversing the list */
<span class="lineNum">     950 </span><span class="lineCov">       4506 :                 somethingchanged = 0;</span>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineCov">     478740 :                 AST_DLLIST_TRAVERSE_BACKWARDS_SAFE_BEGIN(&amp;module_list, mod, entry) {</span>
<span class="lineNum">     953 </span><span class="lineCov">     474234 :                         if (mod-&gt;usecount) {</span>
<span class="lineNum">     954 </span><span class="lineCov">      96996 :                                 ast_debug(1, &quot;Passing on %s: its use count is %d\n&quot;,</span>
<span class="lineNum">     955 </span>            :                                         mod-&gt;resource, mod-&gt;usecount);
<span class="lineNum">     956 </span><span class="lineCov">      96996 :                                 continue;</span>
<span class="lineNum">     957 </span>            :                         }
<span class="lineNum">     958 </span><span class="lineCov">     377238 :                         AST_DLLIST_REMOVE_CURRENT(entry);</span>
<span class="lineNum">     959 </span><span class="lineCov">     377238 :                         if (mod-&gt;flags.running &amp;&amp; !mod-&gt;flags.declined &amp;&amp; mod-&gt;info-&gt;unload) {</span>
<span class="lineNum">     960 </span><span class="lineCov">     371718 :                                 ast_verb(1, &quot;Unloading %s\n&quot;, mod-&gt;resource);</span>
<span class="lineNum">     961 </span><span class="lineCov">     371718 :                                 mod-&gt;info-&gt;unload();</span>
<span class="lineNum">     962 </span>            :                         }
<span class="lineNum">     963 </span><span class="lineCov">     377238 :                         module_destroy(mod);</span>
<span class="lineNum">     964 </span><span class="lineCov">     377238 :                         somethingchanged = 1;</span>
<span class="lineNum">     965 </span>            :                 }
<span class="lineNum">     966 </span>            :                 AST_DLLIST_TRAVERSE_BACKWARDS_SAFE_END;
<span class="lineNum">     967 </span><span class="lineCov">       4506 :                 if (!somethingchanged) {</span>
<span class="lineNum">     968 </span><span class="lineCov">      50358 :                         AST_DLLIST_TRAVERSE(&amp;module_list, mod, entry) {</span>
<span class="lineNum">     969 </span><span class="lineCov">      48114 :                                 if (mod-&gt;flags.keepuntilshutdown) {</span>
<span class="lineNum">     970 </span><span class="lineCov">      39580 :                                         ast_module_unref(mod);</span>
<span class="lineNum">     971 </span><span class="lineCov">      39580 :                                         mod-&gt;flags.keepuntilshutdown = 0;</span>
<span class="lineNum">     972 </span><span class="lineCov">      39580 :                                         somethingchanged = 1;</span>
<span class="lineNum">     973 </span>            :                                 }
<span class="lineNum">     974 </span>            :                         }
<span class="lineNum">     975 </span>            :                 }
<span class="lineNum">     976 </span><span class="lineCov">       4506 :         } while (somethingchanged);</span>
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span><span class="lineCov">       1122 :         res = AST_DLLIST_EMPTY(&amp;module_list);</span>
<span class="lineNum">     979 </span><span class="lineCov">       1122 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span><span class="lineCov">       1122 :         return !res;</span>
<a name="982"><span class="lineNum">     982 </span>            : }</a>
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span><span class="lineCov">          2 : int ast_unload_resource(const char *resource_name, enum ast_module_unload_mode force)</span>
<span class="lineNum">     985 </span>            : {
<span class="lineNum">     986 </span>            :         struct ast_module *mod;
<span class="lineNum">     987 </span><span class="lineCov">          2 :         int res = -1;</span>
<span class="lineNum">     988 </span><span class="lineCov">          2 :         int error = 0;</span>
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span><span class="lineCov">          2 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span><span class="lineCov">          2 :         if (!(mod = find_resource(resource_name, 0))) {</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :                 AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unload failed, '%s' could not be found\n&quot;, resource_name);</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     996 </span>            :         }
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span><span class="lineCov">          2 :         if (!mod-&gt;flags.running || mod-&gt;flags.declined) {</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unload failed, '%s' is not loaded.\n&quot;, resource_name);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :                 error = 1;</span>
<span class="lineNum">    1001 </span>            :         }
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineCov">          2 :         if (!error &amp;&amp; (mod-&gt;usecount &gt; 0)) {</span>
<span class="lineNum">    1004 </span><span class="lineCov">          1 :                 if (force)</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Warning:  Forcing removal of module '%s' with use count %d\n&quot;,</span>
<span class="lineNum">    1006 </span>            :                                 resource_name, mod-&gt;usecount);
<span class="lineNum">    1007 </span>            :                 else {
<span class="lineNum">    1008 </span><span class="lineCov">          1 :                         ast_log(LOG_WARNING, &quot;Soft unload failed, '%s' has use count %d\n&quot;, resource_name,</span>
<span class="lineNum">    1009 </span>            :                                 mod-&gt;usecount);
<span class="lineNum">    1010 </span><span class="lineCov">          1 :                         error = 1;</span>
<span class="lineNum">    1011 </span>            :                 }
<span class="lineNum">    1012 </span>            :         }
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span><span class="lineCov">          2 :         if (!error) {</span>
<span class="lineNum">    1015 </span>            :                 /* Request any channels attached to the module to hangup. */
<span class="lineNum">    1016 </span><span class="lineCov">          1 :                 __ast_module_user_hangup_all(mod);</span>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineCov">          1 :                 ast_verb(1, &quot;Unloading %s\n&quot;, mod-&gt;resource);</span>
<span class="lineNum">    1019 </span><span class="lineCov">          1 :                 res = mod-&gt;info-&gt;unload();</span>
<span class="lineNum">    1020 </span><span class="lineCov">          1 :                 if (res) {</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Firm unload failed for %s\n&quot;, resource_name);</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                         if (force &lt;= AST_FORCE_FIRM) {</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :                                 error = 1;</span>
<span class="lineNum">    1024 </span>            :                         } else {
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;** Dangerous **: Unloading resource anyway, at user request\n&quot;);</span>
<span class="lineNum">    1026 </span>            :                         }
<span class="lineNum">    1027 </span>            :                 }
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span><span class="lineCov">          1 :                 if (!error) {</span>
<span class="lineNum">    1030 </span>            :                         /*
<span class="lineNum">    1031 </span>            :                          * Request hangup on any channels that managed to get attached
<span class="lineNum">    1032 </span>            :                          * while we called the module unload function.
<span class="lineNum">    1033 </span>            :                          */
<span class="lineNum">    1034 </span><span class="lineCov">          1 :                         __ast_module_user_hangup_all(mod);</span>
<span class="lineNum">    1035 </span><span class="lineCov">          1 :                         sched_yield();</span>
<span class="lineNum">    1036 </span>            :                 }
<span class="lineNum">    1037 </span>            :         }
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span><span class="lineCov">          2 :         if (!error)</span>
<span class="lineNum">    1040 </span><span class="lineCov">          1 :                 mod-&gt;flags.running = mod-&gt;flags.declined = 0;</span>
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span><span class="lineCov">          2 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span><span class="lineCov">          2 :         if (!error) {</span>
<span class="lineNum">    1045 </span><span class="lineCov">          1 :                 unload_dynamic_module(mod);</span>
<span class="lineNum">    1046 </span><span class="lineCov">          1 :                 ast_test_suite_event_notify(&quot;MODULE_UNLOAD&quot;, &quot;Message: %s&quot;, resource_name);</span>
<span class="lineNum">    1047 </span><span class="lineCov">          1 :                 ast_update_use_count();</span>
<span class="lineNum">    1048 </span><span class="lineCov">          1 :                 publish_unload_message(resource_name, &quot;Success&quot;);</span>
<span class="lineNum">    1049 </span>            :         }
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span><span class="lineCov">          2 :         return res;</span>
<a name="1052"><span class="lineNum">    1052 </span>            : }</a>
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 : static int module_matches_helper_type(struct ast_module *mod, enum ast_module_helper_type type)</span>
<span class="lineNum">    1055 </span>            : {
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :         switch (type) {</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :         case AST_MODULE_HELPER_UNLOAD:</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :                 return !mod-&gt;usecount &amp;&amp; mod-&gt;flags.running &amp;&amp; !mod-&gt;flags.declined;</span>
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         case AST_MODULE_HELPER_RELOAD:</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :                 return mod-&gt;flags.running &amp;&amp; mod-&gt;info-&gt;reload;</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :         case AST_MODULE_HELPER_RUNNING:</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :                 return mod-&gt;flags.running;</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :         case AST_MODULE_HELPER_LOADED:</span>
<span class="lineNum">    1067 </span>            :                 /* if we have a 'struct ast_module' then we're loaded. */
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    1070 </span>            :                 /* This function is not called for AST_MODULE_HELPER_LOAD. */
<span class="lineNum">    1071 </span>            :                 /* Unknown ast_module_helper_type. Assume it doesn't match. */
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                 ast_assert(0);</span>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1075 </span>            :         }
<span class="lineNum">    1076 </span>            : }
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            : struct module_load_word {
<span class="lineNum">    1079 </span>            :         const char *word;
<span class="lineNum">    1080 </span>            :         size_t len;
<span class="lineNum">    1081 </span>            :         size_t moddir_len;
<a name="1082"><span class="lineNum">    1082 </span>            : };</a>
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 : static int module_load_helper_on_file(const char *dir_name, const char *filename, void *obj)</span>
<span class="lineNum">    1085 </span>            : {
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :         struct module_load_word *word = obj;</span>
<span class="lineNum">    1087 </span>            :         struct ast_module *mod;
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :         char *filename_merged = NULL;</span>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :         /* dir_name will never be shorter than word-&gt;moddir_len. */
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :         dir_name += word-&gt;moddir_len;</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :         if (!ast_strlen_zero(dir_name)) {</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :                 ast_assert(dir_name[0] == '/');</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :                 dir_name += 1;</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :                 if (ast_asprintf(&amp;filename_merged, &quot;%s/%s&quot;, dir_name, filename) &lt; 0) {</span>
<span class="lineNum">    1097 </span>            :                         /* If we can't allocate the string just give up! */
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    1099 </span>            :                 }
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :                 filename = filename_merged;</span>
<span class="lineNum">    1101 </span>            :         }
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :         if (!strncasecmp(filename, word-&gt;word, word-&gt;len)) {</span>
<span class="lineNum">    1104 </span>            :                 /* Don't list files that are already loaded! */
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :                 mod = find_resource(filename, 0);</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                 if (!mod || !mod-&gt;flags.running) {</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :                         ast_cli_completion_add(ast_strdup(filename));</span>
<span class="lineNum">    1108 </span>            :                 }
<span class="lineNum">    1109 </span>            :         }
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :         ast_free(filename_merged);</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1114"><span class="lineNum">    1114 </span>            : }</a>
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 : static void module_load_helper(const char *word)</span>
<span class="lineNum">    1117 </span>            : {
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :         struct module_load_word word_l = {</span>
<span class="lineNum">    1119 </span>            :                 .word = word,
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :                 .len = strlen(word),</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :                 .moddir_len = strlen(ast_config_AST_MODULE_DIR),</span>
<span class="lineNum">    1122 </span>            :         };
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :         ast_file_read_dirs(ast_config_AST_MODULE_DIR, module_load_helper_on_file, &amp;word_l, -1);</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<a name="1127"><span class="lineNum">    1127 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 : char *ast_module_helper(const char *line, const char *word, int pos, int state, int rpos, enum ast_module_helper_type type)</span>
<span class="lineNum">    1130 </span>            : {
<span class="lineNum">    1131 </span>            :         struct ast_module *mod;
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :         int which = 0;</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :         int wordlen = strlen(word);</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :         char *ret = NULL;</span>
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         if (pos != rpos) {</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1138 </span>            :         }
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :         if (type == AST_MODULE_HELPER_LOAD) {</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :                 module_load_helper(word);</span>
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1144 </span>            :         }
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :         AST_DLLIST_TRAVERSE(&amp;module_list, mod, entry) {</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :                 if (!module_matches_helper_type(mod, type)) {</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1150 </span>            :                 }
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :                 if (!strncasecmp(word, mod-&gt;resource, wordlen) &amp;&amp; ++which &gt; state) {</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :                         ret = ast_strdup(mod-&gt;resource);</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1155 </span>            :                 }
<span class="lineNum">    1156 </span>            :         }
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="1160"><span class="lineNum">    1160 </span>            : }</a>
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span><span class="lineCov">       1123 : void ast_process_pending_reloads(void)</span>
<span class="lineNum">    1163 </span>            : {
<span class="lineNum">    1164 </span>            :         struct reload_queue_item *item;
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span><span class="lineCov">       1123 :         modules_loaded = 1;</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineCov">       1123 :         AST_LIST_LOCK(&amp;reload_queue);</span>
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span><span class="lineCov">       1123 :         if (do_full_reload) {</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :                 do_full_reload = 0;</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :                 AST_LIST_UNLOCK(&amp;reload_queue);</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :                 ast_log(LOG_NOTICE, &quot;Executing deferred reload request.\n&quot;);</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                 ast_module_reload(NULL);</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1176 </span>            :         }
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span><span class="lineCov">       1123 :         while ((item = AST_LIST_REMOVE_HEAD(&amp;reload_queue, entry))) {</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :                 ast_log(LOG_NOTICE, &quot;Executing deferred reload request for module '%s'.\n&quot;, item-&gt;module);</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :                 ast_module_reload(item-&gt;module);</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :                 ast_free(item);</span>
<span class="lineNum">    1182 </span>            :         }
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span><span class="lineCov">       1123 :         AST_LIST_UNLOCK(&amp;reload_queue);</span>
<a name="1185"><span class="lineNum">    1185 </span>            : }</a>
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 : static void queue_reload_request(const char *module)</span>
<span class="lineNum">    1188 </span>            : {
<span class="lineNum">    1189 </span>            :         struct reload_queue_item *item;
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :         AST_LIST_LOCK(&amp;reload_queue);</span>
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :         if (do_full_reload) {</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :                 AST_LIST_UNLOCK(&amp;reload_queue);</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1196 </span>            :         }
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :         if (ast_strlen_zero(module)) {</span>
<span class="lineNum">    1199 </span>            :                 /* A full reload request (when module is NULL) wipes out any previous
<span class="lineNum">    1200 </span>            :                    reload requests and causes the queue to ignore future ones */
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :                 while ((item = AST_LIST_REMOVE_HEAD(&amp;reload_queue, entry))) {</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :                         ast_free(item);</span>
<span class="lineNum">    1203 </span>            :                 }
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :                 do_full_reload = 1;</span>
<span class="lineNum">    1205 </span>            :         } else {
<span class="lineNum">    1206 </span>            :                 /* No reason to add the same module twice */
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :                 AST_LIST_TRAVERSE(&amp;reload_queue, item, entry) {</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :                         if (!strcasecmp(item-&gt;module, module)) {</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :                                 AST_LIST_UNLOCK(&amp;reload_queue);</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :                                 return;</span>
<span class="lineNum">    1211 </span>            :                         }
<span class="lineNum">    1212 </span>            :                 }
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :                 item = ast_calloc(1, sizeof(*item) + strlen(module) + 1);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :                 if (!item) {</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR, &quot;Failed to allocate reload queue item.\n&quot;);</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :                         AST_LIST_UNLOCK(&amp;reload_queue);</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    1218 </span>            :                 }
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :                 strcpy(item-&gt;module, module);</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :                 AST_LIST_INSERT_TAIL(&amp;reload_queue, item, entry);</span>
<span class="lineNum">    1221 </span>            :         }
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :         AST_LIST_UNLOCK(&amp;reload_queue);</span>
<span class="lineNum">    1223 </span>            : }
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span>            : /*!
<span class="lineNum">    1226 </span>            :  * \since 12
<span class="lineNum">    1227 </span>            :  * \internal
<a name="1228"><span class="lineNum">    1228 </span>            :  * \brief Publish a \ref stasis message regarding the type.</a>
<span class="lineNum">    1229 </span>            :  */
<a name="1230"><span class="lineNum">    1230 </span><span class="lineCov">          4 : static void publish_load_message_type(const char* type, const char *name, const char *status)</span></a>
<a name="1231"><span class="lineNum">    1231 </span>            : {</a>
<a name="1232"><span class="lineNum">    1232 </span><span class="lineCov">          8 :         RAII_VAR(struct stasis_message *, message, NULL, ao2_cleanup);</span></a>
<a name="1233"><span class="lineNum">    1233 </span><span class="lineCov">          8 :         RAII_VAR(struct ast_json_payload *, payload, NULL, ao2_cleanup);</span></a>
<span class="lineNum">    1234 </span><span class="lineCov">          8 :         RAII_VAR(struct ast_json *, json_object, NULL, ast_json_unref);</span>
<span class="lineNum">    1235 </span><span class="lineCov">          8 :         RAII_VAR(struct ast_json *, event_object, NULL, ast_json_unref);</span>
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span><span class="lineCov">          4 :         ast_assert(type != NULL);</span>
<span class="lineNum">    1238 </span><span class="lineCov">          4 :         ast_assert(!ast_strlen_zero(name));</span>
<span class="lineNum">    1239 </span><span class="lineCov">          4 :         ast_assert(!ast_strlen_zero(status));</span>
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span><span class="lineCov">          4 :         if (!ast_manager_get_generic_type()) {</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1243 </span>            :         }
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span><span class="lineCov">          4 :         event_object = ast_json_pack(&quot;{s:s, s:s}&quot;,</span>
<span class="lineNum">    1246 </span>            :                         &quot;Module&quot;, name,
<span class="lineNum">    1247 </span>            :                         &quot;Status&quot;, status);
<span class="lineNum">    1248 </span><span class="lineCov">          4 :         json_object = ast_json_pack(&quot;{s:s, s:i, s:o}&quot;,</span>
<span class="lineNum">    1249 </span>            :                         &quot;type&quot;, type,
<span class="lineNum">    1250 </span>            :                         &quot;class_type&quot;, EVENT_FLAG_SYSTEM,
<span class="lineNum">    1251 </span>            :                         &quot;event&quot;, ast_json_ref(event_object));
<span class="lineNum">    1252 </span><span class="lineCov">          4 :         if (!json_object) {</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1254 </span>            :         }
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span><span class="lineCov">          4 :         payload = ast_json_payload_create(json_object);</span>
<span class="lineNum">    1257 </span><span class="lineCov">          4 :         if (!payload) {</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1259 </span>            :         }
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span><span class="lineCov">          4 :         message = stasis_message_create(ast_manager_get_generic_type(), payload);</span>
<span class="lineNum">    1262 </span><span class="lineCov">          4 :         if (!message) {</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1264 </span>            :         }
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span><span class="lineCov">          4 :         stasis_publish(ast_manager_get_topic(), message);</span>
<a name="1267"><span class="lineNum">    1267 </span>            : }</a>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineCov">          2 : static const char* loadresult2str(enum ast_module_load_result result)</span>
<span class="lineNum">    1270 </span>            : {
<span class="lineNum">    1271 </span>            :         int i;
<span class="lineNum">    1272 </span><span class="lineCov">          3 :         for (i = 0; i &lt; ARRAY_LEN(load_results); i++) {</span>
<span class="lineNum">    1273 </span><span class="lineCov">          3 :                 if (load_results[i].result == result) {</span>
<span class="lineNum">    1274 </span><span class="lineCov">          2 :                         return load_results[i].name;</span>
<span class="lineNum">    1275 </span>            :                 }
<span class="lineNum">    1276 </span>            :         }
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :         ast_log(LOG_WARNING, &quot;Failed to find correct load result status. result %d\n&quot;, result);</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :         return AST_MODULE_LOAD_UNKNOWN_STRING;</span>
<span class="lineNum">    1280 </span>            : }
<span class="lineNum">    1281 </span>            : 
<span class="lineNum">    1282 </span>            : /*!
<span class="lineNum">    1283 </span>            :  * \internal
<a name="1284"><span class="lineNum">    1284 </span>            :  * \brief Publish a \ref stasis message regarding the load result</a>
<span class="lineNum">    1285 </span>            :  */
<span class="lineNum">    1286 </span><span class="lineCov">          2 : static void publish_load_message(const char *name, enum ast_module_load_result result)</span>
<span class="lineNum">    1287 </span>            : {
<span class="lineNum">    1288 </span>            :         const char *status;
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span><span class="lineCov">          2 :         status = loadresult2str(result);</span>
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span><span class="lineCov">          2 :         publish_load_message_type(&quot;Load&quot;, name, status);</span>
<span class="lineNum">    1293 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            : /*!
<span class="lineNum">    1296 </span>            :  * \internal
<a name="1297"><span class="lineNum">    1297 </span>            :  * \brief Publish a \ref stasis message regarding the unload result</a>
<span class="lineNum">    1298 </span>            :  */
<span class="lineNum">    1299 </span><span class="lineCov">          1 : static void publish_unload_message(const char *name, const char* status)</span>
<span class="lineNum">    1300 </span>            : {
<span class="lineNum">    1301 </span><span class="lineCov">          1 :         publish_load_message_type(&quot;Unload&quot;, name, status);</span>
<span class="lineNum">    1302 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span>            : /*!
<span class="lineNum">    1305 </span>            :  * \since 12
<span class="lineNum">    1306 </span>            :  * \internal
<a name="1307"><span class="lineNum">    1307 </span>            :  * \brief Publish a \ref stasis message regarding the reload result</a>
<span class="lineNum">    1308 </span>            :  */
<span class="lineNum">    1309 </span><span class="lineCov">          1 : static void publish_reload_message(const char *name, enum ast_module_reload_result result)</span>
<span class="lineNum">    1310 </span>            : {
<span class="lineNum">    1311 </span>            :         char res_buffer[8];
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span><span class="lineCov">          1 :         snprintf(res_buffer, sizeof(res_buffer), &quot;%u&quot;, result);</span>
<span class="lineNum">    1314 </span><span class="lineCov">          1 :         publish_load_message_type(&quot;Reload&quot;, S_OR(name, &quot;All&quot;), res_buffer);</span>
<a name="1315"><span class="lineNum">    1315 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span><span class="lineCov">          1 : enum ast_module_reload_result ast_module_reload(const char *name)</span>
<span class="lineNum">    1318 </span>            : {
<span class="lineNum">    1319 </span>            :         struct ast_module *cur;
<span class="lineNum">    1320 </span><span class="lineCov">          1 :         enum ast_module_reload_result res = AST_MODULE_RELOAD_NOT_FOUND;</span>
<span class="lineNum">    1321 </span><span class="lineCov">          1 :         size_t name_baselen = name ? resource_name_baselen(name) : 0;</span>
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span>            :         /* If we aren't fully booted, we just pretend we reloaded but we queue this
<span class="lineNum">    1324 </span>            :            up to run once we are booted up. */
<span class="lineNum">    1325 </span><span class="lineCov">          1 :         if (!modules_loaded) {</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :                 queue_reload_request(name);</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :                 res = AST_MODULE_RELOAD_QUEUED;</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :                 goto module_reload_exit;</span>
<span class="lineNum">    1329 </span>            :         }
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span><span class="lineCov">          1 :         if (ast_mutex_trylock(&amp;reloadlock)) {</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :                 ast_verb(3, &quot;The previous reload command didn't finish yet\n&quot;);</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :                 res = AST_MODULE_RELOAD_IN_PROGRESS;</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :                 goto module_reload_exit;</span>
<span class="lineNum">    1335 </span>            :         }
<span class="lineNum">    1336 </span><span class="lineCov">          1 :         ast_sd_notify(&quot;RELOAD=1&quot;);</span>
<span class="lineNum">    1337 </span><span class="lineCov">          1 :         ast_lastreloadtime = ast_tvnow();</span>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span><span class="lineCov">          1 :         if (ast_opt_lock_confdir) {</span>
<span class="lineNum">    1340 </span>            :                 int try;
<span class="lineNum">    1341 </span>            :                 int res;
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :                 for (try = 1, res = AST_LOCK_TIMEOUT; try &lt; 6 &amp;&amp; (res == AST_LOCK_TIMEOUT); try++) {</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :                         res = ast_lock_path(ast_config_AST_CONFIG_DIR);</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :                         if (res == AST_LOCK_TIMEOUT) {</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;Failed to grab lock on %s, try %d\n&quot;, ast_config_AST_CONFIG_DIR, try);</span>
<span class="lineNum">    1346 </span>            :                         }
<span class="lineNum">    1347 </span>            :                 }
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :                 if (res != AST_LOCK_SUCCESS) {</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :                         ast_log(AST_LOG_WARNING, &quot;Cannot grab lock on %s\n&quot;, ast_config_AST_CONFIG_DIR);</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :                         res = AST_MODULE_RELOAD_ERROR;</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :                         goto module_reload_done;</span>
<span class="lineNum">    1352 </span>            :                 }
<span class="lineNum">    1353 </span>            :         }
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span><span class="lineCov">          1 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">    1356 </span><span class="lineCov">        139 :         AST_DLLIST_TRAVERSE(&amp;module_list, cur, entry) {</span>
<span class="lineNum">    1357 </span><span class="lineCov">        139 :                 const struct ast_module_info *info = cur-&gt;info;</span>
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span><span class="lineCov">        139 :                 if (name &amp;&amp; resource_name_match(name, name_baselen, cur-&gt;resource)) {</span>
<span class="lineNum">    1360 </span><span class="lineCov">        138 :                         continue;</span>
<span class="lineNum">    1361 </span>            :                 }
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span><span class="lineCov">          1 :                 if (!cur-&gt;flags.running || cur-&gt;flags.declined) {</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :                         if (res == AST_MODULE_RELOAD_NOT_FOUND) {</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :                                 res = AST_MODULE_RELOAD_UNINITIALIZED;</span>
<span class="lineNum">    1366 </span>            :                         }
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :                         if (!name) {</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    1369 </span>            :                         }
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1371 </span>            :                 }
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span><span class="lineCov">          1 :                 if (!info-&gt;reload) { /* cannot be reloaded */</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :                         if (res == AST_MODULE_RELOAD_NOT_FOUND) {</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :                                 res = AST_MODULE_RELOAD_NOT_IMPLEMENTED;</span>
<span class="lineNum">    1376 </span>            :                         }
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :                         if (!name) {</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    1379 </span>            :                         }
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1381 </span>            :                 }
<span class="lineNum">    1382 </span><span class="lineCov">          1 :                 ast_verb(3, &quot;Reloading module '%s' (%s)\n&quot;, cur-&gt;resource, info-&gt;description);</span>
<span class="lineNum">    1383 </span><span class="lineCov">          1 :                 if (info-&gt;reload() == AST_MODULE_LOAD_SUCCESS) {</span>
<span class="lineNum">    1384 </span><span class="lineCov">          1 :                         res = AST_MODULE_RELOAD_SUCCESS;</span>
<span class="lineNum">    1385 </span>            :                 }
<span class="lineNum">    1386 </span><span class="lineCov">          1 :                 if (name) {</span>
<span class="lineNum">    1387 </span><span class="lineCov">          1 :                         break;</span>
<span class="lineNum">    1388 </span>            :                 }
<span class="lineNum">    1389 </span>            :         }
<span class="lineNum">    1390 </span><span class="lineCov">          1 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span><span class="lineCov">          1 :         if (ast_opt_lock_confdir) {</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :                 ast_unlock_path(ast_config_AST_CONFIG_DIR);</span>
<span class="lineNum">    1394 </span>            :         }
<span class="lineNum">    1395 </span><span class="lineCov">          1 : module_reload_done:</span>
<span class="lineNum">    1396 </span><span class="lineCov">          1 :         ast_mutex_unlock(&amp;reloadlock);</span>
<span class="lineNum">    1397 </span><span class="lineCov">          1 :         ast_sd_notify(&quot;READY=1&quot;);</span>
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span><span class="lineCov">          1 : module_reload_exit:</span>
<span class="lineNum">    1400 </span><span class="lineCov">          1 :         publish_reload_message(name, res);</span>
<span class="lineNum">    1401 </span><span class="lineCov">          1 :         return res;</span>
<a name="1402"><span class="lineNum">    1402 </span>            : }</a>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span><span class="lineCov">     378118 : static unsigned int inspect_module(const struct ast_module *mod)</span>
<span class="lineNum">    1405 </span>            : {
<span class="lineNum">    1406 </span><span class="lineCov">     378118 :         if (!mod-&gt;info-&gt;description) {</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Module '%s' does not provide a description.\n&quot;, mod-&gt;resource);</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">    1409 </span>            :         }
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span><span class="lineCov">     378118 :         if (!mod-&gt;info-&gt;key) {</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Module '%s' does not provide a license key.\n&quot;, mod-&gt;resource);</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">    1414 </span>            :         }
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span><span class="lineCov">     378118 :         if (verify_key((unsigned char *) mod-&gt;info-&gt;key)) {</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Module '%s' did not provide a valid license key.\n&quot;, mod-&gt;resource);</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">    1419 </span>            :         }
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span><span class="lineCov">     378118 :         if (!ast_strlen_zero(mod-&gt;info-&gt;buildopt_sum) &amp;&amp;</span>
<span class="lineNum">    1422 </span><span class="lineCov">     371384 :             strcmp(buildopt_sum, mod-&gt;info-&gt;buildopt_sum)) {</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Module '%s' was not compiled with the same compile-time options as this version of Asterisk.\n&quot;, mod-&gt;resource);</span>
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Module '%s' will not be initialized as it may cause instability.\n&quot;, mod-&gt;resource);</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">    1426 </span>            :         }
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span><span class="lineCov">     378118 :         return 0;</span>
<a name="1429"><span class="lineNum">    1429 </span>            : }</a>
<span class="lineNum">    1430 </span>            : 
<span class="lineNum">    1431 </span><span class="lineCov">     378097 : static enum ast_module_load_result start_resource(struct ast_module *mod)</span>
<span class="lineNum">    1432 </span>            : {
<span class="lineNum">    1433 </span>            :         char tmp[256];
<span class="lineNum">    1434 </span>            :         enum ast_module_load_result res;
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span><span class="lineCov">     378097 :         if (mod-&gt;flags.running) {</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_SUCCESS;</span>
<span class="lineNum">    1438 </span>            :         }
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span><span class="lineCov">     378097 :         if (!mod-&gt;info-&gt;load) {</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_FAILURE;</span>
<span class="lineNum">    1442 </span>            :         }
<span class="lineNum">    1443 </span>            : 
<span class="lineNum">    1444 </span><span class="lineCov">     378097 :         if (module_deps_reference(mod, NULL)) {</span>
<span class="lineNum">    1445 </span>            :                 struct module_vector missing;
<span class="lineNum">    1446 </span>            :                 int i;
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :                 AST_VECTOR_INIT(&amp;missing, 0);</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :                 if (module_deps_missing_recursive(mod, &amp;missing)) {</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR, &quot;%s has one or more unknown dependencies.\n&quot;, mod-&gt;info-&gt;name);</span>
<span class="lineNum">    1451 </span>            :                 }
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :                 for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;missing); i++) {</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR, &quot;%s loaded before dependency %s!\n&quot;, mod-&gt;info-&gt;name,</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :                                 AST_VECTOR_GET(&amp;missing, i)-&gt;info-&gt;name);</span>
<span class="lineNum">    1455 </span>            :                 }
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :                 AST_VECTOR_FREE(&amp;missing);</span>
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :                 return AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    1459 </span>            :         }
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span><span class="lineCov">     378097 :         if (!ast_fully_booted) {</span>
<span class="lineNum">    1462 </span><span class="lineCov">     378095 :                 ast_verb(1, &quot;Loading %s.\n&quot;, mod-&gt;resource);</span>
<span class="lineNum">    1463 </span>            :         }
<span class="lineNum">    1464 </span><span class="lineCov">     378097 :         res = mod-&gt;info-&gt;load();</span>
<span class="lineNum">    1465 </span>            : 
<span class="lineNum">    1466 </span><span class="lineCov">     378097 :         switch (res) {</span>
<span class="lineNum">    1467 </span><span class="lineCov">     372569 :         case AST_MODULE_LOAD_SUCCESS:</span>
<span class="lineNum">    1468 </span><span class="lineCov">     372569 :                 if (!ast_fully_booted) {</span>
<span class="lineNum">    1469 </span><span class="lineCov">     372568 :                         ast_verb(2, &quot;%s =&gt; (%s)\n&quot;, mod-&gt;resource, term_color(tmp, mod-&gt;info-&gt;description, COLOR_BROWN, COLOR_BLACK, sizeof(tmp)));</span>
<span class="lineNum">    1470 </span>            :                 } else {
<span class="lineNum">    1471 </span><span class="lineCov">          1 :                         ast_verb(1, &quot;Loaded %s =&gt; (%s)\n&quot;, mod-&gt;resource, mod-&gt;info-&gt;description);</span>
<span class="lineNum">    1472 </span>            :                 }
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span><span class="lineCov">     372569 :                 mod-&gt;flags.running = 1;</span>
<span class="lineNum">    1475 </span><span class="lineCov">     372569 :                 if (mod-&gt;flags.builtin) {</span>
<span class="lineNum">    1476 </span>            :                         /* Built-in modules cannot be unloaded. */
<span class="lineNum">    1477 </span><span class="lineCov">      17984 :                         ast_module_shutdown_ref(mod);</span>
<span class="lineNum">    1478 </span>            :                 }
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span><span class="lineCov">     372569 :                 ast_update_use_count();</span>
<span class="lineNum">    1481 </span><span class="lineCov">     372569 :                 break;</span>
<span class="lineNum">    1482 </span><span class="lineCov">       5527 :         case AST_MODULE_LOAD_DECLINE:</span>
<span class="lineNum">    1483 </span><span class="lineCov">       5527 :                 mod-&gt;flags.declined = 1;</span>
<span class="lineNum">    1484 </span><span class="lineCov">       5527 :                 if (mod-&gt;flags.required) {</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :                         res = AST_MODULE_LOAD_FAILURE;</span>
<span class="lineNum">    1486 </span>            :                 }
<span class="lineNum">    1487 </span><span class="lineCov">       5527 :                 break;</span>
<span class="lineNum">    1488 </span><span class="lineCov">          1 :         case AST_MODULE_LOAD_FAILURE:</span>
<span class="lineNum">    1489 </span>            :         case AST_MODULE_LOAD_SKIP: /* modules should never return this value */
<span class="lineNum">    1490 </span>            :         case AST_MODULE_LOAD_PRIORITY:
<span class="lineNum">    1491 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">    1492 </span>            :         }
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            :         /* Make sure the newly started module is at the end of the list */
<span class="lineNum">    1495 </span><span class="lineCov">     378097 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">    1496 </span><span class="lineCov">     378097 :         AST_DLLIST_REMOVE(&amp;module_list, mod, entry);</span>
<span class="lineNum">    1497 </span><span class="lineCov">     378097 :         AST_DLLIST_INSERT_TAIL(&amp;module_list, mod, entry);</span>
<span class="lineNum">    1498 </span><span class="lineCov">     378097 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span><span class="lineCov">     378097 :         return res;</span>
<span class="lineNum">    1501 </span>            : }
<span class="lineNum">    1502 </span>            : 
<span class="lineNum">    1503 </span>            : /*! loads a resource based upon resource_name. If global_symbols_only is set
<span class="lineNum">    1504 </span>            :  *  only modules with global symbols will be loaded.
<span class="lineNum">    1505 </span>            :  *
<span class="lineNum">    1506 </span>            :  *  If the module_vector is provided (not NULL) the module is found and added to the
<span class="lineNum">    1507 </span>            :  *  vector without running the module's load() function.  By doing this, modules
<span class="lineNum">    1508 </span>            :  *  can be initialized later in order by priority and dependencies.
<span class="lineNum">    1509 </span>            :  *
<a name="1510"><span class="lineNum">    1510 </span>            :  *  If the module_vector is not provided, the module's load function will be executed</a>
<span class="lineNum">    1511 </span>            :  *  immediately */
<span class="lineNum">    1512 </span><span class="lineCov">     517686 : static enum ast_module_load_result load_resource(const char *resource_name, unsigned int suppress_logging,</span>
<span class="lineNum">    1513 </span>            :         struct module_vector *module_priorities, int required, int preload)
<span class="lineNum">    1514 </span>            : {
<span class="lineNum">    1515 </span>            :         struct ast_module *mod;
<span class="lineNum">    1516 </span><span class="lineCov">     517686 :         enum ast_module_load_result res = AST_MODULE_LOAD_SUCCESS;</span>
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span><span class="lineCov">     517686 :         if ((mod = find_resource(resource_name, 0))) {</span>
<span class="lineNum">    1519 </span><span class="lineCov">      17984 :                 if (mod-&gt;flags.running) {</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Module '%s' already loaded and running.\n&quot;, resource_name);</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :                         return AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    1522 </span>            :                 }
<span class="lineNum">    1523 </span>            :         } else {
<span class="lineNum">    1524 </span><span class="lineCov">     499702 :                 mod = load_dynamic_module(resource_name, suppress_logging);</span>
<span class="lineNum">    1525 </span><span class="lineCov">     499702 :                 if (!mod) {</span>
<span class="lineNum">    1526 </span><span class="lineCov">     139568 :                         return required ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    1527 </span>            :                 }
<span class="lineNum">    1528 </span>            : 
<span class="lineNum">    1529 </span>            :                 /* Split lists from mod-&gt;info. */
<span class="lineNum">    1530 </span><span class="lineCov">     360134 :                 res  = ast_vector_string_split(&amp;mod-&gt;requires, mod-&gt;info-&gt;requires, &quot;,&quot;, 0, strcasecmp);</span>
<span class="lineNum">    1531 </span><span class="lineCov">     360134 :                 res |= ast_vector_string_split(&amp;mod-&gt;optional_modules, mod-&gt;info-&gt;optional_modules, &quot;,&quot;, 0, strcasecmp);</span>
<span class="lineNum">    1532 </span><span class="lineCov">     360134 :                 res |= ast_vector_string_split(&amp;mod-&gt;enhances, mod-&gt;info-&gt;enhances, &quot;,&quot;, 0, strcasecmp);</span>
<span class="lineNum">    1533 </span><span class="lineCov">     360134 :                 if (res) {</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :                         goto prestart_error;</span>
<span class="lineNum">    1535 </span>            :                 }
<span class="lineNum">    1536 </span>            :         }
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span><span class="lineCov">     378118 :         mod-&gt;flags.required |= required;</span>
<span class="lineNum">    1539 </span><span class="lineCov">     378118 :         mod-&gt;flags.preload |= preload;</span>
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span><span class="lineCov">     378118 :         if (inspect_module(mod)) {</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :                 goto prestart_error;</span>
<span class="lineNum">    1543 </span>            :         }
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span><span class="lineCov">     378118 :         mod-&gt;flags.declined = 0;</span>
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span><span class="lineCov">     378118 :         if (module_priorities) {</span>
<span class="lineNum">    1548 </span><span class="lineCov">   20811806 :                 if (AST_VECTOR_ADD_SORTED(module_priorities, mod, module_vector_cmp)) {</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :                         goto prestart_error;</span>
<span class="lineNum">    1550 </span>            :                 }
<span class="lineNum">    1551 </span><span class="lineCov">     378116 :                 res = AST_MODULE_LOAD_PRIORITY;</span>
<span class="lineNum">    1552 </span>            :         } else {
<span class="lineNum">    1553 </span><span class="lineCov">          2 :                 res = start_resource(mod);</span>
<span class="lineNum">    1554 </span>            :         }
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span><span class="lineCov">     378118 :         if (ast_fully_booted &amp;&amp; !ast_shutdown_final()) {</span>
<span class="lineNum">    1557 </span><span class="lineCov">          2 :                 publish_load_message(resource_name, res);</span>
<span class="lineNum">    1558 </span>            :         }
<span class="lineNum">    1559 </span>            : 
<span class="lineNum">    1560 </span><span class="lineCov">     378118 :         return res;</span>
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 : prestart_error:</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :         ast_log(LOG_WARNING, &quot;Module '%s' could not be loaded.\n&quot;, resource_name);</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :         unload_dynamic_module(mod);</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :         res = required ? AST_MODULE_LOAD_FAILURE : AST_MODULE_LOAD_DECLINE;</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :         if (ast_fully_booted &amp;&amp; !ast_shutdown_final()) {</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :                 publish_load_message(resource_name, res);</span>
<span class="lineNum">    1568 </span>            :         }
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :         return res;</span>
<a name="1570"><span class="lineNum">    1570 </span>            : }</a>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineCov">          3 : int ast_load_resource(const char *resource_name)</span>
<span class="lineNum">    1573 </span>            : {
<span class="lineNum">    1574 </span>            :         int res;
<span class="lineNum">    1575 </span><span class="lineCov">          3 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">    1576 </span><span class="lineCov">          3 :         res = load_resource(resource_name, 0, NULL, 0, 0);</span>
<span class="lineNum">    1577 </span><span class="lineCov">          3 :         if (!res) {</span>
<span class="lineNum">    1578 </span><span class="lineCov">          1 :                 ast_test_suite_event_notify(&quot;MODULE_LOAD&quot;, &quot;Message: %s&quot;, resource_name);</span>
<span class="lineNum">    1579 </span>            :         }
<span class="lineNum">    1580 </span><span class="lineCov">          3 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">    1581 </span>            : 
<span class="lineNum">    1582 </span><span class="lineCov">          3 :         return res;</span>
<span class="lineNum">    1583 </span>            : }
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span>            : struct load_order_entry {
<span class="lineNum">    1586 </span>            :         char *resource;
<span class="lineNum">    1587 </span>            :         int required;
<span class="lineNum">    1588 </span>            :         int preload;
<span class="lineNum">    1589 </span>            :         int builtin;
<span class="lineNum">    1590 </span>            :         AST_LIST_ENTRY(load_order_entry) entry;
<span class="lineNum">    1591 </span>            : };
<span class="lineNum">    1592 </span>            : 
<a name="1593"><span class="lineNum">    1593 </span>            : AST_LIST_HEAD_NOLOCK(load_order, load_order_entry);</a>
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span><span class="lineCov">     391976 : static struct load_order_entry *add_to_load_order(const char *resource, struct load_order *load_order, int required, int preload, int builtin)</span>
<span class="lineNum">    1596 </span>            : {
<span class="lineNum">    1597 </span>            :         struct load_order_entry *order;
<span class="lineNum">    1598 </span><span class="lineCov">     391976 :         size_t resource_baselen = resource_name_baselen(resource);</span>
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineCov">   68588509 :         AST_LIST_TRAVERSE(load_order, order, entry) {</span>
<span class="lineNum">    1601 </span><span class="lineCov">   68196542 :                 if (!resource_name_match(resource, resource_baselen, order-&gt;resource)) {</span>
<span class="lineNum">    1602 </span>            :                         /* Make sure we have the proper setting for the required field
<span class="lineNum">    1603 </span>            :                            (we might have both load= and required= lines in modules.conf) */
<span class="lineNum">    1604 </span><span class="lineCov">          9 :                         order-&gt;required |= required;</span>
<span class="lineNum">    1605 </span><span class="lineCov">          9 :                         order-&gt;preload |= preload;</span>
<span class="lineNum">    1606 </span><span class="lineCov">          9 :                         return order;</span>
<span class="lineNum">    1607 </span>            :                 }
<span class="lineNum">    1608 </span>            :         }
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span><span class="lineCov">     391967 :         order = ast_calloc(1, sizeof(*order));</span>
<span class="lineNum">    1611 </span><span class="lineCov">     391967 :         if (!order) {</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1613 </span>            :         }
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span><span class="lineCov">     391967 :         order-&gt;resource = ast_strdup(resource);</span>
<span class="lineNum">    1616 </span><span class="lineCov">     391967 :         if (!order-&gt;resource) {</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :                 ast_free(order);</span>
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1620 </span>            :         }
<span class="lineNum">    1621 </span><span class="lineCov">     391967 :         order-&gt;required = required;</span>
<span class="lineNum">    1622 </span><span class="lineCov">     391967 :         order-&gt;preload = preload;</span>
<span class="lineNum">    1623 </span><span class="lineCov">     391967 :         order-&gt;builtin = builtin;</span>
<span class="lineNum">    1624 </span><span class="lineCov">     391967 :         AST_LIST_INSERT_TAIL(load_order, order, entry);</span>
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span><span class="lineCov">     391967 :         return order;</span>
<span class="lineNum">    1627 </span>            : }
<span class="lineNum">    1628 </span>            : 
<a name="1629"><span class="lineNum">    1629 </span>            : AST_LIST_HEAD_NOLOCK(load_retries, load_order_entry);</a>
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span><span class="lineCov">     381203 : static enum ast_module_load_result start_resource_attempt(struct ast_module *mod, int *count)</span>
<span class="lineNum">    1632 </span>            : {
<span class="lineNum">    1633 </span>            :         enum ast_module_load_result lres;
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span>            :         /* Try to grab required references. */
<span class="lineNum">    1636 </span><span class="lineCov">     381203 :         if (module_deps_reference(mod, NULL)) {</span>
<span class="lineNum">    1637 </span>            :                 /* We're likely to retry so not an error. */
<span class="lineNum">    1638 </span><span class="lineCov">       3108 :                 ast_debug(1, &quot;Module %s is missing dependencies\n&quot;, mod-&gt;resource);</span>
<span class="lineNum">    1639 </span><span class="lineCov">       3108 :                 return AST_MODULE_LOAD_SKIP;</span>
<span class="lineNum">    1640 </span>            :         }
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span><span class="lineCov">     378095 :         lres = start_resource(mod);</span>
<span class="lineNum">    1643 </span><span class="lineCov">     378095 :         ast_debug(3, &quot;START: %-46s[%d] %d\n&quot;,</span>
<span class="lineNum">    1644 </span>            :                 mod-&gt;resource,
<span class="lineNum">    1645 </span>            :                 ast_test_flag(mod-&gt;info, AST_MODFLAG_LOAD_ORDER) ? mod-&gt;info-&gt;load_pri : AST_MODPRI_DEFAULT,
<span class="lineNum">    1646 </span>            :                 lres);
<span class="lineNum">    1647 </span>            : 
<span class="lineNum">    1648 </span><span class="lineCov">     378095 :         if (lres == AST_MODULE_LOAD_SUCCESS) {</span>
<span class="lineNum">    1649 </span><span class="lineCov">     372568 :                 (*count)++;</span>
<span class="lineNum">    1650 </span><span class="lineCov">       5527 :         } else if (lres == AST_MODULE_LOAD_FAILURE) {</span>
<span class="lineNum">    1651 </span><span class="lineCov">          1 :                 ast_log(LOG_ERROR, &quot;*** Failed to load module %s\n&quot;, mod-&gt;resource);</span>
<span class="lineNum">    1652 </span>            :         }
<span class="lineNum">    1653 </span>            : 
<span class="lineNum">    1654 </span><span class="lineCov">     378095 :         return lres;</span>
<a name="1655"><span class="lineNum">    1655 </span>            : }</a>
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span><span class="lineCov">       1124 : static int start_resource_list(struct module_vector *resources, int *mod_count)</span>
<span class="lineNum">    1658 </span>            : {
<span class="lineNum">    1659 </span>            :         struct module_vector missingdeps;
<span class="lineNum">    1660 </span><span class="lineCov">       1124 :         int res = 0;</span>
<span class="lineNum">    1661 </span>            : 
<span class="lineNum">    1662 </span><span class="lineCov">       1124 :         AST_VECTOR_INIT(&amp;missingdeps, 0);</span>
<span class="lineNum">    1663 </span><span class="lineCov">     374985 :         while (AST_VECTOR_SIZE(resources)) {</span>
<span class="lineNum">    1664 </span><span class="lineCov">     373862 :                 struct ast_module *mod = AST_VECTOR_REMOVE(resources, 0, 1);</span>
<span class="lineNum">    1665 </span>            :                 enum ast_module_load_result lres;
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span><span class="lineCov">     376970 : retry_load:</span>
<span class="lineNum">    1668 </span><span class="lineCov">     376970 :                 lres = start_resource_attempt(mod, mod_count);</span>
<span class="lineNum">    1669 </span><span class="lineCov">     376970 :                 if (lres == AST_MODULE_LOAD_SUCCESS) {</span>
<span class="lineNum">    1670 </span>            :                         /* No missing dependencies, successful. */
<span class="lineNum">    1671 </span><span class="lineCov">     368335 :                         continue;</span>
<span class="lineNum">    1672 </span>            :                 }
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span><span class="lineCov">       8635 :                 if (lres == AST_MODULE_LOAD_FAILURE) {</span>
<span class="lineNum">    1675 </span><span class="lineCov">          1 :                         ast_log(LOG_ERROR, &quot;Failed to load %s.\n&quot;, ast_module_name(mod));</span>
<span class="lineNum">    1676 </span><span class="lineCov">          1 :                         res = -2;</span>
<span class="lineNum">    1677 </span><span class="lineCov">          1 :                         break;</span>
<span class="lineNum">    1678 </span>            :                 }
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span><span class="lineCov">       8634 :                 if (lres == AST_MODULE_LOAD_DECLINE) {</span>
<span class="lineNum">    1681 </span><span class="lineCov">       5526 :                         continue;</span>
<span class="lineNum">    1682 </span>            :                 }
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span><span class="lineCov">       3108 :                 res = module_deps_missing_recursive(mod, &amp;missingdeps);</span>
<span class="lineNum">    1685 </span><span class="lineCov">       3108 :                 if (res) {</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :                         AST_VECTOR_RESET(&amp;missingdeps, AST_VECTOR_ELEM_CLEANUP_NOOP);</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR, &quot;Failed to resolve dependencies for %s\n&quot;, ast_module_name(mod));</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :                         mod-&gt;flags.declined = 1;</span>
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1691 </span>            :                 }
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span><span class="lineCov">       3108 :                 if (!AST_VECTOR_SIZE(&amp;missingdeps)) {</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;%s load function returned an invalid result. &quot;</span>
<span class="lineNum">    1695 </span>            :                                 &quot;This is a bug in the module.\n&quot;, ast_module_name(mod));
<span class="lineNum">    1696 </span>            :                         /* Dependencies were met but the module failed to start and the result
<span class="lineNum">    1697 </span>            :                          * code was not AST_MODULE_LOAD_FAILURE or AST_MODULE_LOAD_DECLINE. */
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :                         res = -1;</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    1700 </span>            :                 }
<span class="lineNum">    1701 </span>            : 
<span class="lineNum">    1702 </span><span class="lineCov">       3108 :                 ast_debug(1, &quot;%s has %d dependencies\n&quot;,</span>
<span class="lineNum">    1703 </span>            :                         ast_module_name(mod), (int)AST_VECTOR_SIZE(&amp;missingdeps));
<span class="lineNum">    1704 </span><span class="lineCov">       6216 :                 while (AST_VECTOR_SIZE(&amp;missingdeps)) {</span>
<span class="lineNum">    1705 </span><span class="lineCov">       3108 :                         int didwork = 0;</span>
<span class="lineNum">    1706 </span><span class="lineCov">       3108 :                         int i = 0;</span>
<span class="lineNum">    1707 </span>            : 
<span class="lineNum">    1708 </span><span class="lineCov">       7341 :                         while (i &lt; AST_VECTOR_SIZE(&amp;missingdeps)) {</span>
<span class="lineNum">    1709 </span><span class="lineCov">       4233 :                                 struct ast_module *dep = AST_VECTOR_GET(&amp;missingdeps, i);</span>
<span class="lineNum">    1710 </span>            : 
<span class="lineNum">    1711 </span><span class="lineCov">       4233 :                                 ast_debug(1, &quot;%s trying to start %s\n&quot;, ast_module_name(mod), ast_module_name(dep));</span>
<span class="lineNum">    1712 </span><span class="lineCov">       4233 :                                 if (!start_resource_attempt(dep, mod_count)) {</span>
<span class="lineNum">    1713 </span><span class="lineCov">       4233 :                                         ast_debug(1, &quot;%s started %s\n&quot;, ast_module_name(mod), ast_module_name(dep));</span>
<span class="lineNum">    1714 </span><span class="lineCov">       4233 :                                         AST_VECTOR_REMOVE(&amp;missingdeps, i, 1);</span>
<span class="lineNum">    1715 </span><span class="lineCov">     289672 :                                         AST_VECTOR_REMOVE_CMP_ORDERED(resources, dep,</span>
<span class="lineNum">    1716 </span>            :                                                 AST_VECTOR_ELEM_DEFAULT_CMP, AST_VECTOR_ELEM_CLEANUP_NOOP);
<span class="lineNum">    1717 </span><span class="lineCov">       4233 :                                         didwork++;</span>
<span class="lineNum">    1718 </span><span class="lineCov">       4233 :                                         continue;</span>
<span class="lineNum">    1719 </span>            :                                 }
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :                                 ast_debug(1, &quot;%s failed to start %s\n&quot;, ast_module_name(mod), ast_module_name(dep));</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :                                 i++;</span>
<span class="lineNum">    1722 </span>            :                         }
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span><span class="lineCov">       3108 :                         if (!didwork) {</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    1726 </span>            :                         }
<span class="lineNum">    1727 </span>            :                 }
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span><span class="lineCov">       3108 :                 if (AST_VECTOR_SIZE(&amp;missingdeps)) {</span>
<span class="lineNum">    1730 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Failed to load %s due to unfilled dependencies.\n&quot;,</span>
<span class="lineNum">    1731 </span>            :                                 ast_module_name(mod));
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :                         mod-&gt;flags.declined = 1;</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :                         AST_VECTOR_RESET(&amp;missingdeps, AST_VECTOR_ELEM_CLEANUP_NOOP);</span>
<span class="lineNum">    1734 </span>            : 
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1736 </span>            :                 }
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span>            :                 /* If we're here it means that we started with missingdeps and they're all loaded
<span class="lineNum">    1739 </span>            :                  * now.  It's impossible to reach this point a second time for the same module. */
<span class="lineNum">    1740 </span><span class="lineCov">       3108 :                 goto retry_load;</span>
<span class="lineNum">    1741 </span>            :         }
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span><span class="lineCov">       1124 :         AST_VECTOR_FREE(&amp;missingdeps);</span>
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span><span class="lineCov">       1124 :         return res;</span>
<span class="lineNum">    1746 </span>            : }
<span class="lineNum">    1747 </span>            : 
<span class="lineNum">    1748 </span>            : /*! loads modules in order by load_pri, updates mod_count
<a name="1749"><span class="lineNum">    1749 </span>            :         \return -1 on failure to load module, -2 on failure to load required module, otherwise 0</a>
<span class="lineNum">    1750 </span>            : */
<span class="lineNum">    1751 </span><span class="lineCov">       1124 : static int load_resource_list(struct load_order *load_order, int *mod_count)</span>
<span class="lineNum">    1752 </span>            : {
<span class="lineNum">    1753 </span>            :         struct module_vector module_priorities;
<span class="lineNum">    1754 </span>            :         struct load_order_entry *order;
<span class="lineNum">    1755 </span><span class="lineCov">       1124 :         int attempt = 0;</span>
<span class="lineNum">    1756 </span><span class="lineCov">       1124 :         int count = 0;</span>
<span class="lineNum">    1757 </span><span class="lineCov">       1124 :         int res = 0;</span>
<span class="lineNum">    1758 </span>            :         int didwork;
<span class="lineNum">    1759 </span><span class="lineCov">       1124 :         int lasttry = 0;</span>
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span><span class="lineCov">       1124 :         if (AST_VECTOR_INIT(&amp;module_priorities, 500)) {</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Failed to initialize module loader.\n&quot;);</span>
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    1765 </span>            :         }
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span><span class="lineCov">       6479 :         while (!res) {</span>
<span class="lineNum">    1768 </span><span class="lineCov">       6479 :                 didwork = 0;</span>
<span class="lineNum">    1769 </span>            : 
<span class="lineNum">    1770 </span><span class="lineCov">     524162 :                 AST_LIST_TRAVERSE_SAFE_BEGIN(load_order, order, entry) {</span>
<span class="lineNum">    1771 </span>            :                         enum ast_module_load_result lres;
<span class="lineNum">    1772 </span>            : 
<span class="lineNum">    1773 </span>            :                         /* Suppress log messages unless this is the last pass */
<span class="lineNum">    1774 </span><span class="lineCov">     517683 :                         lres = load_resource(order-&gt;resource, !lasttry, &amp;module_priorities, order-&gt;required, order-&gt;preload);</span>
<span class="lineNum">    1775 </span><span class="lineCov">     517683 :                         ast_debug(3, &quot;PASS %d: %-46s %d\n&quot;, attempt, order-&gt;resource, lres);</span>
<span class="lineNum">    1776 </span><span class="lineCov">     517683 :                         switch (lres) {</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :                         case AST_MODULE_LOAD_SUCCESS:</span>
<span class="lineNum">    1778 </span>            :                         case AST_MODULE_LOAD_SKIP:
<span class="lineNum">    1779 </span>            :                                 /* We're supplying module_priorities so SUCCESS isn't possible but we
<span class="lineNum">    1780 </span>            :                                  * still have to test for it.  SKIP is only used when we try to start a
<span class="lineNum">    1781 </span>            :                                  * module that is missing dependencies. */
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    1783 </span><span class="lineCov">     139567 :                         case AST_MODULE_LOAD_DECLINE:</span>
<span class="lineNum">    1784 </span><span class="lineCov">     139567 :                                 break;</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :                         case AST_MODULE_LOAD_FAILURE:</span>
<span class="lineNum">    1786 </span>            :                                 /* LOAD_FAILURE only happens for required modules */
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :                                 if (lasttry) {</span>
<span class="lineNum">    1788 </span>            :                                         /* This run is just to print errors. */
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_ERROR, &quot;*** Failed to load module %s - Required\n&quot;, order-&gt;resource);</span>
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :                                         fprintf(stderr, &quot;*** Failed to load module %s - Required\n&quot;, order-&gt;resource);</span>
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :                                         res =  -2;</span>
<span class="lineNum">    1792 </span>            :                                 }
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    1794 </span><span class="lineCov">     378116 :                         case AST_MODULE_LOAD_PRIORITY:</span>
<span class="lineNum">    1795 </span>            :                                 /* load_resource worked and the module was added to module_priorities */
<span class="lineNum">    1796 </span><span class="lineCov">     378116 :                                 AST_LIST_REMOVE_CURRENT(entry);</span>
<span class="lineNum">    1797 </span><span class="lineCov">     378116 :                                 ast_free(order-&gt;resource);</span>
<span class="lineNum">    1798 </span><span class="lineCov">     378116 :                                 ast_free(order);</span>
<span class="lineNum">    1799 </span><span class="lineCov">     378116 :                                 didwork = 1;</span>
<span class="lineNum">    1800 </span><span class="lineCov">     378116 :                                 break;</span>
<span class="lineNum">    1801 </span>            :                         }
<span class="lineNum">    1802 </span><span class="lineCov">     517683 :                 }</span>
<span class="lineNum">    1803 </span>            :                 AST_LIST_TRAVERSE_SAFE_END;
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span><span class="lineCov">       6479 :                 if (!didwork) {</span>
<span class="lineNum">    1806 </span><span class="lineCov">       2248 :                         if (lasttry) {</span>
<span class="lineNum">    1807 </span><span class="lineCov">       1124 :                                 break;</span>
<span class="lineNum">    1808 </span>            :                         }
<span class="lineNum">    1809 </span>            :                         /* We know the next try is going to fail, it's only being performed
<span class="lineNum">    1810 </span>            :                          * so we can print errors. */
<span class="lineNum">    1811 </span><span class="lineCov">       1124 :                         lasttry = 1;</span>
<span class="lineNum">    1812 </span>            :                 }
<span class="lineNum">    1813 </span><span class="lineCov">       5355 :                 attempt++;</span>
<span class="lineNum">    1814 </span>            :         }
<span class="lineNum">    1815 </span>            : 
<span class="lineNum">    1816 </span><span class="lineCov">       1124 :         if (!res) {</span>
<span class="lineNum">    1817 </span><span class="lineCov">       1124 :                 res = start_resource_list(&amp;module_priorities, &amp;count);</span>
<span class="lineNum">    1818 </span>            :         }
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span><span class="lineCov">       1124 :         if (mod_count) {</span>
<span class="lineNum">    1821 </span><span class="lineCov">       1124 :                 *mod_count += count;</span>
<span class="lineNum">    1822 </span>            :         }
<span class="lineNum">    1823 </span><span class="lineCov">       1124 :         AST_VECTOR_FREE(&amp;module_priorities);</span>
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span><span class="lineCov">       1124 :         return res;</span>
<a name="1826"><span class="lineNum">    1826 </span>            : }</a>
<span class="lineNum">    1827 </span>            : 
<span class="lineNum">    1828 </span><span class="lineCov">       1124 : static int loader_builtin_init(struct load_order *load_order)</span>
<span class="lineNum">    1829 </span>            : {
<span class="lineNum">    1830 </span>            :         struct ast_module *mod;
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span>            :         /*
<span class="lineNum">    1833 </span>            :          * All built-in modules have registered the first time, now it's time to complete
<span class="lineNum">    1834 </span>            :          * the registration and add them to the priority list.
<span class="lineNum">    1835 </span>            :          */
<span class="lineNum">    1836 </span><span class="lineCov">       1124 :         loader_ready = 1;</span>
<span class="lineNum">    1837 </span>            : 
<span class="lineNum">    1838 </span><span class="lineCov">      19108 :         while ((resource_being_loaded = AST_DLLIST_REMOVE_HEAD(&amp;builtin_module_list, entry))) {</span>
<span class="lineNum">    1839 </span>            :                 /* ast_module_register doesn't finish when first run by built-in modules. */
<span class="lineNum">    1840 </span><span class="lineCov">      17984 :                 ast_module_register(resource_being_loaded-&gt;info);</span>
<span class="lineNum">    1841 </span>            :         }
<span class="lineNum">    1842 </span>            : 
<span class="lineNum">    1843 </span>            :         /* Add all built-in modules to the load order. */
<span class="lineNum">    1844 </span><span class="lineCov">      19108 :         AST_DLLIST_TRAVERSE(&amp;module_list, mod, entry) {</span>
<span class="lineNum">    1845 </span><span class="lineCov">      17984 :                 if (!mod-&gt;flags.builtin) {</span>
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1847 </span>            :                 }
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span>            :                 /* Built-in modules are not preloaded, most have an early load priority. */
<span class="lineNum">    1850 </span><span class="lineCov">      17984 :                 if (!add_to_load_order(mod-&gt;resource, load_order, 0, 0, 1)) {</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    1852 </span>            :                 }
<span class="lineNum">    1853 </span>            :         }
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span><span class="lineCov">       1124 :         return 0;</span>
<a name="1856"><span class="lineNum">    1856 </span>            : }</a>
<span class="lineNum">    1857 </span>            : 
<span class="lineNum">    1858 </span><span class="lineCov">       1124 : static int loader_config_init(struct load_order *load_order)</span>
<span class="lineNum">    1859 </span>            : {
<span class="lineNum">    1860 </span><span class="lineCov">       1124 :         int res = -1;</span>
<span class="lineNum">    1861 </span>            :         struct load_order_entry *order;
<span class="lineNum">    1862 </span>            :         struct ast_config *cfg;
<span class="lineNum">    1863 </span>            :         struct ast_variable *v;
<span class="lineNum">    1864 </span><span class="lineCov">       1124 :         struct ast_flags config_flags = { 0 };</span>
<span class="lineNum">    1865 </span>            : 
<span class="lineNum">    1866 </span><span class="lineCov">       1124 :         cfg = ast_config_load2(AST_MODULE_CONFIG, &quot;&quot; /* core, can't reload */, config_flags);</span>
<span class="lineNum">    1867 </span><span class="lineCov">       1124 :         if (cfg == CONFIG_STATUS_FILEMISSING || cfg == CONFIG_STATUS_FILEINVALID) {</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;'%s' invalid or missing.\n&quot;, AST_MODULE_CONFIG);</span>
<span class="lineNum">    1869 </span>            : 
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    1871 </span>            :         }
<span class="lineNum">    1872 </span>            : 
<span class="lineNum">    1873 </span>            :         /* first, find all the modules we have been explicitly requested to load */
<span class="lineNum">    1874 </span><span class="lineCov">       7846 :         for (v = ast_variable_browse(cfg, &quot;modules&quot;); v; v = v-&gt;next) {</span>
<span class="lineNum">    1875 </span>            :                 int required;
<span class="lineNum">    1876 </span><span class="lineCov">       6722 :                 int preload = 0;</span>
<span class="lineNum">    1877 </span>            : 
<span class="lineNum">    1878 </span><span class="lineCov">       6722 :                 if (!strncasecmp(v-&gt;name, &quot;preload&quot;, strlen(&quot;preload&quot;))) {</span>
<span class="lineNum">    1879 </span><span class="lineCov">          6 :                         preload = 1;</span>
<span class="lineNum">    1880 </span><span class="lineCov">          6 :                         if (!strcasecmp(v-&gt;name, &quot;preload&quot;)) {</span>
<span class="lineNum">    1881 </span><span class="lineCov">          6 :                                 required = 0;</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :                         } else if (!strcasecmp(v-&gt;name, &quot;preload-require&quot;)) {</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :                                 required = 1;</span>
<span class="lineNum">    1884 </span>            :                         } else {
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_ERROR, &quot;Unknown configuration option '%s'&quot;, v-&gt;name);</span>
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :                                 goto done;</span>
<span class="lineNum">    1887 </span>            :                         }
<span class="lineNum">    1888 </span><span class="lineCov">       6716 :                 } else if (!strcasecmp(v-&gt;name, &quot;load&quot;)) {</span>
<span class="lineNum">    1889 </span><span class="lineCov">         27 :                         required = 0;</span>
<span class="lineNum">    1890 </span><span class="lineCov">       6689 :                 } else if (!strcasecmp(v-&gt;name, &quot;require&quot;)) {</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :                         required = 1;</span>
<span class="lineNum">    1892 </span><span class="lineCov">       6689 :                 } else if (!strcasecmp(v-&gt;name, &quot;noload&quot;) || !strcasecmp(v-&gt;name, &quot;autoload&quot;)) {</span>
<span class="lineNum">    1893 </span><span class="lineCov">       6689 :                         continue;</span>
<span class="lineNum">    1894 </span>            :                 } else {
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR, &quot;Unknown configuration option '%s'&quot;, v-&gt;name);</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :                         goto done;</span>
<span class="lineNum">    1897 </span>            :                 }
<span class="lineNum">    1898 </span>            : 
<span class="lineNum">    1899 </span><span class="lineCov">         33 :                 if (required) {</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :                         ast_debug(2, &quot;Adding module to required list: %s (%s)\n&quot;, v-&gt;value, v-&gt;name);</span>
<span class="lineNum">    1901 </span>            :                 }
<span class="lineNum">    1902 </span>            : 
<span class="lineNum">    1903 </span><span class="lineCov">         33 :                 if (!add_to_load_order(v-&gt;value, load_order, required, preload, 0)) {</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :                         goto done;</span>
<span class="lineNum">    1905 </span>            :                 }
<span class="lineNum">    1906 </span>            :         }
<span class="lineNum">    1907 </span>            : 
<span class="lineNum">    1908 </span>            :         /* check if 'autoload' is on */
<span class="lineNum">    1909 </span><span class="lineCov">       1124 :         if (ast_true(ast_variable_retrieve(cfg, &quot;modules&quot;, &quot;autoload&quot;))) {</span>
<span class="lineNum">    1910 </span>            :                 /* if we are allowed to load dynamic modules, scan the directory for
<span class="lineNum">    1911 </span>            :                    for all available modules and add them as well */
<span class="lineNum">    1912 </span><span class="lineCov">       1123 :                 DIR *dir = opendir(ast_config_AST_MODULE_DIR);</span>
<span class="lineNum">    1913 </span>            :                 struct dirent *dirent;
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span><span class="lineCov">       1123 :                 if (dir) {</span>
<span class="lineNum">    1916 </span><span class="lineCov">     382943 :                         while ((dirent = readdir(dir))) {</span>
<span class="lineNum">    1917 </span><span class="lineCov">     381820 :                                 int ld = strlen(dirent-&gt;d_name);</span>
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span>            :                                 /* Must end in .so to load it.  */
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span><span class="lineCov">     381820 :                                 if (ld &lt; 4)</span>
<span class="lineNum">    1922 </span><span class="lineCov">       2246 :                                         continue;</span>
<span class="lineNum">    1923 </span>            : 
<span class="lineNum">    1924 </span><span class="lineCov">     379574 :                                 if (strcasecmp(dirent-&gt;d_name + ld - 3, &quot;.so&quot;))</span>
<span class="lineNum">    1925 </span><span class="lineCov">       5615 :                                         continue;</span>
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span>            :                                 /* if there is already a module by this name in the module_list,
<span class="lineNum">    1928 </span>            :                                    skip this file */
<span class="lineNum">    1929 </span><span class="lineCov">     373959 :                                 if (find_resource(dirent-&gt;d_name, 0))</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    1931 </span>            : 
<span class="lineNum">    1932 </span><span class="lineCov">     373959 :                                 if (!add_to_load_order(dirent-&gt;d_name, load_order, 0, 0, 0)) {</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :                                         closedir(dir);</span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :                                         goto done;</span>
<span class="lineNum">    1935 </span>            :                                 }
<span class="lineNum">    1936 </span>            :                         }
<span class="lineNum">    1937 </span>            : 
<span class="lineNum">    1938 </span><span class="lineCov">       1123 :                         closedir(dir);</span>
<span class="lineNum">    1939 </span>            :                 } else {
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR, &quot;Unable to open modules directory '%s'.\n&quot;, ast_config_AST_MODULE_DIR);</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :                         goto done;</span>
<span class="lineNum">    1942 </span>            :                 }
<span class="lineNum">    1943 </span>            :         }
<span class="lineNum">    1944 </span>            : 
<span class="lineNum">    1945 </span>            :         /* now scan the config for any modules we are prohibited from loading and
<span class="lineNum">    1946 </span>            :            remove them from the load order */
<span class="lineNum">    1947 </span><span class="lineCov">       7846 :         for (v = ast_variable_browse(cfg, &quot;modules&quot;); v; v = v-&gt;next) {</span>
<span class="lineNum">    1948 </span>            :                 size_t baselen;
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span><span class="lineCov">       6722 :                 if (strcasecmp(v-&gt;name, &quot;noload&quot;)) {</span>
<span class="lineNum">    1951 </span><span class="lineCov">       1157 :                         continue;</span>
<span class="lineNum">    1952 </span>            :                 }
<span class="lineNum">    1953 </span>            : 
<span class="lineNum">    1954 </span><span class="lineCov">       5565 :                 baselen = resource_name_baselen(v-&gt;value);</span>
<span class="lineNum">    1955 </span><span class="lineCov">    1944431 :                 AST_LIST_TRAVERSE_SAFE_BEGIN(load_order, order, entry) {</span>
<span class="lineNum">    1956 </span><span class="lineCov">    1938866 :                         if (!resource_name_match(v-&gt;value, baselen, order-&gt;resource)) {</span>
<span class="lineNum">    1957 </span><span class="lineCov">       2185 :                                 if (order-&gt;builtin) {</span>
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_ERROR, &quot;%s is a built-in module, you cannot specify 'noload'.\n&quot;, v-&gt;value);</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :                                         goto done;</span>
<span class="lineNum">    1960 </span>            :                                 }
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span><span class="lineCov">       2185 :                                 if (order-&gt;required) {</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_ERROR, &quot;%s is configured with '%s' and 'noload', this is impossible.\n&quot;,</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :                                                 v-&gt;value, order-&gt;preload ? &quot;preload-require&quot; : &quot;require&quot;);</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :                                         goto done;</span>
<span class="lineNum">    1966 </span>            :                                 }
<span class="lineNum">    1967 </span><span class="lineCov">       2185 :                                 AST_LIST_REMOVE_CURRENT(entry);</span>
<span class="lineNum">    1968 </span><span class="lineCov">       2185 :                                 ast_free(order-&gt;resource);</span>
<span class="lineNum">    1969 </span><span class="lineCov">       2185 :                                 ast_free(order);</span>
<span class="lineNum">    1970 </span>            :                         }
<span class="lineNum">    1971 </span>            :                 }
<span class="lineNum">    1972 </span>            :                 AST_LIST_TRAVERSE_SAFE_END;
<span class="lineNum">    1973 </span>            :         }
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span><span class="lineCov">       1124 :         res = 0;</span>
<span class="lineNum">    1976 </span><span class="lineCov">       1124 : done:</span>
<span class="lineNum">    1977 </span><span class="lineCov">       1124 :         ast_config_destroy(cfg);</span>
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span><span class="lineCov">       1124 :         return res;</span>
<a name="1980"><span class="lineNum">    1980 </span>            : }</a>
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span><span class="lineCov">       1124 : int load_modules(void)</span>
<span class="lineNum">    1983 </span>            : {
<span class="lineNum">    1984 </span>            :         struct load_order_entry *order;
<span class="lineNum">    1985 </span>            :         unsigned int load_count;
<span class="lineNum">    1986 </span>            :         struct load_order load_order;
<span class="lineNum">    1987 </span><span class="lineCov">       1124 :         int res = 0;</span>
<span class="lineNum">    1988 </span><span class="lineCov">       1124 :         int modulecount = 0;</span>
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span><span class="lineCov">       1124 :         ast_verb(1, &quot;Asterisk Dynamic Loader Starting:\n&quot;);</span>
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span><span class="lineCov">       1124 :         AST_LIST_HEAD_INIT_NOLOCK(&amp;load_order);</span>
<span class="lineNum">    1993 </span><span class="lineCov">       1124 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">    1994 </span>            : 
<span class="lineNum">    1995 </span><span class="lineCov">       1124 :         res = loader_builtin_init(&amp;load_order);</span>
<span class="lineNum">    1996 </span><span class="lineCov">       1124 :         if (res) {</span>
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :                 goto done;</span>
<span class="lineNum">    1998 </span>            :         }
<span class="lineNum">    1999 </span>            : 
<span class="lineNum">    2000 </span><span class="lineCov">       1124 :         res = loader_config_init(&amp;load_order);</span>
<span class="lineNum">    2001 </span><span class="lineCov">       1124 :         if (res) {</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :                 goto done;</span>
<span class="lineNum">    2003 </span>            :         }
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span><span class="lineCov">       1124 :         load_count = 0;</span>
<span class="lineNum">    2006 </span><span class="lineCov">     390906 :         AST_LIST_TRAVERSE(&amp;load_order, order, entry)</span>
<span class="lineNum">    2007 </span><span class="lineCov">     389782 :                 load_count++;</span>
<span class="lineNum">    2008 </span>            : 
<span class="lineNum">    2009 </span><span class="lineCov">       1124 :         if (load_count)</span>
<span class="lineNum">    2010 </span><span class="lineCov">       1124 :                 ast_log(LOG_NOTICE, &quot;%u modules will be loaded.\n&quot;, load_count);</span>
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span><span class="lineCov">       1124 :         res = load_resource_list(&amp;load_order, &amp;modulecount);</span>
<span class="lineNum">    2013 </span>            : 
<span class="lineNum">    2014 </span><span class="lineCov">       1124 : done:</span>
<span class="lineNum">    2015 </span><span class="lineCov">      12790 :         while ((order = AST_LIST_REMOVE_HEAD(&amp;load_order, entry))) {</span>
<span class="lineNum">    2016 </span><span class="lineCov">      11666 :                 ast_free(order-&gt;resource);</span>
<span class="lineNum">    2017 </span><span class="lineCov">      11666 :                 ast_free(order);</span>
<span class="lineNum">    2018 </span>            :         }
<span class="lineNum">    2019 </span>            : 
<span class="lineNum">    2020 </span><span class="lineCov">       1124 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">    2021 </span><span class="lineCov">       1124 :         return res;</span>
<a name="2022"><span class="lineNum">    2022 </span>            : }</a>
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span><span class="lineCov">    2734639 : void ast_update_use_count(void)</span>
<span class="lineNum">    2025 </span>            : {
<span class="lineNum">    2026 </span>            :         /* Notify any module monitors that the use count for a
<span class="lineNum">    2027 </span>            :            resource has changed */
<span class="lineNum">    2028 </span>            :         struct loadupdate *m;
<span class="lineNum">    2029 </span>            : 
<span class="lineNum">    2030 </span><span class="lineCov">    2734639 :         AST_LIST_LOCK(&amp;updaters);</span>
<span class="lineNum">    2031 </span><span class="lineCov">    2734639 :         AST_LIST_TRAVERSE(&amp;updaters, m, entry)</span>
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :                 m-&gt;updater();</span>
<span class="lineNum">    2033 </span><span class="lineCov">    2734639 :         AST_LIST_UNLOCK(&amp;updaters);</span>
<span class="lineNum">    2034 </span><span class="lineCov">    2734639 : }</span>
<span class="lineNum">    2035 </span>            : 
<span class="lineNum">    2036 </span>            : /*!
<span class="lineNum">    2037 </span>            :  * \internal
<span class="lineNum">    2038 </span>            :  * \brief Build an alpha sorted list of modules.
<span class="lineNum">    2039 </span>            :  *
<span class="lineNum">    2040 </span>            :  * \param alpha_module_list Pointer to uninitialized module_vector.
<span class="lineNum">    2041 </span>            :  *
<span class="lineNum">    2042 </span>            :  * This function always initializes alpha_module_list.
<span class="lineNum">    2043 </span>            :  *
<a name="2044"><span class="lineNum">    2044 </span>            :  * \pre module_list must be locked.</a>
<span class="lineNum">    2045 </span>            :  */
<span class="lineNum">    2046 </span><span class="lineCov">          3 : static int alpha_module_list_create(struct module_vector *alpha_module_list)</span>
<span class="lineNum">    2047 </span>            : {
<span class="lineNum">    2048 </span>            :         struct ast_module *cur;
<span class="lineNum">    2049 </span>            : 
<span class="lineNum">    2050 </span><span class="lineCov">          3 :         if (AST_VECTOR_INIT(alpha_module_list, 32)) {</span>
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2052 </span>            :         }
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span><span class="lineCov">        738 :         AST_DLLIST_TRAVERSE(&amp;module_list, cur, entry) {</span>
<span class="lineNum">    2055 </span><span class="lineCov">      59696 :                 if (AST_VECTOR_ADD_SORTED(alpha_module_list, cur, module_vector_strcasecmp)) {</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    2057 </span>            :                 }
<span class="lineNum">    2058 </span>            :         }
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span><span class="lineCov">          3 :         return 0;</span>
<a name="2061"><span class="lineNum">    2061 </span>            : }</a>
<span class="lineNum">    2062 </span>            : 
<span class="lineNum">    2063 </span><span class="lineCov">          1 : int ast_update_module_list(int (*modentry)(const char *module, const char *description,</span>
<span class="lineNum">    2064 </span>            :                                            int usecnt, const char *status, const char *like,
<span class="lineNum">    2065 </span>            :                                                                                    enum ast_module_support_level support_level),
<span class="lineNum">    2066 </span>            :                            const char *like)
<span class="lineNum">    2067 </span>            : {
<span class="lineNum">    2068 </span><span class="lineCov">          1 :         int total_mod_loaded = 0;</span>
<span class="lineNum">    2069 </span>            :         struct module_vector alpha_module_list;
<span class="lineNum">    2070 </span>            : 
<span class="lineNum">    2071 </span><span class="lineCov">          1 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">    2072 </span>            : 
<span class="lineNum">    2073 </span><span class="lineCov">          1 :         if (!alpha_module_list_create(&amp;alpha_module_list)) {</span>
<span class="lineNum">    2074 </span>            :                 int idx;
<span class="lineNum">    2075 </span>            : 
<span class="lineNum">    2076 </span><span class="lineCov">        349 :                 for (idx = 0; idx &lt; AST_VECTOR_SIZE(&amp;alpha_module_list); idx++) {</span>
<span class="lineNum">    2077 </span><span class="lineCov">        348 :                         struct ast_module *cur = AST_VECTOR_GET(&amp;alpha_module_list, idx);</span>
<span class="lineNum">    2078 </span>            : 
<span class="lineNum">    2079 </span><span class="lineCov">        348 :                         total_mod_loaded += modentry(cur-&gt;resource, cur-&gt;info-&gt;description, cur-&gt;usecount,</span>
<span class="lineNum">    2080 </span><span class="lineCov">        348 :                                 cur-&gt;flags.running ? &quot;Running&quot; : &quot;Not Running&quot;, like, cur-&gt;info-&gt;support_level);</span>
<span class="lineNum">    2081 </span>            :                 }
<span class="lineNum">    2082 </span>            :         }
<span class="lineNum">    2083 </span>            : 
<span class="lineNum">    2084 </span><span class="lineCov">          1 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">    2085 </span><span class="lineCov">          1 :         AST_VECTOR_FREE(&amp;alpha_module_list);</span>
<span class="lineNum">    2086 </span>            : 
<span class="lineNum">    2087 </span><span class="lineCov">          1 :         return total_mod_loaded;</span>
<a name="2088"><span class="lineNum">    2088 </span>            : }</a>
<span class="lineNum">    2089 </span>            : 
<span class="lineNum">    2090 </span><span class="lineCov">          1 : int ast_update_module_list_data(int (*modentry)(const char *module, const char *description,</span>
<span class="lineNum">    2091 </span>            :                                                 int usecnt, const char *status, const char *like,
<span class="lineNum">    2092 </span>            :                                                 enum ast_module_support_level support_level,
<span class="lineNum">    2093 </span>            :                                                 void *data),
<span class="lineNum">    2094 </span>            :                                 const char *like, void *data)
<span class="lineNum">    2095 </span>            : {
<span class="lineNum">    2096 </span><span class="lineCov">          1 :         int total_mod_loaded = 0;</span>
<span class="lineNum">    2097 </span>            :         struct module_vector alpha_module_list;
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span><span class="lineCov">          1 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">    2100 </span>            : 
<span class="lineNum">    2101 </span><span class="lineCov">          1 :         if (!alpha_module_list_create(&amp;alpha_module_list)) {</span>
<span class="lineNum">    2102 </span>            :                 int idx;
<span class="lineNum">    2103 </span>            : 
<span class="lineNum">    2104 </span><span class="lineCov">         39 :                 for (idx = 0; idx &lt; AST_VECTOR_SIZE(&amp;alpha_module_list); idx++) {</span>
<span class="lineNum">    2105 </span><span class="lineCov">         38 :                         struct ast_module *cur = AST_VECTOR_GET(&amp;alpha_module_list, idx);</span>
<span class="lineNum">    2106 </span>            : 
<span class="lineNum">    2107 </span><span class="lineCov">         38 :                         total_mod_loaded += modentry(cur-&gt;resource, cur-&gt;info-&gt;description, cur-&gt;usecount,</span>
<span class="lineNum">    2108 </span><span class="lineCov">         38 :                                 cur-&gt;flags.running? &quot;Running&quot; : &quot;Not Running&quot;, like, cur-&gt;info-&gt;support_level, data);</span>
<span class="lineNum">    2109 </span>            :                 }
<span class="lineNum">    2110 </span>            :         }
<span class="lineNum">    2111 </span>            : 
<span class="lineNum">    2112 </span><span class="lineCov">          1 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">    2113 </span><span class="lineCov">          1 :         AST_VECTOR_FREE(&amp;alpha_module_list);</span>
<span class="lineNum">    2114 </span>            : 
<span class="lineNum">    2115 </span><span class="lineCov">          1 :         return total_mod_loaded;</span>
<a name="2116"><span class="lineNum">    2116 </span>            : }</a>
<span class="lineNum">    2117 </span>            : 
<span class="lineNum">    2118 </span><span class="lineCov">          1 : int ast_update_module_list_condition(int (*modentry)(const char *module, const char *description,</span>
<span class="lineNum">    2119 </span>            :                                                      int usecnt, const char *status,
<span class="lineNum">    2120 </span>            :                                                      const char *like,
<span class="lineNum">    2121 </span>            :                                                      enum ast_module_support_level support_level,
<span class="lineNum">    2122 </span>            :                                                      void *data, const char *condition),
<span class="lineNum">    2123 </span>            :                                      const char *like, void *data, const char *condition)
<span class="lineNum">    2124 </span>            : {
<span class="lineNum">    2125 </span><span class="lineCov">          1 :         int conditions_met = 0;</span>
<span class="lineNum">    2126 </span>            :         struct module_vector alpha_module_list;
<span class="lineNum">    2127 </span>            : 
<span class="lineNum">    2128 </span><span class="lineCov">          1 :         AST_DLLIST_LOCK(&amp;module_list);</span>
<span class="lineNum">    2129 </span>            : 
<span class="lineNum">    2130 </span><span class="lineCov">          1 :         if (!alpha_module_list_create(&amp;alpha_module_list)) {</span>
<span class="lineNum">    2131 </span>            :                 int idx;
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span><span class="lineCov">        350 :                 for (idx = 0; idx &lt; AST_VECTOR_SIZE(&amp;alpha_module_list); idx++) {</span>
<span class="lineNum">    2134 </span><span class="lineCov">        349 :                         struct ast_module *cur = AST_VECTOR_GET(&amp;alpha_module_list, idx);</span>
<span class="lineNum">    2135 </span>            : 
<span class="lineNum">    2136 </span><span class="lineCov">        349 :                         conditions_met += modentry(cur-&gt;resource, cur-&gt;info-&gt;description, cur-&gt;usecount,</span>
<span class="lineNum">    2137 </span><span class="lineCov">        349 :                                 cur-&gt;flags.running? &quot;Running&quot; : &quot;Not Running&quot;, like, cur-&gt;info-&gt;support_level, data,</span>
<span class="lineNum">    2138 </span>            :                                 condition);
<span class="lineNum">    2139 </span>            :                 }
<span class="lineNum">    2140 </span>            :         }
<span class="lineNum">    2141 </span>            : 
<span class="lineNum">    2142 </span><span class="lineCov">          1 :         AST_DLLIST_UNLOCK(&amp;module_list);</span>
<span class="lineNum">    2143 </span><span class="lineCov">          1 :         AST_VECTOR_FREE(&amp;alpha_module_list);</span>
<span class="lineNum">    2144 </span>            : 
<span class="lineNum">    2145 </span><span class="lineCov">          1 :         return conditions_met;</span>
<span class="lineNum">    2146 </span>            : }
<a name="2147"><span class="lineNum">    2147 </span>            : </a>
<span class="lineNum">    2148 </span>            : /*! \brief Check if module exists */
<span class="lineNum">    2149 </span><span class="lineCov">         14 : int ast_module_check(const char *name)</span>
<span class="lineNum">    2150 </span>            : {
<span class="lineNum">    2151 </span>            :         struct ast_module *cur;
<span class="lineNum">    2152 </span>            : 
<span class="lineNum">    2153 </span><span class="lineCov">         14 :         if (ast_strlen_zero(name))</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :                 return 0;       /* FALSE */</span>
<span class="lineNum">    2155 </span>            : 
<span class="lineNum">    2156 </span><span class="lineCov">         14 :         cur = find_resource(name, 1);</span>
<span class="lineNum">    2157 </span>            : 
<span class="lineNum">    2158 </span><span class="lineCov">         14 :         return (cur != NULL);</span>
<span class="lineNum">    2159 </span>            : }
<a name="2160"><span class="lineNum">    2160 </span>            : </a>
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 : int ast_loader_register(int (*v)(void))</span>
<span class="lineNum">    2163 </span>            : {
<span class="lineNum">    2164 </span>            :         struct loadupdate *tmp;
<span class="lineNum">    2165 </span>            : 
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :         if (!(tmp = ast_malloc(sizeof(*tmp))))</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2168 </span>            : 
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :         tmp-&gt;updater = v;</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :         AST_LIST_LOCK(&amp;updaters);</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :         AST_LIST_INSERT_HEAD(&amp;updaters, tmp, entry);</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :         AST_LIST_UNLOCK(&amp;updaters);</span>
<span class="lineNum">    2173 </span>            : 
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="2175"><span class="lineNum">    2175 </span>            : }</a>
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 : int ast_loader_unregister(int (*v)(void))</span>
<span class="lineNum">    2178 </span>            : {
<span class="lineNum">    2179 </span>            :         struct loadupdate *cur;
<span class="lineNum">    2180 </span>            : 
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 :         AST_LIST_LOCK(&amp;updaters);</span>
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :         AST_LIST_TRAVERSE_SAFE_BEGIN(&amp;updaters, cur, entry) {</span>
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :                 if (cur-&gt;updater == v)       {</span>
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :                         AST_LIST_REMOVE_CURRENT(entry);</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    2186 </span>            :                 }
<span class="lineNum">    2187 </span>            :         }
<span class="lineNum">    2188 </span>            :         AST_LIST_TRAVERSE_SAFE_END;
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :         AST_LIST_UNLOCK(&amp;updaters);</span>
<span class="lineNum">    2190 </span>            : 
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :         return cur ? 0 : -1;</span>
<a name="2192"><span class="lineNum">    2192 </span>            : }</a>
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span><span class="lineCov">     345586 : struct ast_module *__ast_module_ref(struct ast_module *mod, const char *file, int line, const char *func)</span>
<span class="lineNum">    2195 </span>            : {
<span class="lineNum">    2196 </span><span class="lineCov">     345586 :         if (!mod) {</span>
<span class="lineNum">    2197 </span><span class="lineCov">      11430 :                 return NULL;</span>
<span class="lineNum">    2198 </span>            :         }
<span class="lineNum">    2199 </span>            : 
<span class="lineNum">    2200 </span><span class="lineCov">     334156 :         if (mod-&gt;ref_debug) {</span>
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :                 __ao2_ref(mod-&gt;ref_debug, +1, &quot;&quot;, file, line, func);</span>
<span class="lineNum">    2202 </span>            :         }
<span class="lineNum">    2203 </span>            : 
<span class="lineNum">    2204 </span><span class="lineCov">     334156 :         ast_atomic_fetchadd_int(&amp;mod-&gt;usecount, +1);</span>
<span class="lineNum">    2205 </span><span class="lineCov">     334156 :         ast_update_use_count();</span>
<span class="lineNum">    2206 </span>            : 
<span class="lineNum">    2207 </span><span class="lineCov">     334156 :         return mod;</span>
<a name="2208"><span class="lineNum">    2208 </span>            : }</a>
<span class="lineNum">    2209 </span>            : 
<span class="lineNum">    2210 </span><span class="lineCov">      44439 : struct ast_module *__ast_module_running_ref(struct ast_module *mod,</span>
<span class="lineNum">    2211 </span>            :         const char *file, int line, const char *func)
<span class="lineNum">    2212 </span>            : {
<span class="lineNum">    2213 </span><span class="lineCov">      44439 :         if (!mod || !mod-&gt;flags.running) {</span>
<span class="lineNum">    2214 </span><span class="lineCov">       5485 :                 return NULL;</span>
<span class="lineNum">    2215 </span>            :         }
<span class="lineNum">    2216 </span>            : 
<span class="lineNum">    2217 </span><span class="lineCov">      38954 :         return __ast_module_ref(mod, file, line, func);</span>
<a name="2218"><span class="lineNum">    2218 </span>            : }</a>
<span class="lineNum">    2219 </span>            : 
<span class="lineNum">    2220 </span><span class="lineCov">      95850 : void __ast_module_shutdown_ref(struct ast_module *mod, const char *file, int line, const char *func)</span>
<span class="lineNum">    2221 </span>            : {
<span class="lineNum">    2222 </span><span class="lineCov">      95850 :         if (!mod || mod-&gt;flags.keepuntilshutdown) {</span>
<span class="lineNum">    2223 </span><span class="lineCov">      56200 :                 return;</span>
<span class="lineNum">    2224 </span>            :         }
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span><span class="lineCov">      39650 :         __ast_module_ref(mod, file, line, func);</span>
<span class="lineNum">    2227 </span><span class="lineCov">      39650 :         mod-&gt;flags.keepuntilshutdown = 1;</span>
<a name="2228"><span class="lineNum">    2228 </span>            : }</a>
<span class="lineNum">    2229 </span>            : 
<span class="lineNum">    2230 </span><span class="lineCov">     401765 : void __ast_module_unref(struct ast_module *mod, const char *file, int line, const char *func)</span>
<span class="lineNum">    2231 </span>            : {
<span class="lineNum">    2232 </span><span class="lineCov">     401765 :         if (!mod) {</span>
<span class="lineNum">    2233 </span><span class="lineCov">      68549 :                 return;</span>
<span class="lineNum">    2234 </span>            :         }
<span class="lineNum">    2235 </span>            : 
<span class="lineNum">    2236 </span><span class="lineCov">     333216 :         if (mod-&gt;ref_debug) {</span>
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :                 __ao2_ref(mod-&gt;ref_debug, -1, &quot;&quot;, file, line, func);</span>
<span class="lineNum">    2238 </span>            :         }
<span class="lineNum">    2239 </span>            : 
<span class="lineNum">    2240 </span><span class="lineCov">     333216 :         ast_atomic_fetchadd_int(&amp;mod-&gt;usecount, -1);</span>
<span class="lineNum">    2241 </span><span class="lineCov">     333216 :         ast_update_use_count();</span>
<span class="lineNum">    2242 </span>            : }
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span>            : const char *support_level_map [] = {
<span class="lineNum">    2245 </span>            :         [AST_MODULE_SUPPORT_UNKNOWN] = &quot;unknown&quot;,
<span class="lineNum">    2246 </span>            :         [AST_MODULE_SUPPORT_CORE] = &quot;core&quot;,
<span class="lineNum">    2247 </span>            :         [AST_MODULE_SUPPORT_EXTENDED] = &quot;extended&quot;,
<span class="lineNum">    2248 </span>            :         [AST_MODULE_SUPPORT_DEPRECATED] = &quot;deprecated&quot;,
<a name="2249"><span class="lineNum">    2249 </span>            : };</a>
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span><span class="lineCov">         40 : const char *ast_module_support_level_to_string(enum ast_module_support_level support_level)</span>
<span class="lineNum">    2252 </span>            : {
<span class="lineNum">    2253 </span><span class="lineCov">         40 :         return support_level_map[support_level];</span>
<span class="lineNum">    2254 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
