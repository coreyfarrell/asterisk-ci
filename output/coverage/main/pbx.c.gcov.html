<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Asterisk GIT-16-d8ac5bf1a5 - main/pbx.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">main</a> - pbx.c<span style="font-size: 80%;"> (source / <a href="pbx.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Asterisk GIT-16-d8ac5bf1a5</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2521</td>
            <td class="headerCovTableEntry">3780</td>
            <td class="headerCovTableEntryLo">66.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-07-23 21:48:22</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">194</td>
            <td class="headerCovTableEntry">235</td>
            <td class="headerCovTableEntryMed">82.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Asterisk -- An open source telephony toolkit.
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Copyright (C) 1999 - 2008, Digium, Inc.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Mark Spencer &lt;markster@digium.com&gt;
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * See http://www.asterisk.org for more information about
<span class="lineNum">       9 </span>            :  * the Asterisk project. Please do not directly contact
<span class="lineNum">      10 </span>            :  * any of the maintainers of this project for assistance;
<span class="lineNum">      11 </span>            :  * the project provides a web site, mailing lists and IRC
<span class="lineNum">      12 </span>            :  * channels for your use.
<span class="lineNum">      13 </span>            :  *
<span class="lineNum">      14 </span>            :  * This program is free software, distributed under the terms of
<span class="lineNum">      15 </span>            :  * the GNU General Public License Version 2. See the LICENSE file
<span class="lineNum">      16 </span>            :  * at the top of the source tree.
<span class="lineNum">      17 </span>            :  */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : /*! \file
<span class="lineNum">      20 </span>            :  *
<span class="lineNum">      21 </span>            :  * \brief Core PBX routines.
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  * \author Mark Spencer &lt;markster@digium.com&gt;
<span class="lineNum">      24 </span>            :  */
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : /*** MODULEINFO
<span class="lineNum">      27 </span>            :         &lt;support_level&gt;core&lt;/support_level&gt;
<span class="lineNum">      28 </span>            :  ***/
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;asterisk.h&quot;
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : #include &quot;asterisk/_private.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;asterisk/paths.h&quot;   /* use ast_config_AST_SYSTEM_NAME */
<span class="lineNum">      34 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      37 </span>            : #if defined(HAVE_SYSINFO)
<span class="lineNum">      38 </span>            : #include &lt;sys/sysinfo.h&gt;
<span class="lineNum">      39 </span>            : #endif
<span class="lineNum">      40 </span>            : #if defined(SOLARIS)
<span class="lineNum">      41 </span>            : #include &lt;sys/loadavg.h&gt;
<span class="lineNum">      42 </span>            : #endif
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : #include &quot;asterisk/lock.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;asterisk/cli.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;asterisk/pbx.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;asterisk/channel.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;asterisk/file.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;asterisk/callerid.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;asterisk/cdr.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;asterisk/config.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;asterisk/term.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;asterisk/time.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;asterisk/manager.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;asterisk/ast_expr.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;asterisk/linkedlists.h&quot;
<span class="lineNum">      57 </span>            : #define SAY_STUBS       /* generate declarations and stubs for say methods */
<span class="lineNum">      58 </span>            : #include &quot;asterisk/say.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;asterisk/utils.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;asterisk/causes.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;asterisk/musiconhold.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;asterisk/app.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;asterisk/devicestate.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;asterisk/presencestate.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;asterisk/hashtab.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;asterisk/module.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;asterisk/indications.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;asterisk/taskprocessor.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;asterisk/xmldoc.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;asterisk/astobj2.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;asterisk/stasis_channels.h&quot;
<span class="lineNum">      72 </span>            : #include &quot;asterisk/dial.h&quot;
<span class="lineNum">      73 </span>            : #include &quot;asterisk/vector.h&quot;
<span class="lineNum">      74 </span>            : #include &quot;pbx_private.h&quot;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : /*!
<span class="lineNum">      77 </span>            :  * \note I M P O R T A N T :
<span class="lineNum">      78 </span>            :  *
<span class="lineNum">      79 </span>            :  *              The speed of extension handling will likely be among the most important
<span class="lineNum">      80 </span>            :  * aspects of this PBX.  The switching scheme as it exists right now isn't
<span class="lineNum">      81 </span>            :  * terribly bad (it's O(N+M), where N is the # of extensions and M is the avg #
<span class="lineNum">      82 </span>            :  * of priorities, but a constant search time here would be great ;-)
<span class="lineNum">      83 </span>            :  *
<span class="lineNum">      84 </span>            :  * A new algorithm to do searching based on a 'compiled' pattern tree is introduced
<span class="lineNum">      85 </span>            :  * here, and shows a fairly flat (constant) search time, even for over
<span class="lineNum">      86 </span>            :  * 10000 patterns.
<span class="lineNum">      87 </span>            :  *
<span class="lineNum">      88 </span>            :  * Also, using a hash table for context/priority name lookup can help prevent
<span class="lineNum">      89 </span>            :  * the find_extension routines from absorbing exponential cpu cycles as the number
<span class="lineNum">      90 </span>            :  * of contexts/priorities grow. I've previously tested find_extension with red-black trees,
<span class="lineNum">      91 </span>            :  * which have O(log2(n)) speed. Right now, I'm using hash tables, which do
<span class="lineNum">      92 </span>            :  * searches (ideally) in O(1) time. While these techniques do not yield much
<span class="lineNum">      93 </span>            :  * speed in small dialplans, they are worth the trouble in large dialplans.
<span class="lineNum">      94 </span>            :  *
<span class="lineNum">      95 </span>            :  */
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : /*** DOCUMENTATION
<span class="lineNum">      98 </span>            :         &lt;function name=&quot;EXCEPTION&quot; language=&quot;en_US&quot;&gt;
<span class="lineNum">      99 </span>            :                 &lt;synopsis&gt;
<span class="lineNum">     100 </span>            :                         Retrieve the details of the current dialplan exception.
<span class="lineNum">     101 </span>            :                 &lt;/synopsis&gt;
<span class="lineNum">     102 </span>            :                 &lt;syntax&gt;
<span class="lineNum">     103 </span>            :                         &lt;parameter name=&quot;field&quot; required=&quot;true&quot;&gt;
<span class="lineNum">     104 </span>            :                                 &lt;para&gt;The following fields are available for retrieval:&lt;/para&gt;
<span class="lineNum">     105 </span>            :                                 &lt;enumlist&gt;
<span class="lineNum">     106 </span>            :                                         &lt;enum name=&quot;reason&quot;&gt;
<span class="lineNum">     107 </span>            :                                                 &lt;para&gt;INVALID, ERROR, RESPONSETIMEOUT, ABSOLUTETIMEOUT, or custom
<span class="lineNum">     108 </span>            :                                                 value set by the RaiseException() application&lt;/para&gt;
<span class="lineNum">     109 </span>            :                                         &lt;/enum&gt;
<span class="lineNum">     110 </span>            :                                         &lt;enum name=&quot;context&quot;&gt;
<span class="lineNum">     111 </span>            :                                                 &lt;para&gt;The context executing when the exception occurred.&lt;/para&gt;
<span class="lineNum">     112 </span>            :                                         &lt;/enum&gt;
<span class="lineNum">     113 </span>            :                                         &lt;enum name=&quot;exten&quot;&gt;
<span class="lineNum">     114 </span>            :                                                 &lt;para&gt;The extension executing when the exception occurred.&lt;/para&gt;
<span class="lineNum">     115 </span>            :                                         &lt;/enum&gt;
<span class="lineNum">     116 </span>            :                                         &lt;enum name=&quot;priority&quot;&gt;
<span class="lineNum">     117 </span>            :                                                 &lt;para&gt;The numeric priority executing when the exception occurred.&lt;/para&gt;
<span class="lineNum">     118 </span>            :                                         &lt;/enum&gt;
<span class="lineNum">     119 </span>            :                                 &lt;/enumlist&gt;
<span class="lineNum">     120 </span>            :                         &lt;/parameter&gt;
<span class="lineNum">     121 </span>            :                 &lt;/syntax&gt;
<span class="lineNum">     122 </span>            :                 &lt;description&gt;
<span class="lineNum">     123 </span>            :                         &lt;para&gt;Retrieve the details (specified &lt;replaceable&gt;field&lt;/replaceable&gt;) of the current dialplan exception.&lt;/para&gt;
<span class="lineNum">     124 </span>            :                 &lt;/description&gt;
<span class="lineNum">     125 </span>            :                 &lt;see-also&gt;
<span class="lineNum">     126 </span>            :                         &lt;ref type=&quot;application&quot;&gt;RaiseException&lt;/ref&gt;
<span class="lineNum">     127 </span>            :                 &lt;/see-also&gt;
<span class="lineNum">     128 </span>            :         &lt;/function&gt;
<span class="lineNum">     129 </span>            :         &lt;function name=&quot;TESTTIME&quot; language=&quot;en_US&quot;&gt;
<span class="lineNum">     130 </span>            :                 &lt;synopsis&gt;
<span class="lineNum">     131 </span>            :                         Sets a time to be used with the channel to test logical conditions.
<span class="lineNum">     132 </span>            :                 &lt;/synopsis&gt;
<span class="lineNum">     133 </span>            :                 &lt;syntax&gt;
<span class="lineNum">     134 </span>            :                         &lt;parameter name=&quot;date&quot; required=&quot;true&quot; argsep=&quot; &quot;&gt;
<span class="lineNum">     135 </span>            :                                 &lt;para&gt;Date in ISO 8601 format&lt;/para&gt;
<span class="lineNum">     136 </span>            :                         &lt;/parameter&gt;
<span class="lineNum">     137 </span>            :                         &lt;parameter name=&quot;time&quot; required=&quot;true&quot; argsep=&quot; &quot;&gt;
<span class="lineNum">     138 </span>            :                                 &lt;para&gt;Time in HH:MM:SS format (24-hour time)&lt;/para&gt;
<span class="lineNum">     139 </span>            :                         &lt;/parameter&gt;
<span class="lineNum">     140 </span>            :                         &lt;parameter name=&quot;zone&quot; required=&quot;false&quot;&gt;
<span class="lineNum">     141 </span>            :                                 &lt;para&gt;Timezone name&lt;/para&gt;
<span class="lineNum">     142 </span>            :                         &lt;/parameter&gt;
<span class="lineNum">     143 </span>            :                 &lt;/syntax&gt;
<span class="lineNum">     144 </span>            :                 &lt;description&gt;
<span class="lineNum">     145 </span>            :                         &lt;para&gt;To test dialplan timing conditions at times other than the current time, use
<span class="lineNum">     146 </span>            :                         this function to set an alternate date and time.  For example, you may wish to evaluate
<span class="lineNum">     147 </span>            :                         whether a location will correctly identify to callers that the area is closed on Christmas
<span class="lineNum">     148 </span>            :                         Day, when Christmas would otherwise fall on a day when the office is normally open.&lt;/para&gt;
<span class="lineNum">     149 </span>            :                 &lt;/description&gt;
<span class="lineNum">     150 </span>            :                 &lt;see-also&gt;
<span class="lineNum">     151 </span>            :                         &lt;ref type=&quot;application&quot;&gt;GotoIfTime&lt;/ref&gt;
<span class="lineNum">     152 </span>            :                 &lt;/see-also&gt;
<span class="lineNum">     153 </span>            :         &lt;/function&gt;
<span class="lineNum">     154 </span>            :         &lt;manager name=&quot;ShowDialPlan&quot; language=&quot;en_US&quot;&gt;
<span class="lineNum">     155 </span>            :                 &lt;synopsis&gt;
<span class="lineNum">     156 </span>            :                         Show dialplan contexts and extensions
<span class="lineNum">     157 </span>            :                 &lt;/synopsis&gt;
<span class="lineNum">     158 </span>            :                 &lt;syntax&gt;
<span class="lineNum">     159 </span>            :                         &lt;xi:include xpointer=&quot;xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])&quot; /&gt;
<span class="lineNum">     160 </span>            :                         &lt;parameter name=&quot;Extension&quot;&gt;
<span class="lineNum">     161 </span>            :                                 &lt;para&gt;Show a specific extension.&lt;/para&gt;
<span class="lineNum">     162 </span>            :                         &lt;/parameter&gt;
<span class="lineNum">     163 </span>            :                         &lt;parameter name=&quot;Context&quot;&gt;
<span class="lineNum">     164 </span>            :                                 &lt;para&gt;Show a specific context.&lt;/para&gt;
<span class="lineNum">     165 </span>            :                         &lt;/parameter&gt;
<span class="lineNum">     166 </span>            :                 &lt;/syntax&gt;
<span class="lineNum">     167 </span>            :                 &lt;description&gt;
<span class="lineNum">     168 </span>            :                         &lt;para&gt;Show dialplan contexts and extensions. Be aware that showing the full dialplan
<span class="lineNum">     169 </span>            :                         may take a lot of capacity.&lt;/para&gt;
<span class="lineNum">     170 </span>            :                 &lt;/description&gt;
<span class="lineNum">     171 </span>            :         &lt;/manager&gt;
<span class="lineNum">     172 </span>            :         &lt;manager name=&quot;ExtensionStateList&quot; language=&quot;en_US&quot;&gt;
<span class="lineNum">     173 </span>            :                 &lt;synopsis&gt;
<span class="lineNum">     174 </span>            :                         List the current known extension states.
<span class="lineNum">     175 </span>            :                 &lt;/synopsis&gt;
<span class="lineNum">     176 </span>            :                 &lt;syntax&gt;
<span class="lineNum">     177 </span>            :                         &lt;xi:include xpointer=&quot;xpointer(/docs/manager[@name='Login']/syntax/parameter[@name='ActionID'])&quot; /&gt;
<span class="lineNum">     178 </span>            :                 &lt;/syntax&gt;
<span class="lineNum">     179 </span>            :                 &lt;description&gt;
<span class="lineNum">     180 </span>            :                         &lt;para&gt;This will list out all known extension states in a
<span class="lineNum">     181 </span>            :                         sequence of &lt;replaceable&gt;ExtensionStatus&lt;/replaceable&gt; events.
<span class="lineNum">     182 </span>            :                         When finished, a &lt;replaceable&gt;ExtensionStateListComplete&lt;/replaceable&gt; event
<span class="lineNum">     183 </span>            :                         will be emitted.&lt;/para&gt;
<span class="lineNum">     184 </span>            :                 &lt;/description&gt;
<span class="lineNum">     185 </span>            :                 &lt;see-also&gt;
<span class="lineNum">     186 </span>            :                         &lt;ref type=&quot;manager&quot;&gt;ExtensionState&lt;/ref&gt;
<span class="lineNum">     187 </span>            :                         &lt;ref type=&quot;function&quot;&gt;HINT&lt;/ref&gt;
<span class="lineNum">     188 </span>            :                         &lt;ref type=&quot;function&quot;&gt;EXTENSION_STATE&lt;/ref&gt;
<span class="lineNum">     189 </span>            :                 &lt;/see-also&gt;
<span class="lineNum">     190 </span>            :                 &lt;responses&gt;
<span class="lineNum">     191 </span>            :                         &lt;list-elements&gt;
<span class="lineNum">     192 </span>            :                                 &lt;xi:include xpointer=&quot;xpointer(/docs/managerEvent[@name='ExtensionStatus'])&quot; /&gt;
<span class="lineNum">     193 </span>            :                         &lt;/list-elements&gt;
<span class="lineNum">     194 </span>            :                         &lt;managerEvent name=&quot;ExtensionStateListComplete&quot; language=&quot;en_US&quot;&gt;
<span class="lineNum">     195 </span>            :                                 &lt;managerEventInstance class=&quot;EVENT_FLAG_COMMAND&quot;&gt;
<span class="lineNum">     196 </span>            :                                         &lt;synopsis&gt;
<span class="lineNum">     197 </span>            :                                                 Indicates the end of the list the current known extension states.
<span class="lineNum">     198 </span>            :                                         &lt;/synopsis&gt;
<span class="lineNum">     199 </span>            :                                         &lt;syntax&gt;
<span class="lineNum">     200 </span>            :                                                 &lt;parameter name=&quot;EventList&quot;&gt;
<span class="lineNum">     201 </span>            :                                                         &lt;para&gt;Conveys the status of the event list.&lt;/para&gt;
<span class="lineNum">     202 </span>            :                                                 &lt;/parameter&gt;
<span class="lineNum">     203 </span>            :                                                 &lt;parameter name=&quot;ListItems&quot;&gt;
<span class="lineNum">     204 </span>            :                                                         &lt;para&gt;Conveys the number of statuses reported.&lt;/para&gt;
<span class="lineNum">     205 </span>            :                                                 &lt;/parameter&gt;
<span class="lineNum">     206 </span>            :                                         &lt;/syntax&gt;
<span class="lineNum">     207 </span>            :                                 &lt;/managerEventInstance&gt;
<span class="lineNum">     208 </span>            :                         &lt;/managerEvent&gt;
<span class="lineNum">     209 </span>            :                 &lt;/responses&gt;
<span class="lineNum">     210 </span>            :         &lt;/manager&gt;
<span class="lineNum">     211 </span>            :  ***/
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : #ifdef LOW_MEMORY
<span class="lineNum">     214 </span>            : #define EXT_DATA_SIZE 256
<span class="lineNum">     215 </span>            : #else
<span class="lineNum">     216 </span>            : #define EXT_DATA_SIZE 8192
<span class="lineNum">     217 </span>            : #endif
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : #define SWITCH_DATA_LENGTH 256
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            : #define VAR_NORMAL              1
<span class="lineNum">     222 </span>            : #define VAR_SOFTTRAN    2
<span class="lineNum">     223 </span>            : #define VAR_HARDTRAN    3
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            : struct ast_context;
<a name="226"><span class="lineNum">     226 </span>            : struct ast_app;</a>
<a name="227"><span class="lineNum">     227 </span>            : </a>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 : AST_THREADSTORAGE(switch_data);</span>
<span class="lineNum">     229 </span><span class="lineCov">         82 : AST_THREADSTORAGE(extensionstate_buf);</span>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : /*!
<span class="lineNum">     232 </span>            :    \brief ast_exten: An extension
<span class="lineNum">     233 </span>            :         The dialplan is saved as a linked list with each context
<span class="lineNum">     234 </span>            :         having it's own linked list of extensions - one item per
<span class="lineNum">     235 </span>            :         priority.
<span class="lineNum">     236 </span>            : */
<span class="lineNum">     237 </span>            : struct ast_exten {
<span class="lineNum">     238 </span>            :         char *exten;                    /*!&lt; Clean Extension id */
<span class="lineNum">     239 </span>            :         char *name;                     /*!&lt; Extension name (may include '-' eye candy) */
<span class="lineNum">     240 </span>            :         int matchcid;                   /*!&lt; Match caller id ? */
<span class="lineNum">     241 </span>            :         const char *cidmatch;           /*!&lt; Caller id to match for this extension */
<span class="lineNum">     242 </span>            :         const char *cidmatch_display;   /*!&lt; Caller id to match (display version) */
<span class="lineNum">     243 </span>            :         int priority;                   /*!&lt; Priority */
<span class="lineNum">     244 </span>            :         const char *label;              /*!&lt; Label */
<span class="lineNum">     245 </span>            :         struct ast_context *parent;     /*!&lt; The context this extension belongs to  */
<span class="lineNum">     246 </span>            :         const char *app;                /*!&lt; Application to execute */
<span class="lineNum">     247 </span>            :         struct ast_app *cached_app;     /*!&lt; Cached location of application */
<span class="lineNum">     248 </span>            :         void *data;                     /*!&lt; Data to use (arguments) */
<span class="lineNum">     249 </span>            :         void (*datad)(void *);          /*!&lt; Data destructor */
<span class="lineNum">     250 </span>            :         struct ast_exten *peer;         /*!&lt; Next higher priority with our extension */
<span class="lineNum">     251 </span>            :         struct ast_hashtab *peer_table;    /*!&lt; Priorities list in hashtab form -- only on the head of the peer list */
<span class="lineNum">     252 </span>            :         struct ast_hashtab *peer_label_table; /*!&lt; labeled priorities in the peers -- only on the head of the peer list */
<span class="lineNum">     253 </span>            :         const char *registrar;          /*!&lt; Registrar */
<span class="lineNum">     254 </span>            :         const char *registrar_file;     /*!&lt; File name used to register extension */
<span class="lineNum">     255 </span>            :         int registrar_line;             /*!&lt; Line number the extension was registered in text */
<span class="lineNum">     256 </span>            :         struct ast_exten *next;         /*!&lt; Extension with a greater ID */
<span class="lineNum">     257 </span>            :         char stuff[0];
<span class="lineNum">     258 </span>            : };
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : /*! \brief match_char: forms a syntax tree for quick matching of extension patterns */
<span class="lineNum">     261 </span>            : struct match_char
<span class="lineNum">     262 </span>            : {
<span class="lineNum">     263 </span>            :         int is_pattern; /* the pattern started with '_' */
<span class="lineNum">     264 </span>            :         int deleted;    /* if this is set, then... don't return it */
<span class="lineNum">     265 </span>            :         int specificity; /* simply the strlen of x, or 10 for X, 9 for Z, and 8 for N; and '.' and '!' will add 11 ? */
<span class="lineNum">     266 </span>            :         struct match_char *alt_char;
<span class="lineNum">     267 </span>            :         struct match_char *next_char;
<span class="lineNum">     268 </span>            :         struct ast_exten *exten; /* attached to last char of a pattern for exten */
<span class="lineNum">     269 </span>            :         char x[1];       /* the pattern itself-- matches a single char */
<span class="lineNum">     270 </span>            : };
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : struct scoreboard  /* make sure all fields are 0 before calling new_find_extension */
<span class="lineNum">     273 </span>            : {
<span class="lineNum">     274 </span>            :         int total_specificity;
<span class="lineNum">     275 </span>            :         int total_length;
<span class="lineNum">     276 </span>            :         char last_char;   /* set to ! or . if they are the end of the pattern */
<span class="lineNum">     277 </span>            :         int canmatch;     /* if the string to match was just too short */
<span class="lineNum">     278 </span>            :         struct match_char *node;
<span class="lineNum">     279 </span>            :         struct ast_exten *canmatch_exten;
<span class="lineNum">     280 </span>            :         struct ast_exten *exten;
<span class="lineNum">     281 </span>            : };
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : /*! \brief ast_context: An extension context - must remain in sync with fake_context */
<span class="lineNum">     284 </span>            : struct ast_context {
<span class="lineNum">     285 </span>            :         ast_rwlock_t lock;                      /*!&lt; A lock to prevent multiple threads from clobbering the context */
<span class="lineNum">     286 </span>            :         struct ast_exten *root;                 /*!&lt; The root of the list of extensions */
<span class="lineNum">     287 </span>            :         struct ast_hashtab *root_table;            /*!&lt; For exact matches on the extensions in the pattern tree, and for traversals of the pattern_tree  */
<span class="lineNum">     288 </span>            :         struct match_char *pattern_tree;        /*!&lt; A tree to speed up extension pattern matching */
<span class="lineNum">     289 </span>            :         struct ast_context *next;               /*!&lt; Link them together */
<span class="lineNum">     290 </span>            :         struct ast_includes includes;           /*!&lt; Include other contexts */
<span class="lineNum">     291 </span>            :         struct ast_ignorepats ignorepats;       /*!&lt; Patterns for which to continue playing dialtone */
<span class="lineNum">     292 </span>            :         struct ast_sws alts;                    /*!&lt; Alternative switches */
<span class="lineNum">     293 </span>            :         char *registrar;                        /*!&lt; Registrar -- make sure you malloc this, as the registrar may have to survive module unloads */
<span class="lineNum">     294 </span>            :         int refcount;                   /*!&lt; each module that would have created this context should inc/dec this as appropriate */
<span class="lineNum">     295 </span>            :         int autohints;                  /*!&lt; Whether autohints support is enabled or not */
<span class="lineNum">     296 </span>            :         ast_mutex_t macrolock;                  /*!&lt; A lock to implement &quot;exclusive&quot; macros - held whilst a call is executing in the macro */
<span class="lineNum">     297 </span>            :         char name[0];                           /*!&lt; Name of the context */
<span class="lineNum">     298 </span>            : };
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : /*! \brief ast_state_cb: An extension state notify register item */
<span class="lineNum">     301 </span>            : struct ast_state_cb {
<span class="lineNum">     302 </span>            :         /*! Watcher ID returned when registered. */
<span class="lineNum">     303 </span>            :         int id;
<span class="lineNum">     304 </span>            :         /*! Arbitrary data passed for callbacks. */
<span class="lineNum">     305 </span>            :         void *data;
<span class="lineNum">     306 </span>            :         /*! Flag if this callback is an extended callback containing detailed device status */
<span class="lineNum">     307 </span>            :         int extended;
<span class="lineNum">     308 </span>            :         /*! Callback when state changes. */
<span class="lineNum">     309 </span>            :         ast_state_cb_type change_cb;
<span class="lineNum">     310 </span>            :         /*! Callback when destroyed so any resources given by the registerer can be freed. */
<span class="lineNum">     311 </span>            :         ast_state_cb_destroy_type destroy_cb;
<span class="lineNum">     312 </span>            :         /*! \note Only used by ast_merge_contexts_and_delete */
<span class="lineNum">     313 </span>            :         AST_LIST_ENTRY(ast_state_cb) entry;
<span class="lineNum">     314 </span>            : };
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            : /*!
<span class="lineNum">     317 </span>            :  * \brief Structure for dial plan hints
<span class="lineNum">     318 </span>            :  *
<span class="lineNum">     319 </span>            :  * \note Hints are pointers from an extension in the dialplan to
<span class="lineNum">     320 </span>            :  * one or more devices (tech/name)
<span class="lineNum">     321 </span>            :  *
<span class="lineNum">     322 </span>            :  * See \ref AstExtState
<span class="lineNum">     323 </span>            :  */
<span class="lineNum">     324 </span>            : struct ast_hint {
<span class="lineNum">     325 </span>            :         /*!
<span class="lineNum">     326 </span>            :          * \brief Hint extension
<span class="lineNum">     327 </span>            :          *
<span class="lineNum">     328 </span>            :          * \note
<span class="lineNum">     329 </span>            :          * Will never be NULL while the hint is in the hints container.
<span class="lineNum">     330 </span>            :          */
<span class="lineNum">     331 </span>            :         struct ast_exten *exten;
<span class="lineNum">     332 </span>            :         struct ao2_container *callbacks; /*!&lt; Device state callback container for this extension */
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :         /*! Dev state variables */
<span class="lineNum">     335 </span>            :         int laststate;                  /*!&lt; Last known device state */
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :         /*! Presence state variables */
<span class="lineNum">     338 </span>            :         int last_presence_state;     /*!&lt; Last known presence state */
<span class="lineNum">     339 </span>            :         char *last_presence_subtype; /*!&lt; Last known presence subtype string */
<span class="lineNum">     340 </span>            :         char *last_presence_message; /*!&lt; Last known presence message string */
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :         char context_name[AST_MAX_CONTEXT];/*!&lt; Context of destroyed hint extension. */
<span class="lineNum">     343 </span>            :         char exten_name[AST_MAX_EXTENSION];/*!&lt; Extension of destroyed hint extension. */
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            :         AST_VECTOR(, char *) devices; /*!&lt; Devices associated with the hint */
<a name="346"><span class="lineNum">     346 </span>            : };</a>
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineCov">      24376 : STASIS_MESSAGE_TYPE_DEFN_LOCAL(hint_change_message_type);</span>
<a name="349"><span class="lineNum">     349 </span>            : </a>
<span class="lineNum">     350 </span>            : #define HINTDEVICE_DATA_LENGTH 16
<span class="lineNum">     351 </span><span class="lineCov">         82 : AST_THREADSTORAGE(hintdevice_data);</span>
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            : /* --- Hash tables of various objects --------*/
<span class="lineNum">     354 </span>            : #ifdef LOW_MEMORY
<span class="lineNum">     355 </span>            : #define HASH_EXTENHINT_SIZE 17
<span class="lineNum">     356 </span>            : #else
<span class="lineNum">     357 </span>            : #define HASH_EXTENHINT_SIZE 563
<span class="lineNum">     358 </span>            : #endif
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : /*! \brief Container for hint devices */
<span class="lineNum">     362 </span>            : static struct ao2_container *hintdevices;
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            : /*!
<span class="lineNum">     365 </span>            :  * \brief Structure for dial plan hint devices
<span class="lineNum">     366 </span>            :  * \note hintdevice is one device pointing to a hint.
<span class="lineNum">     367 </span>            :  */
<span class="lineNum">     368 </span>            : struct ast_hintdevice {
<span class="lineNum">     369 </span>            :         /*!
<span class="lineNum">     370 </span>            :          * \brief Hint this hintdevice belongs to.
<span class="lineNum">     371 </span>            :          * \note Holds a reference to the hint object.
<span class="lineNum">     372 </span>            :          */
<span class="lineNum">     373 </span>            :         struct ast_hint *hint;
<span class="lineNum">     374 </span>            :         /*! Name of the hint device. */
<span class="lineNum">     375 </span>            :         char hintdevice[1];
<span class="lineNum">     376 </span>            : };
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            : /*! \brief Container for autohint contexts */
<span class="lineNum">     379 </span>            : static struct ao2_container *autohints;
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : /*!
<span class="lineNum">     382 </span>            :  * \brief Structure for dial plan autohints
<span class="lineNum">     383 </span>            :  */
<span class="lineNum">     384 </span>            : struct ast_autohint {
<span class="lineNum">     385 </span>            :         /*! \brief Name of the registrar */
<span class="lineNum">     386 </span>            :         char *registrar;
<span class="lineNum">     387 </span>            :         /*! \brief Name of the context */
<span class="lineNum">     388 </span>            :         char context[1];
<span class="lineNum">     389 </span>            : };
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : /*!
<a name="392"><span class="lineNum">     392 </span>            :  * \note Using the device for hash</a>
<span class="lineNum">     393 </span>            :  */
<span class="lineNum">     394 </span><span class="lineCov">        672 : static int hintdevice_hash_cb(const void *obj, const int flags)</span>
<span class="lineNum">     395 </span>            : {
<span class="lineNum">     396 </span>            :         const struct ast_hintdevice *ext;
<span class="lineNum">     397 </span>            :         const char *key;
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span><span class="lineCov">        672 :         switch (flags &amp; OBJ_SEARCH_MASK) {</span>
<span class="lineNum">     400 </span><span class="lineCov">        176 :         case OBJ_SEARCH_KEY:</span>
<span class="lineNum">     401 </span><span class="lineCov">        176 :                 key = obj;</span>
<span class="lineNum">     402 </span><span class="lineCov">        176 :                 break;</span>
<span class="lineNum">     403 </span><span class="lineCov">        496 :         case OBJ_SEARCH_OBJECT:</span>
<span class="lineNum">     404 </span><span class="lineCov">        496 :                 ext = obj;</span>
<span class="lineNum">     405 </span><span class="lineCov">        496 :                 key = ext-&gt;hintdevice;</span>
<span class="lineNum">     406 </span><span class="lineCov">        496 :                 break;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                 ast_assert(0);</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     410 </span>            :         }
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span><span class="lineCov">        672 :         return ast_str_case_hash(key);</span>
<span class="lineNum">     413 </span>            : }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : /*!
<span class="lineNum">     416 </span>            :  * \note Devices on hints are not unique so no CMP_STOP is returned
<span class="lineNum">     417 </span>            :  * Dont use ao2_find against hintdevices container cause there always
<a name="418"><span class="lineNum">     418 </span>            :  * could be more than one result.</a>
<span class="lineNum">     419 </span>            :  */
<span class="lineNum">     420 </span><span class="lineCov">        157 : static int hintdevice_cmp_multiple(void *obj, void *arg, int flags)</span>
<span class="lineNum">     421 </span>            : {
<span class="lineNum">     422 </span><span class="lineCov">        157 :         struct ast_hintdevice *left = obj;</span>
<span class="lineNum">     423 </span><span class="lineCov">        157 :         struct ast_hintdevice *right = arg;</span>
<span class="lineNum">     424 </span><span class="lineCov">        157 :         const char *right_key = arg;</span>
<span class="lineNum">     425 </span>            :         int cmp;
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span><span class="lineCov">        157 :         switch (flags &amp; OBJ_SEARCH_MASK) {</span>
<span class="lineNum">     428 </span><span class="lineCov">        157 :         case OBJ_SEARCH_OBJECT:</span>
<span class="lineNum">     429 </span><span class="lineCov">        157 :                 right_key = right-&gt;hintdevice;</span>
<span class="lineNum">     430 </span>            :                 /* Fall through */
<span class="lineNum">     431 </span><span class="lineCov">        157 :         case OBJ_SEARCH_KEY:</span>
<span class="lineNum">     432 </span><span class="lineCov">        157 :                 cmp = strcasecmp(left-&gt;hintdevice, right_key);</span>
<span class="lineNum">     433 </span><span class="lineCov">        157 :                 break;</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :         case OBJ_SEARCH_PARTIAL_KEY:</span>
<span class="lineNum">     435 </span>            :                 /*
<span class="lineNum">     436 </span>            :                 * We could also use a partial key struct containing a length
<span class="lineNum">     437 </span>            :                 * so strlen() does not get called for every comparison instead.
<span class="lineNum">     438 </span>            :                 */
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :                 cmp = strncmp(left-&gt;hintdevice, right_key, strlen(right_key));</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :                 ast_assert(0);</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :                 cmp = 0;</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     445 </span>            :         }
<span class="lineNum">     446 </span><span class="lineCov">        157 :         return cmp ? 0 : CMP_MATCH;</span>
<span class="lineNum">     447 </span>            : }
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            : /*!
<a name="450"><span class="lineNum">     450 </span>            :  * \note Using the context name for hash</a>
<span class="lineNum">     451 </span>            :  */
<span class="lineNum">     452 </span><span class="lineCov">          1 : static int autohint_hash_cb(const void *obj, const int flags)</span>
<span class="lineNum">     453 </span>            : {
<span class="lineNum">     454 </span>            :         const struct ast_autohint *autohint;
<span class="lineNum">     455 </span>            :         const char *key;
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span><span class="lineCov">          1 :         switch (flags &amp; OBJ_SEARCH_MASK) {</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :         case OBJ_SEARCH_KEY:</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                 key = obj;</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     461 </span><span class="lineCov">          1 :         case OBJ_SEARCH_OBJECT:</span>
<span class="lineNum">     462 </span><span class="lineCov">          1 :                 autohint = obj;</span>
<span class="lineNum">     463 </span><span class="lineCov">          1 :                 key = autohint-&gt;context;</span>
<span class="lineNum">     464 </span><span class="lineCov">          1 :                 break;</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                 ast_assert(0);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     468 </span>            :         }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineCov">          1 :         return ast_str_case_hash(key);</span>
<a name="471"><span class="lineNum">     471 </span>            : }</a>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 : static int autohint_cmp(void *obj, void *arg, int flags)</span>
<span class="lineNum">     474 </span>            : {
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :         struct ast_autohint *left = obj;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :         struct ast_autohint *right = arg;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :         const char *right_key = arg;</span>
<span class="lineNum">     478 </span>            :         int cmp;
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :         switch (flags &amp; OBJ_SEARCH_MASK) {</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :         case OBJ_SEARCH_OBJECT:</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :                 right_key = right-&gt;context;</span>
<span class="lineNum">     483 </span>            :                 /* Fall through */
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :         case OBJ_SEARCH_KEY:</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :                 cmp = strcasecmp(left-&gt;context, right_key);</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :         case OBJ_SEARCH_PARTIAL_KEY:</span>
<span class="lineNum">     488 </span>            :                 /*
<span class="lineNum">     489 </span>            :                 * We could also use a partial key struct containing a length
<span class="lineNum">     490 </span>            :                 * so strlen() does not get called for every comparison instead.
<span class="lineNum">     491 </span>            :                 */
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :                 cmp = strncmp(left-&gt;context, right_key, strlen(right_key));</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :                 ast_assert(0);</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :                 cmp = 0;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     498 </span>            :         }
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :         return cmp ? 0 : CMP_MATCH | CMP_STOP;</span>
<span class="lineNum">     500 </span>            : }
<a name="501"><span class="lineNum">     501 </span>            : </a>
<span class="lineNum">     502 </span>            : /*! \internal \brief \c ao2_callback function to remove hintdevices */
<span class="lineNum">     503 </span><span class="lineCov">        176 : static int hintdevice_remove_cb(void *obj, void *arg, void *data, int flags)</span>
<span class="lineNum">     504 </span>            : {
<span class="lineNum">     505 </span><span class="lineCov">        176 :         struct ast_hintdevice *candidate = obj;</span>
<span class="lineNum">     506 </span><span class="lineCov">        176 :         char *device = arg;</span>
<span class="lineNum">     507 </span><span class="lineCov">        176 :         struct ast_hint *hint = data;</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span><span class="lineCov">        176 :         if (!strcasecmp(candidate-&gt;hintdevice, device)</span>
<span class="lineNum">     510 </span><span class="lineCov">        176 :                 &amp;&amp; candidate-&gt;hint == hint) {</span>
<span class="lineNum">     511 </span><span class="lineCov">        176 :                 return CMP_MATCH;</span>
<span class="lineNum">     512 </span>            :         }
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="514"><span class="lineNum">     514 </span>            : }</a>
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineCov">        162 : static int remove_hintdevice(struct ast_hint *hint)</span>
<span class="lineNum">     517 </span>            : {
<span class="lineNum">     518 </span><span class="lineCov">        338 :         while (AST_VECTOR_SIZE(&amp;hint-&gt;devices) &gt; 0) {</span>
<span class="lineNum">     519 </span><span class="lineCov">        176 :                 char *device = AST_VECTOR_GET(&amp;hint-&gt;devices, 0);</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineCov">        176 :                 ao2_t_callback_data(hintdevices, OBJ_SEARCH_KEY | OBJ_UNLINK | OBJ_NODATA,</span>
<span class="lineNum">     522 </span>            :                         hintdevice_remove_cb, device, hint, &quot;Remove device from container&quot;);
<span class="lineNum">     523 </span><span class="lineCov">        176 :                 AST_VECTOR_REMOVE_UNORDERED(&amp;hint-&gt;devices, 0);</span>
<span class="lineNum">     524 </span><span class="lineCov">        176 :                 ast_free(device);</span>
<span class="lineNum">     525 </span>            :         }
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">        162 :         return 0;</span>
<span class="lineNum">     528 </span>            : }
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            : static char *parse_hint_device(struct ast_str *hint_args);
<span class="lineNum">     531 </span>            : /*!
<span class="lineNum">     532 </span>            :  * \internal
<span class="lineNum">     533 </span>            :  * \brief Destroy the given hintdevice object.
<span class="lineNum">     534 </span>            :  *
<span class="lineNum">     535 </span>            :  * \param obj Hint device to destroy.
<span class="lineNum">     536 </span>            :  *
<a name="537"><span class="lineNum">     537 </span>            :  * \return Nothing</a>
<span class="lineNum">     538 </span>            :  */
<span class="lineNum">     539 </span><span class="lineCov">        177 : static void hintdevice_destroy(void *obj)</span>
<span class="lineNum">     540 </span>            : {
<span class="lineNum">     541 </span><span class="lineCov">        177 :         struct ast_hintdevice *doomed = obj;</span>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineCov">        177 :         if (doomed-&gt;hint) {</span>
<span class="lineNum">     544 </span><span class="lineCov">        177 :                 ao2_ref(doomed-&gt;hint, -1);</span>
<span class="lineNum">     545 </span><span class="lineCov">        177 :                 doomed-&gt;hint = NULL;</span>
<span class="lineNum">     546 </span>            :         }
<span class="lineNum">     547 </span><span class="lineCov">        177 : }</span>
<span class="lineNum">     548 </span>            : 
<a name="549"><span class="lineNum">     549 </span>            : /*! \brief add hintdevice structure and link it into the container.</a>
<span class="lineNum">     550 </span>            :  */
<span class="lineNum">     551 </span><span class="lineCov">        163 : static int add_hintdevice(struct ast_hint *hint, const char *devicelist)</span>
<span class="lineNum">     552 </span>            : {
<span class="lineNum">     553 </span>            :         struct ast_str *str;
<span class="lineNum">     554 </span>            :         char *parse;
<span class="lineNum">     555 </span>            :         char *cur;
<span class="lineNum">     556 </span>            :         struct ast_hintdevice *device;
<span class="lineNum">     557 </span>            :         int devicelength;
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span><span class="lineCov">        163 :         if (!hint || !devicelist) {</span>
<span class="lineNum">     560 </span>            :                 /* Trying to add garbage? Don't bother. */
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     562 </span>            :         }
<span class="lineNum">     563 </span><span class="lineCov">        163 :         if (!(str = ast_str_thread_get(&amp;hintdevice_data, 16))) {</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">     565 </span>            :         }
<span class="lineNum">     566 </span><span class="lineCov">        163 :         ast_str_set(&amp;str, 0, &quot;%s&quot;, devicelist);</span>
<span class="lineNum">     567 </span><span class="lineCov">        163 :         parse = ast_str_buffer(str);</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            :         /* Spit on '&amp;' and ',' to handle presence hints as well */
<span class="lineNum">     570 </span><span class="lineCov">        342 :         while ((cur = strsep(&amp;parse, &quot;&amp;,&quot;))) {</span>
<span class="lineNum">     571 </span>            :                 char *device_name;
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineCov">        179 :                 devicelength = strlen(cur);</span>
<span class="lineNum">     574 </span><span class="lineCov">        179 :                 if (!devicelength) {</span>
<span class="lineNum">     575 </span><span class="lineCov">          2 :                         continue;</span>
<span class="lineNum">     576 </span>            :                 }
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineCov">        177 :                 device_name = ast_strdup(cur);</span>
<span class="lineNum">     579 </span><span class="lineCov">        177 :                 if (!device_name) {</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">     581 </span>            :                 }
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineCov">        177 :                 device = ao2_t_alloc(sizeof(*device) + devicelength, hintdevice_destroy,</span>
<span class="lineNum">     584 </span>            :                         &quot;allocating a hintdevice structure&quot;);
<span class="lineNum">     585 </span><span class="lineCov">        177 :                 if (!device) {</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :                         ast_free(device_name);</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">     588 </span>            :                 }
<span class="lineNum">     589 </span><span class="lineCov">        177 :                 strcpy(device-&gt;hintdevice, cur);</span>
<span class="lineNum">     590 </span><span class="lineCov">        177 :                 ao2_ref(hint, +1);</span>
<span class="lineNum">     591 </span><span class="lineCov">        177 :                 device-&gt;hint = hint;</span>
<span class="lineNum">     592 </span><span class="lineCov">        177 :                 if (AST_VECTOR_APPEND(&amp;hint-&gt;devices, device_name)) {</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :                         ast_free(device_name);</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :                         ao2_ref(device, -1);</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">     596 </span>            :                 }
<span class="lineNum">     597 </span><span class="lineCov">        177 :                 ao2_t_link(hintdevices, device, &quot;Linking device into hintdevice container.&quot;);</span>
<span class="lineNum">     598 </span><span class="lineCov">        177 :                 ao2_t_ref(device, -1, &quot;hintdevice is linked so we can unref&quot;);</span>
<span class="lineNum">     599 </span>            :         }
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineCov">        163 :         return 0;</span>
<span class="lineNum">     602 </span>            : }
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            : static const struct cfextension_states {
<span class="lineNum">     606 </span>            :         int extension_state;
<span class="lineNum">     607 </span>            :         const char * const text;
<span class="lineNum">     608 </span>            : } extension_states[] = {
<span class="lineNum">     609 </span>            :         { AST_EXTENSION_NOT_INUSE,                     &quot;Idle&quot; },
<span class="lineNum">     610 </span>            :         { AST_EXTENSION_INUSE,                         &quot;InUse&quot; },
<span class="lineNum">     611 </span>            :         { AST_EXTENSION_BUSY,                          &quot;Busy&quot; },
<span class="lineNum">     612 </span>            :         { AST_EXTENSION_UNAVAILABLE,                   &quot;Unavailable&quot; },
<span class="lineNum">     613 </span>            :         { AST_EXTENSION_RINGING,                       &quot;Ringing&quot; },
<span class="lineNum">     614 </span>            :         { AST_EXTENSION_INUSE | AST_EXTENSION_RINGING, &quot;InUse&amp;Ringing&quot; },
<span class="lineNum">     615 </span>            :         { AST_EXTENSION_ONHOLD,                        &quot;Hold&quot; },
<span class="lineNum">     616 </span>            :         { AST_EXTENSION_INUSE | AST_EXTENSION_ONHOLD,  &quot;InUse&amp;Hold&quot; }
<span class="lineNum">     617 </span>            : };
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            : struct pbx_exception {
<span class="lineNum">     620 </span>            :         AST_DECLARE_STRING_FIELDS(
<span class="lineNum">     621 </span>            :                 AST_STRING_FIELD(context);      /*!&lt; Context associated with this exception */
<span class="lineNum">     622 </span>            :                 AST_STRING_FIELD(exten);        /*!&lt; Exten associated with this exception */
<span class="lineNum">     623 </span>            :                 AST_STRING_FIELD(reason);               /*!&lt; The exception reason */
<span class="lineNum">     624 </span>            :         );
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :         int priority;                           /*!&lt; Priority associated with this exception */
<span class="lineNum">     627 </span>            : };
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            : static int matchcid(const char *cidpattern, const char *callerid);
<span class="lineNum">     630 </span>            : #ifdef NEED_DEBUG
<span class="lineNum">     631 </span>            : static void log_match_char_tree(struct match_char *node, char *prefix); /* for use anywhere */
<span class="lineNum">     632 </span>            : #endif
<span class="lineNum">     633 </span>            : static void new_find_extension(const char *str, struct scoreboard *score,
<span class="lineNum">     634 </span>            :                 struct match_char *tree, int length, int spec, const char *callerid,
<span class="lineNum">     635 </span>            :                 const char *label, enum ext_match_t action);
<span class="lineNum">     636 </span>            : static struct match_char *already_in_tree(struct match_char *current, char *pat, int is_pattern);
<span class="lineNum">     637 </span>            : static struct match_char *add_exten_to_pattern_tree(struct ast_context *con,
<span class="lineNum">     638 </span>            :                 struct ast_exten *e1, int findonly);
<span class="lineNum">     639 </span>            : static void create_match_char_tree(struct ast_context *con);
<span class="lineNum">     640 </span>            : static struct ast_exten *get_canmatch_exten(struct match_char *node);
<span class="lineNum">     641 </span>            : static void destroy_pattern_tree(struct match_char *pattern_tree);
<span class="lineNum">     642 </span>            : static int hashtab_compare_extens(const void *ha_a, const void *ah_b);
<span class="lineNum">     643 </span>            : static int hashtab_compare_exten_numbers(const void *ah_a, const void *ah_b);
<span class="lineNum">     644 </span>            : static int hashtab_compare_exten_labels(const void *ah_a, const void *ah_b);
<span class="lineNum">     645 </span>            : static unsigned int hashtab_hash_extens(const void *obj);
<span class="lineNum">     646 </span>            : static unsigned int hashtab_hash_priority(const void *obj);
<span class="lineNum">     647 </span>            : static unsigned int hashtab_hash_labels(const void *obj);
<span class="lineNum">     648 </span>            : static void __ast_internal_context_destroy( struct ast_context *con);
<span class="lineNum">     649 </span>            : static int ast_add_extension_nolock(const char *context, int replace, const char *extension,
<span class="lineNum">     650 </span>            :         int priority, const char *label, const char *callerid,
<span class="lineNum">     651 </span>            :         const char *application, void *data, void (*datad)(void *), const char *registrar);
<span class="lineNum">     652 </span>            : static int ast_add_extension2_lockopt(struct ast_context *con,
<span class="lineNum">     653 </span>            :         int replace, const char *extension, int priority, const char *label, const char *callerid,
<span class="lineNum">     654 </span>            :         const char *application, void *data, void (*datad)(void *),
<span class="lineNum">     655 </span>            :         const char *registrar, const char *registrar_file, int registrar_line,
<span class="lineNum">     656 </span>            :         int lock_context);
<span class="lineNum">     657 </span>            : static struct ast_context *find_context_locked(const char *context);
<span class="lineNum">     658 </span>            : static struct ast_context *find_context(const char *context);
<span class="lineNum">     659 </span>            : static void get_device_state_causing_channels(struct ao2_container *c);
<span class="lineNum">     660 </span>            : static unsigned int ext_strncpy(char *dst, const char *src, size_t dst_size, int nofluff);
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            : /*!
<span class="lineNum">     663 </span>            :  * \internal
<span class="lineNum">     664 </span>            :  * \brief Character array comparison function for qsort.
<span class="lineNum">     665 </span>            :  *
<span class="lineNum">     666 </span>            :  * \param a Left side object.
<span class="lineNum">     667 </span>            :  * \param b Right side object.
<span class="lineNum">     668 </span>            :  *
<span class="lineNum">     669 </span>            :  * \retval &lt;0 if a &lt; b
<span class="lineNum">     670 </span>            :  * \retval =0 if a = b
<a name="671"><span class="lineNum">     671 </span>            :  * \retval &gt;0 if a &gt; b</a>
<span class="lineNum">     672 </span>            :  */
<span class="lineNum">     673 </span><span class="lineCov">        418 : static int compare_char(const void *a, const void *b)</span>
<span class="lineNum">     674 </span>            : {
<span class="lineNum">     675 </span><span class="lineCov">        418 :         const unsigned char *ac = a;</span>
<span class="lineNum">     676 </span><span class="lineCov">        418 :         const unsigned char *bc = b;</span>
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineCov">        418 :         return *ac - *bc;</span>
<span class="lineNum">     679 </span>            : }
<a name="680"><span class="lineNum">     680 </span>            : </a>
<span class="lineNum">     681 </span>            : /* labels, contexts are case sensitive  priority numbers are ints */
<span class="lineNum">     682 </span><span class="lineCov">      62802 : int ast_hashtab_compare_contexts(const void *ah_a, const void *ah_b)</span>
<span class="lineNum">     683 </span>            : {
<span class="lineNum">     684 </span><span class="lineCov">      62802 :         const struct ast_context *ac = ah_a;</span>
<span class="lineNum">     685 </span><span class="lineCov">      62802 :         const struct ast_context *bc = ah_b;</span>
<span class="lineNum">     686 </span><span class="lineCov">      62802 :         if (!ac || !bc) /* safety valve, but it might prevent a crash you'd rather have happen */</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     688 </span>            :         /* assume context names are registered in a string table! */
<span class="lineNum">     689 </span><span class="lineCov">      62802 :         return strcmp(ac-&gt;name, bc-&gt;name);</span>
<a name="690"><span class="lineNum">     690 </span>            : }</a>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineCov">      69372 : static int hashtab_compare_extens(const void *ah_a, const void *ah_b)</span>
<span class="lineNum">     693 </span>            : {
<span class="lineNum">     694 </span><span class="lineCov">      69372 :         const struct ast_exten *ac = ah_a;</span>
<span class="lineNum">     695 </span><span class="lineCov">      69372 :         const struct ast_exten *bc = ah_b;</span>
<span class="lineNum">     696 </span><span class="lineCov">      69372 :         int x = strcmp(ac-&gt;exten, bc-&gt;exten);</span>
<span class="lineNum">     697 </span><span class="lineCov">      69372 :         if (x) { /* if exten names are diff, then return */</span>
<span class="lineNum">     698 </span><span class="lineCov">        336 :                 return x;</span>
<span class="lineNum">     699 </span>            :         }
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            :         /* but if they are the same, do the cidmatch values match? */
<span class="lineNum">     702 </span>            :         /* not sure which side may be using ast_ext_matchcid_types, so check both */
<span class="lineNum">     703 </span><span class="lineCov">      69036 :         if (ac-&gt;matchcid == AST_EXT_MATCHCID_ANY || bc-&gt;matchcid == AST_EXT_MATCHCID_ANY) {</span>
<span class="lineNum">     704 </span><span class="lineCov">          3 :                 return 0;</span>
<span class="lineNum">     705 </span>            :         }
<span class="lineNum">     706 </span><span class="lineCov">      69033 :         if (ac-&gt;matchcid == AST_EXT_MATCHCID_OFF &amp;&amp; bc-&gt;matchcid == AST_EXT_MATCHCID_OFF) {</span>
<span class="lineNum">     707 </span><span class="lineCov">      68971 :                 return 0;</span>
<span class="lineNum">     708 </span>            :         }
<span class="lineNum">     709 </span><span class="lineCov">         62 :         if (ac-&gt;matchcid != bc-&gt;matchcid) {</span>
<span class="lineNum">     710 </span><span class="lineCov">         15 :                 return 1;</span>
<span class="lineNum">     711 </span>            :         }
<span class="lineNum">     712 </span>            :         /* all other cases already disposed of, match now required on callerid string (cidmatch) */
<span class="lineNum">     713 </span>            :         /* although ast_add_extension2_lockopt() enforces non-zero ptr, caller may not have */
<span class="lineNum">     714 </span><span class="lineCov">         47 :         if (ast_strlen_zero(ac-&gt;cidmatch) &amp;&amp; ast_strlen_zero(bc-&gt;cidmatch)) {</span>
<span class="lineNum">     715 </span><span class="lineCov">         20 :                 return 0;</span>
<span class="lineNum">     716 </span>            :         }
<span class="lineNum">     717 </span><span class="lineCov">         27 :         return strcmp(ac-&gt;cidmatch, bc-&gt;cidmatch);</span>
<a name="718"><span class="lineNum">     718 </span>            : }</a>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span><span class="lineCov">      65150 : static int hashtab_compare_exten_numbers(const void *ah_a, const void *ah_b)</span>
<span class="lineNum">     721 </span>            : {
<span class="lineNum">     722 </span><span class="lineCov">      65150 :         const struct ast_exten *ac = ah_a;</span>
<span class="lineNum">     723 </span><span class="lineCov">      65150 :         const struct ast_exten *bc = ah_b;</span>
<span class="lineNum">     724 </span><span class="lineCov">      65150 :         return ac-&gt;priority != bc-&gt;priority;</span>
<a name="725"><span class="lineNum">     725 </span>            : }</a>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineCov">        792 : static int hashtab_compare_exten_labels(const void *ah_a, const void *ah_b)</span>
<span class="lineNum">     728 </span>            : {
<span class="lineNum">     729 </span><span class="lineCov">        792 :         const struct ast_exten *ac = ah_a;</span>
<span class="lineNum">     730 </span><span class="lineCov">        792 :         const struct ast_exten *bc = ah_b;</span>
<span class="lineNum">     731 </span><span class="lineCov">        792 :         return strcmp(S_OR(ac-&gt;label, &quot;&quot;), S_OR(bc-&gt;label, &quot;&quot;));</span>
<a name="732"><span class="lineNum">     732 </span>            : }</a>
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span><span class="lineCov">      78890 : unsigned int ast_hashtab_hash_contexts(const void *obj)</span>
<span class="lineNum">     735 </span>            : {
<span class="lineNum">     736 </span><span class="lineCov">      78890 :         const struct ast_context *ac = obj;</span>
<span class="lineNum">     737 </span><span class="lineCov">      78890 :         return ast_hashtab_hash_string(ac-&gt;name);</span>
<a name="738"><span class="lineNum">     738 </span>            : }</a>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineCov">     212285 : static unsigned int hashtab_hash_extens(const void *obj)</span>
<span class="lineNum">     741 </span>            : {
<span class="lineNum">     742 </span><span class="lineCov">     212285 :         const struct ast_exten *ac = obj;</span>
<span class="lineNum">     743 </span><span class="lineCov">     212285 :         unsigned int x = ast_hashtab_hash_string(ac-&gt;exten);</span>
<span class="lineNum">     744 </span><span class="lineCov">     212285 :         unsigned int y = 0;</span>
<span class="lineNum">     745 </span><span class="lineCov">     212285 :         if (ac-&gt;matchcid == AST_EXT_MATCHCID_ON)</span>
<span class="lineNum">     746 </span><span class="lineCov">         86 :                 y = ast_hashtab_hash_string(ac-&gt;cidmatch);</span>
<span class="lineNum">     747 </span><span class="lineCov">     212285 :         return x+y;</span>
<a name="748"><span class="lineNum">     748 </span>            : }</a>
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span><span class="lineCov">     179766 : static unsigned int hashtab_hash_priority(const void *obj)</span>
<span class="lineNum">     751 </span>            : {
<span class="lineNum">     752 </span><span class="lineCov">     179766 :         const struct ast_exten *ac = obj;</span>
<span class="lineNum">     753 </span><span class="lineCov">     179766 :         return ast_hashtab_hash_int(ac-&gt;priority);</span>
<a name="754"><span class="lineNum">     754 </span>            : }</a>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineCov">       1401 : static unsigned int hashtab_hash_labels(const void *obj)</span>
<span class="lineNum">     757 </span>            : {
<span class="lineNum">     758 </span><span class="lineCov">       1401 :         const struct ast_exten *ac = obj;</span>
<span class="lineNum">     759 </span><span class="lineCov">       1401 :         return ast_hashtab_hash_string(S_OR(ac-&gt;label, &quot;&quot;));</span>
<span class="lineNum">     760 </span>            : }
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            : static int autofallthrough = 1;
<span class="lineNum">     763 </span>            : static int extenpatternmatchnew = 0;
<span class="lineNum">     764 </span>            : static char *overrideswitch = NULL;
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            : /*! \brief Subscription for device state change events */
<span class="lineNum">     767 </span>            : static struct stasis_subscription *device_state_sub;
<span class="lineNum">     768 </span>            : /*! \brief Subscription for presence state change events */
<span class="lineNum">     769 </span>            : static struct stasis_subscription *presence_state_sub;
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span>            : AST_MUTEX_DEFINE_STATIC(maxcalllock);
<span class="lineNum">     772 </span>            : static int countcalls;
<span class="lineNum">     773 </span>            : static int totalcalls;
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            : static struct ast_context *contexts;
<span class="lineNum">     776 </span>            : static struct ast_hashtab *contexts_table = NULL;
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : /*!
<span class="lineNum">     779 </span>            :  * \brief Lock for the ast_context list
<span class="lineNum">     780 </span>            :  * \note
<span class="lineNum">     781 </span>            :  * This lock MUST be recursive, or a deadlock on reload may result.  See
<span class="lineNum">     782 </span>            :  * https://issues.asterisk.org/view.php?id=17643
<span class="lineNum">     783 </span>            :  */
<span class="lineNum">     784 </span>            : AST_MUTEX_DEFINE_STATIC(conlock);
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            : /*!
<span class="lineNum">     787 </span>            :  * \brief Lock to hold off restructuring of hints by ast_merge_contexts_and_delete.
<span class="lineNum">     788 </span>            :  */
<span class="lineNum">     789 </span>            : AST_MUTEX_DEFINE_STATIC(context_merge_lock);
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            : static int stateid = 1;
<span class="lineNum">     792 </span>            : /*!
<span class="lineNum">     793 </span>            :  * \note When holding this container's lock, do _not_ do
<span class="lineNum">     794 </span>            :  * anything that will cause conlock to be taken, unless you
<span class="lineNum">     795 </span>            :  * _already_ hold it.  The ast_merge_contexts_and_delete function
<span class="lineNum">     796 </span>            :  * will take the locks in conlock/hints order, so any other
<span class="lineNum">     797 </span>            :  * paths that require both locks must also take them in that
<span class="lineNum">     798 </span>            :  * order.
<span class="lineNum">     799 </span>            :  */
<span class="lineNum">     800 </span>            : static struct ao2_container *hints;
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            : static struct ao2_container *statecbs;
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            : #ifdef CONTEXT_DEBUG
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            : /* these routines are provided for doing run-time checks
<span class="lineNum">     807 </span>            :    on the extension structures, in case you are having
<span class="lineNum">     808 </span>            :    problems, this routine might help you localize where
<span class="lineNum">     809 </span>            :    the problem is occurring. It's kinda like a debug memory
<span class="lineNum">     810 </span>            :    allocator's arena checker... It'll eat up your cpu cycles!
<span class="lineNum">     811 </span>            :    but you'll see, if you call it in the right places,
<span class="lineNum">     812 </span>            :    right where your problems began...
<span class="lineNum">     813 </span>            : */
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            : /* you can break on the check_contexts_trouble()
<span class="lineNum">     816 </span>            : routine in your debugger to stop at the moment
<span class="lineNum">     817 </span>            : there's a problem */
<span class="lineNum">     818 </span>            : void check_contexts_trouble(void);
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            : void check_contexts_trouble(void)
<span class="lineNum">     821 </span>            : {
<span class="lineNum">     822 </span>            :         int x = 1;
<span class="lineNum">     823 </span>            :         x = 2;
<span class="lineNum">     824 </span>            : }
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span>            : int check_contexts(char *, int);
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            : int check_contexts(char *file, int line )
<span class="lineNum">     829 </span>            : {
<span class="lineNum">     830 </span>            :         struct ast_hashtab_iter *t1;
<span class="lineNum">     831 </span>            :         struct ast_context *c1, *c2;
<span class="lineNum">     832 </span>            :         int found = 0;
<span class="lineNum">     833 </span>            :         struct ast_exten *e1, *e2, *e3;
<span class="lineNum">     834 </span>            :         struct ast_exten ex;
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            :         /* try to find inconsistencies */
<span class="lineNum">     837 </span>            :         /* is every context in the context table in the context list and vice-versa ? */
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :         if (!contexts_table) {
<span class="lineNum">     840 </span>            :                 ast_log(LOG_NOTICE,&quot;Called from: %s:%d: No contexts_table!\n&quot;, file, line);
<span class="lineNum">     841 </span>            :                 usleep(500000);
<span class="lineNum">     842 </span>            :         }
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :         t1 = ast_hashtab_start_traversal(contexts_table);
<span class="lineNum">     845 </span>            :         while( (c1 = ast_hashtab_next(t1))) {
<span class="lineNum">     846 </span>            :                 for(c2=contexts;c2;c2=c2-&gt;next) {
<span class="lineNum">     847 </span>            :                         if (!strcmp(c1-&gt;name, c2-&gt;name)) {
<span class="lineNum">     848 </span>            :                                 found = 1;
<span class="lineNum">     849 </span>            :                                 break;
<span class="lineNum">     850 </span>            :                         }
<span class="lineNum">     851 </span>            :                 }
<span class="lineNum">     852 </span>            :                 if (!found) {
<span class="lineNum">     853 </span>            :                         ast_log(LOG_NOTICE,&quot;Called from: %s:%d: Could not find the %s context in the linked list\n&quot;, file, line, c1-&gt;name);
<span class="lineNum">     854 </span>            :                         check_contexts_trouble();
<span class="lineNum">     855 </span>            :                 }
<span class="lineNum">     856 </span>            :         }
<span class="lineNum">     857 </span>            :         ast_hashtab_end_traversal(t1);
<span class="lineNum">     858 </span>            :         for(c2=contexts;c2;c2=c2-&gt;next) {
<span class="lineNum">     859 </span>            :                 c1 = find_context_locked(c2-&gt;name);
<span class="lineNum">     860 </span>            :                 if (!c1) {
<span class="lineNum">     861 </span>            :                         ast_log(LOG_NOTICE,&quot;Called from: %s:%d: Could not find the %s context in the hashtab\n&quot;, file, line, c2-&gt;name);
<span class="lineNum">     862 </span>            :                         check_contexts_trouble();
<span class="lineNum">     863 </span>            :                 } else
<span class="lineNum">     864 </span>            :                         ast_unlock_contexts();
<span class="lineNum">     865 </span>            :         }
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            :         /* loop thru all contexts, and verify the exten structure compares to the
<span class="lineNum">     868 </span>            :            hashtab structure */
<span class="lineNum">     869 </span>            :         for(c2=contexts;c2;c2=c2-&gt;next) {
<span class="lineNum">     870 </span>            :                 c1 = find_context_locked(c2-&gt;name);
<span class="lineNum">     871 </span>            :                 if (c1) {
<span class="lineNum">     872 </span>            :                         ast_unlock_contexts();
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :                         /* is every entry in the root list also in the root_table? */
<span class="lineNum">     875 </span>            :                         for(e1 = c1-&gt;root; e1; e1=e1-&gt;next)
<span class="lineNum">     876 </span>            :                         {
<span class="lineNum">     877 </span>            :                                 char dummy_name[1024];
<span class="lineNum">     878 </span>            :                                 ex.exten = dummy_name;
<span class="lineNum">     879 </span>            :                                 ex.matchcid = e1-&gt;matchcid;
<span class="lineNum">     880 </span>            :                                 ex.cidmatch = e1-&gt;cidmatch;
<span class="lineNum">     881 </span>            :                                 ast_copy_string(dummy_name, e1-&gt;exten, sizeof(dummy_name));
<span class="lineNum">     882 </span>            :                                 e2 = ast_hashtab_lookup(c1-&gt;root_table, &amp;ex);
<span class="lineNum">     883 </span>            :                                 if (!e2) {
<span class="lineNum">     884 </span>            :                                         if (e1-&gt;matchcid == AST_EXT_MATCHCID_ON) {
<span class="lineNum">     885 </span>            :                                                 ast_log(LOG_NOTICE, &quot;Called from: %s:%d: The %s context records &quot;
<span class="lineNum">     886 </span>            :                                                         &quot;the exten %s (CID match: %s) but it is not in its root_table\n&quot;,
<span class="lineNum">     887 </span>            :                                                         file, line, c2-&gt;name, dummy_name, e1-&gt;cidmatch_display);
<span class="lineNum">     888 </span>            :                                         } else {
<span class="lineNum">     889 </span>            :                                                 ast_log(LOG_NOTICE, &quot;Called from: %s:%d: The %s context records &quot;
<span class="lineNum">     890 </span>            :                                                         &quot;the exten %s but it is not in its root_table\n&quot;,
<span class="lineNum">     891 </span>            :                                                         file, line, c2-&gt;name, dummy_name);
<span class="lineNum">     892 </span>            :                                         }
<span class="lineNum">     893 </span>            :                                         check_contexts_trouble();
<span class="lineNum">     894 </span>            :                                 }
<span class="lineNum">     895 </span>            :                         }
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span>            :                         /* is every entry in the root_table also in the root list? */
<span class="lineNum">     898 </span>            :                         if (!c2-&gt;root_table) {
<span class="lineNum">     899 </span>            :                                 if (c2-&gt;root) {
<span class="lineNum">     900 </span>            :                                         ast_log(LOG_NOTICE,&quot;Called from: %s:%d: No c2-&gt;root_table for context %s!\n&quot;, file, line, c2-&gt;name);
<span class="lineNum">     901 </span>            :                                         usleep(500000);
<span class="lineNum">     902 </span>            :                                 }
<span class="lineNum">     903 </span>            :                         } else {
<span class="lineNum">     904 </span>            :                                 t1 = ast_hashtab_start_traversal(c2-&gt;root_table);
<span class="lineNum">     905 </span>            :                                 while( (e2 = ast_hashtab_next(t1)) ) {
<span class="lineNum">     906 </span>            :                                         for(e1=c2-&gt;root;e1;e1=e1-&gt;next) {
<span class="lineNum">     907 </span>            :                                                 if (!strcmp(e1-&gt;exten, e2-&gt;exten)) {
<span class="lineNum">     908 </span>            :                                                         found = 1;
<span class="lineNum">     909 </span>            :                                                         break;
<span class="lineNum">     910 </span>            :                                                 }
<span class="lineNum">     911 </span>            :                                         }
<span class="lineNum">     912 </span>            :                                         if (!found) {
<span class="lineNum">     913 </span>            :                                                 ast_log(LOG_NOTICE,&quot;Called from: %s:%d: The %s context records the exten %s but it is not in its root_table\n&quot;, file, line, c2-&gt;name, e2-&gt;exten);
<span class="lineNum">     914 </span>            :                                                 check_contexts_trouble();
<span class="lineNum">     915 </span>            :                                         }
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :                                 }
<span class="lineNum">     918 </span>            :                                 ast_hashtab_end_traversal(t1);
<span class="lineNum">     919 </span>            :                         }
<span class="lineNum">     920 </span>            :                 }
<span class="lineNum">     921 </span>            :                 /* is every priority reflected in the peer_table at the head of the list? */
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            :                 /* is every entry in the root list also in the root_table? */
<span class="lineNum">     924 </span>            :                 /* are the per-extension peer_tables in the right place? */
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            :                 for(e1 = c2-&gt;root; e1; e1 = e1-&gt;next) {
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            :                         for(e2=e1;e2;e2=e2-&gt;peer) {
<span class="lineNum">     929 </span>            :                                 ex.priority = e2-&gt;priority;
<span class="lineNum">     930 </span>            :                                 if (e2 != e1 &amp;&amp; e2-&gt;peer_table) {
<span class="lineNum">     931 </span>            :                                         ast_log(LOG_NOTICE,&quot;Called from: %s:%d: The %s context, %s exten, %d priority has a peer_table entry, and shouldn't!\n&quot;, file, line, c2-&gt;name, e1-&gt;exten, e2-&gt;priority );
<span class="lineNum">     932 </span>            :                                         check_contexts_trouble();
<span class="lineNum">     933 </span>            :                                 }
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :                                 if (e2 != e1 &amp;&amp; e2-&gt;peer_label_table) {
<span class="lineNum">     936 </span>            :                                         ast_log(LOG_NOTICE,&quot;Called from: %s:%d: The %s context, %s exten, %d priority has a peer_label_table entry, and shouldn't!\n&quot;, file, line, c2-&gt;name, e1-&gt;exten, e2-&gt;priority );
<span class="lineNum">     937 </span>            :                                         check_contexts_trouble();
<span class="lineNum">     938 </span>            :                                 }
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :                                 if (e2 == e1 &amp;&amp; !e2-&gt;peer_table){
<span class="lineNum">     941 </span>            :                                         ast_log(LOG_NOTICE,&quot;Called from: %s:%d: The %s context, %s exten, %d priority doesn't have a peer_table!\n&quot;, file, line, c2-&gt;name, e1-&gt;exten, e2-&gt;priority );
<span class="lineNum">     942 </span>            :                                         check_contexts_trouble();
<span class="lineNum">     943 </span>            :                                 }
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :                                 if (e2 == e1 &amp;&amp; !e2-&gt;peer_label_table) {
<span class="lineNum">     946 </span>            :                                         ast_log(LOG_NOTICE,&quot;Called from: %s:%d: The %s context, %s exten, %d priority doesn't have a peer_label_table!\n&quot;, file, line, c2-&gt;name, e1-&gt;exten, e2-&gt;priority );
<span class="lineNum">     947 </span>            :                                         check_contexts_trouble();
<span class="lineNum">     948 </span>            :                                 }
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            :                                 e3 = ast_hashtab_lookup(e1-&gt;peer_table, &amp;ex);
<span class="lineNum">     952 </span>            :                                 if (!e3) {
<span class="lineNum">     953 </span>            :                                         ast_log(LOG_NOTICE,&quot;Called from: %s:%d: The %s context, %s exten, %d priority is not reflected in the peer_table\n&quot;, file, line, c2-&gt;name, e1-&gt;exten, e2-&gt;priority );
<span class="lineNum">     954 </span>            :                                         check_contexts_trouble();
<span class="lineNum">     955 </span>            :                                 }
<span class="lineNum">     956 </span>            :                         }
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            :                         if (!e1-&gt;peer_table){
<span class="lineNum">     959 </span>            :                                 ast_log(LOG_NOTICE,&quot;Called from: %s:%d: No e1-&gt;peer_table!\n&quot;, file, line);
<span class="lineNum">     960 </span>            :                                 usleep(500000);
<span class="lineNum">     961 </span>            :                         }
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            :                         /* is every entry in the peer_table also in the peer list? */
<span class="lineNum">     964 </span>            :                         t1 = ast_hashtab_start_traversal(e1-&gt;peer_table);
<span class="lineNum">     965 </span>            :                         while( (e2 = ast_hashtab_next(t1)) ) {
<span class="lineNum">     966 </span>            :                                 for(e3=e1;e3;e3=e3-&gt;peer) {
<span class="lineNum">     967 </span>            :                                         if (e3-&gt;priority == e2-&gt;priority) {
<span class="lineNum">     968 </span>            :                                                 found = 1;
<span class="lineNum">     969 </span>            :                                                 break;
<span class="lineNum">     970 </span>            :                                         }
<span class="lineNum">     971 </span>            :                                 }
<span class="lineNum">     972 </span>            :                                 if (!found) {
<span class="lineNum">     973 </span>            :                                         ast_log(LOG_NOTICE,&quot;Called from: %s:%d: The %s context, %s exten, %d priority is not reflected in the peer list\n&quot;, file, line, c2-&gt;name, e1-&gt;exten, e2-&gt;priority );
<span class="lineNum">     974 </span>            :                                         check_contexts_trouble();
<span class="lineNum">     975 </span>            :                                 }
<span class="lineNum">     976 </span>            :                         }
<span class="lineNum">     977 </span>            :                         ast_hashtab_end_traversal(t1);
<span class="lineNum">     978 </span>            :                 }
<span class="lineNum">     979 </span>            :         }
<span class="lineNum">     980 </span>            :         return 0;
<span class="lineNum">     981 </span>            : }
<a name="982"><span class="lineNum">     982 </span>            : #endif</a>
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span><span class="lineCov">       2900 : static void pbx_destroy(struct ast_pbx *p)</span>
<span class="lineNum">     985 </span>            : {
<span class="lineNum">     986 </span><span class="lineCov">       2900 :         ast_free(p);</span>
<span class="lineNum">     987 </span><span class="lineCov">       2900 : }</span>
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            : /* form a tree that fully describes all the patterns in a context's extensions
<span class="lineNum">     990 </span>            :  * in this tree, a &quot;node&quot; represents an individual character or character set
<span class="lineNum">     991 </span>            :  * meant to match the corresponding character in a dial string. The tree
<span class="lineNum">     992 </span>            :  * consists of a series of match_char structs linked in a chain
<span class="lineNum">     993 </span>            :  * via the alt_char pointers. More than one pattern can share the same parts of the
<span class="lineNum">     994 </span>            :  * tree as other extensions with the same pattern to that point.
<span class="lineNum">     995 </span>            :  * My first attempt to duplicate the finding of the 'best' pattern was flawed in that
<span class="lineNum">     996 </span>            :  * I misunderstood the general algorithm. I thought that the 'best' pattern
<span class="lineNum">     997 </span>            :  * was the one with lowest total score. This was not true. Thus, if you have
<span class="lineNum">     998 </span>            :  * patterns &quot;1XXXXX&quot; and &quot;X11111&quot;, you would be tempted to say that &quot;X11111&quot; is
<span class="lineNum">     999 </span>            :  * the &quot;best&quot; match because it has fewer X's, and is therefore more specific,
<span class="lineNum">    1000 </span>            :  * but this is not how the old algorithm works. It sorts matching patterns
<span class="lineNum">    1001 </span>            :  * in a similar collating sequence as sorting alphabetic strings, from left to
<span class="lineNum">    1002 </span>            :  * right. Thus, &quot;1XXXXX&quot; comes before &quot;X11111&quot;, and would be the &quot;better&quot; match,
<span class="lineNum">    1003 </span>            :  * because &quot;1&quot; is more specific than &quot;X&quot;.
<span class="lineNum">    1004 </span>            :  * So, to accomodate this philosophy, I sort the tree branches along the alt_char
<span class="lineNum">    1005 </span>            :  * line so they are lowest to highest in specificity numbers. This way, as soon
<span class="lineNum">    1006 </span>            :  * as we encounter our first complete match, we automatically have the &quot;best&quot;
<span class="lineNum">    1007 </span>            :  * match and can stop the traversal immediately. Same for CANMATCH/MATCHMORE.
<span class="lineNum">    1008 </span>            :  * If anyone would like to resurrect the &quot;wrong&quot; pattern trie searching algorithm,
<span class="lineNum">    1009 </span>            :  * they are welcome to revert pbx to before 1 Apr 2008.
<span class="lineNum">    1010 </span>            :  * As an example, consider these 4 extensions:
<span class="lineNum">    1011 </span>            :  * (a) NXXNXXXXXX
<span class="lineNum">    1012 </span>            :  * (b) 307754XXXX
<span class="lineNum">    1013 </span>            :  * (c) fax
<span class="lineNum">    1014 </span>            :  * (d) NXXXXXXXXX
<span class="lineNum">    1015 </span>            :  *
<span class="lineNum">    1016 </span>            :  * In the above, between (a) and (d), (a) is a more specific pattern than (d), and would win over
<span class="lineNum">    1017 </span>            :  * most numbers. For all numbers beginning with 307754, (b) should always win.
<span class="lineNum">    1018 </span>            :  *
<span class="lineNum">    1019 </span>            :  * These pattern should form a (sorted) tree that looks like this:
<span class="lineNum">    1020 </span>            :  *   { &quot;3&quot; }  --next--&gt;  { &quot;0&quot; }  --next--&gt; { &quot;7&quot; } --next--&gt; { &quot;7&quot; } --next--&gt; { &quot;5&quot; } ... blah ... --&gt; { &quot;X&quot; exten_match: (b) }
<span class="lineNum">    1021 </span>            :  *      |
<span class="lineNum">    1022 </span>            :  *      |alt
<span class="lineNum">    1023 </span>            :  *      |
<span class="lineNum">    1024 </span>            :  *   { &quot;f&quot; }  --next--&gt;  { &quot;a&quot; }  --next--&gt; { &quot;x&quot;  exten_match: (c) }
<span class="lineNum">    1025 </span>            :  *   { &quot;N&quot; }  --next--&gt;  { &quot;X&quot; }  --next--&gt; { &quot;X&quot; } --next--&gt; { &quot;N&quot; } --next--&gt; { &quot;X&quot; } ... blah ... --&gt; { &quot;X&quot; exten_match: (a) }
<span class="lineNum">    1026 </span>            :  *      |                                                        |
<span class="lineNum">    1027 </span>            :  *      |                                                        |alt
<span class="lineNum">    1028 </span>            :  *      |alt                                                     |
<span class="lineNum">    1029 </span>            :  *      |                                                     { &quot;X&quot; } --next--&gt; { &quot;X&quot; } ... blah ... --&gt; { &quot;X&quot; exten_match: (d) }
<span class="lineNum">    1030 </span>            :  *      |
<span class="lineNum">    1031 </span>            :  *     NULL
<span class="lineNum">    1032 </span>            :  *
<span class="lineNum">    1033 </span>            :  *   In the above, I could easily turn &quot;N&quot; into &quot;23456789&quot;, but I think that a quick &quot;if( *z &gt;= '2' &amp;&amp; *z &lt;= '9' )&quot; might take
<span class="lineNum">    1034 </span>            :  *   fewer CPU cycles than a call to strchr(&quot;23456789&quot;,*z), where *z is the char to match...
<span class="lineNum">    1035 </span>            :  *
<span class="lineNum">    1036 </span>            :  *   traversal is pretty simple: one routine merely traverses the alt list, and for each matching char in the pattern,  it calls itself
<span class="lineNum">    1037 </span>            :  *   on the corresponding next pointer, incrementing also the pointer of the string to be matched, and passing the total specificity and length.
<span class="lineNum">    1038 </span>            :  *   We pass a pointer to a scoreboard down through, also.
<span class="lineNum">    1039 </span>            :  *   The scoreboard isn't as necessary to the revised algorithm, but I kept it as a handy way to return the matched extension.
<span class="lineNum">    1040 </span>            :  *   The first complete match ends the traversal, which should make this version of the pattern matcher faster
<span class="lineNum">    1041 </span>            :  *   the previous. The same goes for &quot;CANMATCH&quot; or &quot;MATCHMORE&quot;; the first such match ends the traversal. In both
<span class="lineNum">    1042 </span>            :  *   these cases, the reason we can stop immediately, is because the first pattern match found will be the &quot;best&quot;
<span class="lineNum">    1043 </span>            :  *   according to the sort criteria.
<span class="lineNum">    1044 </span>            :  *   Hope the limit on stack depth won't be a problem... this routine should
<span class="lineNum">    1045 </span>            :  *   be pretty lean as far a stack usage goes. Any non-match terminates the recursion down a branch.
<span class="lineNum">    1046 </span>            :  *
<span class="lineNum">    1047 </span>            :  *   In the above example, with the number &quot;3077549999&quot; as the pattern, the traversor could match extensions a, b and d.  All are
<span class="lineNum">    1048 </span>            :  *   of length 10; they have total specificities of  24580, 10246, and 25090, respectively, not that this matters
<span class="lineNum">    1049 </span>            :  *   at all. (b) wins purely because the first character &quot;3&quot; is much more specific (lower specificity) than &quot;N&quot;. I have
<span class="lineNum">    1050 </span>            :  *   left the specificity totals in the code as an artifact; at some point, I will strip it out.
<span class="lineNum">    1051 </span>            :  *
<span class="lineNum">    1052 </span>            :  *   Just how much time this algorithm might save over a plain linear traversal over all possible patterns is unknown,
<span class="lineNum">    1053 </span>            :  *   because it's a function of how many extensions are stored in a context. With thousands of extensions, the speedup
<span class="lineNum">    1054 </span>            :  *   can be very noticeable. The new matching algorithm can run several hundreds of times faster, if not a thousand or
<span class="lineNum">    1055 </span>            :  *   more times faster in extreme cases.
<span class="lineNum">    1056 </span>            :  *
<span class="lineNum">    1057 </span>            :  *   MatchCID patterns are also supported, and stored in the tree just as the extension pattern is. Thus, you
<span class="lineNum">    1058 </span>            :  *   can have patterns in your CID field as well.
<span class="lineNum">    1059 </span>            :  *
<span class="lineNum">    1060 </span>            :  * */
<a name="1061"><span class="lineNum">    1061 </span>            : </a>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span><span class="lineCov">         16 : static void update_scoreboard(struct scoreboard *board, int length, int spec, struct ast_exten *exten, char last, const char *callerid, int deleted, struct match_char *node)</span>
<span class="lineNum">    1064 </span>            : {
<span class="lineNum">    1065 </span>            :         /* if this extension is marked as deleted, then skip this -- if it never shows
<span class="lineNum">    1066 </span>            :            on the scoreboard, it will never be found, nor will halt the traversal. */
<span class="lineNum">    1067 </span><span class="lineCov">         16 :         if (deleted)</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1069 </span><span class="lineCov">         16 :         board-&gt;total_specificity = spec;</span>
<span class="lineNum">    1070 </span><span class="lineCov">         16 :         board-&gt;total_length = length;</span>
<span class="lineNum">    1071 </span><span class="lineCov">         16 :         board-&gt;exten = exten;</span>
<span class="lineNum">    1072 </span><span class="lineCov">         16 :         board-&gt;last_char = last;</span>
<span class="lineNum">    1073 </span><span class="lineCov">         16 :         board-&gt;node = node;</span>
<span class="lineNum">    1074 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    1075 </span>            :         ast_log(LOG_NOTICE,&quot;Scoreboarding (LONGER) %s, len=%d, score=%d\n&quot;, exten-&gt;exten, length, spec);
<span class="lineNum">    1076 </span>            : #endif
<span class="lineNum">    1077 </span>            : }
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            : #ifdef NEED_DEBUG
<span class="lineNum">    1080 </span>            : static void log_match_char_tree(struct match_char *node, char *prefix)
<span class="lineNum">    1081 </span>            : {
<span class="lineNum">    1082 </span>            :         char extenstr[40];
<span class="lineNum">    1083 </span>            :         struct ast_str *my_prefix = ast_str_alloca(1024);
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            :         extenstr[0] = '\0';
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            :         if (node &amp;&amp; node-&gt;exten)
<span class="lineNum">    1088 </span>            :                 snprintf(extenstr, sizeof(extenstr), &quot;(%p)&quot;, node-&gt;exten);
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :         if (strlen(node-&gt;x) &gt; 1) {
<span class="lineNum">    1091 </span>            :                 ast_debug(1, &quot;%s[%s]:%c:%c:%d:%s%s%s\n&quot;, prefix, node-&gt;x, node-&gt;is_pattern ? 'Y':'N',
<span class="lineNum">    1092 </span>            :                         node-&gt;deleted? 'D':'-', node-&gt;specificity, node-&gt;exten? &quot;EXTEN:&quot;:&quot;&quot;,
<span class="lineNum">    1093 </span>            :                         node-&gt;exten ? node-&gt;exten-&gt;exten : &quot;&quot;, extenstr);
<span class="lineNum">    1094 </span>            :         } else {
<span class="lineNum">    1095 </span>            :                 ast_debug(1, &quot;%s%s:%c:%c:%d:%s%s%s\n&quot;, prefix, node-&gt;x, node-&gt;is_pattern ? 'Y':'N',
<span class="lineNum">    1096 </span>            :                         node-&gt;deleted? 'D':'-', node-&gt;specificity, node-&gt;exten? &quot;EXTEN:&quot;:&quot;&quot;,
<span class="lineNum">    1097 </span>            :                         node-&gt;exten ? node-&gt;exten-&gt;exten : &quot;&quot;, extenstr);
<span class="lineNum">    1098 </span>            :         }
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            :         ast_str_set(&amp;my_prefix, 0, &quot;%s+       &quot;, prefix);
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            :         if (node-&gt;next_char)
<span class="lineNum">    1103 </span>            :                 log_match_char_tree(node-&gt;next_char, ast_str_buffer(my_prefix));
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span>            :         if (node-&gt;alt_char)
<span class="lineNum">    1106 </span>            :                 log_match_char_tree(node-&gt;alt_char, prefix);
<span class="lineNum">    1107 </span>            : }
<a name="1108"><span class="lineNum">    1108 </span>            : #endif</a>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 : static void cli_match_char_tree(struct match_char *node, char *prefix, int fd)</span>
<span class="lineNum">    1111 </span>            : {
<span class="lineNum">    1112 </span>            :         char extenstr[40];
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :         struct ast_str *my_prefix = ast_str_alloca(1024);</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :         extenstr[0] = '\0';</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         if (node-&gt;exten) {</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :                 snprintf(extenstr, sizeof(extenstr), &quot;(%p)&quot;, node-&gt;exten);</span>
<span class="lineNum">    1119 </span>            :         }
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :         if (strlen(node-&gt;x) &gt; 1) {</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :                 ast_cli(fd, &quot;%s[%s]:%c:%c:%d:%s%s%s\n&quot;, prefix, node-&gt;x, node-&gt;is_pattern ? 'Y' : 'N',</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :                         node-&gt;deleted ? 'D' : '-', node-&gt;specificity, node-&gt;exten? &quot;EXTEN:&quot; : &quot;&quot;,</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :                         node-&gt;exten ? node-&gt;exten-&gt;name : &quot;&quot;, extenstr);</span>
<span class="lineNum">    1125 </span>            :         } else {
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :                 ast_cli(fd, &quot;%s%s:%c:%c:%d:%s%s%s\n&quot;, prefix, node-&gt;x, node-&gt;is_pattern ? 'Y' : 'N',</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :                         node-&gt;deleted ? 'D' : '-', node-&gt;specificity, node-&gt;exten? &quot;EXTEN:&quot; : &quot;&quot;,</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :                         node-&gt;exten ? node-&gt;exten-&gt;name : &quot;&quot;, extenstr);</span>
<span class="lineNum">    1129 </span>            :         }
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :         ast_str_set(&amp;my_prefix, 0, &quot;%s+       &quot;, prefix);</span>
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :         if (node-&gt;next_char)</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :                 cli_match_char_tree(node-&gt;next_char, ast_str_buffer(my_prefix), fd);</span>
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         if (node-&gt;alt_char)</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :                 cli_match_char_tree(node-&gt;alt_char, prefix, fd);</span>
<a name="1138"><span class="lineNum">    1138 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span><span class="lineCov">          5 : static struct ast_exten *get_canmatch_exten(struct match_char *node)</span>
<span class="lineNum">    1141 </span>            : {
<span class="lineNum">    1142 </span>            :         /* find the exten at the end of the rope */
<span class="lineNum">    1143 </span><span class="lineCov">          5 :         struct match_char *node2 = node;</span>
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span><span class="lineCov">          7 :         for (node2 = node; node2; node2 = node2-&gt;next_char) {</span>
<span class="lineNum">    1146 </span><span class="lineCov">          7 :                 if (node2-&gt;exten) {</span>
<span class="lineNum">    1147 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    1148 </span>            :                         ast_log(LOG_NOTICE,&quot;CanMatch_exten returns exten %s(%p)\n&quot;, node2-&gt;exten-&gt;exten, node2-&gt;exten);
<span class="lineNum">    1149 </span>            : #endif
<span class="lineNum">    1150 </span><span class="lineCov">          5 :                         return node2-&gt;exten;</span>
<span class="lineNum">    1151 </span>            :                 }
<span class="lineNum">    1152 </span>            :         }
<span class="lineNum">    1153 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    1154 </span>            :         ast_log(LOG_NOTICE,&quot;CanMatch_exten returns NULL, match_char=%s\n&quot;, node-&gt;x);
<span class="lineNum">    1155 </span>            : #endif
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="1157"><span class="lineNum">    1157 </span>            : }</a>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span><span class="lineCov">          3 : static struct ast_exten *trie_find_next_match(struct match_char *node)</span>
<span class="lineNum">    1160 </span>            : {
<span class="lineNum">    1161 </span>            :         struct match_char *m3;
<span class="lineNum">    1162 </span>            :         struct match_char *m4;
<span class="lineNum">    1163 </span>            :         struct ast_exten *e3;
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span><span class="lineCov">          3 :         if (node &amp;&amp; node-&gt;x[0] == '.' &amp;&amp; !node-&gt;x[1]) { /* dot and ! will ALWAYS be next match in a matchmore */</span>
<span class="lineNum">    1166 </span><span class="lineCov">          3 :                 return node-&gt;exten;</span>
<span class="lineNum">    1167 </span>            :         }
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :         if (node &amp;&amp; node-&gt;x[0] == '!' &amp;&amp; !node-&gt;x[1]) {</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :                 return node-&gt;exten;</span>
<span class="lineNum">    1171 </span>            :         }
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :         if (!node || !node-&gt;next_char) {</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1175 </span>            :         }
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :         m3 = node-&gt;next_char;</span>
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :         if (m3-&gt;exten) {</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :                 return m3-&gt;exten;</span>
<span class="lineNum">    1181 </span>            :         }
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :         for (m4 = m3-&gt;alt_char; m4; m4 = m4-&gt;alt_char) {</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :                 if (m4-&gt;exten) {</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :                         return m4-&gt;exten;</span>
<span class="lineNum">    1185 </span>            :                 }
<span class="lineNum">    1186 </span>            :         }
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :         for (m4 = m3; m4; m4 = m4-&gt;alt_char) {</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :                 e3 = trie_find_next_match(m3);</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :                 if (e3) {</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :                         return e3;</span>
<span class="lineNum">    1191 </span>            :                 }
<span class="lineNum">    1192 </span>            :         }
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1195 </span>            : }
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span>            : #ifdef DEBUG_THIS
<span class="lineNum">    1198 </span>            : static char *action2str(enum ext_match_t action)
<span class="lineNum">    1199 </span>            : {
<span class="lineNum">    1200 </span>            :         switch (action) {
<span class="lineNum">    1201 </span>            :         case E_MATCH:
<span class="lineNum">    1202 </span>            :                 return &quot;MATCH&quot;;
<span class="lineNum">    1203 </span>            :         case E_CANMATCH:
<span class="lineNum">    1204 </span>            :                 return &quot;CANMATCH&quot;;
<span class="lineNum">    1205 </span>            :         case E_MATCHMORE:
<span class="lineNum">    1206 </span>            :                 return &quot;MATCHMORE&quot;;
<span class="lineNum">    1207 </span>            :         case E_FINDLABEL:
<span class="lineNum">    1208 </span>            :                 return &quot;FINDLABEL&quot;;
<span class="lineNum">    1209 </span>            :         case E_SPAWN:
<span class="lineNum">    1210 </span>            :                 return &quot;SPAWN&quot;;
<span class="lineNum">    1211 </span>            :         default:
<span class="lineNum">    1212 </span>            :                 return &quot;?ACTION?&quot;;
<span class="lineNum">    1213 </span>            :         }
<span class="lineNum">    1214 </span>            : }
<span class="lineNum">    1215 </span>            : 
<a name="1216"><span class="lineNum">    1216 </span>            : #endif</a>
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span><span class="lineCov">        204 : static void new_find_extension(const char *str, struct scoreboard *score, struct match_char *tree, int length, int spec, const char *callerid, const char *label, enum ext_match_t action)</span>
<span class="lineNum">    1219 </span>            : {
<span class="lineNum">    1220 </span>            :         struct match_char *p; /* note minimal stack storage requirements */
<span class="lineNum">    1221 </span><span class="lineCov">        204 :         struct ast_exten pattern = { .label = label };</span>
<span class="lineNum">    1222 </span>            : #ifdef DEBUG_THIS
<span class="lineNum">    1223 </span>            :         if (tree)
<span class="lineNum">    1224 </span>            :                 ast_log(LOG_NOTICE,&quot;new_find_extension called with %s on (sub)tree %s action=%s\n&quot;, str, tree-&gt;x, action2str(action));
<span class="lineNum">    1225 </span>            :         else
<span class="lineNum">    1226 </span>            :                 ast_log(LOG_NOTICE,&quot;new_find_extension called with %s on (sub)tree NULL action=%s\n&quot;, str, action2str(action));
<span class="lineNum">    1227 </span>            : #endif
<span class="lineNum">    1228 </span><span class="lineCov">        568 :         for (p = tree; p; p = p-&gt;alt_char) {</span>
<span class="lineNum">    1229 </span><span class="lineCov">        416 :                 if (p-&gt;is_pattern) {</span>
<span class="lineNum">    1230 </span><span class="lineCov">          8 :                         if (p-&gt;x[0] == 'N') {</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :                                 if (p-&gt;x[1] == 0 &amp;&amp; *str &gt;= '2' &amp;&amp; *str &lt;= '9' ) {</span>
<span class="lineNum">    1232 </span>            : #define NEW_MATCHER_CHK_MATCH          \
<span class="lineNum">    1233 </span>            :                                         if (p-&gt;exten &amp;&amp; !(*(str + 1))) { /* if a shorter pattern matches along the way, might as well report it */             \
<span class="lineNum">    1234 </span>            :                                                 if (action == E_MATCH || action == E_SPAWN || action == E_FINDLABEL) { /* if in CANMATCH/MATCHMORE, don't let matches get in the way */   \
<span class="lineNum">    1235 </span>            :                                                         update_scoreboard(score, length + 1, spec + p-&gt;specificity, p-&gt;exten, 0, callerid, p-&gt;deleted, p);                 \
<span class="lineNum">    1236 </span>            :                                                         if (!p-&gt;deleted) {                                                                                           \
<span class="lineNum">    1237 </span>            :                                                                 if (action == E_FINDLABEL) {                                                                             \
<span class="lineNum">    1238 </span>            :                                                                         if (ast_hashtab_lookup(score-&gt;exten-&gt;peer_label_table, &amp;pattern)) {                                  \
<span class="lineNum">    1239 </span>            :                                                                                 ast_debug(4, &quot;Found label in preferred extension\n&quot;);                                            \
<span class="lineNum">    1240 </span>            :                                                                                 return;                                                                                          \
<span class="lineNum">    1241 </span>            :                                                                         }                                                                                                    \
<span class="lineNum">    1242 </span>            :                                                                 } else {                                                                                                 \
<span class="lineNum">    1243 </span>            :                                                                         ast_debug(4, &quot;returning an exact match-- first found-- %s\n&quot;, p-&gt;exten-&gt;name);                       \
<span class="lineNum">    1244 </span>            :                                                                         return; /* the first match, by definition, will be the best, because of the sorted tree */           \
<span class="lineNum">    1245 </span>            :                                                                 }                                                                                                        \
<span class="lineNum">    1246 </span>            :                                                         }                                                                                                            \
<span class="lineNum">    1247 </span>            :                                                 }                                                                                                                \
<span class="lineNum">    1248 </span>            :                                         }
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span>            : #define NEW_MATCHER_RECURSE                \
<span class="lineNum">    1251 </span>            :                                         if (p-&gt;next_char &amp;&amp; (*(str + 1) || (p-&gt;next_char-&gt;x[0] == '/' &amp;&amp; p-&gt;next_char-&gt;x[1] == 0)                 \
<span class="lineNum">    1252 </span>            :                                                        || p-&gt;next_char-&gt;x[0] == '!')) {                                          \
<span class="lineNum">    1253 </span>            :                                                 if (*(str + 1) || p-&gt;next_char-&gt;x[0] == '!') {                                                         \
<span class="lineNum">    1254 </span>            :                                                         new_find_extension(str + 1, score, p-&gt;next_char, length + 1, spec + p-&gt;specificity, callerid, label, action); \
<span class="lineNum">    1255 </span>            :                                                         if (score-&gt;exten)  {                                                                             \
<span class="lineNum">    1256 </span>            :                                                         ast_debug(4 ,&quot;returning an exact match-- %s\n&quot;, score-&gt;exten-&gt;name);                         \
<span class="lineNum">    1257 </span>            :                                                                 return; /* the first match is all we need */                                                 \
<span class="lineNum">    1258 </span>            :                                                         }                                                                                                                                                \
<span class="lineNum">    1259 </span>            :                                                 } else {                                                                                             \
<span class="lineNum">    1260 </span>            :                                                         new_find_extension(&quot;/&quot;, score, p-&gt;next_char, length + 1, spec + p-&gt;specificity, callerid, label, action);        \
<span class="lineNum">    1261 </span>            :                                                         if (score-&gt;exten || ((action == E_CANMATCH || action == E_MATCHMORE) &amp;&amp; score-&gt;canmatch)) {      \
<span class="lineNum">    1262 </span>            :                                                         ast_debug(4,&quot;returning a (can/more) match--- %s\n&quot;, score-&gt;exten ? score-&gt;exten-&gt;name :      \
<span class="lineNum">    1263 </span>            :                                                &quot;NULL&quot;);                                                                        \
<span class="lineNum">    1264 </span>            :                                                                 return; /* the first match is all we need */                                                 \
<span class="lineNum">    1265 </span>            :                                                         }                                                                                                                                                \
<span class="lineNum">    1266 </span>            :                                                 }                                                                                                    \
<span class="lineNum">    1267 </span>            :                                         } else if ((p-&gt;next_char || action == E_CANMATCH) &amp;&amp; !*(str + 1)) {                                                                  \
<span class="lineNum">    1268 </span>            :                                                 score-&gt;canmatch = 1;                                                                                 \
<span class="lineNum">    1269 </span>            :                                                 score-&gt;canmatch_exten = get_canmatch_exten(p);                                                       \
<span class="lineNum">    1270 </span>            :                                                 if (action == E_CANMATCH || action == E_MATCHMORE) {                                                 \
<span class="lineNum">    1271 </span>            :                                                 ast_debug(4, &quot;returning a canmatch/matchmore--- str=%s\n&quot;, str);                                  \
<span class="lineNum">    1272 </span>            :                                                         return;                                                                                          \
<span class="lineNum">    1273 </span>            :                                                 }                                                                                                                                                    \
<span class="lineNum">    1274 </span>            :                                         }
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span><span class="lineCov">         52 :                                         NEW_MATCHER_CHK_MATCH;</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :                                         NEW_MATCHER_RECURSE;</span>
<span class="lineNum">    1278 </span>            :                                 }
<span class="lineNum">    1279 </span><span class="lineCov">          8 :                         } else if (p-&gt;x[0] == 'Z') {</span>
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :                                 if (p-&gt;x[1] == 0 &amp;&amp; *str &gt;= '1' &amp;&amp; *str &lt;= '9' ) {</span>
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :                                         NEW_MATCHER_CHK_MATCH;</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :                                         NEW_MATCHER_RECURSE;</span>
<span class="lineNum">    1283 </span>            :                                 }
<span class="lineNum">    1284 </span><span class="lineCov">          8 :                         } else if (p-&gt;x[0] == 'X') {</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :                                 if (p-&gt;x[1] == 0 &amp;&amp; *str &gt;= '0' &amp;&amp; *str &lt;= '9' ) {</span>
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :                                         NEW_MATCHER_CHK_MATCH;</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :                                         NEW_MATCHER_RECURSE;</span>
<span class="lineNum">    1288 </span>            :                                 }
<span class="lineNum">    1289 </span><span class="lineCov">          8 :                         } else if (p-&gt;x[0] == '.' &amp;&amp; p-&gt;x[1] == 0) {</span>
<span class="lineNum">    1290 </span>            :                                 /* how many chars will the . match against? */
<span class="lineNum">    1291 </span><span class="lineCov">          4 :                                 int i = 0;</span>
<span class="lineNum">    1292 </span><span class="lineCov">          4 :                                 const char *str2 = str;</span>
<span class="lineNum">    1293 </span><span class="lineCov">         14 :                                 while (*str2 &amp;&amp; *str2 != '/') {</span>
<span class="lineNum">    1294 </span><span class="lineCov">         10 :                                         str2++;</span>
<span class="lineNum">    1295 </span><span class="lineCov">         10 :                                         i++;</span>
<span class="lineNum">    1296 </span>            :                                 }
<span class="lineNum">    1297 </span><span class="lineCov">          4 :                                 if (p-&gt;exten &amp;&amp; *str2 != '/') {</span>
<span class="lineNum">    1298 </span><span class="lineCov">          4 :                                         update_scoreboard(score, length + i, spec + (i * p-&gt;specificity), p-&gt;exten, '.', callerid, p-&gt;deleted, p);</span>
<span class="lineNum">    1299 </span><span class="lineCov">          4 :                                         if (score-&gt;exten) {</span>
<span class="lineNum">    1300 </span><span class="lineCov">          4 :                                                 ast_debug(4, &quot;return because scoreboard has a match with '/'--- %s\n&quot;,</span>
<span class="lineNum">    1301 </span>            :                                                         score-&gt;exten-&gt;name);
<span class="lineNum">    1302 </span><span class="lineCov">          4 :                                                 return; /* the first match is all we need */</span>
<span class="lineNum">    1303 </span>            :                                         }
<span class="lineNum">    1304 </span>            :                                 }
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :                                 if (p-&gt;next_char &amp;&amp; p-&gt;next_char-&gt;x[0] == '/' &amp;&amp; p-&gt;next_char-&gt;x[1] == 0) {</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :                                         new_find_extension(&quot;/&quot;, score, p-&gt;next_char, length + i, spec+(p-&gt;specificity*i), callerid, label, action);</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :                                         if (score-&gt;exten || ((action == E_CANMATCH || action == E_MATCHMORE) &amp;&amp; score-&gt;canmatch)) {</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :                                                 ast_debug(4, &quot;return because scoreboard has exact match OR &quot;</span>
<span class="lineNum">    1309 </span>            :                                                         &quot;CANMATCH/MATCHMORE &amp; canmatch set--- %s\n&quot;,
<span class="lineNum">    1310 </span>            :                                                         score-&gt;exten ? score-&gt;exten-&gt;name : &quot;NULL&quot;);
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :                                                 return; /* the first match is all we need */</span>
<span class="lineNum">    1312 </span>            :                                         }
<span class="lineNum">    1313 </span>            :                                 }
<span class="lineNum">    1314 </span><span class="lineCov">          4 :                         } else if (p-&gt;x[0] == '!' &amp;&amp; p-&gt;x[1] == 0) {</span>
<span class="lineNum">    1315 </span>            :                                 /* how many chars will the . match against? */
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :                                 int i = 1;</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :                                 const char *str2 = str;</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :                                 while (*str2 &amp;&amp; *str2 != '/') {</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :                                         str2++;</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :                                         i++;</span>
<span class="lineNum">    1321 </span>            :                                 }
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :                                 if (p-&gt;exten &amp;&amp; *str2 != '/') {</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :                                         update_scoreboard(score, length + 1, spec + (p-&gt;specificity * i), p-&gt;exten, '!', callerid, p-&gt;deleted, p);</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :                                         if (score-&gt;exten) {</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :                                                 ast_debug(4, &quot;return because scoreboard has a '!' match--- %s\n&quot;,</span>
<span class="lineNum">    1326 </span>            :                                                         score-&gt;exten-&gt;name);
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :                                                 return; /* the first match is all we need */</span>
<span class="lineNum">    1328 </span>            :                                         }
<span class="lineNum">    1329 </span>            :                                 }
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :                                 if (p-&gt;next_char &amp;&amp; p-&gt;next_char-&gt;x[0] == '/' &amp;&amp; p-&gt;next_char-&gt;x[1] == 0) {</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :                                         new_find_extension(&quot;/&quot;, score, p-&gt;next_char, length + i, spec + (p-&gt;specificity * i), callerid, label, action);</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :                                         if (score-&gt;exten || ((action == E_CANMATCH || action == E_MATCHMORE) &amp;&amp; score-&gt;canmatch)) {</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :                                                 ast_debug(4, &quot;return because scoreboard has exact match OR &quot;</span>
<span class="lineNum">    1334 </span>            :                                                         &quot;CANMATCH/MATCHMORE &amp; canmatch set with '/' and '!'--- %s\n&quot;,
<span class="lineNum">    1335 </span>            :                                                         score-&gt;exten ? score-&gt;exten-&gt;name : &quot;NULL&quot;);
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :                                                 return; /* the first match is all we need */</span>
<span class="lineNum">    1337 </span>            :                                         }
<span class="lineNum">    1338 </span>            :                                 }
<span class="lineNum">    1339 </span><span class="lineCov">          4 :                         } else if (p-&gt;x[0] == '/' &amp;&amp; p-&gt;x[1] == 0) {</span>
<span class="lineNum">    1340 </span>            :                                 /* the pattern in the tree includes the cid match! */
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :                                 if (p-&gt;next_char &amp;&amp; callerid &amp;&amp; *callerid) {</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :                                         new_find_extension(callerid, score, p-&gt;next_char, length + 1, spec, callerid, label, action);</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :                                         if (score-&gt;exten || ((action == E_CANMATCH || action == E_MATCHMORE) &amp;&amp; score-&gt;canmatch)) {</span>
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :                                                 ast_debug(4, &quot;return because scoreboard has exact match OR &quot;</span>
<span class="lineNum">    1345 </span>            :                                                         &quot;CANMATCH/MATCHMORE &amp; canmatch set with '/'--- %s\n&quot;,
<span class="lineNum">    1346 </span>            :                                                         score-&gt;exten ? score-&gt;exten-&gt;name : &quot;NULL&quot;);
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :                                                 return; /* the first match is all we need */</span>
<span class="lineNum">    1348 </span>            :                                         }
<span class="lineNum">    1349 </span>            :                                 }
<span class="lineNum">    1350 </span><span class="lineCov">          4 :                         } else if (strchr(p-&gt;x, *str)) {</span>
<span class="lineNum">    1351 </span><span class="lineCov">          4 :                                 ast_debug(4, &quot;Nothing strange about this match\n&quot;);</span>
<span class="lineNum">    1352 </span><span class="lineCov">          4 :                                 NEW_MATCHER_CHK_MATCH;</span>
<span class="lineNum">    1353 </span><span class="lineCov">          4 :                                 NEW_MATCHER_RECURSE;</span>
<span class="lineNum">    1354 </span>            :                         }
<span class="lineNum">    1355 </span><span class="lineCov">        408 :                 } else if (strchr(p-&gt;x, *str)) {</span>
<span class="lineNum">    1356 </span><span class="lineCov">        161 :                         ast_debug(4, &quot;Nothing strange about this match\n&quot;);</span>
<span class="lineNum">    1357 </span><span class="lineCov">        161 :                         NEW_MATCHER_CHK_MATCH;</span>
<span class="lineNum">    1358 </span><span class="lineCov">        149 :                         NEW_MATCHER_RECURSE;</span>
<span class="lineNum">    1359 </span>            :                 }
<span class="lineNum">    1360 </span>            :         }
<span class="lineNum">    1361 </span><span class="lineCov">        152 :         ast_debug(4, &quot;return at end of func\n&quot;);</span>
<span class="lineNum">    1362 </span>            : }
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            : /* the algorithm for forming the extension pattern tree is also a bit simple; you
<span class="lineNum">    1365 </span>            :  * traverse all the extensions in a context, and for each char of the extension,
<span class="lineNum">    1366 </span>            :  * you see if it exists in the tree; if it doesn't, you add it at the appropriate
<span class="lineNum">    1367 </span>            :  * spot. What more can I say? At the end of each exten, you cap it off by adding the
<span class="lineNum">    1368 </span>            :  * address of the extension involved. Duplicate patterns will be complained about.
<span class="lineNum">    1369 </span>            :  *
<span class="lineNum">    1370 </span>            :  * Ideally, this would be done for each context after it is created and fully
<span class="lineNum">    1371 </span>            :  * filled. It could be done as a finishing step after extensions.conf or .ael is
<span class="lineNum">    1372 </span>            :  * loaded, or it could be done when the first search is encountered. It should only
<span class="lineNum">    1373 </span>            :  * have to be done once, until the next unload or reload.
<span class="lineNum">    1374 </span>            :  *
<span class="lineNum">    1375 </span>            :  * I guess forming this pattern tree would be analogous to compiling a regex. Except
<span class="lineNum">    1376 </span>            :  * that a regex only handles 1 pattern, really. This trie holds any number
<span class="lineNum">    1377 </span>            :  * of patterns. Well, really, it **could** be considered a single pattern,
<span class="lineNum">    1378 </span>            :  * where the &quot;|&quot; (or) operator is allowed, I guess, in a way, sort of...
<a name="1379"><span class="lineNum">    1379 </span>            :  */</a>
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span><span class="lineCov">      89200 : static struct match_char *already_in_tree(struct match_char *current, char *pat, int is_pattern)</span>
<span class="lineNum">    1382 </span>            : {
<span class="lineNum">    1383 </span>            :         struct match_char *t;
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span><span class="lineCov">      89200 :         if (!current) {</span>
<span class="lineNum">    1386 </span><span class="lineCov">       2264 :                 return 0;</span>
<span class="lineNum">    1387 </span>            :         }
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span><span class="lineCov">     214416 :         for (t = current; t; t = t-&gt;alt_char) {</span>
<span class="lineNum">    1390 </span><span class="lineCov">     190016 :                 if (is_pattern == t-&gt;is_pattern &amp;&amp; !strcmp(pat, t-&gt;x)) {/* uh, we may want to sort exploded [] contents to make matching easy */</span>
<span class="lineNum">    1391 </span><span class="lineCov">      62536 :                         return t;</span>
<span class="lineNum">    1392 </span>            :                 }
<span class="lineNum">    1393 </span>            :         }
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span><span class="lineCov">      24400 :         return 0;</span>
<span class="lineNum">    1396 </span>            : }
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            : /* The first arg is the location of the tree ptr, or the
<span class="lineNum">    1399 </span>            :    address of the next_char ptr in the node, so we can mess
<a name="1400"><span class="lineNum">    1400 </span>            :    with it, if we need to insert at the beginning of the list */</a>
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span><span class="lineCov">      40887 : static void insert_in_next_chars_alt_char_list(struct match_char **parent_ptr, struct match_char *node)</span>
<span class="lineNum">    1403 </span>            : {
<span class="lineNum">    1404 </span>            :         struct match_char *curr, *lcurr;
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            :         /* insert node into the tree at &quot;current&quot;, so the alt_char list from current is
<span class="lineNum">    1407 </span>            :            sorted in increasing value as you go to the leaves */
<span class="lineNum">    1408 </span><span class="lineCov">      40887 :         if (!(*parent_ptr)) {</span>
<span class="lineNum">    1409 </span><span class="lineCov">      16487 :                 *parent_ptr = node;</span>
<span class="lineNum">    1410 </span><span class="lineCov">      16487 :                 return;</span>
<span class="lineNum">    1411 </span>            :         }
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span><span class="lineCov">      24400 :         if ((*parent_ptr)-&gt;specificity &gt; node-&gt;specificity) {</span>
<span class="lineNum">    1414 </span>            :                 /* insert at head */
<span class="lineNum">    1415 </span><span class="lineCov">         12 :                 node-&gt;alt_char = (*parent_ptr);</span>
<span class="lineNum">    1416 </span><span class="lineCov">         12 :                 *parent_ptr = node;</span>
<span class="lineNum">    1417 </span><span class="lineCov">         12 :                 return;</span>
<span class="lineNum">    1418 </span>            :         }
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span><span class="lineCov">      24388 :         lcurr = *parent_ptr;</span>
<span class="lineNum">    1421 </span><span class="lineCov">     109481 :         for (curr = (*parent_ptr)-&gt;alt_char; curr; curr = curr-&gt;alt_char) {</span>
<span class="lineNum">    1422 </span><span class="lineCov">      85117 :                 if (curr-&gt;specificity &gt; node-&gt;specificity) {</span>
<span class="lineNum">    1423 </span><span class="lineCov">         24 :                         node-&gt;alt_char = curr;</span>
<span class="lineNum">    1424 </span><span class="lineCov">         24 :                         lcurr-&gt;alt_char = node;</span>
<span class="lineNum">    1425 </span><span class="lineCov">         24 :                         break;</span>
<span class="lineNum">    1426 </span>            :                 }
<span class="lineNum">    1427 </span><span class="lineCov">      85093 :                 lcurr = curr;</span>
<span class="lineNum">    1428 </span>            :         }
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span><span class="lineCov">      24388 :         if (!curr) {</span>
<span class="lineNum">    1431 </span><span class="lineCov">      24364 :                 lcurr-&gt;alt_char = node;</span>
<span class="lineNum">    1432 </span>            :         }
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span>            : }
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span>            : struct pattern_node {
<span class="lineNum">    1437 </span>            :         /*! Pattern node specificity */
<span class="lineNum">    1438 </span>            :         int specif;
<span class="lineNum">    1439 </span>            :         /*! Pattern node match characters. */
<span class="lineNum">    1440 </span>            :         char buf[256];
<a name="1441"><span class="lineNum">    1441 </span>            : };</a>
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span><span class="lineCov">      40887 : static struct match_char *add_pattern_node(struct ast_context *con, struct match_char *current, const struct pattern_node *pattern, int is_pattern, int already, struct match_char **nextcharptr)</span>
<span class="lineNum">    1444 </span>            : {
<span class="lineNum">    1445 </span>            :         struct match_char *m;
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span><span class="lineCov">      40887 :         if (!(m = ast_calloc(1, sizeof(*m) + strlen(pattern-&gt;buf)))) {</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    1449 </span>            :         }
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            :         /* strcpy is safe here since we know its size and have allocated
<span class="lineNum">    1452 </span>            :          * just enough space for when we allocated m
<span class="lineNum">    1453 </span>            :          */
<span class="lineNum">    1454 </span><span class="lineCov">      40887 :         strcpy(m-&gt;x, pattern-&gt;buf);</span>
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span>            :         /* the specificity scores are the same as used in the old
<span class="lineNum">    1457 </span>            :            pattern matcher. */
<span class="lineNum">    1458 </span><span class="lineCov">      40887 :         m-&gt;is_pattern = is_pattern;</span>
<span class="lineNum">    1459 </span><span class="lineCov">      40887 :         if (pattern-&gt;specif == 1 &amp;&amp; is_pattern &amp;&amp; pattern-&gt;buf[0] == 'N') {</span>
<span class="lineNum">    1460 </span><span class="lineCov">          7 :                 m-&gt;specificity = 0x0832;</span>
<span class="lineNum">    1461 </span><span class="lineCov">      40880 :         } else if (pattern-&gt;specif == 1 &amp;&amp; is_pattern &amp;&amp; pattern-&gt;buf[0] == 'Z') {</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :                 m-&gt;specificity = 0x0931;</span>
<span class="lineNum">    1463 </span><span class="lineCov">      40880 :         } else if (pattern-&gt;specif == 1 &amp;&amp; is_pattern &amp;&amp; pattern-&gt;buf[0] == 'X') {</span>
<span class="lineNum">    1464 </span><span class="lineCov">         85 :                 m-&gt;specificity = 0x0a30;</span>
<span class="lineNum">    1465 </span><span class="lineCov">      40795 :         } else if (pattern-&gt;specif == 1 &amp;&amp; is_pattern &amp;&amp; pattern-&gt;buf[0] == '.') {</span>
<span class="lineNum">    1466 </span><span class="lineCov">         39 :                 m-&gt;specificity = 0x18000;</span>
<span class="lineNum">    1467 </span><span class="lineCov">      40756 :         } else if (pattern-&gt;specif == 1 &amp;&amp; is_pattern &amp;&amp; pattern-&gt;buf[0] == '!') {</span>
<span class="lineNum">    1468 </span><span class="lineCov">          2 :                 m-&gt;specificity = 0x28000;</span>
<span class="lineNum">    1469 </span>            :         } else {
<span class="lineNum">    1470 </span><span class="lineCov">      40754 :                 m-&gt;specificity = pattern-&gt;specif;</span>
<span class="lineNum">    1471 </span>            :         }
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span><span class="lineCov">      40887 :         if (!con-&gt;pattern_tree) {</span>
<span class="lineNum">    1474 </span><span class="lineCov">       2264 :                 insert_in_next_chars_alt_char_list(&amp;con-&gt;pattern_tree, m);</span>
<span class="lineNum">    1475 </span>            :         } else {
<span class="lineNum">    1476 </span><span class="lineCov">      38623 :                 if (already) { /* switch to the new regime (traversing vs appending)*/</span>
<span class="lineNum">    1477 </span><span class="lineCov">      24400 :                         insert_in_next_chars_alt_char_list(nextcharptr, m);</span>
<span class="lineNum">    1478 </span>            :                 } else {
<span class="lineNum">    1479 </span><span class="lineCov">      14223 :                         insert_in_next_chars_alt_char_list(&amp;current-&gt;next_char, m);</span>
<span class="lineNum">    1480 </span>            :                 }
<span class="lineNum">    1481 </span>            :         }
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span><span class="lineCov">      40887 :         return m;</span>
<span class="lineNum">    1484 </span>            : }
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span>            : /*!
<span class="lineNum">    1487 </span>            :  * \internal
<span class="lineNum">    1488 </span>            :  * \brief Extract the next exten pattern node.
<span class="lineNum">    1489 </span>            :  *
<span class="lineNum">    1490 </span>            :  * \param node Pattern node to fill.
<span class="lineNum">    1491 </span>            :  * \param src Next source character to read.
<span class="lineNum">    1492 </span>            :  * \param pattern TRUE if the exten is a pattern.
<span class="lineNum">    1493 </span>            :  * \param extenbuf Original exten buffer to use in diagnostic messages.
<span class="lineNum">    1494 </span>            :  *
<a name="1495"><span class="lineNum">    1495 </span>            :  * \retval Ptr to next extenbuf pos to read.</a>
<span class="lineNum">    1496 </span>            :  */
<span class="lineNum">    1497 </span><span class="lineCov">     133208 : static const char *get_pattern_node(struct pattern_node *node, const char *src, int pattern, const char *extenbuf)</span>
<span class="lineNum">    1498 </span>            : {
<span class="lineNum">    1499 </span>            : #define INC_DST_OVERFLOW_CHECK                                                  \
<span class="lineNum">    1500 </span>            :         do {                                                                                            \
<span class="lineNum">    1501 </span>            :                 if (dst - node-&gt;buf &lt; sizeof(node-&gt;buf) - 1) { \
<span class="lineNum">    1502 </span>            :                         ++dst;                                                                          \
<span class="lineNum">    1503 </span>            :                 } else {                                                                                \
<span class="lineNum">    1504 </span>            :                         overflow = 1;                                                           \
<span class="lineNum">    1505 </span>            :                 }                                                                                               \
<span class="lineNum">    1506 </span>            :         } while (0)
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span><span class="lineCov">     133208 :         node-&gt;specif = 0;</span>
<span class="lineNum">    1509 </span><span class="lineCov">     133208 :         node-&gt;buf[0] = '\0';</span>
<span class="lineNum">    1510 </span><span class="lineCov">     133210 :         while (*src) {</span>
<span class="lineNum">    1511 </span><span class="lineCov">     103425 :                 if (*src == '[' &amp;&amp; pattern) {</span>
<span class="lineNum">    1512 </span><span class="lineCov">         68 :                         char *dst = node-&gt;buf;</span>
<span class="lineNum">    1513 </span>            :                         const char *src_next;
<span class="lineNum">    1514 </span>            :                         int length;
<span class="lineNum">    1515 </span><span class="lineCov">         68 :                         int overflow = 0;</span>
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span>            :                         /* get past the '[' */
<span class="lineNum">    1518 </span><span class="lineCov">         68 :                         ++src;</span>
<span class="lineNum">    1519 </span>            :                         for (;;) {
<span class="lineNum">    1520 </span><span class="lineCov">        178 :                                 if (*src == '\\') {</span>
<span class="lineNum">    1521 </span>            :                                         /* Escaped character. */
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :                                         ++src;</span>
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :                                         if (*src == '[' || *src == '\\' || *src == '-' || *src == ']') {</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :                                                 *dst = *src++;</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :                                                 INC_DST_OVERFLOW_CHECK;</span>
<span class="lineNum">    1526 </span>            :                                         }
<span class="lineNum">    1527 </span><span class="lineCov">        178 :                                 } else if (*src == '-') {</span>
<span class="lineNum">    1528 </span>            :                                         unsigned char first;
<span class="lineNum">    1529 </span>            :                                         unsigned char last;
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span><span class="lineCov">         18 :                                         src_next = src;</span>
<span class="lineNum">    1532 </span><span class="lineCov">         18 :                                         first = *(src_next - 1);</span>
<span class="lineNum">    1533 </span><span class="lineCov">         18 :                                         last = *++src_next;</span>
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span><span class="lineCov">         18 :                                         if (last == '\\') {</span>
<span class="lineNum">    1536 </span>            :                                                 /* Escaped character. */
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :                                                 last = *++src_next;</span>
<span class="lineNum">    1538 </span>            :                                         }
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span>            :                                         /* Possible char range. */
<span class="lineNum">    1541 </span><span class="lineCov">         18 :                                         if (node-&gt;buf[0] &amp;&amp; last) {</span>
<span class="lineNum">    1542 </span>            :                                                 /* Expand the char range. */
<span class="lineNum">    1543 </span><span class="lineCov">        192 :                                                 while (++first &lt;= last) {</span>
<span class="lineNum">    1544 </span><span class="lineCov">        174 :                                                         *dst = first;</span>
<span class="lineNum">    1545 </span><span class="lineCov">        174 :                                                         INC_DST_OVERFLOW_CHECK;</span>
<span class="lineNum">    1546 </span>            :                                                 }
<span class="lineNum">    1547 </span><span class="lineCov">         18 :                                                 src = src_next + 1;</span>
<span class="lineNum">    1548 </span>            :                                         } else {
<span class="lineNum">    1549 </span>            :                                                 /*
<span class="lineNum">    1550 </span>            :                                                  * There was no left or right char for the range.
<span class="lineNum">    1551 </span>            :                                                  * It is just a '-'.
<span class="lineNum">    1552 </span>            :                                                  */
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :                                                 *dst = *src++;</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :                                                 INC_DST_OVERFLOW_CHECK;</span>
<span class="lineNum">    1555 </span>            :                                         }
<span class="lineNum">    1556 </span><span class="lineCov">        160 :                                 } else if (*src == '\0') {</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_WARNING,</span>
<span class="lineNum">    1558 </span>            :                                                 &quot;A matching ']' was not found for '[' in exten pattern '%s'\n&quot;,
<span class="lineNum">    1559 </span>            :                                                 extenbuf);
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">    1561 </span><span class="lineCov">        160 :                                 } else if (*src == ']') {</span>
<span class="lineNum">    1562 </span><span class="lineCov">         68 :                                         ++src;</span>
<span class="lineNum">    1563 </span><span class="lineCov">         68 :                                         break;</span>
<span class="lineNum">    1564 </span>            :                                 } else {
<span class="lineNum">    1565 </span><span class="lineCov">         92 :                                         *dst = *src++;</span>
<span class="lineNum">    1566 </span><span class="lineCov">         92 :                                         INC_DST_OVERFLOW_CHECK;</span>
<span class="lineNum">    1567 </span>            :                                 }
<span class="lineNum">    1568 </span>            :                         }
<span class="lineNum">    1569 </span>            :                         /* null terminate the exploded range */
<span class="lineNum">    1570 </span><span class="lineCov">         68 :                         *dst = '\0';</span>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineCov">         68 :                         if (overflow) {</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_ERROR,</span>
<span class="lineNum">    1574 </span>            :                                         &quot;Expanded character set too large to deal with in exten pattern '%s'. Ignoring character set.\n&quot;,
<span class="lineNum">    1575 </span>            :                                         extenbuf);
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :                                 node-&gt;buf[0] = '\0';</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    1578 </span>            :                         }
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            :                         /* Sort the characters in character set. */
<span class="lineNum">    1581 </span><span class="lineCov">         68 :                         length = strlen(node-&gt;buf);</span>
<span class="lineNum">    1582 </span><span class="lineCov">         68 :                         if (!length) {</span>
<span class="lineNum">    1583 </span><span class="lineCov">          2 :                                 ast_log(LOG_WARNING, &quot;Empty character set in exten pattern '%s'. Ignoring.\n&quot;,</span>
<span class="lineNum">    1584 </span>            :                                         extenbuf);
<span class="lineNum">    1585 </span><span class="lineCov">          2 :                                 node-&gt;buf[0] = '\0';</span>
<span class="lineNum">    1586 </span><span class="lineCov">          2 :                                 continue;</span>
<span class="lineNum">    1587 </span>            :                         }
<span class="lineNum">    1588 </span><span class="lineCov">         66 :                         qsort(node-&gt;buf, length, 1, compare_char);</span>
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span>            :                         /* Remove duplicate characters from character set. */
<span class="lineNum">    1591 </span><span class="lineCov">         66 :                         dst = node-&gt;buf;</span>
<span class="lineNum">    1592 </span><span class="lineCov">         66 :                         src_next = node-&gt;buf;</span>
<span class="lineNum">    1593 </span><span class="lineCov">        332 :                         while (*src_next++) {</span>
<span class="lineNum">    1594 </span><span class="lineCov">        266 :                                 if (*dst != *src_next) {</span>
<span class="lineNum">    1595 </span><span class="lineCov">        266 :                                         *++dst = *src_next;</span>
<span class="lineNum">    1596 </span>            :                                 }
<span class="lineNum">    1597 </span>            :                         }
<span class="lineNum">    1598 </span>            : 
<span class="lineNum">    1599 </span><span class="lineCov">         66 :                         length = strlen(node-&gt;buf);</span>
<span class="lineNum">    1600 </span><span class="lineCov">         66 :                         length &lt;&lt;= 8;</span>
<span class="lineNum">    1601 </span><span class="lineCov">         66 :                         node-&gt;specif = length | (unsigned char) node-&gt;buf[0];</span>
<span class="lineNum">    1602 </span><span class="lineCov">         66 :                         break;</span>
<span class="lineNum">    1603 </span><span class="lineCov">     103357 :                 } else if (*src == '-') {</span>
<span class="lineNum">    1604 </span>            :                         /* Skip dashes in all extensions. */
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :                         ++src;</span>
<span class="lineNum">    1606 </span>            :                 } else {
<span class="lineNum">    1607 </span><span class="lineCov">     103357 :                         if (*src == '\\') {</span>
<span class="lineNum">    1608 </span>            :                                 /*
<span class="lineNum">    1609 </span>            :                                  * XXX The escape character here does not remove any special
<span class="lineNum">    1610 </span>            :                                  * meaning to characters except the '[', '\\', and '-'
<span class="lineNum">    1611 </span>            :                                  * characters since they are special only in this function.
<span class="lineNum">    1612 </span>            :                                  */
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :                                 node-&gt;buf[0] = *++src;</span>
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :                                 if (!node-&gt;buf[0]) {</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">    1616 </span>            :                                 }
<span class="lineNum">    1617 </span>            :                         } else {
<span class="lineNum">    1618 </span><span class="lineCov">     103357 :                                 node-&gt;buf[0] = *src;</span>
<span class="lineNum">    1619 </span><span class="lineCov">     103357 :                                 if (pattern) {</span>
<span class="lineNum">    1620 </span>            :                                         /* make sure n,x,z patterns are canonicalized to N,X,Z */
<span class="lineNum">    1621 </span><span class="lineCov">        461 :                                         if (node-&gt;buf[0] == 'n') {</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :                                                 node-&gt;buf[0] = 'N';</span>
<span class="lineNum">    1623 </span><span class="lineCov">        461 :                                         } else if (node-&gt;buf[0] == 'x') {</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :                                                 node-&gt;buf[0] = 'X';</span>
<span class="lineNum">    1625 </span><span class="lineCov">        461 :                                         } else if (node-&gt;buf[0] == 'z') {</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :                                                 node-&gt;buf[0] = 'Z';</span>
<span class="lineNum">    1627 </span>            :                                         }
<span class="lineNum">    1628 </span>            :                                 }
<span class="lineNum">    1629 </span>            :                         }
<span class="lineNum">    1630 </span><span class="lineCov">     103357 :                         node-&gt;buf[1] = '\0';</span>
<span class="lineNum">    1631 </span><span class="lineCov">     103357 :                         node-&gt;specif = 1;</span>
<span class="lineNum">    1632 </span><span class="lineCov">     103357 :                         ++src;</span>
<span class="lineNum">    1633 </span><span class="lineCov">     103357 :                         break;</span>
<span class="lineNum">    1634 </span>            :                 }
<span class="lineNum">    1635 </span>            :         }
<span class="lineNum">    1636 </span><span class="lineCov">     133208 :         return src;</span>
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span>            : #undef INC_DST_OVERFLOW_CHECK
<a name="1639"><span class="lineNum">    1639 </span>            : }</a>
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span><span class="lineCov">      29785 : static struct match_char *add_exten_to_pattern_tree(struct ast_context *con, struct ast_exten *e1, int findonly)</span>
<span class="lineNum">    1642 </span>            : {
<span class="lineNum">    1643 </span><span class="lineCov">      29785 :         struct match_char *m1 = NULL;</span>
<span class="lineNum">    1644 </span><span class="lineCov">      29785 :         struct match_char *m2 = NULL;</span>
<span class="lineNum">    1645 </span>            :         struct match_char **m0;
<span class="lineNum">    1646 </span>            :         const char *pos;
<span class="lineNum">    1647 </span>            :         int already;
<span class="lineNum">    1648 </span><span class="lineCov">      29785 :         int pattern = 0;</span>
<span class="lineNum">    1649 </span>            :         int idx_cur;
<span class="lineNum">    1650 </span>            :         int idx_next;
<span class="lineNum">    1651 </span>            :         char extenbuf[512];
<span class="lineNum">    1652 </span>            :         struct pattern_node pat_node[2];
<span class="lineNum">    1653 </span>            : 
<span class="lineNum">    1654 </span><span class="lineCov">      29785 :         if (e1-&gt;matchcid) {</span>
<span class="lineNum">    1655 </span><span class="lineCov">         28 :                 if (sizeof(extenbuf) &lt; strlen(e1-&gt;exten) + strlen(e1-&gt;cidmatch) + 2) {</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR,</span>
<span class="lineNum">    1657 </span>            :                                 &quot;The pattern %s/%s is too big to deal with: it will be ignored! Disaster!\n&quot;,
<span class="lineNum">    1658 </span>            :                                 e1-&gt;exten, e1-&gt;cidmatch);
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">    1660 </span>            :                 }
<span class="lineNum">    1661 </span><span class="lineCov">         28 :                 sprintf(extenbuf, &quot;%s/%s&quot;, e1-&gt;exten, e1-&gt;cidmatch);/* Safe.  We just checked. */</span>
<span class="lineNum">    1662 </span>            :         } else {
<span class="lineNum">    1663 </span><span class="lineCov">      29757 :                 ast_copy_string(extenbuf, e1-&gt;exten, sizeof(extenbuf));</span>
<span class="lineNum">    1664 </span>            :         }
<span class="lineNum">    1665 </span>            : 
<span class="lineNum">    1666 </span>            : #ifdef NEED_DEBUG
<span class="lineNum">    1667 </span>            :         ast_debug(1, &quot;Adding exten %s to tree\n&quot;, extenbuf);
<span class="lineNum">    1668 </span>            : #endif
<span class="lineNum">    1669 </span><span class="lineCov">      29785 :         m1 = con-&gt;pattern_tree; /* each pattern starts over at the root of the pattern tree */</span>
<span class="lineNum">    1670 </span><span class="lineCov">      29785 :         m0 = &amp;con-&gt;pattern_tree;</span>
<span class="lineNum">    1671 </span><span class="lineCov">      29785 :         already = 1;</span>
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span><span class="lineCov">      29785 :         pos = extenbuf;</span>
<span class="lineNum">    1674 </span><span class="lineCov">      29785 :         if (*pos == '_') {</span>
<span class="lineNum">    1675 </span><span class="lineCov">        170 :                 pattern = 1;</span>
<span class="lineNum">    1676 </span><span class="lineCov">        170 :                 ++pos;</span>
<span class="lineNum">    1677 </span>            :         }
<span class="lineNum">    1678 </span><span class="lineCov">      29785 :         idx_cur = 0;</span>
<span class="lineNum">    1679 </span><span class="lineCov">      29785 :         pos = get_pattern_node(&amp;pat_node[idx_cur], pos, pattern, extenbuf);</span>
<span class="lineNum">    1680 </span><span class="lineCov">     130186 :         for (; pat_node[idx_cur].buf[0]; idx_cur = idx_next) {</span>
<span class="lineNum">    1681 </span><span class="lineCov">     103423 :                 idx_next = (idx_cur + 1) % ARRAY_LEN(pat_node);</span>
<span class="lineNum">    1682 </span><span class="lineCov">     103423 :                 pos = get_pattern_node(&amp;pat_node[idx_next], pos, pattern, extenbuf);</span>
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span>            :                 /* See about adding node to tree. */
<span class="lineNum">    1685 </span><span class="lineCov">     103423 :                 m2 = NULL;</span>
<span class="lineNum">    1686 </span><span class="lineCov">     103423 :                 if (already &amp;&amp; (m2 = already_in_tree(m1, pat_node[idx_cur].buf, pattern))</span>
<span class="lineNum">    1687 </span><span class="lineCov">      62536 :                         &amp;&amp; m2-&gt;next_char) {</span>
<span class="lineNum">    1688 </span><span class="lineCov">      59592 :                         if (!pat_node[idx_next].buf[0]) {</span>
<span class="lineNum">    1689 </span>            :                                 /*
<span class="lineNum">    1690 </span>            :                                  * This is the end of the pattern, but not the end of the tree.
<span class="lineNum">    1691 </span>            :                                  * Mark this node with the exten... a shorter pattern might win
<span class="lineNum">    1692 </span>            :                                  * if the longer one doesn't match.
<span class="lineNum">    1693 </span>            :                                  */
<span class="lineNum">    1694 </span><span class="lineCov">        177 :                                 if (findonly) {</span>
<span class="lineNum">    1695 </span><span class="lineCov">         93 :                                         return m2;</span>
<span class="lineNum">    1696 </span>            :                                 }
<span class="lineNum">    1697 </span><span class="lineCov">         84 :                                 if (m2-&gt;exten) {</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_WARNING, &quot;Found duplicate exten. Had %s found %s\n&quot;,</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :                                                 m2-&gt;deleted ? &quot;(deleted/invalid)&quot; : m2-&gt;exten-&gt;name, e1-&gt;name);</span>
<span class="lineNum">    1700 </span>            :                                 }
<span class="lineNum">    1701 </span><span class="lineCov">         84 :                                 m2-&gt;exten = e1;</span>
<span class="lineNum">    1702 </span><span class="lineCov">         84 :                                 m2-&gt;deleted = 0;</span>
<span class="lineNum">    1703 </span>            :                         }
<span class="lineNum">    1704 </span><span class="lineCov">      59499 :                         m1 = m2-&gt;next_char; /* m1 points to the node to compare against */</span>
<span class="lineNum">    1705 </span><span class="lineCov">      59499 :                         m0 = &amp;m2-&gt;next_char; /* m0 points to the ptr that points to m1 */</span>
<span class="lineNum">    1706 </span>            :                 } else { /* not already OR not m2 OR nor m2-&gt;next_char */
<span class="lineNum">    1707 </span><span class="lineCov">      43831 :                         if (m2) {</span>
<span class="lineNum">    1708 </span><span class="lineCov">       2944 :                                 if (findonly) {</span>
<span class="lineNum">    1709 </span><span class="lineCov">       2929 :                                         return m2;</span>
<span class="lineNum">    1710 </span>            :                                 }
<span class="lineNum">    1711 </span><span class="lineCov">         15 :                                 m1 = m2; /* while m0 stays the same */</span>
<span class="lineNum">    1712 </span>            :                         } else {
<span class="lineNum">    1713 </span><span class="lineCov">      40887 :                                 if (findonly) {</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :                                         return m1;</span>
<span class="lineNum">    1715 </span>            :                                 }
<span class="lineNum">    1716 </span><span class="lineCov">      40887 :                                 m1 = add_pattern_node(con, m1, &amp;pat_node[idx_cur], pattern, already, m0);</span>
<span class="lineNum">    1717 </span><span class="lineCov">      40887 :                                 if (!m1) { /* m1 is the node just added */</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :                                         return NULL;</span>
<span class="lineNum">    1719 </span>            :                                 }
<span class="lineNum">    1720 </span><span class="lineCov">      40887 :                                 m0 = &amp;m1-&gt;next_char;</span>
<span class="lineNum">    1721 </span>            :                         }
<span class="lineNum">    1722 </span><span class="lineCov">      40902 :                         if (!pat_node[idx_next].buf[0]) {</span>
<span class="lineNum">    1723 </span><span class="lineCov">      26679 :                                 if (m2 &amp;&amp; m2-&gt;exten) {</span>
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_WARNING, &quot;Found duplicate exten. Had %s found %s\n&quot;,</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :                                                 m2-&gt;deleted ? &quot;(deleted/invalid)&quot; : m2-&gt;exten-&gt;name, e1-&gt;name);</span>
<span class="lineNum">    1726 </span>            :                                 }
<span class="lineNum">    1727 </span><span class="lineCov">      26679 :                                 m1-&gt;deleted = 0;</span>
<span class="lineNum">    1728 </span><span class="lineCov">      26679 :                                 m1-&gt;exten = e1;</span>
<span class="lineNum">    1729 </span>            :                         }
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span>            :                         /* The 'already' variable is a mini-optimization designed to make it so that we
<span class="lineNum">    1732 </span>            :                          * don't have to call already_in_tree when we know it will return false.
<span class="lineNum">    1733 </span>            :                          */
<span class="lineNum">    1734 </span><span class="lineCov">      40902 :                         already = 0;</span>
<span class="lineNum">    1735 </span>            :                 }
<span class="lineNum">    1736 </span>            :         }
<span class="lineNum">    1737 </span><span class="lineCov">      26763 :         return m1;</span>
<a name="1738"><span class="lineNum">    1738 </span>            : }</a>
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span><span class="lineCov">       2264 : static void create_match_char_tree(struct ast_context *con)</span>
<span class="lineNum">    1741 </span>            : {
<span class="lineNum">    1742 </span>            :         struct ast_hashtab_iter *t1;
<span class="lineNum">    1743 </span>            :         struct ast_exten *e1;
<span class="lineNum">    1744 </span>            : #ifdef NEED_DEBUG
<span class="lineNum">    1745 </span>            :         int biggest_bucket, resizes, numobjs, numbucks;
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span>            :         ast_debug(1, &quot;Creating Extension Trie for context %s(%p)\n&quot;, con-&gt;name, con);
<span class="lineNum">    1748 </span>            :         ast_hashtab_get_stats(con-&gt;root_table, &amp;biggest_bucket, &amp;resizes, &amp;numobjs, &amp;numbucks);
<span class="lineNum">    1749 </span>            :         ast_debug(1, &quot;This tree has %d objects in %d bucket lists, longest list=%d objects, and has resized %d times\n&quot;,
<span class="lineNum">    1750 </span>            :                         numobjs, numbucks, biggest_bucket, resizes);
<span class="lineNum">    1751 </span>            : #endif
<span class="lineNum">    1752 </span><span class="lineCov">       2264 :         t1 = ast_hashtab_start_traversal(con-&gt;root_table);</span>
<span class="lineNum">    1753 </span><span class="lineCov">       6333 :         while ((e1 = ast_hashtab_next(t1))) {</span>
<span class="lineNum">    1754 </span><span class="lineCov">       4069 :                 if (e1-&gt;exten) {</span>
<span class="lineNum">    1755 </span><span class="lineCov">       4069 :                         add_exten_to_pattern_tree(con, e1, 0);</span>
<span class="lineNum">    1756 </span>            :                 } else {
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR, &quot;Attempt to create extension with no extension name.\n&quot;);</span>
<span class="lineNum">    1758 </span>            :                 }
<span class="lineNum">    1759 </span>            :         }
<span class="lineNum">    1760 </span><span class="lineCov">       2264 :         ast_hashtab_end_traversal(t1);</span>
<a name="1761"><span class="lineNum">    1761 </span><span class="lineCov">       2264 : }</span></a>
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span><span class="lineCov">      40142 : static void destroy_pattern_tree(struct match_char *pattern_tree) /* pattern tree is a simple binary tree, sort of, so the proper way to destroy it is... recursively! */</span>
<span class="lineNum">    1764 </span>            : {
<span class="lineNum">    1765 </span>            :         /* destroy all the alternates */
<span class="lineNum">    1766 </span><span class="lineCov">      40142 :         if (pattern_tree-&gt;alt_char) {</span>
<span class="lineNum">    1767 </span><span class="lineCov">      24007 :                 destroy_pattern_tree(pattern_tree-&gt;alt_char);</span>
<span class="lineNum">    1768 </span><span class="lineCov">      24007 :                 pattern_tree-&gt;alt_char = 0;</span>
<span class="lineNum">    1769 </span>            :         }
<span class="lineNum">    1770 </span>            :         /* destroy all the nexts */
<span class="lineNum">    1771 </span><span class="lineCov">      40142 :         if (pattern_tree-&gt;next_char) {</span>
<span class="lineNum">    1772 </span><span class="lineCov">      13898 :                 destroy_pattern_tree(pattern_tree-&gt;next_char);</span>
<span class="lineNum">    1773 </span><span class="lineCov">      13898 :                 pattern_tree-&gt;next_char = 0;</span>
<span class="lineNum">    1774 </span>            :         }
<span class="lineNum">    1775 </span><span class="lineCov">      40142 :         pattern_tree-&gt;exten = 0; /* never hurts to make sure there's no pointers laying around */</span>
<span class="lineNum">    1776 </span><span class="lineCov">      40142 :         ast_free(pattern_tree);</span>
<span class="lineNum">    1777 </span><span class="lineCov">      40142 : }</span>
<span class="lineNum">    1778 </span>            : 
<span class="lineNum">    1779 </span>            : /*!
<span class="lineNum">    1780 </span>            :  * \internal
<span class="lineNum">    1781 </span>            :  * \brief Get the length of the exten string.
<span class="lineNum">    1782 </span>            :  *
<span class="lineNum">    1783 </span>            :  * \param str Exten to get length.
<span class="lineNum">    1784 </span>            :  *
<a name="1785"><span class="lineNum">    1785 </span>            :  * \retval strlen of exten.</a>
<span class="lineNum">    1786 </span>            :  */
<span class="lineNum">    1787 </span><span class="lineCov">     661196 : static int ext_cmp_exten_strlen(const char *str)</span>
<span class="lineNum">    1788 </span>            : {
<span class="lineNum">    1789 </span>            :         int len;
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span><span class="lineCov">     661196 :         len = 0;</span>
<span class="lineNum">    1792 </span>            :         for (;;) {
<span class="lineNum">    1793 </span>            :                 /* Ignore '-' chars as eye candy fluff. */
<span class="lineNum">    1794 </span><span class="lineCov">    3274884 :                 while (*str == '-') {</span>
<span class="lineNum">    1795 </span><span class="lineCov">       2337 :                         ++str;</span>
<span class="lineNum">    1796 </span>            :                 }
<span class="lineNum">    1797 </span><span class="lineCov">    3272547 :                 if (!*str) {</span>
<span class="lineNum">    1798 </span><span class="lineCov">     661196 :                         break;</span>
<span class="lineNum">    1799 </span>            :                 }
<span class="lineNum">    1800 </span><span class="lineCov">    2611351 :                 ++str;</span>
<span class="lineNum">    1801 </span><span class="lineCov">    2611351 :                 ++len;</span>
<span class="lineNum">    1802 </span>            :         }
<span class="lineNum">    1803 </span><span class="lineCov">     661196 :         return len;</span>
<span class="lineNum">    1804 </span>            : }
<span class="lineNum">    1805 </span>            : 
<span class="lineNum">    1806 </span>            : /*!
<span class="lineNum">    1807 </span>            :  * \internal
<span class="lineNum">    1808 </span>            :  * \brief Partial comparison of non-pattern extens.
<span class="lineNum">    1809 </span>            :  *
<span class="lineNum">    1810 </span>            :  * \param left Exten to compare.
<span class="lineNum">    1811 </span>            :  * \param right Exten to compare.  Also matches if this string ends first.
<span class="lineNum">    1812 </span>            :  *
<span class="lineNum">    1813 </span>            :  * \retval &lt;0 if left &lt; right
<span class="lineNum">    1814 </span>            :  * \retval =0 if left == right
<a name="1815"><span class="lineNum">    1815 </span>            :  * \retval &gt;0 if left &gt; right</a>
<span class="lineNum">    1816 </span>            :  */
<span class="lineNum">    1817 </span><span class="lineCov">       2606 : static int ext_cmp_exten_partial(const char *left, const char *right)</span>
<span class="lineNum">    1818 </span>            : {
<span class="lineNum">    1819 </span>            :         int cmp;
<span class="lineNum">    1820 </span>            : 
<span class="lineNum">    1821 </span>            :         for (;;) {
<span class="lineNum">    1822 </span>            :                 /* Ignore '-' chars as eye candy fluff. */
<span class="lineNum">    1823 </span><span class="lineCov">       2606 :                 while (*left == '-') {</span>
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :                         ++left;</span>
<span class="lineNum">    1825 </span>            :                 }
<span class="lineNum">    1826 </span><span class="lineCov">       2606 :                 while (*right == '-') {</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :                         ++right;</span>
<span class="lineNum">    1828 </span>            :                 }
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span><span class="lineCov">       2606 :                 if (!*right) {</span>
<span class="lineNum">    1831 </span>            :                         /*
<span class="lineNum">    1832 </span>            :                          * Right ended first for partial match or both ended at the same
<span class="lineNum">    1833 </span>            :                          * time for a match.
<span class="lineNum">    1834 </span>            :                          */
<span class="lineNum">    1835 </span><span class="lineCov">        289 :                         cmp = 0;</span>
<span class="lineNum">    1836 </span><span class="lineCov">        289 :                         break;</span>
<span class="lineNum">    1837 </span>            :                 }
<span class="lineNum">    1838 </span>            : 
<span class="lineNum">    1839 </span><span class="lineCov">       2317 :                 cmp = *left - *right;</span>
<span class="lineNum">    1840 </span><span class="lineCov">       2317 :                 if (cmp) {</span>
<span class="lineNum">    1841 </span><span class="lineCov">       1551 :                         break;</span>
<span class="lineNum">    1842 </span>            :                 }
<span class="lineNum">    1843 </span><span class="lineCov">        766 :                 ++left;</span>
<span class="lineNum">    1844 </span><span class="lineCov">        766 :                 ++right;</span>
<span class="lineNum">    1845 </span>            :         }
<span class="lineNum">    1846 </span><span class="lineCov">       1840 :         return cmp;</span>
<span class="lineNum">    1847 </span>            : }
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span>            : /*!
<span class="lineNum">    1850 </span>            :  * \internal
<span class="lineNum">    1851 </span>            :  * \brief Comparison of non-pattern extens.
<span class="lineNum">    1852 </span>            :  *
<span class="lineNum">    1853 </span>            :  * \param left Exten to compare.
<span class="lineNum">    1854 </span>            :  * \param right Exten to compare.
<span class="lineNum">    1855 </span>            :  *
<span class="lineNum">    1856 </span>            :  * \retval &lt;0 if left &lt; right
<span class="lineNum">    1857 </span>            :  * \retval =0 if left == right
<a name="1858"><span class="lineNum">    1858 </span>            :  * \retval &gt;0 if left &gt; right</a>
<span class="lineNum">    1859 </span>            :  */
<span class="lineNum">    1860 </span><span class="lineCov">    1828911 : static int ext_cmp_exten(const char *left, const char *right)</span>
<span class="lineNum">    1861 </span>            : {
<span class="lineNum">    1862 </span>            :         int cmp;
<span class="lineNum">    1863 </span>            : 
<span class="lineNum">    1864 </span>            :         for (;;) {
<span class="lineNum">    1865 </span>            :                 /* Ignore '-' chars as eye candy fluff. */
<span class="lineNum">    1866 </span><span class="lineCov">    1828911 :                 while (*left == '-') {</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :                         ++left;</span>
<span class="lineNum">    1868 </span>            :                 }
<span class="lineNum">    1869 </span><span class="lineCov">    1829790 :                 while (*right == '-') {</span>
<span class="lineNum">    1870 </span><span class="lineCov">        879 :                         ++right;</span>
<span class="lineNum">    1871 </span>            :                 }
<span class="lineNum">    1872 </span>            : 
<span class="lineNum">    1873 </span><span class="lineCov">    1828911 :                 cmp = *left - *right;</span>
<span class="lineNum">    1874 </span><span class="lineCov">    1828911 :                 if (cmp) {</span>
<span class="lineNum">    1875 </span><span class="lineCov">     560578 :                         break;</span>
<span class="lineNum">    1876 </span>            :                 }
<span class="lineNum">    1877 </span><span class="lineCov">    1268333 :                 if (!*left) {</span>
<span class="lineNum">    1878 </span>            :                         /*
<span class="lineNum">    1879 </span>            :                          * Get here only if both strings ended at the same time.  cmp
<span class="lineNum">    1880 </span>            :                          * would be non-zero if only one string ended.
<span class="lineNum">    1881 </span>            :                          */
<span class="lineNum">    1882 </span><span class="lineCov">      43591 :                         break;</span>
<span class="lineNum">    1883 </span>            :                 }
<span class="lineNum">    1884 </span><span class="lineCov">    1224742 :                 ++left;</span>
<span class="lineNum">    1885 </span><span class="lineCov">    1224742 :                 ++right;</span>
<span class="lineNum">    1886 </span>            :         }
<span class="lineNum">    1887 </span><span class="lineCov">     604169 :         return cmp;</span>
<span class="lineNum">    1888 </span>            : }
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span>            : /*
<span class="lineNum">    1891 </span>            :  * Special characters used in patterns:
<span class="lineNum">    1892 </span>            :  *      '_'     underscore is the leading character of a pattern.
<span class="lineNum">    1893 </span>            :  *              In other position it is treated as a regular char.
<span class="lineNum">    1894 </span>            :  *      '-' The '-' is a separator and ignored.  Why?  So patterns like NXX-XXX-XXXX work.
<span class="lineNum">    1895 </span>            :  *      .       one or more of any character. Only allowed at the end of
<span class="lineNum">    1896 </span>            :  *              a pattern.
<span class="lineNum">    1897 </span>            :  *      !       zero or more of anything. Also impacts the result of CANMATCH
<span class="lineNum">    1898 </span>            :  *              and MATCHMORE. Only allowed at the end of a pattern.
<span class="lineNum">    1899 </span>            :  *              In the core routine, ! causes a match with a return code of 2.
<span class="lineNum">    1900 </span>            :  *              In turn, depending on the search mode: (XXX check if it is implemented)
<span class="lineNum">    1901 </span>            :  *              - E_MATCH retuns 1 (does match)
<span class="lineNum">    1902 </span>            :  *              - E_MATCHMORE returns 0 (no match)
<span class="lineNum">    1903 </span>            :  *              - E_CANMATCH returns 1 (does match)
<span class="lineNum">    1904 </span>            :  *
<span class="lineNum">    1905 </span>            :  *      /       should not appear as it is considered the separator of the CID info.
<span class="lineNum">    1906 </span>            :  *              XXX at the moment we may stop on this char.
<span class="lineNum">    1907 </span>            :  *
<span class="lineNum">    1908 </span>            :  *      X Z N   match ranges 0-9, 1-9, 2-9 respectively.
<span class="lineNum">    1909 </span>            :  *      [       denotes the start of a set of character. Everything inside
<span class="lineNum">    1910 </span>            :  *              is considered literally. We can have ranges a-d and individual
<span class="lineNum">    1911 </span>            :  *              characters. A '[' and '-' can be considered literally if they
<span class="lineNum">    1912 </span>            :  *              are just before ']'.
<span class="lineNum">    1913 </span>            :  *              XXX currently there is no way to specify ']' in a range, nor \ is
<span class="lineNum">    1914 </span>            :  *              considered specially.
<span class="lineNum">    1915 </span>            :  *
<span class="lineNum">    1916 </span>            :  * When we compare a pattern with a specific extension, all characters in the extension
<span class="lineNum">    1917 </span>            :  * itself are considered literally.
<span class="lineNum">    1918 </span>            :  * XXX do we want to consider space as a separator as well ?
<span class="lineNum">    1919 </span>            :  * XXX do we want to consider the separators in non-patterns as well ?
<span class="lineNum">    1920 </span>            :  */
<span class="lineNum">    1921 </span>            : 
<span class="lineNum">    1922 </span>            : /*!
<span class="lineNum">    1923 </span>            :  * \brief helper functions to sort extension patterns in the desired way,
<span class="lineNum">    1924 </span>            :  * so that more specific patterns appear first.
<span class="lineNum">    1925 </span>            :  *
<span class="lineNum">    1926 </span>            :  * \details
<span class="lineNum">    1927 </span>            :  * The function compares individual characters (or sets of), returning
<span class="lineNum">    1928 </span>            :  * an int where bits 0-7 are the ASCII code of the first char in the set,
<span class="lineNum">    1929 </span>            :  * bits 8-15 are the number of characters in the set, and bits 16-20 are
<span class="lineNum">    1930 </span>            :  * for special cases.
<span class="lineNum">    1931 </span>            :  * This way more specific patterns (smaller character sets) appear first.
<span class="lineNum">    1932 </span>            :  * Wildcards have a special value, so that we can directly compare them to
<span class="lineNum">    1933 </span>            :  * sets by subtracting the two values. In particular:
<span class="lineNum">    1934 </span>            :  *  0x001xx     one character, character set starting with xx
<span class="lineNum">    1935 </span>            :  *  0x0yyxx     yy characters, character set starting with xx
<span class="lineNum">    1936 </span>            :  *  0x18000     '.' (one or more of anything)
<span class="lineNum">    1937 </span>            :  *  0x28000     '!' (zero or more of anything)
<span class="lineNum">    1938 </span>            :  *  0x30000     NUL (end of string)
<span class="lineNum">    1939 </span>            :  *  0x40000     error in set.
<span class="lineNum">    1940 </span>            :  * The pointer to the string is advanced according to needs.
<span class="lineNum">    1941 </span>            :  * NOTES:
<span class="lineNum">    1942 </span>            :  *  1. the empty set is ignored.
<span class="lineNum">    1943 </span>            :  *  2. given that a full set has always 0 as the first element,
<span class="lineNum">    1944 </span>            :  *     we could encode the special cases as 0xffXX where XX
<a name="1945"><span class="lineNum">    1945 </span>            :  *     is 1, 2, 3, 4 as used above.</a>
<span class="lineNum">    1946 </span>            :  */
<span class="lineNum">    1947 </span><span class="lineCov">       3990 : static int ext_cmp_pattern_pos(const char **p, unsigned char *bitwise)</span>
<span class="lineNum">    1948 </span>            : {
<span class="lineNum">    1949 </span>            : #define BITS_PER        8       /* Number of bits per unit (byte). */
<span class="lineNum">    1950 </span>            :         unsigned char c;
<span class="lineNum">    1951 </span>            :         unsigned char cmin;
<span class="lineNum">    1952 </span>            :         int count;
<span class="lineNum">    1953 </span>            :         const char *end;
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span>            :         do {
<span class="lineNum">    1956 </span>            :                 /* Get character and advance. (Ignore '-' chars as eye candy fluff.) */
<span class="lineNum">    1957 </span>            :                 do {
<span class="lineNum">    1958 </span><span class="lineCov">       3990 :                         c = *(*p)++;</span>
<span class="lineNum">    1959 </span><span class="lineCov">       3990 :                 } while (c == '-');</span>
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span>            :                 /* always return unless we have a set of chars */
<span class="lineNum">    1962 </span><span class="lineCov">       3990 :                 switch (c) {</span>
<span class="lineNum">    1963 </span><span class="lineCov">       1530 :                 default:</span>
<span class="lineNum">    1964 </span>            :                         /* ordinary character */
<span class="lineNum">    1965 </span><span class="lineCov">       1530 :                         bitwise[c / BITS_PER] = 1 &lt;&lt; ((BITS_PER - 1) - (c % BITS_PER));</span>
<span class="lineNum">    1966 </span><span class="lineCov">       1530 :                         return 0x0100 | c;</span>
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span><span class="lineCov">         13 :                 case 'n':</span>
<span class="lineNum">    1969 </span>            :                 case 'N':
<span class="lineNum">    1970 </span>            :                         /* 2..9 */
<span class="lineNum">    1971 </span><span class="lineCov">         13 :                         bitwise[6] = 0x3f;</span>
<span class="lineNum">    1972 </span><span class="lineCov">         13 :                         bitwise[7] = 0xc0;</span>
<span class="lineNum">    1973 </span><span class="lineCov">         13 :                         return 0x0800 | '2';</span>
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span><span class="lineCov">       1180 :                 case 'x':</span>
<span class="lineNum">    1976 </span>            :                 case 'X':
<span class="lineNum">    1977 </span>            :                         /* 0..9 */
<span class="lineNum">    1978 </span><span class="lineCov">       1180 :                         bitwise[6] = 0xff;</span>
<span class="lineNum">    1979 </span><span class="lineCov">       1180 :                         bitwise[7] = 0xc0;</span>
<span class="lineNum">    1980 </span><span class="lineCov">       1180 :                         return 0x0A00 | '0';</span>
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :                 case 'z':</span>
<span class="lineNum">    1983 </span>            :                 case 'Z':
<span class="lineNum">    1984 </span>            :                         /* 1..9 */
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :                         bitwise[6] = 0x7f;</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :                         bitwise[7] = 0xc0;</span>
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :                         return 0x0900 | '1';</span>
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span><span class="lineCov">        124 :                 case '.':</span>
<span class="lineNum">    1990 </span>            :                         /* wildcard */
<span class="lineNum">    1991 </span><span class="lineCov">        124 :                         return 0x18000;</span>
<span class="lineNum">    1992 </span>            : 
<span class="lineNum">    1993 </span><span class="lineCov">         17 :                 case '!':</span>
<span class="lineNum">    1994 </span>            :                         /* earlymatch */
<span class="lineNum">    1995 </span><span class="lineCov">         17 :                         return 0x28000; /* less specific than '.' */</span>
<span class="lineNum">    1996 </span>            : 
<span class="lineNum">    1997 </span><span class="lineCov">        706 :                 case '\0':</span>
<span class="lineNum">    1998 </span>            :                         /* empty string */
<span class="lineNum">    1999 </span><span class="lineCov">        706 :                         *p = NULL;</span>
<span class="lineNum">    2000 </span><span class="lineCov">        706 :                         return 0x30000;</span>
<span class="lineNum">    2001 </span>            : 
<span class="lineNum">    2002 </span><span class="lineCov">        420 :                 case '[':</span>
<span class="lineNum">    2003 </span>            :                         /* char set */
<span class="lineNum">    2004 </span><span class="lineCov">        420 :                         break;</span>
<span class="lineNum">    2005 </span>            :                 }
<span class="lineNum">    2006 </span>            :                 /* locate end of set */
<span class="lineNum">    2007 </span><span class="lineCov">        420 :                 end = strchr(*p, ']');</span>
<span class="lineNum">    2008 </span>            : 
<span class="lineNum">    2009 </span><span class="lineCov">        420 :                 if (!end) {</span>
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Wrong usage of [] in the extension\n&quot;);</span>
<span class="lineNum">    2011 </span><span class="lineNoCov">          0 :                         return 0x40000; /* XXX make this entry go last... */</span>
<span class="lineNum">    2012 </span>            :                 }
<span class="lineNum">    2013 </span>            : 
<span class="lineNum">    2014 </span><span class="lineCov">        420 :                 count = 0;</span>
<span class="lineNum">    2015 </span><span class="lineCov">        420 :                 cmin = 0xFF;</span>
<span class="lineNum">    2016 </span><span class="lineCov">        972 :                 for (; *p &lt; end; ++*p) {</span>
<span class="lineNum">    2017 </span>            :                         unsigned char c1;       /* first char in range */
<span class="lineNum">    2018 </span>            :                         unsigned char c2;       /* last char in range */
<span class="lineNum">    2019 </span>            : 
<span class="lineNum">    2020 </span><span class="lineCov">        552 :                         c1 = (*p)[0];</span>
<span class="lineNum">    2021 </span><span class="lineCov">        552 :                         if (*p + 2 &lt; end &amp;&amp; (*p)[1] == '-') { /* this is a range */</span>
<span class="lineNum">    2022 </span><span class="lineCov">         91 :                                 c2 = (*p)[2];</span>
<span class="lineNum">    2023 </span><span class="lineCov">         91 :                                 *p += 2;    /* skip a total of 3 chars */</span>
<span class="lineNum">    2024 </span>            :                         } else {        /* individual character */
<span class="lineNum">    2025 </span><span class="lineCov">        461 :                                 c2 = c1;</span>
<span class="lineNum">    2026 </span>            :                         }
<span class="lineNum">    2027 </span><span class="lineCov">        552 :                         if (c1 &lt; cmin) {</span>
<span class="lineNum">    2028 </span><span class="lineCov">        414 :                                 cmin = c1;</span>
<span class="lineNum">    2029 </span>            :                         }
<span class="lineNum">    2030 </span><span class="lineCov">       1639 :                         for (; c1 &lt;= c2; ++c1) {</span>
<span class="lineNum">    2031 </span><span class="lineCov">       1087 :                                 unsigned char mask = 1 &lt;&lt; ((BITS_PER - 1) - (c1 % BITS_PER));</span>
<span class="lineNum">    2032 </span>            : 
<span class="lineNum">    2033 </span>            :                                 /*
<span class="lineNum">    2034 </span>            :                                  * Note: If two character sets score the same, the one with the
<span class="lineNum">    2035 </span>            :                                  * lowest ASCII values will compare as coming first.  Must fill
<span class="lineNum">    2036 </span>            :                                  * in most significant bits for lower ASCII values to accomplish
<span class="lineNum">    2037 </span>            :                                  * the desired sort order.
<span class="lineNum">    2038 </span>            :                                  */
<span class="lineNum">    2039 </span><span class="lineCov">       1087 :                                 if (!(bitwise[c1 / BITS_PER] &amp; mask)) {</span>
<span class="lineNum">    2040 </span>            :                                         /* Add the character to the set. */
<span class="lineNum">    2041 </span><span class="lineCov">       1087 :                                         bitwise[c1 / BITS_PER] |= mask;</span>
<span class="lineNum">    2042 </span><span class="lineCov">       1087 :                                         count += 0x100;</span>
<span class="lineNum">    2043 </span>            :                                 }
<span class="lineNum">    2044 </span>            :                         }
<span class="lineNum">    2045 </span>            :                 }
<span class="lineNum">    2046 </span><span class="lineCov">        420 :                 ++*p;</span>
<span class="lineNum">    2047 </span><span class="lineCov">        420 :         } while (!count);/* While the char set was empty. */</span>
<span class="lineNum">    2048 </span><span class="lineCov">        414 :         return count | cmin;</span>
<span class="lineNum">    2049 </span>            : }
<span class="lineNum">    2050 </span>            : 
<span class="lineNum">    2051 </span>            : /*!
<span class="lineNum">    2052 </span>            :  * \internal
<span class="lineNum">    2053 </span>            :  * \brief Comparison of exten patterns.
<span class="lineNum">    2054 </span>            :  *
<span class="lineNum">    2055 </span>            :  * \param left Pattern to compare.
<span class="lineNum">    2056 </span>            :  * \param right Pattern to compare.
<span class="lineNum">    2057 </span>            :  *
<span class="lineNum">    2058 </span>            :  * \retval &lt;0 if left &lt; right
<span class="lineNum">    2059 </span>            :  * \retval =0 if left == right
<a name="2060"><span class="lineNum">    2060 </span>            :  * \retval &gt;0 if left &gt; right</a>
<span class="lineNum">    2061 </span>            :  */
<span class="lineNum">    2062 </span><span class="lineCov">       1992 : static int ext_cmp_pattern(const char *left, const char *right)</span>
<span class="lineNum">    2063 </span>            : {
<span class="lineNum">    2064 </span>            :         int cmp;
<span class="lineNum">    2065 </span>            :         int left_pos;
<span class="lineNum">    2066 </span>            :         int right_pos;
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span><span class="lineCov">       1306 :         for (;;) {</span>
<span class="lineNum">    2069 </span><span class="lineCov">       1992 :                 unsigned char left_bitwise[32] = { 0, };</span>
<span class="lineNum">    2070 </span><span class="lineCov">       1992 :                 unsigned char right_bitwise[32] = { 0, };</span>
<span class="lineNum">    2071 </span>            : 
<span class="lineNum">    2072 </span><span class="lineCov">       1992 :                 left_pos = ext_cmp_pattern_pos(&amp;left, left_bitwise);</span>
<span class="lineNum">    2073 </span><span class="lineCov">       1992 :                 right_pos = ext_cmp_pattern_pos(&amp;right, right_bitwise);</span>
<span class="lineNum">    2074 </span><span class="lineCov">       1992 :                 cmp = left_pos - right_pos;</span>
<span class="lineNum">    2075 </span><span class="lineCov">       1992 :                 if (!cmp) {</span>
<span class="lineNum">    2076 </span>            :                         /*
<span class="lineNum">    2077 </span>            :                          * Are the character sets different, even though they score the same?
<span class="lineNum">    2078 </span>            :                          *
<span class="lineNum">    2079 </span>            :                          * Note: Must swap left and right to get the sense of the
<span class="lineNum">    2080 </span>            :                          * comparison correct.  Otherwise, we would need to multiply by
<span class="lineNum">    2081 </span>            :                          * -1 instead.
<span class="lineNum">    2082 </span>            :                          */
<span class="lineNum">    2083 </span><span class="lineCov">       1662 :                         cmp = memcmp(right_bitwise, left_bitwise, ARRAY_LEN(left_bitwise));</span>
<span class="lineNum">    2084 </span>            :                 }
<span class="lineNum">    2085 </span><span class="lineCov">       1992 :                 if (cmp) {</span>
<span class="lineNum">    2086 </span><span class="lineCov">        334 :                         break;</span>
<span class="lineNum">    2087 </span>            :                 }
<span class="lineNum">    2088 </span><span class="lineCov">       1658 :                 if (!left) {</span>
<span class="lineNum">    2089 </span>            :                         /*
<span class="lineNum">    2090 </span>            :                          * Get here only if both patterns ended at the same time.  cmp
<span class="lineNum">    2091 </span>            :                          * would be non-zero if only one pattern ended.
<span class="lineNum">    2092 </span>            :                          */
<span class="lineNum">    2093 </span><span class="lineCov">        352 :                         break;</span>
<span class="lineNum">    2094 </span>            :                 }
<span class="lineNum">    2095 </span>            :         }
<span class="lineNum">    2096 </span><span class="lineCov">        686 :         return cmp;</span>
<span class="lineNum">    2097 </span>            : }
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span>            : /*!
<span class="lineNum">    2100 </span>            :  * \internal
<span class="lineNum">    2101 </span>            :  * \brief Comparison of dialplan extens for sorting purposes.
<span class="lineNum">    2102 </span>            :  *
<span class="lineNum">    2103 </span>            :  * \param left Exten/pattern to compare.
<span class="lineNum">    2104 </span>            :  * \param right Exten/pattern to compare.
<span class="lineNum">    2105 </span>            :  *
<span class="lineNum">    2106 </span>            :  * \retval &lt;0 if left &lt; right
<span class="lineNum">    2107 </span>            :  * \retval =0 if left == right
<a name="2108"><span class="lineNum">    2108 </span>            :  * \retval &gt;0 if left &gt; right</a>
<span class="lineNum">    2109 </span>            :  */
<span class="lineNum">    2110 </span><span class="lineCov">     296818 : static int ext_cmp(const char *left, const char *right)</span>
<span class="lineNum">    2111 </span>            : {
<span class="lineNum">    2112 </span>            :         /* Make sure non-pattern extens come first. */
<span class="lineNum">    2113 </span><span class="lineCov">     296818 :         if (left[0] != '_') {</span>
<span class="lineNum">    2114 </span><span class="lineCov">     296050 :                 if (right[0] == '_') {</span>
<span class="lineNum">    2115 </span><span class="lineCov">        618 :                         return -1;</span>
<span class="lineNum">    2116 </span>            :                 }
<span class="lineNum">    2117 </span>            :                 /* Compare two non-pattern extens. */
<span class="lineNum">    2118 </span><span class="lineCov">     295432 :                 return ext_cmp_exten(left, right);</span>
<span class="lineNum">    2119 </span>            :         }
<span class="lineNum">    2120 </span><span class="lineCov">        768 :         if (right[0] != '_') {</span>
<span class="lineNum">    2121 </span><span class="lineCov">         83 :                 return 1;</span>
<span class="lineNum">    2122 </span>            :         }
<span class="lineNum">    2123 </span>            : 
<span class="lineNum">    2124 </span>            :         /*
<span class="lineNum">    2125 </span>            :          * OK, we need full pattern sorting routine.
<span class="lineNum">    2126 </span>            :          *
<span class="lineNum">    2127 </span>            :          * Skip past the underscores
<span class="lineNum">    2128 </span>            :          */
<span class="lineNum">    2129 </span><span class="lineCov">        685 :         return ext_cmp_pattern(left + 1, right + 1);</span>
<a name="2130"><span class="lineNum">    2130 </span>            : }</a>
<span class="lineNum">    2131 </span>            : 
<span class="lineNum">    2132 </span><span class="lineCov">      71409 : static int ext_fluff_count(const char *exten)</span>
<span class="lineNum">    2133 </span>            : {
<span class="lineNum">    2134 </span><span class="lineCov">      71409 :         int fluff = 0;</span>
<span class="lineNum">    2135 </span>            : 
<span class="lineNum">    2136 </span><span class="lineCov">      71409 :         if (*exten != '_') {</span>
<span class="lineNum">    2137 </span>            :                 /* not a pattern, simple check. */
<span class="lineNum">    2138 </span><span class="lineCov">     570139 :                 while (*exten) {</span>
<span class="lineNum">    2139 </span><span class="lineCov">     499192 :                         if (*exten == '-') {</span>
<span class="lineNum">    2140 </span><span class="lineCov">        247 :                                 fluff++;</span>
<span class="lineNum">    2141 </span>            :                         }
<span class="lineNum">    2142 </span><span class="lineCov">     499192 :                         exten++;</span>
<span class="lineNum">    2143 </span>            :                 }
<span class="lineNum">    2144 </span>            : 
<span class="lineNum">    2145 </span><span class="lineCov">      70947 :                 return fluff;</span>
<span class="lineNum">    2146 </span>            :         }
<span class="lineNum">    2147 </span>            : 
<span class="lineNum">    2148 </span>            :         /* do pattern check */
<span class="lineNum">    2149 </span><span class="lineCov">       2500 :         while (*exten) {</span>
<span class="lineNum">    2150 </span><span class="lineCov">       2038 :                 if (*exten == '-') {</span>
<span class="lineNum">    2151 </span><span class="lineCov">         56 :                         fluff++;</span>
<span class="lineNum">    2152 </span><span class="lineCov">       1982 :                 } else if (*exten == '[') {</span>
<span class="lineNum">    2153 </span>            :                         /* skip set, dashes here matter. */
<span class="lineNum">    2154 </span><span class="lineCov">        135 :                         exten = strchr(exten, ']');</span>
<span class="lineNum">    2155 </span>            : 
<span class="lineNum">    2156 </span><span class="lineCov">        135 :                         if (!exten) {</span>
<span class="lineNum">    2157 </span>            :                                 /* we'll end up warning about this later, don't spam logs */
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :                                 return fluff;</span>
<span class="lineNum">    2159 </span>            :                         }
<span class="lineNum">    2160 </span>            :                 }
<span class="lineNum">    2161 </span><span class="lineCov">       2038 :                 exten++;</span>
<span class="lineNum">    2162 </span>            :         }
<span class="lineNum">    2163 </span>            : 
<span class="lineNum">    2164 </span><span class="lineCov">        462 :         return fluff;</span>
<a name="2165"><span class="lineNum">    2165 </span>            : }</a>
<span class="lineNum">    2166 </span>            : 
<span class="lineNum">    2167 </span><span class="lineCov">          4 : int ast_extension_cmp(const char *a, const char *b)</span>
<span class="lineNum">    2168 </span>            : {
<span class="lineNum">    2169 </span>            :         int cmp;
<span class="lineNum">    2170 </span>            : 
<span class="lineNum">    2171 </span><span class="lineCov">          4 :         cmp = ext_cmp(a, b);</span>
<span class="lineNum">    2172 </span><span class="lineCov">          4 :         if (cmp &lt; 0) {</span>
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2174 </span>            :         }
<span class="lineNum">    2175 </span><span class="lineCov">          4 :         if (cmp &gt; 0) {</span>
<span class="lineNum">    2176 </span><span class="lineCov">          4 :                 return 1;</span>
<span class="lineNum">    2177 </span>            :         }
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    2179 </span>            : }
<span class="lineNum">    2180 </span>            : 
<span class="lineNum">    2181 </span>            : /*!
<span class="lineNum">    2182 </span>            :  * \internal
<span class="lineNum">    2183 </span>            :  * \brief used ast_extension_{match|close}
<span class="lineNum">    2184 </span>            :  * mode is as follows:
<span class="lineNum">    2185 </span>            :  *      E_MATCH         success only on exact match
<span class="lineNum">    2186 </span>            :  *      E_MATCHMORE     success only on partial match (i.e. leftover digits in pattern)
<span class="lineNum">    2187 </span>            :  *      E_CANMATCH      either of the above.
<span class="lineNum">    2188 </span>            :  * \retval 0 on no-match
<span class="lineNum">    2189 </span>            :  * \retval 1 on match
<span class="lineNum">    2190 </span>            :  * \retval 2 on early match.
<a name="2191"><span class="lineNum">    2191 </span>            :  */</a>
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span><span class="lineCov">     333957 : static int _extension_match_core(const char *pattern, const char *data, enum ext_match_t mode)</span>
<span class="lineNum">    2194 </span>            : {
<span class="lineNum">    2195 </span><span class="lineCov">     333957 :         mode &amp;= E_MATCH_MASK;       /* only consider the relevant bits */</span>
<span class="lineNum">    2196 </span>            : 
<span class="lineNum">    2197 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2198 </span>            :         ast_log(LOG_NOTICE,&quot;match core: pat: '%s', dat: '%s', mode=%d\n&quot;, pattern, data, (int)mode);
<span class="lineNum">    2199 </span>            : #endif
<span class="lineNum">    2200 </span>            : 
<span class="lineNum">    2201 </span><span class="lineCov">     333957 :         if (pattern[0] != '_') { /* not a pattern, try exact or partial match */</span>
<span class="lineNum">    2202 </span><span class="lineCov">     330598 :                 int lp = ext_cmp_exten_strlen(pattern);</span>
<span class="lineNum">    2203 </span><span class="lineCov">     330598 :                 int ld = ext_cmp_exten_strlen(data);</span>
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span><span class="lineCov">     330598 :                 if (lp &lt; ld) {               /* pattern too short, cannot match */</span>
<span class="lineNum">    2206 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2207 </span>            :                         ast_log(LOG_NOTICE,&quot;return (0) - pattern too short, cannot match\n&quot;);
<span class="lineNum">    2208 </span>            : #endif
<span class="lineNum">    2209 </span><span class="lineCov">      20021 :                         return 0;</span>
<span class="lineNum">    2210 </span>            :                 }
<span class="lineNum">    2211 </span>            :                 /* depending on the mode, accept full or partial match or both */
<span class="lineNum">    2212 </span><span class="lineCov">     310577 :                 if (mode == E_MATCH) {</span>
<span class="lineNum">    2213 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2214 </span>            :                         ast_log(LOG_NOTICE,&quot;return (!ext_cmp_exten(%s,%s) when mode== E_MATCH)\n&quot;, pattern, data);
<span class="lineNum">    2215 </span>            : #endif
<span class="lineNum">    2216 </span><span class="lineCov">     308737 :                         return !ext_cmp_exten(pattern, data); /* 1 on match, 0 on fail */</span>
<span class="lineNum">    2217 </span>            :                 }
<span class="lineNum">    2218 </span><span class="lineCov">       1840 :                 if (ld == 0 || !ext_cmp_exten_partial(pattern, data)) { /* partial or full match */</span>
<span class="lineNum">    2219 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2220 </span>            :                         ast_log(LOG_NOTICE,&quot;return (mode(%d) == E_MATCHMORE ? lp(%d) &gt; ld(%d) : 1)\n&quot;, mode, lp, ld);
<span class="lineNum">    2221 </span>            : #endif
<span class="lineNum">    2222 </span><span class="lineCov">        289 :                         return (mode == E_MATCHMORE) ? lp &gt; ld : 1; /* XXX should consider '!' and '/' ? */</span>
<span class="lineNum">    2223 </span>            :                 } else {
<span class="lineNum">    2224 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2225 </span>            :                         ast_log(LOG_NOTICE,&quot;return (0) when ld(%d) &gt; 0 &amp;&amp; pattern(%s) != data(%s)\n&quot;, ld, pattern, data);
<span class="lineNum">    2226 </span>            : #endif
<span class="lineNum">    2227 </span><span class="lineCov">       1551 :                         return 0;</span>
<span class="lineNum">    2228 </span>            :                 }
<span class="lineNum">    2229 </span>            :         }
<span class="lineNum">    2230 </span><span class="lineCov">       3359 :         if (mode == E_MATCH &amp;&amp; data[0] == '_') {</span>
<span class="lineNum">    2231 </span>            :                 /*
<span class="lineNum">    2232 </span>            :                  * XXX It is bad design that we don't know if we should be
<span class="lineNum">    2233 </span>            :                  * comparing data and pattern as patterns or comparing data if
<span class="lineNum">    2234 </span>            :                  * it conforms to pattern when the function is called.  First,
<span class="lineNum">    2235 </span>            :                  * assume they are both patterns.  If they don't match then try
<span class="lineNum">    2236 </span>            :                  * to see if data conforms to the given pattern.
<span class="lineNum">    2237 </span>            :                  *
<span class="lineNum">    2238 </span>            :                  * note: if this test is left out, then _x. will not match _x. !!!
<span class="lineNum">    2239 </span>            :                  */
<span class="lineNum">    2240 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2241 </span>            :                 ast_log(LOG_NOTICE, &quot;Comparing as patterns first. pattern:%s data:%s\n&quot;, pattern, data);
<span class="lineNum">    2242 </span>            : #endif
<span class="lineNum">    2243 </span><span class="lineCov">          1 :                 if (!ext_cmp_pattern(pattern + 1, data + 1)) {</span>
<span class="lineNum">    2244 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2245 </span>            :                         ast_log(LOG_NOTICE,&quot;return (1) - pattern matches pattern\n&quot;);
<span class="lineNum">    2246 </span>            : #endif
<span class="lineNum">    2247 </span><span class="lineCov">          1 :                         return 1;</span>
<span class="lineNum">    2248 </span>            :                 }
<span class="lineNum">    2249 </span>            :         }
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span><span class="lineCov">       3358 :         ++pattern; /* skip leading _ */</span>
<span class="lineNum">    2252 </span>            :         /*
<span class="lineNum">    2253 </span>            :          * XXX below we stop at '/' which is a separator for the CID info. However we should
<span class="lineNum">    2254 </span>            :          * not store '/' in the pattern at all. When we insure it, we can remove the checks.
<span class="lineNum">    2255 </span>            :          */
<span class="lineNum">    2256 </span><span class="lineCov">       8626 :         for (;;) {</span>
<span class="lineNum">    2257 </span>            :                 const char *end;
<span class="lineNum">    2258 </span>            : 
<span class="lineNum">    2259 </span>            :                 /* Ignore '-' chars as eye candy fluff. */
<span class="lineNum">    2260 </span><span class="lineCov">      12084 :                 while (*data == '-') {</span>
<span class="lineNum">    2261 </span><span class="lineCov">        100 :                         ++data;</span>
<span class="lineNum">    2262 </span>            :                 }
<span class="lineNum">    2263 </span><span class="lineCov">      11984 :                 while (*pattern == '-') {</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :                         ++pattern;</span>
<span class="lineNum">    2265 </span>            :                 }
<span class="lineNum">    2266 </span><span class="lineCov">      11984 :                 if (!*data || !*pattern || *pattern == '/') {</span>
<span class="lineNum">    2267 </span>            :                         break;
<span class="lineNum">    2268 </span>            :                 }
<span class="lineNum">    2269 </span>            : 
<span class="lineNum">    2270 </span><span class="lineCov">       9886 :                 switch (*pattern) {</span>
<span class="lineNum">    2271 </span><span class="lineCov">        353 :                 case '[':       /* a range */</span>
<span class="lineNum">    2272 </span><span class="lineCov">        353 :                         ++pattern;</span>
<span class="lineNum">    2273 </span><span class="lineCov">        353 :                         end = strchr(pattern, ']'); /* XXX should deal with escapes ? */</span>
<span class="lineNum">    2274 </span><span class="lineCov">        353 :                         if (!end) {</span>
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;Wrong usage of [] in the extension\n&quot;);</span>
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :                                 return 0;       /* unconditional failure */</span>
<span class="lineNum">    2277 </span>            :                         }
<span class="lineNum">    2278 </span><span class="lineCov">        353 :                         if (pattern == end) {</span>
<span class="lineNum">    2279 </span>            :                                 /* Ignore empty character sets. */
<span class="lineNum">    2280 </span><span class="lineCov">          4 :                                 ++pattern;</span>
<span class="lineNum">    2281 </span><span class="lineCov">          4 :                                 continue;</span>
<span class="lineNum">    2282 </span>            :                         }
<span class="lineNum">    2283 </span><span class="lineCov">        517 :                         for (; pattern &lt; end; ++pattern) {</span>
<span class="lineNum">    2284 </span><span class="lineCov">        408 :                                 if (pattern+2 &lt; end &amp;&amp; pattern[1] == '-') { /* this is a range */</span>
<span class="lineNum">    2285 </span><span class="lineCov">         52 :                                         if (*data &gt;= pattern[0] &amp;&amp; *data &lt;= pattern[2])</span>
<span class="lineNum">    2286 </span>            :                                                 break;  /* match found */
<span class="lineNum">    2287 </span>            :                                         else {
<span class="lineNum">    2288 </span><span class="lineCov">          7 :                                                 pattern += 2; /* skip a total of 3 chars */</span>
<span class="lineNum">    2289 </span><span class="lineCov">          7 :                                                 continue;</span>
<span class="lineNum">    2290 </span>            :                                         }
<span class="lineNum">    2291 </span><span class="lineCov">        356 :                                 } else if (*data == pattern[0])</span>
<span class="lineNum">    2292 </span><span class="lineCov">        195 :                                         break;  /* match found */</span>
<span class="lineNum">    2293 </span>            :                         }
<span class="lineNum">    2294 </span><span class="lineCov">        349 :                         if (pattern &gt;= end) {</span>
<span class="lineNum">    2295 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2296 </span>            :                                 ast_log(LOG_NOTICE,&quot;return (0) when pattern&gt;=end\n&quot;);
<span class="lineNum">    2297 </span>            : #endif
<span class="lineNum">    2298 </span><span class="lineCov">        109 :                                 return 0;</span>
<span class="lineNum">    2299 </span>            :                         }
<span class="lineNum">    2300 </span><span class="lineCov">        240 :                         pattern = end;  /* skip and continue */</span>
<span class="lineNum">    2301 </span><span class="lineCov">        240 :                         break;</span>
<span class="lineNum">    2302 </span><span class="lineCov">          8 :                 case 'n':</span>
<span class="lineNum">    2303 </span>            :                 case 'N':
<span class="lineNum">    2304 </span><span class="lineCov">          8 :                         if (*data &lt; '2' || *data &gt; '9') {</span>
<span class="lineNum">    2305 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2306 </span>            :                                 ast_log(LOG_NOTICE,&quot;return (0) N is not matched\n&quot;);
<span class="lineNum">    2307 </span>            : #endif
<span class="lineNum">    2308 </span><span class="lineCov">          4 :                                 return 0;</span>
<span class="lineNum">    2309 </span>            :                         }
<span class="lineNum">    2310 </span><span class="lineCov">          4 :                         break;</span>
<span class="lineNum">    2311 </span><span class="lineCov">       7832 :                 case 'x':</span>
<span class="lineNum">    2312 </span>            :                 case 'X':
<span class="lineNum">    2313 </span><span class="lineCov">       7832 :                         if (*data &lt; '0' || *data &gt; '9') {</span>
<span class="lineNum">    2314 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2315 </span>            :                                 ast_log(LOG_NOTICE,&quot;return (0) X is not matched\n&quot;);
<span class="lineNum">    2316 </span>            : #endif
<span class="lineNum">    2317 </span><span class="lineCov">        226 :                                 return 0;</span>
<span class="lineNum">    2318 </span>            :                         }
<span class="lineNum">    2319 </span><span class="lineCov">       7606 :                         break;</span>
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :                 case 'z':</span>
<span class="lineNum">    2321 </span>            :                 case 'Z':
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :                         if (*data &lt; '1' || *data &gt; '9') {</span>
<span class="lineNum">    2323 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2324 </span>            :                                 ast_log(LOG_NOTICE,&quot;return (0) Z is not matched\n&quot;);
<span class="lineNum">    2325 </span>            : #endif
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :                                 return 0;</span>
<span class="lineNum">    2327 </span>            :                         }
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    2329 </span><span class="lineCov">        399 :                 case '.':       /* Must match, even with more digits */</span>
<span class="lineNum">    2330 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2331 </span>            :                         ast_log(LOG_NOTICE, &quot;return (1) when '.' is matched\n&quot;);
<span class="lineNum">    2332 </span>            : #endif
<span class="lineNum">    2333 </span><span class="lineCov">        399 :                         return 1;</span>
<span class="lineNum">    2334 </span><span class="lineCov">          8 :                 case '!':       /* Early match */</span>
<span class="lineNum">    2335 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2336 </span>            :                         ast_log(LOG_NOTICE, &quot;return (2) when '!' is matched\n&quot;);
<span class="lineNum">    2337 </span>            : #endif
<span class="lineNum">    2338 </span><span class="lineCov">          8 :                         return 2;</span>
<span class="lineNum">    2339 </span><span class="lineCov">       1286 :                 default:</span>
<span class="lineNum">    2340 </span><span class="lineCov">       1286 :                         if (*data != *pattern) {</span>
<span class="lineNum">    2341 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2342 </span>            :                                 ast_log(LOG_NOTICE, &quot;return (0) when *data(%c) != *pattern(%c)\n&quot;, *data, *pattern);
<span class="lineNum">    2343 </span>            : #endif
<span class="lineNum">    2344 </span><span class="lineCov">        514 :                                 return 0;</span>
<span class="lineNum">    2345 </span>            :                         }
<span class="lineNum">    2346 </span><span class="lineCov">        772 :                         break;</span>
<span class="lineNum">    2347 </span>            :                 }
<span class="lineNum">    2348 </span><span class="lineCov">       8622 :                 ++data;</span>
<span class="lineNum">    2349 </span><span class="lineCov">       8622 :                 ++pattern;</span>
<span class="lineNum">    2350 </span>            :         }
<span class="lineNum">    2351 </span><span class="lineCov">       2098 :         if (*data)                      /* data longer than pattern, no match */ {</span>
<span class="lineNum">    2352 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2353 </span>            :                 ast_log(LOG_NOTICE, &quot;return (0) when data longer than pattern\n&quot;);
<span class="lineNum">    2354 </span>            : #endif
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    2356 </span>            :         }
<span class="lineNum">    2357 </span>            : 
<span class="lineNum">    2358 </span>            :         /*
<span class="lineNum">    2359 </span>            :          * match so far, but ran off the end of data.
<span class="lineNum">    2360 </span>            :          * Depending on what is next, determine match or not.
<span class="lineNum">    2361 </span>            :          */
<span class="lineNum">    2362 </span><span class="lineCov">       2098 :         if (*pattern == '\0' || *pattern == '/') {      /* exact match */</span>
<span class="lineNum">    2363 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2364 </span>            :                 ast_log(LOG_NOTICE, &quot;at end, return (%d) in 'exact match'\n&quot;, (mode==E_MATCHMORE) ? 0 : 1);
<span class="lineNum">    2365 </span>            : #endif
<span class="lineNum">    2366 </span><span class="lineCov">       2061 :                 return (mode == E_MATCHMORE) ? 0 : 1;   /* this is a failure for E_MATCHMORE */</span>
<span class="lineNum">    2367 </span><span class="lineCov">         37 :         } else if (*pattern == '!')     {               /* early match */</span>
<span class="lineNum">    2368 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2369 </span>            :                 ast_log(LOG_NOTICE, &quot;at end, return (2) when '!' is matched\n&quot;);
<span class="lineNum">    2370 </span>            : #endif
<span class="lineNum">    2371 </span><span class="lineCov">          4 :                 return 2;</span>
<span class="lineNum">    2372 </span>            :         } else {                                                /* partial match */
<span class="lineNum">    2373 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2374 </span>            :                 ast_log(LOG_NOTICE, &quot;at end, return (%d) which deps on E_MATCH\n&quot;, (mode == E_MATCH) ? 0 : 1);
<span class="lineNum">    2375 </span>            : #endif
<span class="lineNum">    2376 </span><span class="lineCov">         33 :                 return (mode == E_MATCH) ? 0 : 1;       /* this is a failure for E_MATCH */</span>
<span class="lineNum">    2377 </span>            :         }
<span class="lineNum">    2378 </span>            : }
<span class="lineNum">    2379 </span>            : 
<span class="lineNum">    2380 </span>            : /*
<span class="lineNum">    2381 </span>            :  * Wrapper around _extension_match_core() to do performance measurement
<a name="2382"><span class="lineNum">    2382 </span>            :  * using the profiling code.</a>
<span class="lineNum">    2383 </span>            :  */
<span class="lineNum">    2384 </span><span class="lineCov">     333957 : static int extension_match_core(const char *pattern, const char *data, enum ext_match_t mode)</span>
<span class="lineNum">    2385 </span>            : {
<span class="lineNum">    2386 </span>            :         int i;
<span class="lineNum">    2387 </span>            :         static int prof_id = -2;        /* marker for 'unallocated' id */
<span class="lineNum">    2388 </span><span class="lineCov">     333957 :         if (prof_id == -2) {</span>
<span class="lineNum">    2389 </span><span class="lineCov">       1124 :                 prof_id = ast_add_profile(&quot;ext_match&quot;, 0);</span>
<span class="lineNum">    2390 </span>            :         }
<span class="lineNum">    2391 </span><span class="lineCov">     333957 :         ast_mark(prof_id, 1);</span>
<span class="lineNum">    2392 </span><span class="lineCov">     333957 :         i = _extension_match_core(ast_strlen_zero(pattern) ? &quot;&quot; : pattern, ast_strlen_zero(data) ? &quot;&quot; : data, mode);</span>
<span class="lineNum">    2393 </span><span class="lineCov">     333957 :         ast_mark(prof_id, 0);</span>
<span class="lineNum">    2394 </span><span class="lineCov">     333957 :         return i;</span>
<a name="2395"><span class="lineNum">    2395 </span>            : }</a>
<span class="lineNum">    2396 </span>            : 
<span class="lineNum">    2397 </span><span class="lineCov">       1194 : int ast_extension_match(const char *pattern, const char *data)</span>
<span class="lineNum">    2398 </span>            : {
<span class="lineNum">    2399 </span><span class="lineCov">       1194 :         return extension_match_core(pattern, data, E_MATCH);</span>
<a name="2400"><span class="lineNum">    2400 </span>            : }</a>
<span class="lineNum">    2401 </span>            : 
<span class="lineNum">    2402 </span><span class="lineCov">          9 : int ast_extension_close(const char *pattern, const char *data, int needmore)</span>
<span class="lineNum">    2403 </span>            : {
<span class="lineNum">    2404 </span><span class="lineCov">          9 :         if (needmore != E_MATCHMORE &amp;&amp; needmore != E_CANMATCH)</span>
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;invalid argument %d\n&quot;, needmore);</span>
<span class="lineNum">    2406 </span><span class="lineCov">          9 :         return extension_match_core(pattern, data, needmore);</span>
<span class="lineNum">    2407 </span>            : }
<span class="lineNum">    2408 </span>            : 
<span class="lineNum">    2409 </span>            : /* This structure must remain in sync with ast_context for proper hashtab matching */
<span class="lineNum">    2410 </span>            : struct fake_context /* this struct is purely for matching in the hashtab */
<span class="lineNum">    2411 </span>            : {
<span class="lineNum">    2412 </span>            :         ast_rwlock_t lock;
<span class="lineNum">    2413 </span>            :         struct ast_exten *root;
<span class="lineNum">    2414 </span>            :         struct ast_hashtab *root_table;
<span class="lineNum">    2415 </span>            :         struct match_char *pattern_tree;
<span class="lineNum">    2416 </span>            :         struct ast_context *next;
<span class="lineNum">    2417 </span>            :         struct ast_includes includes;
<span class="lineNum">    2418 </span>            :         struct ast_ignorepats ignorepats;
<span class="lineNum">    2419 </span>            :         struct ast_sws alts;
<span class="lineNum">    2420 </span>            :         const char *registrar;
<span class="lineNum">    2421 </span>            :         int refcount;
<span class="lineNum">    2422 </span>            :         int autohints;
<span class="lineNum">    2423 </span>            :         ast_mutex_t macrolock;
<span class="lineNum">    2424 </span>            :         char name[256];
<a name="2425"><span class="lineNum">    2425 </span>            : };</a>
<span class="lineNum">    2426 </span>            : 
<span class="lineNum">    2427 </span><span class="lineCov">       1812 : struct ast_context *ast_context_find(const char *name)</span>
<span class="lineNum">    2428 </span>            : {
<span class="lineNum">    2429 </span>            :         struct ast_context *tmp;
<span class="lineNum">    2430 </span>            :         struct fake_context item;
<span class="lineNum">    2431 </span>            : 
<span class="lineNum">    2432 </span><span class="lineCov">       1812 :         if (!name) {</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    2434 </span>            :         }
<span class="lineNum">    2435 </span><span class="lineCov">       1812 :         ast_rdlock_contexts();</span>
<span class="lineNum">    2436 </span><span class="lineCov">       1812 :         if (contexts_table) {</span>
<span class="lineNum">    2437 </span><span class="lineCov">       1812 :                 ast_copy_string(item.name, name, sizeof(item.name));</span>
<span class="lineNum">    2438 </span><span class="lineCov">       1812 :                 tmp = ast_hashtab_lookup(contexts_table, &amp;item);</span>
<span class="lineNum">    2439 </span>            :         } else {
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :                 tmp = NULL;</span>
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 :                 while ((tmp = ast_walk_contexts(tmp))) {</span>
<span class="lineNum">    2442 </span><span class="lineNoCov">          0 :                         if (!strcasecmp(name, tmp-&gt;name)) {</span>
<span class="lineNum">    2443 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    2444 </span>            :                         }
<span class="lineNum">    2445 </span>            :                 }
<span class="lineNum">    2446 </span>            :         }
<span class="lineNum">    2447 </span><span class="lineCov">       1812 :         ast_unlock_contexts();</span>
<span class="lineNum">    2448 </span><span class="lineCov">       1812 :         return tmp;</span>
<span class="lineNum">    2449 </span>            : }
<span class="lineNum">    2450 </span>            : 
<span class="lineNum">    2451 </span>            : #define STATUS_NO_CONTEXT       1
<span class="lineNum">    2452 </span>            : #define STATUS_NO_EXTENSION     2
<span class="lineNum">    2453 </span>            : #define STATUS_NO_PRIORITY      3
<span class="lineNum">    2454 </span>            : #define STATUS_NO_LABEL         4
<a name="2455"><span class="lineNum">    2455 </span>            : #define STATUS_SUCCESS          5</a>
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span><span class="lineCov">         69 : static int matchcid(const char *cidpattern, const char *callerid)</span>
<span class="lineNum">    2458 </span>            : {
<span class="lineNum">    2459 </span>            :         /* If the Caller*ID pattern is empty, then we're matching NO Caller*ID, so
<span class="lineNum">    2460 </span>            :            failing to get a number should count as a match, otherwise not */
<span class="lineNum">    2461 </span>            : 
<span class="lineNum">    2462 </span><span class="lineCov">         69 :         if (ast_strlen_zero(callerid)) {</span>
<span class="lineNum">    2463 </span><span class="lineCov">         21 :                 return ast_strlen_zero(cidpattern) ? 1 : 0;</span>
<span class="lineNum">    2464 </span>            :         }
<span class="lineNum">    2465 </span>            : 
<span class="lineNum">    2466 </span><span class="lineCov">         48 :         return ast_extension_match(cidpattern, callerid);</span>
<a name="2467"><span class="lineNum">    2467 </span>            : }</a>
<span class="lineNum">    2468 </span>            : 
<span class="lineNum">    2469 </span><span class="lineCov">      53755 : struct ast_exten *pbx_find_extension(struct ast_channel *chan,</span>
<span class="lineNum">    2470 </span>            :         struct ast_context *bypass, struct pbx_find_info *q,
<span class="lineNum">    2471 </span>            :         const char *context, const char *exten, int priority,
<span class="lineNum">    2472 </span>            :         const char *label, const char *callerid, enum ext_match_t action)
<span class="lineNum">    2473 </span>            : {
<span class="lineNum">    2474 </span>            :         int x, res;
<span class="lineNum">    2475 </span><span class="lineCov">      53755 :         struct ast_context *tmp = NULL;</span>
<span class="lineNum">    2476 </span><span class="lineCov">      53755 :         struct ast_exten *e = NULL, *eroot = NULL;</span>
<span class="lineNum">    2477 </span><span class="lineCov">      53755 :         struct ast_exten pattern = {NULL, };</span>
<span class="lineNum">    2478 </span><span class="lineCov">      53755 :         struct scoreboard score = {0, };</span>
<span class="lineNum">    2479 </span><span class="lineCov">      53755 :         struct ast_str *tmpdata = NULL;</span>
<span class="lineNum">    2480 </span>            :         int idx;
<span class="lineNum">    2481 </span>            : 
<span class="lineNum">    2482 </span><span class="lineCov">      53755 :         pattern.label = label;</span>
<span class="lineNum">    2483 </span><span class="lineCov">      53755 :         pattern.priority = priority;</span>
<span class="lineNum">    2484 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2485 </span>            :         ast_log(LOG_NOTICE, &quot;Looking for cont/ext/prio/label/action = %s/%s/%d/%s/%d\n&quot;, context, exten, priority, label, (int) action);
<span class="lineNum">    2486 </span>            : #endif
<span class="lineNum">    2487 </span>            : 
<span class="lineNum">    2488 </span>            :         /* Initialize status if appropriate */
<span class="lineNum">    2489 </span><span class="lineCov">      53755 :         if (q-&gt;stacklen == 0) {</span>
<span class="lineNum">    2490 </span><span class="lineCov">      53656 :                 q-&gt;status = STATUS_NO_CONTEXT;</span>
<span class="lineNum">    2491 </span><span class="lineCov">      53656 :                 q-&gt;swo = NULL;</span>
<span class="lineNum">    2492 </span><span class="lineCov">      53656 :                 q-&gt;data = NULL;</span>
<span class="lineNum">    2493 </span><span class="lineCov">      53656 :                 q-&gt;foundcontext = NULL;</span>
<span class="lineNum">    2494 </span><span class="lineCov">         99 :         } else if (q-&gt;stacklen &gt;= AST_PBX_MAX_STACK) {</span>
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Maximum PBX stack exceeded\n&quot;);</span>
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    2497 </span>            :         }
<span class="lineNum">    2498 </span>            : 
<span class="lineNum">    2499 </span>            :         /* Check first to see if we've already been checked */
<span class="lineNum">    2500 </span><span class="lineCov">      53888 :         for (x = 0; x &lt; q-&gt;stacklen; x++) {</span>
<span class="lineNum">    2501 </span><span class="lineCov">        133 :                 if (!strcasecmp(q-&gt;incstack[x], context))</span>
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">    2503 </span>            :         }
<span class="lineNum">    2504 </span>            : 
<span class="lineNum">    2505 </span><span class="lineCov">      53755 :         if (bypass) { /* bypass means we only look there */</span>
<span class="lineNum">    2506 </span><span class="lineCov">          2 :                 tmp = bypass;</span>
<span class="lineNum">    2507 </span>            :         } else {      /* look in contexts */
<span class="lineNum">    2508 </span><span class="lineCov">      53753 :                 tmp = find_context(context);</span>
<span class="lineNum">    2509 </span><span class="lineCov">      53753 :                 if (!tmp) {</span>
<span class="lineNum">    2510 </span><span class="lineCov">        188 :                         return NULL;</span>
<span class="lineNum">    2511 </span>            :                 }
<span class="lineNum">    2512 </span>            :         }
<span class="lineNum">    2513 </span>            : 
<span class="lineNum">    2514 </span><span class="lineCov">      53567 :         if (q-&gt;status &lt; STATUS_NO_EXTENSION)</span>
<span class="lineNum">    2515 </span><span class="lineCov">      53468 :                 q-&gt;status = STATUS_NO_EXTENSION;</span>
<span class="lineNum">    2516 </span>            : 
<span class="lineNum">    2517 </span>            :         /* Do a search for matching extension */
<span class="lineNum">    2518 </span>            : 
<span class="lineNum">    2519 </span><span class="lineCov">      53567 :         eroot = NULL;</span>
<span class="lineNum">    2520 </span><span class="lineCov">      53567 :         score.total_specificity = 0;</span>
<span class="lineNum">    2521 </span><span class="lineCov">      53567 :         score.exten = 0;</span>
<span class="lineNum">    2522 </span><span class="lineCov">      53567 :         score.total_length = 0;</span>
<span class="lineNum">    2523 </span><span class="lineCov">      53567 :         if (!tmp-&gt;pattern_tree &amp;&amp; tmp-&gt;root_table) {</span>
<span class="lineNum">    2524 </span><span class="lineCov">       2264 :                 create_match_char_tree(tmp);</span>
<span class="lineNum">    2525 </span>            : #ifdef NEED_DEBUG
<span class="lineNum">    2526 </span>            :                 ast_debug(1, &quot;Tree Created in context %s:\n&quot;, context);
<span class="lineNum">    2527 </span>            :                 log_match_char_tree(tmp-&gt;pattern_tree,&quot; &quot;);
<span class="lineNum">    2528 </span>            : #endif
<span class="lineNum">    2529 </span>            :         }
<span class="lineNum">    2530 </span>            : #ifdef NEED_DEBUG
<span class="lineNum">    2531 </span>            :         ast_log(LOG_NOTICE, &quot;The Trie we are searching in:\n&quot;);
<span class="lineNum">    2532 </span>            :         log_match_char_tree(tmp-&gt;pattern_tree, &quot;::  &quot;);
<span class="lineNum">    2533 </span>            : #endif
<span class="lineNum">    2534 </span>            : 
<span class="lineNum">    2535 </span>            :         do {
<span class="lineNum">    2536 </span><span class="lineCov">      53567 :                 if (!ast_strlen_zero(overrideswitch)) {</span>
<span class="lineNum">    2537 </span><span class="lineNoCov">          0 :                         char *osw = ast_strdupa(overrideswitch), *name;</span>
<span class="lineNum">    2538 </span>            :                         struct ast_switch *asw;
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 :                         ast_switch_f *aswf = NULL;</span>
<span class="lineNum">    2540 </span>            :                         char *datap;
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :                         int eval = 0;</span>
<span class="lineNum">    2542 </span>            : 
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :                         name = strsep(&amp;osw, &quot;/&quot;);</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :                         asw = pbx_findswitch(name);</span>
<span class="lineNum">    2545 </span>            : 
<span class="lineNum">    2546 </span><span class="lineNoCov">          0 :                         if (!asw) {</span>
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;No such switch '%s'\n&quot;, name);</span>
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    2549 </span>            :                         }
<span class="lineNum">    2550 </span>            : 
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :                         if (osw &amp;&amp; strchr(osw, '$')) {</span>
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :                                 eval = 1;</span>
<span class="lineNum">    2553 </span>            :                         }
<span class="lineNum">    2554 </span>            : 
<span class="lineNum">    2555 </span><span class="lineNoCov">          0 :                         if (eval &amp;&amp; !(tmpdata = ast_str_thread_get(&amp;switch_data, 512))) {</span>
<span class="lineNum">    2556 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;Can't evaluate overrideswitch?!\n&quot;);</span>
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 :                         } else if (eval) {</span>
<span class="lineNum">    2559 </span>            :                                 /* Substitute variables now */
<span class="lineNum">    2560 </span><span class="lineNoCov">          0 :                                 pbx_substitute_variables_helper(chan, osw, ast_str_buffer(tmpdata), ast_str_size(tmpdata));</span>
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :                                 datap = ast_str_buffer(tmpdata);</span>
<span class="lineNum">    2562 </span>            :                         } else {
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :                                 datap = osw;</span>
<span class="lineNum">    2564 </span>            :                         }
<span class="lineNum">    2565 </span>            : 
<span class="lineNum">    2566 </span>            :                         /* equivalent of extension_match_core() at the switch level */
<span class="lineNum">    2567 </span><span class="lineNoCov">          0 :                         if (action == E_CANMATCH)</span>
<span class="lineNum">    2568 </span><span class="lineNoCov">          0 :                                 aswf = asw-&gt;canmatch;</span>
<span class="lineNum">    2569 </span><span class="lineNoCov">          0 :                         else if (action == E_MATCHMORE)</span>
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 :                                 aswf = asw-&gt;matchmore;</span>
<span class="lineNum">    2571 </span>            :                         else /* action == E_MATCH */
<span class="lineNum">    2572 </span><span class="lineNoCov">          0 :                                 aswf = asw-&gt;exists;</span>
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :                         if (!aswf) {</span>
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :                                 res = 0;</span>
<span class="lineNum">    2575 </span>            :                         } else {
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :                                 if (chan) {</span>
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :                                         ast_autoservice_start(chan);</span>
<span class="lineNum">    2578 </span>            :                                 }
<span class="lineNum">    2579 </span><span class="lineNoCov">          0 :                                 res = aswf(chan, context, exten, priority, callerid, datap);</span>
<span class="lineNum">    2580 </span><span class="lineNoCov">          0 :                                 if (chan) {</span>
<span class="lineNum">    2581 </span><span class="lineNoCov">          0 :                                         ast_autoservice_stop(chan);</span>
<span class="lineNum">    2582 </span>            :                                 }
<span class="lineNum">    2583 </span>            :                         }
<span class="lineNum">    2584 </span><span class="lineNoCov">          0 :                         if (res) {      /* Got a match */</span>
<span class="lineNum">    2585 </span><span class="lineNoCov">          0 :                                 q-&gt;swo = asw;</span>
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :                                 q-&gt;data = datap;</span>
<span class="lineNum">    2587 </span><span class="lineNoCov">          0 :                                 q-&gt;foundcontext = context;</span>
<span class="lineNum">    2588 </span>            :                                 /* XXX keep status = STATUS_NO_CONTEXT ? */
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :                                 return NULL;</span>
<span class="lineNum">    2590 </span>            :                         }
<span class="lineNum">    2591 </span>            :                 }
<span class="lineNum">    2592 </span>            :         } while (0);
<span class="lineNum">    2593 </span>            : 
<span class="lineNum">    2594 </span><span class="lineCov">      53567 :         if (extenpatternmatchnew) {</span>
<span class="lineNum">    2595 </span><span class="lineCov">         66 :                 new_find_extension(exten, &amp;score, tmp-&gt;pattern_tree, 0, 0, callerid, label, action);</span>
<span class="lineNum">    2596 </span><span class="lineCov">         66 :                 eroot = score.exten;</span>
<span class="lineNum">    2597 </span>            : 
<span class="lineNum">    2598 </span><span class="lineCov">         66 :                 if (score.last_char == '!' &amp;&amp; action == E_MATCHMORE) {</span>
<span class="lineNum">    2599 </span>            :                         /* We match an extension ending in '!'.
<span class="lineNum">    2600 </span>            :                          * The decision in this case is final and is NULL (no match).
<span class="lineNum">    2601 </span>            :                          */
<span class="lineNum">    2602 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2603 </span>            :                         ast_log(LOG_NOTICE,&quot;Returning MATCHMORE NULL with exclamation point.\n&quot;);
<span class="lineNum">    2604 </span>            : #endif
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">    2606 </span>            :                 }
<span class="lineNum">    2607 </span>            : 
<span class="lineNum">    2608 </span><span class="lineCov">         66 :                 if (!eroot &amp;&amp; (action == E_CANMATCH || action == E_MATCHMORE) &amp;&amp; score.canmatch_exten) {</span>
<span class="lineNum">    2609 </span><span class="lineCov">          1 :                         q-&gt;status = STATUS_SUCCESS;</span>
<span class="lineNum">    2610 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2611 </span>            :                         ast_log(LOG_NOTICE,&quot;Returning CANMATCH exten %s\n&quot;, score.canmatch_exten-&gt;exten);
<span class="lineNum">    2612 </span>            : #endif
<span class="lineNum">    2613 </span><span class="lineCov">          1 :                         return score.canmatch_exten;</span>
<span class="lineNum">    2614 </span>            :                 }
<span class="lineNum">    2615 </span>            : 
<span class="lineNum">    2616 </span><span class="lineCov">         65 :                 if ((action == E_MATCHMORE || action == E_CANMATCH)  &amp;&amp; eroot) {</span>
<span class="lineNum">    2617 </span><span class="lineCov">          3 :                         if (score.node) {</span>
<span class="lineNum">    2618 </span><span class="lineCov">          3 :                                 struct ast_exten *z = trie_find_next_match(score.node);</span>
<span class="lineNum">    2619 </span><span class="lineCov">          3 :                                 if (z) {</span>
<span class="lineNum">    2620 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2621 </span>            :                                         ast_log(LOG_NOTICE,&quot;Returning CANMATCH/MATCHMORE next_match exten %s\n&quot;, z-&gt;exten);
<span class="lineNum">    2622 </span>            : #endif
<span class="lineNum">    2623 </span>            :                                 } else {
<span class="lineNum">    2624 </span><span class="lineNoCov">          0 :                                         if (score.canmatch_exten) {</span>
<span class="lineNum">    2625 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2626 </span>            :                                                 ast_log(LOG_NOTICE,&quot;Returning CANMATCH/MATCHMORE canmatchmatch exten %s(%p)\n&quot;, score.canmatch_exten-&gt;exten, score.canmatch_exten);
<span class="lineNum">    2627 </span>            : #endif
<span class="lineNum">    2628 </span><span class="lineNoCov">          0 :                                                 return score.canmatch_exten;</span>
<span class="lineNum">    2629 </span>            :                                         } else {
<span class="lineNum">    2630 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2631 </span>            :                                                 ast_log(LOG_NOTICE,&quot;Returning CANMATCH/MATCHMORE next_match exten NULL\n&quot;);
<span class="lineNum">    2632 </span>            : #endif
<span class="lineNum">    2633 </span>            :                                         }
<span class="lineNum">    2634 </span>            :                                 }
<span class="lineNum">    2635 </span><span class="lineCov">          3 :                                 return z;</span>
<span class="lineNum">    2636 </span>            :                         }
<span class="lineNum">    2637 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2638 </span>            :                         ast_log(LOG_NOTICE, &quot;Returning CANMATCH/MATCHMORE NULL (no next_match)\n&quot;);
<span class="lineNum">    2639 </span>            : #endif
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 :                         return NULL;  /* according to the code, complete matches are null matches in MATCHMORE mode */</span>
<span class="lineNum">    2641 </span>            :                 }
<span class="lineNum">    2642 </span>            : 
<span class="lineNum">    2643 </span><span class="lineCov">         62 :                 if (eroot) {</span>
<span class="lineNum">    2644 </span>            :                         /* found entry, now look for the right priority */
<span class="lineNum">    2645 </span><span class="lineCov">         13 :                         if (q-&gt;status &lt; STATUS_NO_PRIORITY)</span>
<span class="lineNum">    2646 </span><span class="lineCov">         12 :                                 q-&gt;status = STATUS_NO_PRIORITY;</span>
<span class="lineNum">    2647 </span><span class="lineCov">         13 :                         e = NULL;</span>
<span class="lineNum">    2648 </span><span class="lineCov">         13 :                         if (action == E_FINDLABEL &amp;&amp; label ) {</span>
<span class="lineNum">    2649 </span><span class="lineNoCov">          0 :                                 if (q-&gt;status &lt; STATUS_NO_LABEL)</span>
<span class="lineNum">    2650 </span><span class="lineNoCov">          0 :                                         q-&gt;status = STATUS_NO_LABEL;</span>
<span class="lineNum">    2651 </span><span class="lineNoCov">          0 :                                 e = ast_hashtab_lookup(eroot-&gt;peer_label_table, &amp;pattern);</span>
<span class="lineNum">    2652 </span>            :                         } else {
<span class="lineNum">    2653 </span><span class="lineCov">         13 :                                 e = ast_hashtab_lookup(eroot-&gt;peer_table, &amp;pattern);</span>
<span class="lineNum">    2654 </span>            :                         }
<span class="lineNum">    2655 </span><span class="lineCov">         13 :                         if (e) {        /* found a valid match */</span>
<span class="lineNum">    2656 </span><span class="lineCov">         12 :                                 q-&gt;status = STATUS_SUCCESS;</span>
<span class="lineNum">    2657 </span><span class="lineCov">         12 :                                 q-&gt;foundcontext = context;</span>
<span class="lineNum">    2658 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2659 </span>            :                                 ast_log(LOG_NOTICE,&quot;Returning complete match of exten %s\n&quot;, e-&gt;exten);
<span class="lineNum">    2660 </span>            : #endif
<span class="lineNum">    2661 </span><span class="lineCov">         12 :                                 return e;</span>
<span class="lineNum">    2662 </span>            :                         }
<span class="lineNum">    2663 </span>            :                 }
<span class="lineNum">    2664 </span>            :         } else {   /* the old/current default exten pattern match algorithm */
<span class="lineNum">    2665 </span>            : 
<span class="lineNum">    2666 </span>            :                 /* scan the list trying to match extension and CID */
<span class="lineNum">    2667 </span><span class="lineCov">      53501 :                 eroot = NULL;</span>
<span class="lineNum">    2668 </span><span class="lineCov">     361061 :                 while ( (eroot = ast_walk_context_extensions(tmp, eroot)) ) {</span>
<span class="lineNum">    2669 </span><span class="lineCov">     332754 :                         int match = extension_match_core(eroot-&gt;exten, exten, action);</span>
<span class="lineNum">    2670 </span>            :                         /* 0 on fail, 1 on match, 2 on earlymatch */
<span class="lineNum">    2671 </span>            : 
<span class="lineNum">    2672 </span><span class="lineCov">     332754 :                         if (!match || (eroot-&gt;matchcid &amp;&amp; !matchcid(eroot-&gt;cidmatch, callerid)))</span>
<span class="lineNum">    2673 </span><span class="lineCov">     306103 :                                 continue;       /* keep trying */</span>
<span class="lineNum">    2674 </span><span class="lineCov">      26651 :                         if (match == 2 &amp;&amp; action == E_MATCHMORE) {</span>
<span class="lineNum">    2675 </span>            :                                 /* We match an extension ending in '!'.
<span class="lineNum">    2676 </span>            :                                  * The decision in this case is final and is NULL (no match).
<span class="lineNum">    2677 </span>            :                                  */
<span class="lineNum">    2678 </span><span class="lineNoCov">          0 :                                 return NULL;</span>
<span class="lineNum">    2679 </span>            :                         }
<span class="lineNum">    2680 </span>            :                         /* found entry, now look for the right priority */
<span class="lineNum">    2681 </span><span class="lineCov">      26651 :                         if (q-&gt;status &lt; STATUS_NO_PRIORITY)</span>
<span class="lineNum">    2682 </span><span class="lineCov">      26528 :                                 q-&gt;status = STATUS_NO_PRIORITY;</span>
<span class="lineNum">    2683 </span><span class="lineCov">      26651 :                         e = NULL;</span>
<span class="lineNum">    2684 </span><span class="lineCov">      26651 :                         if (action == E_FINDLABEL &amp;&amp; label ) {</span>
<span class="lineNum">    2685 </span><span class="lineCov">        777 :                                 if (q-&gt;status &lt; STATUS_NO_LABEL)</span>
<span class="lineNum">    2686 </span><span class="lineCov">        777 :                                         q-&gt;status = STATUS_NO_LABEL;</span>
<span class="lineNum">    2687 </span><span class="lineCov">        777 :                                 e = ast_hashtab_lookup(eroot-&gt;peer_label_table, &amp;pattern);</span>
<span class="lineNum">    2688 </span>            :                         } else {
<span class="lineNum">    2689 </span><span class="lineCov">      25874 :                                 e = ast_hashtab_lookup(eroot-&gt;peer_table, &amp;pattern);</span>
<span class="lineNum">    2690 </span>            :                         }
<span class="lineNum">    2691 </span><span class="lineCov">      26651 :                         if (e) {        /* found a valid match */</span>
<span class="lineNum">    2692 </span><span class="lineCov">      25194 :                                 q-&gt;status = STATUS_SUCCESS;</span>
<span class="lineNum">    2693 </span><span class="lineCov">      25194 :                                 q-&gt;foundcontext = context;</span>
<span class="lineNum">    2694 </span><span class="lineCov">      25194 :                                 return e;</span>
<span class="lineNum">    2695 </span>            :                         }
<span class="lineNum">    2696 </span>            :                 }
<span class="lineNum">    2697 </span>            :         }
<span class="lineNum">    2698 </span>            : 
<span class="lineNum">    2699 </span>            :         /* Check alternative switches */
<span class="lineNum">    2700 </span><span class="lineCov">      28359 :         for (idx = 0; idx &lt; ast_context_switches_count(tmp); idx++) {</span>
<span class="lineNum">    2701 </span><span class="lineCov">         13 :                 const struct ast_sw *sw = ast_context_switches_get(tmp, idx);</span>
<span class="lineNum">    2702 </span><span class="lineCov">         13 :                 struct ast_switch *asw = pbx_findswitch(ast_get_switch_name(sw));</span>
<span class="lineNum">    2703 </span><span class="lineCov">         13 :                 ast_switch_f *aswf = NULL;</span>
<span class="lineNum">    2704 </span>            :                 const char *datap;
<span class="lineNum">    2705 </span>            : 
<span class="lineNum">    2706 </span><span class="lineCov">         13 :                 if (!asw) {</span>
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;No such switch '%s'\n&quot;, ast_get_switch_name(sw));</span>
<span class="lineNum">    2708 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    2709 </span>            :                 }
<span class="lineNum">    2710 </span>            : 
<span class="lineNum">    2711 </span>            :                 /* Substitute variables now */
<span class="lineNum">    2712 </span><span class="lineCov">         13 :                 if (ast_get_switch_eval(sw)) {</span>
<span class="lineNum">    2713 </span><span class="lineNoCov">          0 :                         if (!(tmpdata = ast_str_thread_get(&amp;switch_data, 512))) {</span>
<span class="lineNum">    2714 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;Can't evaluate switch?!\n&quot;);</span>
<span class="lineNum">    2715 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    2716 </span>            :                         }
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :                         pbx_substitute_variables_helper(chan, ast_get_switch_data(sw),</span>
<span class="lineNum">    2718 </span><span class="lineNoCov">          0 :                                 ast_str_buffer(tmpdata), ast_str_size(tmpdata));</span>
<span class="lineNum">    2719 </span><span class="lineNoCov">          0 :                         datap = ast_str_buffer(tmpdata);</span>
<span class="lineNum">    2720 </span>            :                 } else {
<span class="lineNum">    2721 </span><span class="lineCov">         13 :                         datap = ast_get_switch_data(sw);</span>
<span class="lineNum">    2722 </span>            :                 }
<span class="lineNum">    2723 </span>            : 
<span class="lineNum">    2724 </span>            :                 /* equivalent of extension_match_core() at the switch level */
<span class="lineNum">    2725 </span><span class="lineCov">         13 :                 if (action == E_CANMATCH)</span>
<span class="lineNum">    2726 </span><span class="lineCov">          1 :                         aswf = asw-&gt;canmatch;</span>
<span class="lineNum">    2727 </span><span class="lineCov">         12 :                 else if (action == E_MATCHMORE)</span>
<span class="lineNum">    2728 </span><span class="lineCov">          6 :                         aswf = asw-&gt;matchmore;</span>
<span class="lineNum">    2729 </span>            :                 else /* action == E_MATCH */
<span class="lineNum">    2730 </span><span class="lineCov">          6 :                         aswf = asw-&gt;exists;</span>
<span class="lineNum">    2731 </span><span class="lineCov">         13 :                 if (!aswf)</span>
<span class="lineNum">    2732 </span><span class="lineNoCov">          0 :                         res = 0;</span>
<span class="lineNum">    2733 </span>            :                 else {
<span class="lineNum">    2734 </span><span class="lineCov">         13 :                         if (chan)</span>
<span class="lineNum">    2735 </span><span class="lineCov">         11 :                                 ast_autoservice_start(chan);</span>
<span class="lineNum">    2736 </span><span class="lineCov">         13 :                         res = aswf(chan, context, exten, priority, callerid, datap);</span>
<span class="lineNum">    2737 </span><span class="lineCov">         13 :                         if (chan)</span>
<span class="lineNum">    2738 </span><span class="lineCov">         11 :                                 ast_autoservice_stop(chan);</span>
<span class="lineNum">    2739 </span>            :                 }
<span class="lineNum">    2740 </span><span class="lineCov">         13 :                 if (res) {      /* Got a match */</span>
<span class="lineNum">    2741 </span><span class="lineCov">         11 :                         q-&gt;swo = asw;</span>
<span class="lineNum">    2742 </span><span class="lineCov">         11 :                         q-&gt;data = datap;</span>
<span class="lineNum">    2743 </span><span class="lineCov">         11 :                         q-&gt;foundcontext = context;</span>
<span class="lineNum">    2744 </span>            :                         /* XXX keep status = STATUS_NO_CONTEXT ? */
<span class="lineNum">    2745 </span><span class="lineCov">         11 :                         return NULL;</span>
<span class="lineNum">    2746 </span>            :                 }
<span class="lineNum">    2747 </span>            :         }
<span class="lineNum">    2748 </span><span class="lineCov">      28346 :         q-&gt;incstack[q-&gt;stacklen++] = tmp-&gt;name;        /* Setup the stack */</span>
<span class="lineNum">    2749 </span>            :         /* Now try any includes we have in this context */
<span class="lineNum">    2750 </span><span class="lineCov">      28421 :         for (idx = 0; idx &lt; ast_context_includes_count(tmp); idx++) {</span>
<span class="lineNum">    2751 </span><span class="lineCov">         99 :                 const struct ast_include *i = ast_context_includes_get(tmp, idx);</span>
<span class="lineNum">    2752 </span>            : 
<span class="lineNum">    2753 </span><span class="lineCov">         99 :                 if (include_valid(i)) {</span>
<span class="lineNum">    2754 </span><span class="lineCov">         99 :                         if ((e = pbx_find_extension(chan, bypass, q, include_rname(i), exten, priority, label, callerid, action))) {</span>
<span class="lineNum">    2755 </span>            : #ifdef NEED_DEBUG_HERE
<span class="lineNum">    2756 </span>            :                                 ast_log(LOG_NOTICE,&quot;Returning recursive match of %s\n&quot;, e-&gt;exten);
<span class="lineNum">    2757 </span>            : #endif
<span class="lineNum">    2758 </span><span class="lineCov">         24 :                                 return e;</span>
<span class="lineNum">    2759 </span>            :                         }
<span class="lineNum">    2760 </span><span class="lineCov">         75 :                         if (q-&gt;swo)</span>
<span class="lineNum">    2761 </span><span class="lineNoCov">          0 :                                 return NULL;</span>
<span class="lineNum">    2762 </span>            :                 }
<span class="lineNum">    2763 </span>            :         }
<span class="lineNum">    2764 </span><span class="lineCov">      28322 :         return NULL;</span>
<a name="2765"><span class="lineNum">    2765 </span>            : }</a>
<span class="lineNum">    2766 </span>            : 
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 : static void exception_store_free(void *data)</span>
<span class="lineNum">    2768 </span>            : {
<span class="lineNum">    2769 </span><span class="lineNoCov">          0 :         struct pbx_exception *exception = data;</span>
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :         ast_string_field_free_memory(exception);</span>
<span class="lineNum">    2771 </span><span class="lineNoCov">          0 :         ast_free(exception);</span>
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2773 </span>            : 
<span class="lineNum">    2774 </span>            : static const struct ast_datastore_info exception_store_info = {
<span class="lineNum">    2775 </span>            :         .type = &quot;EXCEPTION&quot;,
<span class="lineNum">    2776 </span>            :         .destroy = exception_store_free,
<span class="lineNum">    2777 </span>            : };
<span class="lineNum">    2778 </span>            : 
<span class="lineNum">    2779 </span>            : /*!
<span class="lineNum">    2780 </span>            :  * \internal
<span class="lineNum">    2781 </span>            :  * \brief Set the PBX to execute the exception extension.
<span class="lineNum">    2782 </span>            :  *
<span class="lineNum">    2783 </span>            :  * \param chan Channel to raise the exception on.
<span class="lineNum">    2784 </span>            :  * \param reason Reason exception is raised.
<span class="lineNum">    2785 </span>            :  * \param priority Dialplan priority to set.
<span class="lineNum">    2786 </span>            :  *
<span class="lineNum">    2787 </span>            :  * \retval 0 on success.
<a name="2788"><span class="lineNum">    2788 </span>            :  * \retval -1 on error.</a>
<span class="lineNum">    2789 </span>            :  */
<span class="lineNum">    2790 </span><span class="lineNoCov">          0 : int raise_exception(struct ast_channel *chan, const char *reason, int priority)</span>
<span class="lineNum">    2791 </span>            : {
<span class="lineNum">    2792 </span><span class="lineNoCov">          0 :         struct ast_datastore *ds = ast_channel_datastore_find(chan, &amp;exception_store_info, NULL);</span>
<span class="lineNum">    2793 </span><span class="lineNoCov">          0 :         struct pbx_exception *exception = NULL;</span>
<span class="lineNum">    2794 </span>            : 
<span class="lineNum">    2795 </span><span class="lineNoCov">          0 :         if (!ds) {</span>
<span class="lineNum">    2796 </span><span class="lineNoCov">          0 :                 ds = ast_datastore_alloc(&amp;exception_store_info, NULL);</span>
<span class="lineNum">    2797 </span><span class="lineNoCov">          0 :                 if (!ds)</span>
<span class="lineNum">    2798 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    2799 </span><span class="lineNoCov">          0 :                 if (!(exception = ast_calloc_with_stringfields(1, struct pbx_exception, 128))) {</span>
<span class="lineNum">    2800 </span><span class="lineNoCov">          0 :                         ast_datastore_free(ds);</span>
<span class="lineNum">    2801 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    2802 </span>            :                 }
<span class="lineNum">    2803 </span><span class="lineNoCov">          0 :                 ds-&gt;data = exception;</span>
<span class="lineNum">    2804 </span><span class="lineNoCov">          0 :                 ast_channel_datastore_add(chan, ds);</span>
<span class="lineNum">    2805 </span>            :         } else
<span class="lineNum">    2806 </span><span class="lineNoCov">          0 :                 exception = ds-&gt;data;</span>
<span class="lineNum">    2807 </span>            : 
<span class="lineNum">    2808 </span><span class="lineNoCov">          0 :         ast_string_field_set(exception, reason, reason);</span>
<span class="lineNum">    2809 </span><span class="lineNoCov">          0 :         ast_string_field_set(exception, context, ast_channel_context(chan));</span>
<span class="lineNum">    2810 </span><span class="lineNoCov">          0 :         ast_string_field_set(exception, exten, ast_channel_exten(chan));</span>
<span class="lineNum">    2811 </span><span class="lineNoCov">          0 :         exception-&gt;priority = ast_channel_priority(chan);</span>
<span class="lineNum">    2812 </span><span class="lineNoCov">          0 :         set_ext_pri(chan, &quot;e&quot;, priority);</span>
<span class="lineNum">    2813 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="2814"><span class="lineNum">    2814 </span>            : }</a>
<span class="lineNum">    2815 </span>            : 
<span class="lineNum">    2816 </span><span class="lineNoCov">          0 : static int acf_exception_read(struct ast_channel *chan, const char *name, char *data, char *buf, size_t buflen)</span>
<span class="lineNum">    2817 </span>            : {
<span class="lineNum">    2818 </span><span class="lineNoCov">          0 :         struct ast_datastore *ds = ast_channel_datastore_find(chan, &amp;exception_store_info, NULL);</span>
<span class="lineNum">    2819 </span><span class="lineNoCov">          0 :         struct pbx_exception *exception = NULL;</span>
<span class="lineNum">    2820 </span><span class="lineNoCov">          0 :         if (!ds || !ds-&gt;data)</span>
<span class="lineNum">    2821 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2822 </span><span class="lineNoCov">          0 :         exception = ds-&gt;data;</span>
<span class="lineNum">    2823 </span><span class="lineNoCov">          0 :         if (!strcasecmp(data, &quot;REASON&quot;))</span>
<span class="lineNum">    2824 </span><span class="lineNoCov">          0 :                 ast_copy_string(buf, exception-&gt;reason, buflen);</span>
<span class="lineNum">    2825 </span><span class="lineNoCov">          0 :         else if (!strcasecmp(data, &quot;CONTEXT&quot;))</span>
<span class="lineNum">    2826 </span><span class="lineNoCov">          0 :                 ast_copy_string(buf, exception-&gt;context, buflen);</span>
<span class="lineNum">    2827 </span><span class="lineNoCov">          0 :         else if (!strncasecmp(data, &quot;EXTEN&quot;, 5))</span>
<span class="lineNum">    2828 </span><span class="lineNoCov">          0 :                 ast_copy_string(buf, exception-&gt;exten, buflen);</span>
<span class="lineNum">    2829 </span><span class="lineNoCov">          0 :         else if (!strcasecmp(data, &quot;PRIORITY&quot;))</span>
<span class="lineNum">    2830 </span><span class="lineNoCov">          0 :                 snprintf(buf, buflen, &quot;%d&quot;, exception-&gt;priority);</span>
<span class="lineNum">    2831 </span>            :         else
<span class="lineNum">    2832 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2833 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    2834 </span>            : }
<span class="lineNum">    2835 </span>            : 
<span class="lineNum">    2836 </span>            : static struct ast_custom_function exception_function = {
<span class="lineNum">    2837 </span>            :         .name = &quot;EXCEPTION&quot;,
<span class="lineNum">    2838 </span>            :         .read = acf_exception_read,
<span class="lineNum">    2839 </span>            : };
<span class="lineNum">    2840 </span>            : 
<span class="lineNum">    2841 </span>            : /*!
<span class="lineNum">    2842 </span>            :  * \brief The return value depends on the action:
<span class="lineNum">    2843 </span>            :  *
<span class="lineNum">    2844 </span>            :  * E_MATCH, E_CANMATCH, E_MATCHMORE require a real match,
<span class="lineNum">    2845 </span>            :  *      and return 0 on failure, -1 on match;
<span class="lineNum">    2846 </span>            :  * E_FINDLABEL maps the label to a priority, and returns
<span class="lineNum">    2847 </span>            :  *      the priority on success, ... XXX
<span class="lineNum">    2848 </span>            :  * E_SPAWN, spawn an application,
<span class="lineNum">    2849 </span>            :  *
<span class="lineNum">    2850 </span>            :  * \retval 0 on success.
<span class="lineNum">    2851 </span>            :  * \retval  -1 on failure.
<span class="lineNum">    2852 </span>            :  *
<span class="lineNum">    2853 </span>            :  * \note The channel is auto-serviced in this function, because doing an extension
<span class="lineNum">    2854 </span>            :  * match may block for a long time.  For example, if the lookup has to use a network
<span class="lineNum">    2855 </span>            :  * dialplan switch, such as DUNDi or IAX2, it may take a while.  However, the channel
<span class="lineNum">    2856 </span>            :  * auto-service code will queue up any important signalling frames to be processed
<a name="2857"><span class="lineNum">    2857 </span>            :  * after this is done.</a>
<span class="lineNum">    2858 </span>            :  */
<span class="lineNum">    2859 </span><span class="lineCov">      28321 : static int pbx_extension_helper(struct ast_channel *c, struct ast_context *con,</span>
<span class="lineNum">    2860 </span>            :   const char *context, const char *exten, int priority,
<span class="lineNum">    2861 </span>            :   const char *label, const char *callerid, enum ext_match_t action, int *found, int combined_find_spawn)
<span class="lineNum">    2862 </span>            : {
<span class="lineNum">    2863 </span>            :         struct ast_exten *e;
<span class="lineNum">    2864 </span>            :         struct ast_app *app;
<span class="lineNum">    2865 </span><span class="lineCov">      28321 :         char *substitute = NULL;</span>
<span class="lineNum">    2866 </span><span class="lineCov">      28321 :         struct pbx_find_info q = { .stacklen = 0 }; /* the rest is reset in pbx_find_extension */</span>
<span class="lineNum">    2867 </span>            :         char passdata[EXT_DATA_SIZE];
<span class="lineNum">    2868 </span><span class="lineCov">      28321 :         int matching_action = (action == E_MATCH || action == E_CANMATCH || action == E_MATCHMORE);</span>
<span class="lineNum">    2869 </span>            : 
<span class="lineNum">    2870 </span><span class="lineCov">      28321 :         ast_rdlock_contexts();</span>
<span class="lineNum">    2871 </span><span class="lineCov">      28321 :         if (found)</span>
<span class="lineNum">    2872 </span><span class="lineCov">      17493 :                 *found = 0;</span>
<span class="lineNum">    2873 </span>            : 
<span class="lineNum">    2874 </span><span class="lineCov">      28321 :         e = pbx_find_extension(c, con, &amp;q, context, exten, priority, label, callerid, action);</span>
<span class="lineNum">    2875 </span><span class="lineCov">      28321 :         if (e) {</span>
<span class="lineNum">    2876 </span><span class="lineCov">      24574 :                 if (found)</span>
<span class="lineNum">    2877 </span><span class="lineCov">      16921 :                         *found = 1;</span>
<span class="lineNum">    2878 </span><span class="lineCov">      24574 :                 if (matching_action) {</span>
<span class="lineNum">    2879 </span><span class="lineCov">       6878 :                         ast_unlock_contexts();</span>
<span class="lineNum">    2880 </span><span class="lineCov">       6878 :                         return -1;      /* success, we found it */</span>
<span class="lineNum">    2881 </span><span class="lineCov">      17696 :                 } else if (action == E_FINDLABEL) { /* map the label to a priority */</span>
<span class="lineNum">    2882 </span><span class="lineCov">        775 :                         int res = e-&gt;priority;</span>
<span class="lineNum">    2883 </span>            : 
<span class="lineNum">    2884 </span><span class="lineCov">        775 :                         ast_unlock_contexts();</span>
<span class="lineNum">    2885 </span>            : 
<span class="lineNum">    2886 </span>            :                         /* the priority we were looking for */
<span class="lineNum">    2887 </span><span class="lineCov">        775 :                         return res;</span>
<span class="lineNum">    2888 </span>            :                 } else {        /* spawn */
<span class="lineNum">    2889 </span><span class="lineCov">      16921 :                         if (!e-&gt;cached_app)</span>
<span class="lineNum">    2890 </span><span class="lineCov">       6925 :                                 e-&gt;cached_app = pbx_findapp(e-&gt;app);</span>
<span class="lineNum">    2891 </span><span class="lineCov">      16921 :                         app = e-&gt;cached_app;</span>
<span class="lineNum">    2892 </span><span class="lineCov">      16921 :                         if (ast_strlen_zero(e-&gt;data)) {</span>
<span class="lineNum">    2893 </span><span class="lineCov">       6318 :                                 *passdata = '\0';</span>
<span class="lineNum">    2894 </span>            :                         } else {
<span class="lineNum">    2895 </span>            :                                 const char *tmp;
<span class="lineNum">    2896 </span><span class="lineCov">      10603 :                                 if ((!(tmp = strchr(e-&gt;data, '$'))) || (!strstr(tmp, &quot;${&quot;) &amp;&amp; !strstr(tmp, &quot;$[&quot;))) {</span>
<span class="lineNum">    2897 </span>            :                                         /* no variables to substitute, copy on through */
<span class="lineNum">    2898 </span><span class="lineCov">       4507 :                                         ast_copy_string(passdata, e-&gt;data, sizeof(passdata));</span>
<span class="lineNum">    2899 </span>            :                                 } else {
<span class="lineNum">    2900 </span>            :                                         /* save e-&gt;data on stack for later processing after lock released */
<span class="lineNum">    2901 </span><span class="lineCov">       6096 :                                         substitute = ast_strdupa(e-&gt;data);</span>
<span class="lineNum">    2902 </span>            :                                 }
<span class="lineNum">    2903 </span>            :                         }
<span class="lineNum">    2904 </span><span class="lineCov">      16921 :                         ast_unlock_contexts();</span>
<span class="lineNum">    2905 </span><span class="lineCov">      16921 :                         if (!app) {</span>
<span class="lineNum">    2906 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;No application '%s' for extension (%s, %s, %d)\n&quot;, e-&gt;app, context, exten, priority);</span>
<span class="lineNum">    2907 </span><span class="lineNoCov">          0 :                                 return -1;</span>
<span class="lineNum">    2908 </span>            :                         }
<span class="lineNum">    2909 </span><span class="lineCov">      16921 :                         if (ast_channel_context(c) != context)</span>
<span class="lineNum">    2910 </span><span class="lineNoCov">          0 :                                 ast_channel_context_set(c, context);</span>
<span class="lineNum">    2911 </span><span class="lineCov">      16921 :                         if (ast_channel_exten(c) != exten)</span>
<span class="lineNum">    2912 </span><span class="lineNoCov">          0 :                                 ast_channel_exten_set(c, exten);</span>
<span class="lineNum">    2913 </span><span class="lineCov">      16921 :                         ast_channel_priority_set(c, priority);</span>
<span class="lineNum">    2914 </span><span class="lineCov">      16921 :                         if (substitute) {</span>
<span class="lineNum">    2915 </span><span class="lineCov">       6096 :                                 pbx_substitute_variables_helper(c, substitute, passdata, sizeof(passdata)-1);</span>
<span class="lineNum">    2916 </span>            :                         }
<span class="lineNum">    2917 </span><span class="lineCov">      16921 :                         ast_debug(1, &quot;Launching '%s'\n&quot;, app_name(app));</span>
<span class="lineNum">    2918 </span><span class="lineCov">      16921 :                         if (VERBOSITY_ATLEAST(3)) {</span>
<span class="lineNum">    2919 </span><span class="lineCov">      16909 :                                 ast_verb(3, &quot;Executing [%s@%s:%d] &quot; COLORIZE_FMT &quot;(\&quot;&quot; COLORIZE_FMT &quot;\&quot;, \&quot;&quot; COLORIZE_FMT &quot;\&quot;) %s\n&quot;,</span>
<span class="lineNum">    2920 </span>            :                                         exten, context, priority,
<span class="lineNum">    2921 </span>            :                                         COLORIZE(COLOR_BRCYAN, 0, app_name(app)),
<span class="lineNum">    2922 </span>            :                                         COLORIZE(COLOR_BRMAGENTA, 0, ast_channel_name(c)),
<span class="lineNum">    2923 </span>            :                                         COLORIZE(COLOR_BRMAGENTA, 0, passdata),
<span class="lineNum">    2924 </span>            :                                         &quot;in new stack&quot;);
<span class="lineNum">    2925 </span>            :                         }
<span class="lineNum">    2926 </span><span class="lineCov">      16921 :                         return pbx_exec(c, app, passdata);      /* 0 on success, -1 on failure */</span>
<span class="lineNum">    2927 </span>            :                 }
<span class="lineNum">    2928 </span><span class="lineCov">       3747 :         } else if (q.swo) {     /* not found here, but in another switch */</span>
<span class="lineNum">    2929 </span><span class="lineCov">         11 :                 if (found)</span>
<span class="lineNum">    2930 </span><span class="lineCov">          2 :                         *found = 1;</span>
<span class="lineNum">    2931 </span><span class="lineCov">         11 :                 ast_unlock_contexts();</span>
<span class="lineNum">    2932 </span><span class="lineCov">         11 :                 if (matching_action) {</span>
<span class="lineNum">    2933 </span><span class="lineCov">          9 :                         return -1;</span>
<span class="lineNum">    2934 </span>            :                 } else {
<span class="lineNum">    2935 </span><span class="lineCov">          2 :                         if (!q.swo-&gt;exec) {</span>
<span class="lineNum">    2936 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;No execution engine for switch %s\n&quot;, q.swo-&gt;name);</span>
<span class="lineNum">    2937 </span><span class="lineNoCov">          0 :                                 return -1;</span>
<span class="lineNum">    2938 </span>            :                         }
<span class="lineNum">    2939 </span><span class="lineCov">          2 :                         return q.swo-&gt;exec(c, q.foundcontext ? q.foundcontext : context, exten, priority, callerid, q.data);</span>
<span class="lineNum">    2940 </span>            :                 }
<span class="lineNum">    2941 </span>            :         } else {        /* not found anywhere, see what happened */
<span class="lineNum">    2942 </span><span class="lineCov">       3736 :                 ast_unlock_contexts();</span>
<span class="lineNum">    2943 </span>            :                 /* Using S_OR here because Solaris doesn't like NULL being passed to ast_log */
<span class="lineNum">    2944 </span><span class="lineCov">       3736 :                 switch (q.status) {</span>
<span class="lineNum">    2945 </span><span class="lineCov">         59 :                 case STATUS_NO_CONTEXT:</span>
<span class="lineNum">    2946 </span><span class="lineCov">         59 :                         if (!matching_action &amp;&amp; !combined_find_spawn)</span>
<span class="lineNum">    2947 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_NOTICE, &quot;Cannot find extension context '%s'\n&quot;, S_OR(context, &quot;&quot;));</span>
<span class="lineNum">    2948 </span><span class="lineCov">         59 :                         break;</span>
<span class="lineNum">    2949 </span><span class="lineCov">       3105 :                 case STATUS_NO_EXTENSION:</span>
<span class="lineNum">    2950 </span><span class="lineCov">       3105 :                         if (!matching_action &amp;&amp; !combined_find_spawn)</span>
<span class="lineNum">    2951 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_NOTICE, &quot;Cannot find extension '%s' in context '%s'\n&quot;, exten, S_OR(context, &quot;&quot;));</span>
<span class="lineNum">    2952 </span><span class="lineCov">       3105 :                         break;</span>
<span class="lineNum">    2953 </span><span class="lineCov">        570 :                 case STATUS_NO_PRIORITY:</span>
<span class="lineNum">    2954 </span><span class="lineCov">        570 :                         if (!matching_action &amp;&amp; !combined_find_spawn)</span>
<span class="lineNum">    2955 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_NOTICE, &quot;No such priority %d in extension '%s' in context '%s'\n&quot;, priority, exten, S_OR(context, &quot;&quot;));</span>
<span class="lineNum">    2956 </span><span class="lineCov">        570 :                         break;</span>
<span class="lineNum">    2957 </span><span class="lineCov">          2 :                 case STATUS_NO_LABEL:</span>
<span class="lineNum">    2958 </span><span class="lineCov">          2 :                         if (context &amp;&amp; !combined_find_spawn)</span>
<span class="lineNum">    2959 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_NOTICE, &quot;No such label '%s' in extension '%s' in context '%s'\n&quot;, label, exten, S_OR(context, &quot;&quot;));</span>
<span class="lineNum">    2960 </span><span class="lineCov">          2 :                         break;</span>
<span class="lineNum">    2961 </span><span class="lineNoCov">          0 :                 default:</span>
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 :                         ast_debug(1, &quot;Shouldn't happen!\n&quot;);</span>
<span class="lineNum">    2963 </span>            :                 }
<span class="lineNum">    2964 </span>            : 
<span class="lineNum">    2965 </span><span class="lineCov">       3736 :                 return (matching_action) ? 0 : -1;</span>
<span class="lineNum">    2966 </span>            :         }
<span class="lineNum">    2967 </span>            : }
<a name="2968"><span class="lineNum">    2968 </span>            : </a>
<span class="lineNum">    2969 </span>            : /*! \brief Find hint for given extension in context */
<span class="lineNum">    2970 </span><span class="lineCov">       1439 : static struct ast_exten *ast_hint_extension_nolock(struct ast_channel *c, const char *context, const char *exten)</span>
<span class="lineNum">    2971 </span>            : {
<span class="lineNum">    2972 </span><span class="lineCov">       1439 :         struct pbx_find_info q = { .stacklen = 0 }; /* the rest is set in pbx_find_context */</span>
<span class="lineNum">    2973 </span><span class="lineCov">       1439 :         return pbx_find_extension(c, NULL, &amp;q, context, exten, PRIORITY_HINT, NULL, &quot;&quot;, E_MATCH);</span>
<a name="2974"><span class="lineNum">    2974 </span>            : }</a>
<span class="lineNum">    2975 </span>            : 
<span class="lineNum">    2976 </span><span class="lineCov">       1439 : static struct ast_exten *ast_hint_extension(struct ast_channel *c, const char *context, const char *exten)</span>
<span class="lineNum">    2977 </span>            : {
<span class="lineNum">    2978 </span>            :         struct ast_exten *e;
<span class="lineNum">    2979 </span><span class="lineCov">       1439 :         ast_rdlock_contexts();</span>
<span class="lineNum">    2980 </span><span class="lineCov">       1439 :         e = ast_hint_extension_nolock(c, context, exten);</span>
<span class="lineNum">    2981 </span><span class="lineCov">       1439 :         ast_unlock_contexts();</span>
<span class="lineNum">    2982 </span><span class="lineCov">       1439 :         return e;</span>
<a name="2983"><span class="lineNum">    2983 </span>            : }</a>
<span class="lineNum">    2984 </span>            : 
<span class="lineNum">    2985 </span><span class="lineCov">        488 : enum ast_extension_states ast_devstate_to_extenstate(enum ast_device_state devstate)</span>
<span class="lineNum">    2986 </span>            : {
<span class="lineNum">    2987 </span><span class="lineCov">        488 :         switch (devstate) {</span>
<span class="lineNum">    2988 </span><span class="lineCov">         30 :         case AST_DEVICE_ONHOLD:</span>
<span class="lineNum">    2989 </span><span class="lineCov">         30 :                 return AST_EXTENSION_ONHOLD;</span>
<span class="lineNum">    2990 </span><span class="lineCov">         17 :         case AST_DEVICE_BUSY:</span>
<span class="lineNum">    2991 </span><span class="lineCov">         17 :                 return AST_EXTENSION_BUSY;</span>
<span class="lineNum">    2992 </span><span class="lineCov">        213 :         case AST_DEVICE_UNKNOWN:</span>
<span class="lineNum">    2993 </span><span class="lineCov">        213 :                 return AST_EXTENSION_NOT_INUSE;</span>
<span class="lineNum">    2994 </span><span class="lineCov">         56 :         case AST_DEVICE_UNAVAILABLE:</span>
<span class="lineNum">    2995 </span>            :         case AST_DEVICE_INVALID:
<span class="lineNum">    2996 </span><span class="lineCov">         56 :                 return AST_EXTENSION_UNAVAILABLE;</span>
<span class="lineNum">    2997 </span><span class="lineCov">         23 :         case AST_DEVICE_RINGINUSE:</span>
<span class="lineNum">    2998 </span><span class="lineCov">         23 :                 return (AST_EXTENSION_INUSE | AST_EXTENSION_RINGING);</span>
<span class="lineNum">    2999 </span><span class="lineCov">         20 :         case AST_DEVICE_RINGING:</span>
<span class="lineNum">    3000 </span><span class="lineCov">         20 :                 return AST_EXTENSION_RINGING;</span>
<span class="lineNum">    3001 </span><span class="lineCov">         71 :         case AST_DEVICE_INUSE:</span>
<span class="lineNum">    3002 </span><span class="lineCov">         71 :                 return AST_EXTENSION_INUSE;</span>
<span class="lineNum">    3003 </span><span class="lineCov">         58 :         case AST_DEVICE_NOT_INUSE:</span>
<span class="lineNum">    3004 </span><span class="lineCov">         58 :                 return AST_EXTENSION_NOT_INUSE;</span>
<span class="lineNum">    3005 </span><span class="lineNoCov">          0 :         case AST_DEVICE_TOTAL: /* not a device state, included for completeness */</span>
<span class="lineNum">    3006 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3007 </span>            :         }
<span class="lineNum">    3008 </span>            : 
<span class="lineNum">    3009 </span><span class="lineNoCov">          0 :         return AST_EXTENSION_NOT_INUSE;</span>
<span class="lineNum">    3010 </span>            : }
<span class="lineNum">    3011 </span>            : 
<span class="lineNum">    3012 </span>            : /*!
<span class="lineNum">    3013 </span>            :  * \internal
<a name="3014"><span class="lineNum">    3014 </span>            :  * \brief Parse out the presence portion of the hint string</a>
<span class="lineNum">    3015 </span>            :  */
<span class="lineNum">    3016 </span><span class="lineCov">        261 : static char *parse_hint_presence(struct ast_str *hint_args)</span>
<span class="lineNum">    3017 </span>            : {
<span class="lineNum">    3018 </span><span class="lineCov">        261 :         char *copy = ast_strdupa(ast_str_buffer(hint_args));</span>
<span class="lineNum">    3019 </span><span class="lineCov">        261 :         char *tmp = &quot;&quot;;</span>
<span class="lineNum">    3020 </span>            : 
<span class="lineNum">    3021 </span><span class="lineCov">        261 :         if ((tmp = strrchr(copy, ','))) {</span>
<span class="lineNum">    3022 </span><span class="lineCov">         24 :                 *tmp = '\0';</span>
<span class="lineNum">    3023 </span><span class="lineCov">         24 :                 tmp++;</span>
<span class="lineNum">    3024 </span>            :         } else {
<span class="lineNum">    3025 </span><span class="lineCov">        237 :                 return NULL;</span>
<span class="lineNum">    3026 </span>            :         }
<span class="lineNum">    3027 </span><span class="lineCov">         24 :         ast_str_set(&amp;hint_args, 0, &quot;%s&quot;, tmp);</span>
<span class="lineNum">    3028 </span><span class="lineCov">         24 :         return ast_str_buffer(hint_args);</span>
<span class="lineNum">    3029 </span>            : }
<span class="lineNum">    3030 </span>            : 
<span class="lineNum">    3031 </span>            : /*!
<span class="lineNum">    3032 </span>            :  * \internal
<a name="3033"><span class="lineNum">    3033 </span>            :  * \brief Parse out the device portion of the hint string</a>
<span class="lineNum">    3034 </span>            :  */
<span class="lineNum">    3035 </span><span class="lineCov">        407 : static char *parse_hint_device(struct ast_str *hint_args)</span>
<span class="lineNum">    3036 </span>            : {
<span class="lineNum">    3037 </span><span class="lineCov">        407 :         char *copy = ast_strdupa(ast_str_buffer(hint_args));</span>
<span class="lineNum">    3038 </span>            :         char *tmp;
<span class="lineNum">    3039 </span>            : 
<span class="lineNum">    3040 </span><span class="lineCov">        407 :         if ((tmp = strrchr(copy, ','))) {</span>
<span class="lineNum">    3041 </span><span class="lineCov">         27 :                 *tmp = '\0';</span>
<span class="lineNum">    3042 </span>            :         }
<span class="lineNum">    3043 </span>            : 
<span class="lineNum">    3044 </span><span class="lineCov">        407 :         ast_str_set(&amp;hint_args, 0, &quot;%s&quot;, copy);</span>
<span class="lineNum">    3045 </span><span class="lineCov">        407 :         return ast_str_buffer(hint_args);</span>
<a name="3046"><span class="lineNum">    3046 </span>            : }</a>
<span class="lineNum">    3047 </span>            : 
<span class="lineNum">    3048 </span><span class="lineCov">        253 : static void device_state_info_dt(void *obj)</span>
<span class="lineNum">    3049 </span>            : {
<span class="lineNum">    3050 </span><span class="lineCov">        253 :         struct ast_device_state_info *info = obj;</span>
<span class="lineNum">    3051 </span>            : 
<span class="lineNum">    3052 </span><span class="lineCov">        253 :         ao2_cleanup(info-&gt;causing_channel);</span>
<a name="3053"><span class="lineNum">    3053 </span><span class="lineCov">        253 : }</span></a>
<span class="lineNum">    3054 </span>            : 
<span class="lineNum">    3055 </span><span class="lineCov">        251 : static struct ao2_container *alloc_device_state_info(void)</span>
<span class="lineNum">    3056 </span>            : {
<span class="lineNum">    3057 </span><span class="lineCov">        251 :         return ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, 1, NULL, NULL);</span>
<a name="3058"><span class="lineNum">    3058 </span>            : }</a>
<span class="lineNum">    3059 </span>            : 
<span class="lineNum">    3060 </span><span class="lineCov">        407 : static int ast_extension_state3(struct ast_str *hint_app, struct ao2_container *device_state_info)</span>
<span class="lineNum">    3061 </span>            : {
<span class="lineNum">    3062 </span>            :         char *cur;
<span class="lineNum">    3063 </span>            :         char *rest;
<span class="lineNum">    3064 </span>            :         struct ast_devstate_aggregate agg;
<span class="lineNum">    3065 </span>            : 
<span class="lineNum">    3066 </span>            :         /* One or more devices separated with a &amp; character */
<span class="lineNum">    3067 </span><span class="lineCov">        407 :         rest = parse_hint_device(hint_app);</span>
<span class="lineNum">    3068 </span>            : 
<span class="lineNum">    3069 </span><span class="lineCov">        407 :         ast_devstate_aggregate_init(&amp;agg);</span>
<span class="lineNum">    3070 </span><span class="lineCov">        820 :         while ((cur = strsep(&amp;rest, &quot;&amp;&quot;))) {</span>
<span class="lineNum">    3071 </span><span class="lineCov">        413 :                 enum ast_device_state state = ast_device_state(cur);</span>
<span class="lineNum">    3072 </span>            : 
<span class="lineNum">    3073 </span><span class="lineCov">        413 :                 ast_devstate_aggregate_add(&amp;agg, state);</span>
<span class="lineNum">    3074 </span><span class="lineCov">        413 :                 if (device_state_info) {</span>
<span class="lineNum">    3075 </span>            :                         struct ast_device_state_info *obj;
<span class="lineNum">    3076 </span>            : 
<span class="lineNum">    3077 </span><span class="lineCov">        253 :                         obj = ao2_alloc_options(sizeof(*obj) + strlen(cur), device_state_info_dt, AO2_ALLOC_OPT_LOCK_NOLOCK);</span>
<span class="lineNum">    3078 </span>            :                         /* if failed we cannot add this device */
<span class="lineNum">    3079 </span><span class="lineCov">        253 :                         if (obj) {</span>
<span class="lineNum">    3080 </span><span class="lineCov">        253 :                                 obj-&gt;device_state = state;</span>
<span class="lineNum">    3081 </span><span class="lineCov">        253 :                                 strcpy(obj-&gt;device_name, cur);</span>
<span class="lineNum">    3082 </span><span class="lineCov">        253 :                                 ao2_link(device_state_info, obj);</span>
<span class="lineNum">    3083 </span><span class="lineCov">        253 :                                 ao2_ref(obj, -1);</span>
<span class="lineNum">    3084 </span>            :                         }
<span class="lineNum">    3085 </span>            :                 }
<span class="lineNum">    3086 </span>            :         }
<span class="lineNum">    3087 </span>            : 
<span class="lineNum">    3088 </span><span class="lineCov">        407 :         return ast_devstate_to_extenstate(ast_devstate_aggregate_result(&amp;agg));</span>
<span class="lineNum">    3089 </span>            : }
<a name="3090"><span class="lineNum">    3090 </span>            : </a>
<span class="lineNum">    3091 </span>            : /*! \brief Check state of extension by using hints */
<span class="lineNum">    3092 </span><span class="lineCov">        265 : static int ast_extension_state2(struct ast_exten *e, struct ao2_container *device_state_info)</span>
<span class="lineNum">    3093 </span>            : {
<span class="lineNum">    3094 </span><span class="lineCov">        265 :         struct ast_str *hint_app = ast_str_thread_get(&amp;extensionstate_buf, 32);</span>
<span class="lineNum">    3095 </span>            : 
<span class="lineNum">    3096 </span><span class="lineCov">        265 :         if (!e || !hint_app) {</span>
<span class="lineNum">    3097 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3098 </span>            :         }
<span class="lineNum">    3099 </span>            : 
<span class="lineNum">    3100 </span><span class="lineCov">        265 :         ast_str_set(&amp;hint_app, 0, &quot;%s&quot;, ast_get_extension_app(e));</span>
<span class="lineNum">    3101 </span><span class="lineCov">        265 :         return ast_extension_state3(hint_app, device_state_info);</span>
<span class="lineNum">    3102 </span>            : }
<a name="3103"><span class="lineNum">    3103 </span>            : </a>
<span class="lineNum">    3104 </span>            : /*! \brief Return extension_state as string */
<span class="lineNum">    3105 </span><span class="lineCov">        317 : const char *ast_extension_state2str(int extension_state)</span>
<span class="lineNum">    3106 </span>            : {
<span class="lineNum">    3107 </span>            :         int i;
<span class="lineNum">    3108 </span>            : 
<span class="lineNum">    3109 </span><span class="lineCov">        714 :         for (i = 0; (i &lt; ARRAY_LEN(extension_states)); i++) {</span>
<span class="lineNum">    3110 </span><span class="lineCov">        713 :                 if (extension_states[i].extension_state == extension_state)</span>
<span class="lineNum">    3111 </span><span class="lineCov">        316 :                         return extension_states[i].text;</span>
<span class="lineNum">    3112 </span>            :         }
<span class="lineNum">    3113 </span><span class="lineCov">          1 :         return &quot;Unknown&quot;;</span>
<span class="lineNum">    3114 </span>            : }
<span class="lineNum">    3115 </span>            : 
<span class="lineNum">    3116 </span>            : /*!
<span class="lineNum">    3117 </span>            :  * \internal
<a name="3118"><span class="lineNum">    3118 </span>            :  * \brief Check extension state for an extension by using hint</a>
<span class="lineNum">    3119 </span>            :  */
<span class="lineNum">    3120 </span><span class="lineCov">        109 : static int internal_extension_state_extended(struct ast_channel *c, const char *context, const char *exten,</span>
<span class="lineNum">    3121 </span>            :         struct ao2_container *device_state_info)
<span class="lineNum">    3122 </span>            : {
<span class="lineNum">    3123 </span>            :         struct ast_exten *e;
<span class="lineNum">    3124 </span>            : 
<span class="lineNum">    3125 </span><span class="lineCov">        109 :         if (!(e = ast_hint_extension(c, context, exten))) {  /* Do we have a hint for this extension ? */</span>
<span class="lineNum">    3126 </span><span class="lineNoCov">          0 :                 return -1;                   /* No hint, return -1 */</span>
<span class="lineNum">    3127 </span>            :         }
<span class="lineNum">    3128 </span>            : 
<span class="lineNum">    3129 </span><span class="lineCov">        109 :         if (e-&gt;exten[0] == '_') {</span>
<span class="lineNum">    3130 </span>            :                 /* Create this hint on-the-fly */
<span class="lineNum">    3131 </span><span class="lineNoCov">          0 :                 ast_add_extension(e-&gt;parent-&gt;name, 0, exten, e-&gt;priority, e-&gt;label,</span>
<span class="lineNum">    3132 </span><span class="lineNoCov">          0 :                         e-&gt;matchcid ? e-&gt;cidmatch : NULL, e-&gt;app, ast_strdup(e-&gt;data), ast_free_ptr,</span>
<span class="lineNum">    3133 </span>            :                         e-&gt;registrar);
<span class="lineNum">    3134 </span><span class="lineNoCov">          0 :                 if (!(e = ast_hint_extension(c, context, exten))) {</span>
<span class="lineNum">    3135 </span>            :                         /* Improbable, but not impossible */
<span class="lineNum">    3136 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    3137 </span>            :                 }
<span class="lineNum">    3138 </span>            :         }
<span class="lineNum">    3139 </span>            : 
<span class="lineNum">    3140 </span><span class="lineCov">        109 :         return ast_extension_state2(e, device_state_info);  /* Check all devices in the hint */</span>
<span class="lineNum">    3141 </span>            : }
<a name="3142"><span class="lineNum">    3142 </span>            : </a>
<span class="lineNum">    3143 </span>            : /*! \brief Check extension state for an extension by using hint */
<span class="lineNum">    3144 </span><span class="lineNoCov">          0 : int ast_extension_state(struct ast_channel *c, const char *context, const char *exten)</span>
<span class="lineNum">    3145 </span>            : {
<span class="lineNum">    3146 </span><span class="lineNoCov">          0 :         return internal_extension_state_extended(c, context, exten, NULL);</span>
<span class="lineNum">    3147 </span>            : }
<a name="3148"><span class="lineNum">    3148 </span>            : </a>
<span class="lineNum">    3149 </span>            : /*! \brief Check extended extension state for an extension by using hint */
<span class="lineNum">    3150 </span><span class="lineCov">        109 : int ast_extension_state_extended(struct ast_channel *c, const char *context, const char *exten,</span>
<span class="lineNum">    3151 </span>            :         struct ao2_container **device_state_info)
<span class="lineNum">    3152 </span>            : {
<span class="lineNum">    3153 </span><span class="lineCov">        109 :         struct ao2_container *container = NULL;</span>
<span class="lineNum">    3154 </span>            :         int ret;
<span class="lineNum">    3155 </span>            : 
<span class="lineNum">    3156 </span><span class="lineCov">        109 :         if (device_state_info) {</span>
<span class="lineNum">    3157 </span><span class="lineCov">        109 :                 container = alloc_device_state_info();</span>
<span class="lineNum">    3158 </span>            :         }
<span class="lineNum">    3159 </span>            : 
<span class="lineNum">    3160 </span><span class="lineCov">        109 :         ret = internal_extension_state_extended(c, context, exten, container);</span>
<span class="lineNum">    3161 </span><span class="lineCov">        109 :         if (ret &lt; 0 &amp;&amp; container) {</span>
<span class="lineNum">    3162 </span><span class="lineNoCov">          0 :                 ao2_ref(container, -1);</span>
<span class="lineNum">    3163 </span><span class="lineNoCov">          0 :                 container = NULL;</span>
<span class="lineNum">    3164 </span>            :         }
<span class="lineNum">    3165 </span>            : 
<span class="lineNum">    3166 </span><span class="lineCov">        109 :         if (device_state_info) {</span>
<span class="lineNum">    3167 </span><span class="lineCov">        109 :                 get_device_state_causing_channels(container);</span>
<span class="lineNum">    3168 </span><span class="lineCov">        109 :                 *device_state_info = container;</span>
<span class="lineNum">    3169 </span>            :         }
<span class="lineNum">    3170 </span>            : 
<span class="lineNum">    3171 </span><span class="lineCov">        109 :         return ret;</span>
<a name="3172"><span class="lineNum">    3172 </span>            : }</a>
<span class="lineNum">    3173 </span>            : 
<span class="lineNum">    3174 </span><span class="lineCov">        261 : static int extension_presence_state_helper(struct ast_exten *e, char **subtype, char **message)</span>
<span class="lineNum">    3175 </span>            : {
<span class="lineNum">    3176 </span><span class="lineCov">        261 :         struct ast_str *hint_app = ast_str_thread_get(&amp;extensionstate_buf, 32);</span>
<span class="lineNum">    3177 </span>            :         char *presence_provider;
<span class="lineNum">    3178 </span>            :         const char *app;
<span class="lineNum">    3179 </span>            : 
<span class="lineNum">    3180 </span><span class="lineCov">        261 :         if (!e || !hint_app) {</span>
<span class="lineNum">    3181 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3182 </span>            :         }
<span class="lineNum">    3183 </span>            : 
<span class="lineNum">    3184 </span><span class="lineCov">        261 :         app = ast_get_extension_app(e);</span>
<span class="lineNum">    3185 </span><span class="lineCov">        261 :         if (ast_strlen_zero(app)) {</span>
<span class="lineNum">    3186 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3187 </span>            :         }
<span class="lineNum">    3188 </span>            : 
<span class="lineNum">    3189 </span><span class="lineCov">        261 :         ast_str_set(&amp;hint_app, 0, &quot;%s&quot;, app);</span>
<span class="lineNum">    3190 </span><span class="lineCov">        261 :         presence_provider = parse_hint_presence(hint_app);</span>
<span class="lineNum">    3191 </span>            : 
<span class="lineNum">    3192 </span><span class="lineCov">        261 :         if (ast_strlen_zero(presence_provider)) {</span>
<span class="lineNum">    3193 </span>            :                 /* No presence string in the hint */
<span class="lineNum">    3194 </span><span class="lineCov">        237 :                 return 0;</span>
<span class="lineNum">    3195 </span>            :         }
<span class="lineNum">    3196 </span>            : 
<span class="lineNum">    3197 </span><span class="lineCov">         24 :         return ast_presence_state(presence_provider, subtype, message);</span>
<a name="3198"><span class="lineNum">    3198 </span>            : }</a>
<span class="lineNum">    3199 </span>            : 
<span class="lineNum">    3200 </span><span class="lineCov">        105 : int ast_hint_presence_state(struct ast_channel *c, const char *context, const char *exten, char **subtype, char **message)</span>
<span class="lineNum">    3201 </span>            : {
<span class="lineNum">    3202 </span>            :         struct ast_exten *e;
<span class="lineNum">    3203 </span>            : 
<span class="lineNum">    3204 </span><span class="lineCov">        105 :         if (!(e = ast_hint_extension(c, context, exten))) {  /* Do we have a hint for this extension ? */</span>
<span class="lineNum">    3205 </span><span class="lineNoCov">          0 :                 return -1;                   /* No hint, return -1 */</span>
<span class="lineNum">    3206 </span>            :         }
<span class="lineNum">    3207 </span>            : 
<span class="lineNum">    3208 </span><span class="lineCov">        105 :         if (e-&gt;exten[0] == '_') {</span>
<span class="lineNum">    3209 </span>            :                 /* Create this hint on-the-fly */
<span class="lineNum">    3210 </span><span class="lineNoCov">          0 :                 ast_add_extension(e-&gt;parent-&gt;name, 0, exten, e-&gt;priority, e-&gt;label,</span>
<span class="lineNum">    3211 </span><span class="lineNoCov">          0 :                         e-&gt;matchcid ? e-&gt;cidmatch : NULL, e-&gt;app, ast_strdup(e-&gt;data), ast_free_ptr,</span>
<span class="lineNum">    3212 </span>            :                         e-&gt;registrar);
<span class="lineNum">    3213 </span><span class="lineNoCov">          0 :                 if (!(e = ast_hint_extension(c, context, exten))) {</span>
<span class="lineNum">    3214 </span>            :                         /* Improbable, but not impossible */
<span class="lineNum">    3215 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    3216 </span>            :                 }
<span class="lineNum">    3217 </span>            :         }
<span class="lineNum">    3218 </span>            : 
<span class="lineNum">    3219 </span><span class="lineCov">        105 :         return extension_presence_state_helper(e, subtype, message);</span>
<a name="3220"><span class="lineNum">    3220 </span>            : }</a>
<span class="lineNum">    3221 </span>            : 
<span class="lineNum">    3222 </span><span class="lineCov">        459 : static int execute_state_callback(ast_state_cb_type cb,</span>
<span class="lineNum">    3223 </span>            :         const char *context,
<span class="lineNum">    3224 </span>            :         const char *exten,
<span class="lineNum">    3225 </span>            :         void *data,
<span class="lineNum">    3226 </span>            :         enum ast_state_cb_update_reason reason,
<span class="lineNum">    3227 </span>            :         struct ast_hint *hint,
<span class="lineNum">    3228 </span>            :         struct ao2_container *device_state_info)
<span class="lineNum">    3229 </span>            : {
<span class="lineNum">    3230 </span><span class="lineCov">        459 :         int res = 0;</span>
<span class="lineNum">    3231 </span><span class="lineCov">        459 :         struct ast_state_cb_info info = { 0, };</span>
<span class="lineNum">    3232 </span>            : 
<span class="lineNum">    3233 </span><span class="lineCov">        459 :         info.reason = reason;</span>
<span class="lineNum">    3234 </span>            : 
<span class="lineNum">    3235 </span>            :         /* Copy over current hint data */
<span class="lineNum">    3236 </span><span class="lineCov">        459 :         if (hint) {</span>
<span class="lineNum">    3237 </span><span class="lineCov">        459 :                 ao2_lock(hint);</span>
<span class="lineNum">    3238 </span><span class="lineCov">        459 :                 info.exten_state = hint-&gt;laststate;</span>
<span class="lineNum">    3239 </span><span class="lineCov">        459 :                 info.device_state_info = device_state_info;</span>
<span class="lineNum">    3240 </span><span class="lineCov">        459 :                 info.presence_state = hint-&gt;last_presence_state;</span>
<span class="lineNum">    3241 </span><span class="lineCov">        459 :                 if (!(ast_strlen_zero(hint-&gt;last_presence_subtype))) {</span>
<span class="lineNum">    3242 </span><span class="lineCov">         24 :                         info.presence_subtype = ast_strdupa(hint-&gt;last_presence_subtype);</span>
<span class="lineNum">    3243 </span>            :                 } else {
<span class="lineNum">    3244 </span><span class="lineCov">        435 :                         info.presence_subtype = &quot;&quot;;</span>
<span class="lineNum">    3245 </span>            :                 }
<span class="lineNum">    3246 </span><span class="lineCov">        459 :                 if (!(ast_strlen_zero(hint-&gt;last_presence_message))) {</span>
<span class="lineNum">    3247 </span><span class="lineCov">         24 :                         info.presence_message = ast_strdupa(hint-&gt;last_presence_message);</span>
<span class="lineNum">    3248 </span>            :                 } else {
<span class="lineNum">    3249 </span><span class="lineCov">        435 :                         info.presence_message = &quot;&quot;;</span>
<span class="lineNum">    3250 </span>            :                 }
<span class="lineNum">    3251 </span><span class="lineCov">        459 :                 ao2_unlock(hint);</span>
<span class="lineNum">    3252 </span>            :         } else {
<span class="lineNum">    3253 </span><span class="lineNoCov">          0 :                 info.exten_state = AST_EXTENSION_REMOVED;</span>
<span class="lineNum">    3254 </span>            :         }
<span class="lineNum">    3255 </span>            : 
<span class="lineNum">    3256 </span><span class="lineCov">        459 :         res = cb(context, exten, &amp;info, data);</span>
<span class="lineNum">    3257 </span>            : 
<span class="lineNum">    3258 </span><span class="lineCov">        459 :         return res;</span>
<span class="lineNum">    3259 </span>            : }
<span class="lineNum">    3260 </span>            : 
<span class="lineNum">    3261 </span>            : /*!
<span class="lineNum">    3262 </span>            :  * /internal
<span class="lineNum">    3263 </span>            :  * /brief Identify a channel for every device which is supposedly responsible for the device state.
<span class="lineNum">    3264 </span>            :  *
<span class="lineNum">    3265 </span>            :  * Especially when the device is ringing, the oldest ringing channel is chosen.
<a name="3266"><span class="lineNum">    3266 </span>            :  * For all other cases the first encountered channel in the specific state is chosen.</a>
<span class="lineNum">    3267 </span>            :  */
<span class="lineNum">    3268 </span><span class="lineCov">        160 : static void get_device_state_causing_channels(struct ao2_container *c)</span>
<span class="lineNum">    3269 </span>            : {
<span class="lineNum">    3270 </span>            :         struct ao2_iterator iter;
<span class="lineNum">    3271 </span>            :         struct ast_device_state_info *info;
<span class="lineNum">    3272 </span>            :         struct ast_channel *chan;
<span class="lineNum">    3273 </span>            : 
<span class="lineNum">    3274 </span><span class="lineCov">        160 :         if (!c || !ao2_container_count(c)) {</span>
<span class="lineNum">    3275 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    3276 </span>            :         }
<span class="lineNum">    3277 </span><span class="lineCov">        160 :         iter = ao2_iterator_init(c, 0);</span>
<span class="lineNum">    3278 </span><span class="lineCov">        320 :         for (; (info = ao2_iterator_next(&amp;iter)); ao2_ref(info, -1)) {</span>
<span class="lineNum">    3279 </span><span class="lineCov">        160 :                 enum ast_channel_state search_state = 0; /* prevent false uninit warning */</span>
<span class="lineNum">    3280 </span>            :                 char match[AST_CHANNEL_NAME];
<span class="lineNum">    3281 </span>            :                 struct ast_channel_iterator *chan_iter;
<span class="lineNum">    3282 </span><span class="lineCov">        160 :                 struct timeval chantime = {0, }; /* prevent false uninit warning */</span>
<span class="lineNum">    3283 </span>            : 
<span class="lineNum">    3284 </span><span class="lineCov">        160 :                 switch (info-&gt;device_state) {</span>
<span class="lineNum">    3285 </span><span class="lineCov">          6 :                 case AST_DEVICE_RINGING:</span>
<span class="lineNum">    3286 </span>            :                 case AST_DEVICE_RINGINUSE:
<span class="lineNum">    3287 </span>            :                         /* find ringing channel */
<span class="lineNum">    3288 </span><span class="lineCov">          6 :                         search_state = AST_STATE_RINGING;</span>
<span class="lineNum">    3289 </span><span class="lineCov">          6 :                         break;</span>
<span class="lineNum">    3290 </span><span class="lineCov">          4 :                 case AST_DEVICE_BUSY:</span>
<span class="lineNum">    3291 </span>            :                         /* find busy channel */
<span class="lineNum">    3292 </span><span class="lineCov">          4 :                         search_state = AST_STATE_BUSY;</span>
<span class="lineNum">    3293 </span><span class="lineCov">          4 :                         break;</span>
<span class="lineNum">    3294 </span><span class="lineCov">         29 :                 case AST_DEVICE_ONHOLD:</span>
<span class="lineNum">    3295 </span>            :                 case AST_DEVICE_INUSE:
<span class="lineNum">    3296 </span>            :                         /* find up channel */
<span class="lineNum">    3297 </span><span class="lineCov">         29 :                         search_state = AST_STATE_UP;</span>
<span class="lineNum">    3298 </span><span class="lineCov">         29 :                         break;</span>
<span class="lineNum">    3299 </span><span class="lineCov">        121 :                 case AST_DEVICE_UNKNOWN:</span>
<span class="lineNum">    3300 </span>            :                 case AST_DEVICE_NOT_INUSE:
<span class="lineNum">    3301 </span>            :                 case AST_DEVICE_INVALID:
<span class="lineNum">    3302 </span>            :                 case AST_DEVICE_UNAVAILABLE:
<span class="lineNum">    3303 </span>            :                 case AST_DEVICE_TOTAL /* not a state */:
<span class="lineNum">    3304 </span>            :                         /* no channels are of interest */
<span class="lineNum">    3305 </span><span class="lineCov">        121 :                         continue;</span>
<span class="lineNum">    3306 </span>            :                 }
<span class="lineNum">    3307 </span>            : 
<span class="lineNum">    3308 </span>            :                 /* iterate over all channels of the device */
<span class="lineNum">    3309 </span><span class="lineCov">         39 :                 snprintf(match, sizeof(match), &quot;%s-&quot;, info-&gt;device_name);</span>
<span class="lineNum">    3310 </span><span class="lineCov">         39 :                 chan_iter = ast_channel_iterator_by_name_new(match, strlen(match));</span>
<span class="lineNum">    3311 </span><span class="lineCov">         39 :                 for (; (chan = ast_channel_iterator_next(chan_iter)); ast_channel_unref(chan)) {</span>
<span class="lineNum">    3312 </span><span class="lineNoCov">          0 :                         ast_channel_lock(chan);</span>
<span class="lineNum">    3313 </span>            :                         /* this channel's state doesn't match */
<span class="lineNum">    3314 </span><span class="lineNoCov">          0 :                         if (search_state != ast_channel_state(chan)) {</span>
<span class="lineNum">    3315 </span><span class="lineNoCov">          0 :                                 ast_channel_unlock(chan);</span>
<span class="lineNum">    3316 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    3317 </span>            :                         }
<span class="lineNum">    3318 </span>            :                         /* any non-ringing channel will fit */
<span class="lineNum">    3319 </span><span class="lineNoCov">          0 :                         if (search_state != AST_STATE_RINGING) {</span>
<span class="lineNum">    3320 </span><span class="lineNoCov">          0 :                                 ast_channel_unlock(chan);</span>
<span class="lineNum">    3321 </span><span class="lineNoCov">          0 :                                 info-&gt;causing_channel = chan; /* is kept ref'd! */</span>
<span class="lineNum">    3322 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    3323 </span>            :                         }
<span class="lineNum">    3324 </span>            :                         /* but we need the oldest ringing channel of the device to match with undirected pickup */
<span class="lineNum">    3325 </span><span class="lineNoCov">          0 :                         if (!info-&gt;causing_channel) {</span>
<span class="lineNum">    3326 </span><span class="lineNoCov">          0 :                                 chantime = ast_channel_creationtime(chan);</span>
<span class="lineNum">    3327 </span><span class="lineNoCov">          0 :                                 ast_channel_ref(chan); /* must ref it! */</span>
<span class="lineNum">    3328 </span><span class="lineNoCov">          0 :                                 info-&gt;causing_channel = chan;</span>
<span class="lineNum">    3329 </span><span class="lineNoCov">          0 :                         } else if (ast_tvcmp(ast_channel_creationtime(chan), chantime) &lt; 0) {</span>
<span class="lineNum">    3330 </span><span class="lineNoCov">          0 :                                 chantime = ast_channel_creationtime(chan);</span>
<span class="lineNum">    3331 </span><span class="lineNoCov">          0 :                                 ast_channel_unref(info-&gt;causing_channel);</span>
<span class="lineNum">    3332 </span><span class="lineNoCov">          0 :                                 ast_channel_ref(chan); /* must ref it! */</span>
<span class="lineNum">    3333 </span><span class="lineNoCov">          0 :                                 info-&gt;causing_channel = chan;</span>
<span class="lineNum">    3334 </span>            :                         }
<span class="lineNum">    3335 </span><span class="lineNoCov">          0 :                         ast_channel_unlock(chan);</span>
<span class="lineNum">    3336 </span>            :                 }
<span class="lineNum">    3337 </span><span class="lineCov">         39 :                 ast_channel_iterator_destroy(chan_iter);</span>
<span class="lineNum">    3338 </span>            :         }
<span class="lineNum">    3339 </span><span class="lineCov">        160 :         ao2_iterator_destroy(&amp;iter);</span>
<a name="3340"><span class="lineNum">    3340 </span>            : }</a>
<span class="lineNum">    3341 </span>            : 
<span class="lineNum">    3342 </span><span class="lineCov">        142 : static void device_state_notify_callbacks(struct ast_hint *hint, struct ast_str **hint_app)</span>
<span class="lineNum">    3343 </span>            : {
<span class="lineNum">    3344 </span>            :         struct ao2_iterator cb_iter;
<span class="lineNum">    3345 </span>            :         struct ast_state_cb *state_cb;
<span class="lineNum">    3346 </span>            :         int state;
<span class="lineNum">    3347 </span>            :         int same_state;
<span class="lineNum">    3348 </span>            :         struct ao2_container *device_state_info;
<span class="lineNum">    3349 </span><span class="lineCov">        142 :         int first_extended_cb_call = 1;</span>
<span class="lineNum">    3350 </span>            :         char context_name[AST_MAX_CONTEXT];
<span class="lineNum">    3351 </span>            :         char exten_name[AST_MAX_EXTENSION];
<span class="lineNum">    3352 </span>            : 
<span class="lineNum">    3353 </span><span class="lineCov">        142 :         ao2_lock(hint);</span>
<span class="lineNum">    3354 </span><span class="lineCov">        142 :         if (!hint-&gt;exten) {</span>
<span class="lineNum">    3355 </span>            :                 /* The extension has already been destroyed */
<span class="lineNum">    3356 </span><span class="lineNoCov">          0 :                 ao2_unlock(hint);</span>
<span class="lineNum">    3357 </span><span class="lineCov">          4 :                 return;</span>
<span class="lineNum">    3358 </span>            :         }
<span class="lineNum">    3359 </span>            : 
<span class="lineNum">    3360 </span>            :         /*
<span class="lineNum">    3361 </span>            :          * Save off strings in case the hint extension gets destroyed
<span class="lineNum">    3362 </span>            :          * while we are notifying the watchers.
<span class="lineNum">    3363 </span>            :          */
<span class="lineNum">    3364 </span><span class="lineCov">        142 :         ast_copy_string(context_name,</span>
<span class="lineNum">    3365 </span>            :                         ast_get_context_name(ast_get_extension_context(hint-&gt;exten)),
<span class="lineNum">    3366 </span>            :                         sizeof(context_name));
<span class="lineNum">    3367 </span><span class="lineCov">        142 :         ast_copy_string(exten_name, ast_get_extension_name(hint-&gt;exten),</span>
<span class="lineNum">    3368 </span>            :                         sizeof(exten_name));
<span class="lineNum">    3369 </span><span class="lineCov">        142 :         ast_str_set(hint_app, 0, &quot;%s&quot;, ast_get_extension_app(hint-&gt;exten));</span>
<span class="lineNum">    3370 </span><span class="lineCov">        142 :         ao2_unlock(hint);</span>
<span class="lineNum">    3371 </span>            : 
<span class="lineNum">    3372 </span>            :         /*
<span class="lineNum">    3373 </span>            :          * Get device state for this hint.
<span class="lineNum">    3374 </span>            :          *
<span class="lineNum">    3375 </span>            :          * NOTE: We cannot hold any locks while determining the hint
<span class="lineNum">    3376 </span>            :          * device state or notifying the watchers without causing a
<span class="lineNum">    3377 </span>            :          * deadlock.  (conlock, hints, and hint)
<span class="lineNum">    3378 </span>            :          */
<span class="lineNum">    3379 </span>            : 
<span class="lineNum">    3380 </span>            :         /* Make a container so state3 can fill it if we wish.
<span class="lineNum">    3381 </span>            :          * If that failed we simply do not provide the extended state info.
<span class="lineNum">    3382 </span>            :          */
<span class="lineNum">    3383 </span><span class="lineCov">        142 :         device_state_info = alloc_device_state_info();</span>
<span class="lineNum">    3384 </span>            : 
<span class="lineNum">    3385 </span><span class="lineCov">        142 :         state = ast_extension_state3(*hint_app, device_state_info);</span>
<span class="lineNum">    3386 </span><span class="lineCov">        142 :         same_state = state == hint-&gt;laststate;</span>
<span class="lineNum">    3387 </span><span class="lineCov">        142 :         if (same_state &amp;&amp; (~state &amp; AST_EXTENSION_RINGING)) {</span>
<span class="lineNum">    3388 </span><span class="lineCov">          4 :                 ao2_cleanup(device_state_info);</span>
<span class="lineNum">    3389 </span><span class="lineCov">          4 :                 return;</span>
<span class="lineNum">    3390 </span>            :         }
<span class="lineNum">    3391 </span>            : 
<span class="lineNum">    3392 </span>            :         /* Device state changed since last check - notify the watchers. */
<span class="lineNum">    3393 </span><span class="lineCov">        138 :         hint-&gt;laststate = state;     /* record we saw the change */</span>
<span class="lineNum">    3394 </span>            : 
<span class="lineNum">    3395 </span>            :         /* For general callbacks */
<span class="lineNum">    3396 </span><span class="lineCov">        138 :         if (!same_state) {</span>
<span class="lineNum">    3397 </span><span class="lineCov">        138 :                 cb_iter = ao2_iterator_init(statecbs, 0);</span>
<span class="lineNum">    3398 </span><span class="lineCov">        288 :                 for (; (state_cb = ao2_iterator_next(&amp;cb_iter)); ao2_ref(state_cb, -1)) {</span>
<span class="lineNum">    3399 </span><span class="lineCov">        150 :                         execute_state_callback(state_cb-&gt;change_cb,</span>
<span class="lineNum">    3400 </span>            :                                 context_name,
<span class="lineNum">    3401 </span>            :                                 exten_name,
<span class="lineNum">    3402 </span>            :                                 state_cb-&gt;data,
<span class="lineNum">    3403 </span>            :                                 AST_HINT_UPDATE_DEVICE,
<span class="lineNum">    3404 </span>            :                                 hint,
<span class="lineNum">    3405 </span>            :                                 NULL);
<span class="lineNum">    3406 </span>            :                 }
<span class="lineNum">    3407 </span><span class="lineCov">        138 :                 ao2_iterator_destroy(&amp;cb_iter);</span>
<span class="lineNum">    3408 </span>            :         }
<span class="lineNum">    3409 </span>            : 
<span class="lineNum">    3410 </span>            :         /* For extension callbacks */
<span class="lineNum">    3411 </span>            :         /* extended callbacks are called when the state changed or when AST_STATE_RINGING is
<span class="lineNum">    3412 </span>            :          * included. Normal callbacks are only called when the state changed.
<span class="lineNum">    3413 </span>            :          */
<span class="lineNum">    3414 </span><span class="lineCov">        138 :         cb_iter = ao2_iterator_init(hint-&gt;callbacks, 0);</span>
<span class="lineNum">    3415 </span><span class="lineCov">        189 :         for (; (state_cb = ao2_iterator_next(&amp;cb_iter)); ao2_ref(state_cb, -1)) {</span>
<span class="lineNum">    3416 </span><span class="lineCov">         51 :                 if (state_cb-&gt;extended &amp;&amp; first_extended_cb_call) {</span>
<span class="lineNum">    3417 </span>            :                         /* Fill detailed device_state_info now that we know it is used by extd. callback */
<span class="lineNum">    3418 </span><span class="lineCov">         51 :                         first_extended_cb_call = 0;</span>
<span class="lineNum">    3419 </span><span class="lineCov">         51 :                         get_device_state_causing_channels(device_state_info);</span>
<span class="lineNum">    3420 </span>            :                 }
<span class="lineNum">    3421 </span><span class="lineCov">         51 :                 if (state_cb-&gt;extended || !same_state) {</span>
<span class="lineNum">    3422 </span><span class="lineCov">         51 :                         execute_state_callback(state_cb-&gt;change_cb,</span>
<span class="lineNum">    3423 </span>            :                                 context_name,
<span class="lineNum">    3424 </span>            :                                 exten_name,
<span class="lineNum">    3425 </span>            :                                 state_cb-&gt;data,
<span class="lineNum">    3426 </span>            :                                 AST_HINT_UPDATE_DEVICE,
<span class="lineNum">    3427 </span>            :                                 hint,
<span class="lineNum">    3428 </span><span class="lineCov">         51 :                                 state_cb-&gt;extended ? device_state_info : NULL);</span>
<span class="lineNum">    3429 </span>            :                 }
<span class="lineNum">    3430 </span>            :         }
<span class="lineNum">    3431 </span><span class="lineCov">        138 :         ao2_iterator_destroy(&amp;cb_iter);</span>
<span class="lineNum">    3432 </span>            : 
<span class="lineNum">    3433 </span><span class="lineCov">        138 :         ao2_cleanup(device_state_info);</span>
<a name="3434"><span class="lineNum">    3434 </span>            : }</a>
<span class="lineNum">    3435 </span>            : 
<span class="lineNum">    3436 </span><span class="lineCov">         15 : static void presence_state_notify_callbacks(struct ast_hint *hint, struct ast_str **hint_app,</span>
<span class="lineNum">    3437 </span>            :                                             struct ast_presence_state_message *presence_state)
<span class="lineNum">    3438 </span>            : {
<span class="lineNum">    3439 </span>            :         struct ao2_iterator cb_iter;
<span class="lineNum">    3440 </span>            :         struct ast_state_cb *state_cb;
<span class="lineNum">    3441 </span>            :         char context_name[AST_MAX_CONTEXT];
<span class="lineNum">    3442 </span>            :         char exten_name[AST_MAX_EXTENSION];
<span class="lineNum">    3443 </span>            : 
<span class="lineNum">    3444 </span><span class="lineCov">         15 :         ao2_lock(hint);</span>
<span class="lineNum">    3445 </span><span class="lineCov">         15 :         if (!hint-&gt;exten) {</span>
<span class="lineNum">    3446 </span>            :                 /* The extension has already been destroyed */
<span class="lineNum">    3447 </span><span class="lineNoCov">          0 :                 ao2_unlock(hint);</span>
<span class="lineNum">    3448 </span><span class="lineCov">          1 :                 return;</span>
<span class="lineNum">    3449 </span>            :         }
<span class="lineNum">    3450 </span>            : 
<span class="lineNum">    3451 </span>            :         /*
<span class="lineNum">    3452 </span>            :          * Save off strings in case the hint extension gets destroyed
<span class="lineNum">    3453 </span>            :          * while we are notifying the watchers.
<span class="lineNum">    3454 </span>            :          */
<span class="lineNum">    3455 </span><span class="lineCov">         15 :         ast_copy_string(context_name,</span>
<span class="lineNum">    3456 </span>            :                         ast_get_context_name(ast_get_extension_context(hint-&gt;exten)),
<span class="lineNum">    3457 </span>            :                         sizeof(context_name));
<span class="lineNum">    3458 </span><span class="lineCov">         15 :         ast_copy_string(exten_name, ast_get_extension_name(hint-&gt;exten),</span>
<span class="lineNum">    3459 </span>            :                         sizeof(exten_name));
<span class="lineNum">    3460 </span><span class="lineCov">         15 :         ast_str_set(hint_app, 0, &quot;%s&quot;, ast_get_extension_app(hint-&gt;exten));</span>
<span class="lineNum">    3461 </span><span class="lineCov">         15 :         ao2_unlock(hint);</span>
<span class="lineNum">    3462 </span>            : 
<span class="lineNum">    3463 </span>            :         /* Check to see if update is necessary */
<span class="lineNum">    3464 </span><span class="lineCov">         15 :         if ((hint-&gt;last_presence_state == presence_state-&gt;state) &amp;&amp;</span>
<span class="lineNum">    3465 </span><span class="lineCov">          3 :             ((hint-&gt;last_presence_subtype &amp;&amp; presence_state-&gt;subtype &amp;&amp;</span>
<span class="lineNum">    3466 </span><span class="lineCov">          3 :               !strcmp(hint-&gt;last_presence_subtype, presence_state-&gt;subtype)) ||</span>
<span class="lineNum">    3467 </span><span class="lineCov">          1 :              (!hint-&gt;last_presence_subtype &amp;&amp; !presence_state-&gt;subtype)) &amp;&amp;</span>
<span class="lineNum">    3468 </span><span class="lineCov">          2 :             ((hint-&gt;last_presence_message &amp;&amp; presence_state-&gt;message &amp;&amp;</span>
<span class="lineNum">    3469 </span><span class="lineCov">          2 :               !strcmp(hint-&gt;last_presence_message, presence_state-&gt;message)) ||</span>
<span class="lineNum">    3470 </span><span class="lineCov">          1 :              (!hint-&gt;last_presence_message &amp;&amp; !presence_state-&gt;message))) {</span>
<span class="lineNum">    3471 </span>            :                 /* this update is the same as the last, do nothing */
<span class="lineNum">    3472 </span><span class="lineCov">          1 :                 return;</span>
<span class="lineNum">    3473 </span>            :         }
<span class="lineNum">    3474 </span>            : 
<span class="lineNum">    3475 </span>            :         /* update new values */
<span class="lineNum">    3476 </span><span class="lineCov">         14 :         ast_free(hint-&gt;last_presence_subtype);</span>
<span class="lineNum">    3477 </span><span class="lineCov">         14 :         ast_free(hint-&gt;last_presence_message);</span>
<span class="lineNum">    3478 </span><span class="lineCov">         14 :         hint-&gt;last_presence_state = presence_state-&gt;state;</span>
<span class="lineNum">    3479 </span><span class="lineCov">         14 :         hint-&gt;last_presence_subtype = presence_state-&gt;subtype ? ast_strdup(presence_state-&gt;subtype) : NULL;</span>
<span class="lineNum">    3480 </span><span class="lineCov">         14 :         hint-&gt;last_presence_message = presence_state-&gt;message ? ast_strdup(presence_state-&gt;message) : NULL;</span>
<span class="lineNum">    3481 </span>            : 
<span class="lineNum">    3482 </span>            :         /* For general callbacks */
<span class="lineNum">    3483 </span><span class="lineCov">         14 :         cb_iter = ao2_iterator_init(statecbs, 0);</span>
<span class="lineNum">    3484 </span><span class="lineCov">         28 :         for (; (state_cb = ao2_iterator_next(&amp;cb_iter)); ao2_ref(state_cb, -1)) {</span>
<span class="lineNum">    3485 </span><span class="lineCov">         14 :                 execute_state_callback(state_cb-&gt;change_cb,</span>
<span class="lineNum">    3486 </span>            :                         context_name,
<span class="lineNum">    3487 </span>            :                         exten_name,
<span class="lineNum">    3488 </span>            :                         state_cb-&gt;data,
<span class="lineNum">    3489 </span>            :                         AST_HINT_UPDATE_PRESENCE,
<span class="lineNum">    3490 </span>            :                         hint,
<span class="lineNum">    3491 </span>            :                         NULL);
<span class="lineNum">    3492 </span>            :         }
<span class="lineNum">    3493 </span><span class="lineCov">         14 :         ao2_iterator_destroy(&amp;cb_iter);</span>
<span class="lineNum">    3494 </span>            : 
<span class="lineNum">    3495 </span>            :         /* For extension callbacks */
<span class="lineNum">    3496 </span><span class="lineCov">         14 :         cb_iter = ao2_iterator_init(hint-&gt;callbacks, 0);</span>
<span class="lineNum">    3497 </span><span class="lineCov">         21 :         for (; (state_cb = ao2_iterator_next(&amp;cb_iter)); ao2_cleanup(state_cb)) {</span>
<span class="lineNum">    3498 </span><span class="lineCov">          7 :                 execute_state_callback(state_cb-&gt;change_cb,</span>
<span class="lineNum">    3499 </span>            :                         context_name,
<span class="lineNum">    3500 </span>            :                         exten_name,
<span class="lineNum">    3501 </span>            :                         state_cb-&gt;data,
<span class="lineNum">    3502 </span>            :                         AST_HINT_UPDATE_PRESENCE,
<span class="lineNum">    3503 </span>            :                         hint,
<span class="lineNum">    3504 </span>            :                         NULL);
<span class="lineNum">    3505 </span>            :         }
<span class="lineNum">    3506 </span><span class="lineCov">         14 :         ao2_iterator_destroy(&amp;cb_iter);</span>
<a name="3507"><span class="lineNum">    3507 </span>            : }</a>
<span class="lineNum">    3508 </span>            : 
<span class="lineNum">    3509 </span><span class="lineCov">      24376 : static int handle_hint_change_message_type(struct stasis_message *msg, enum ast_state_cb_update_reason reason)</span>
<span class="lineNum">    3510 </span>            : {
<span class="lineNum">    3511 </span>            :         struct ast_hint *hint;
<span class="lineNum">    3512 </span>            :         struct ast_str *hint_app;
<span class="lineNum">    3513 </span>            : 
<span class="lineNum">    3514 </span><span class="lineCov">      24376 :         if (hint_change_message_type() != stasis_message_type(msg)) {</span>
<span class="lineNum">    3515 </span><span class="lineCov">      24376 :                 return 0;</span>
<span class="lineNum">    3516 </span>            :         }
<span class="lineNum">    3517 </span>            : 
<span class="lineNum">    3518 </span><span class="lineNoCov">          0 :         if (!(hint_app = ast_str_create(1024))) {</span>
<span class="lineNum">    3519 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3520 </span>            :         }
<span class="lineNum">    3521 </span>            : 
<span class="lineNum">    3522 </span><span class="lineNoCov">          0 :         hint = stasis_message_data(msg);</span>
<span class="lineNum">    3523 </span>            : 
<span class="lineNum">    3524 </span><span class="lineNoCov">          0 :         switch (reason) {</span>
<span class="lineNum">    3525 </span><span class="lineNoCov">          0 :         case AST_HINT_UPDATE_DEVICE:</span>
<span class="lineNum">    3526 </span><span class="lineNoCov">          0 :                 device_state_notify_callbacks(hint, &amp;hint_app);</span>
<span class="lineNum">    3527 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3528 </span><span class="lineNoCov">          0 :         case AST_HINT_UPDATE_PRESENCE:</span>
<span class="lineNum">    3529 </span>            :                 {
<span class="lineNum">    3530 </span><span class="lineNoCov">          0 :                         char *presence_subtype = NULL;</span>
<span class="lineNum">    3531 </span><span class="lineNoCov">          0 :                         char *presence_message = NULL;</span>
<span class="lineNum">    3532 </span>            :                         int state;
<span class="lineNum">    3533 </span>            : 
<span class="lineNum">    3534 </span><span class="lineNoCov">          0 :                         state = extension_presence_state_helper(</span>
<span class="lineNum">    3535 </span>            :                                 hint-&gt;exten, &amp;presence_subtype, &amp;presence_message);
<span class="lineNum">    3536 </span>            :                         {
<span class="lineNum">    3537 </span><span class="lineNoCov">          0 :                                 struct ast_presence_state_message presence_state = {</span>
<span class="lineNum">    3538 </span><span class="lineNoCov">          0 :                                         .state = state &gt; 0 ? state : AST_PRESENCE_INVALID,</span>
<span class="lineNum">    3539 </span>            :                                         .subtype = presence_subtype,
<span class="lineNum">    3540 </span>            :                                         .message = presence_message
<span class="lineNum">    3541 </span>            :                                 };
<span class="lineNum">    3542 </span>            : 
<span class="lineNum">    3543 </span><span class="lineNoCov">          0 :                                 presence_state_notify_callbacks(hint, &amp;hint_app, &amp;presence_state);</span>
<span class="lineNum">    3544 </span>            :                         }
<span class="lineNum">    3545 </span>            : 
<span class="lineNum">    3546 </span><span class="lineNoCov">          0 :                         ast_free(presence_subtype);</span>
<span class="lineNum">    3547 </span><span class="lineNoCov">          0 :                         ast_free(presence_message);</span>
<span class="lineNum">    3548 </span>            :                 }
<span class="lineNum">    3549 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3550 </span>            :         }
<span class="lineNum">    3551 </span>            : 
<span class="lineNum">    3552 </span><span class="lineNoCov">          0 :         ast_free(hint_app);</span>
<span class="lineNum">    3553 </span><span class="lineNoCov">          0 :         return 1;</span>
<a name="3554"><span class="lineNum">    3554 </span>            : }</a>
<span class="lineNum">    3555 </span>            : 
<span class="lineNum">    3556 </span><span class="lineCov">      24376 : static void device_state_cb(void *unused, struct stasis_subscription *sub, struct stasis_message *msg)</span>
<span class="lineNum">    3557 </span>            : {
<span class="lineNum">    3558 </span>            :         struct ast_device_state_message *dev_state;
<span class="lineNum">    3559 </span>            :         struct ast_str *hint_app;
<span class="lineNum">    3560 </span>            :         struct ast_hintdevice *device;
<span class="lineNum">    3561 </span>            :         struct ast_hintdevice *cmpdevice;
<span class="lineNum">    3562 </span>            :         struct ao2_iterator *dev_iter;
<span class="lineNum">    3563 </span>            :         struct ao2_iterator auto_iter;
<span class="lineNum">    3564 </span>            :         struct ast_autohint *autohint;
<span class="lineNum">    3565 </span>            :         char *virtual_device;
<span class="lineNum">    3566 </span>            :         char *type;
<span class="lineNum">    3567 </span>            :         char *device_name;
<span class="lineNum">    3568 </span>            : 
<span class="lineNum">    3569 </span><span class="lineCov">      24376 :         if (handle_hint_change_message_type(msg, AST_HINT_UPDATE_DEVICE)) {</span>
<span class="lineNum">    3570 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    3571 </span>            :         }
<span class="lineNum">    3572 </span>            : 
<span class="lineNum">    3573 </span><span class="lineCov">      24376 :         if (ast_device_state_message_type() != stasis_message_type(msg)) {</span>
<span class="lineNum">    3574 </span><span class="lineCov">       4404 :                 return;</span>
<span class="lineNum">    3575 </span>            :         }
<span class="lineNum">    3576 </span>            : 
<span class="lineNum">    3577 </span><span class="lineCov">      19972 :         dev_state = stasis_message_data(msg);</span>
<span class="lineNum">    3578 </span><span class="lineCov">      19972 :         if (dev_state-&gt;eid) {</span>
<span class="lineNum">    3579 </span>            :                 /* ignore non-aggregate states */
<span class="lineNum">    3580 </span><span class="lineCov">      10910 :                 return;</span>
<span class="lineNum">    3581 </span>            :         }
<span class="lineNum">    3582 </span>            : 
<span class="lineNum">    3583 </span><span class="lineCov">       9062 :         if (ao2_container_count(hintdevices) == 0 &amp;&amp; ao2_container_count(autohints) == 0) {</span>
<span class="lineNum">    3584 </span>            :                 /* There are no hints monitoring devices. */
<span class="lineNum">    3585 </span><span class="lineCov">       8758 :                 return;</span>
<span class="lineNum">    3586 </span>            :         }
<span class="lineNum">    3587 </span>            : 
<span class="lineNum">    3588 </span><span class="lineCov">        304 :         hint_app = ast_str_create(1024);</span>
<span class="lineNum">    3589 </span><span class="lineCov">        304 :         if (!hint_app) {</span>
<span class="lineNum">    3590 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    3591 </span>            :         }
<span class="lineNum">    3592 </span>            : 
<span class="lineNum">    3593 </span><span class="lineCov">        304 :         cmpdevice = ast_alloca(sizeof(*cmpdevice) + strlen(dev_state-&gt;device));</span>
<span class="lineNum">    3594 </span><span class="lineCov">        304 :         strcpy(cmpdevice-&gt;hintdevice, dev_state-&gt;device);</span>
<span class="lineNum">    3595 </span>            : 
<span class="lineNum">    3596 </span><span class="lineCov">        304 :         ast_mutex_lock(&amp;context_merge_lock);/* Hold off ast_merge_contexts_and_delete */</span>
<span class="lineNum">    3597 </span>            : 
<span class="lineNum">    3598 </span>            :         /* Initially we find all hints for the device and notify them */
<span class="lineNum">    3599 </span><span class="lineCov">        304 :         dev_iter = ao2_t_callback(hintdevices,</span>
<span class="lineNum">    3600 </span>            :                 OBJ_SEARCH_OBJECT | OBJ_MULTIPLE,
<span class="lineNum">    3601 </span>            :                 hintdevice_cmp_multiple,
<span class="lineNum">    3602 </span>            :                 cmpdevice,
<span class="lineNum">    3603 </span>            :                 &quot;find devices in container&quot;);
<span class="lineNum">    3604 </span><span class="lineCov">        304 :         if (dev_iter) {</span>
<span class="lineNum">    3605 </span><span class="lineCov">        446 :                 for (; (device = ao2_iterator_next(dev_iter)); ao2_t_ref(device, -1, &quot;Next device&quot;)) {</span>
<span class="lineNum">    3606 </span><span class="lineCov">        142 :                         if (device-&gt;hint) {</span>
<span class="lineNum">    3607 </span><span class="lineCov">        142 :                                 device_state_notify_callbacks(device-&gt;hint, &amp;hint_app);</span>
<span class="lineNum">    3608 </span>            :                         }
<span class="lineNum">    3609 </span>            :                 }
<span class="lineNum">    3610 </span><span class="lineCov">        304 :                 ao2_iterator_destroy(dev_iter);</span>
<span class="lineNum">    3611 </span>            :         }
<span class="lineNum">    3612 </span>            : 
<span class="lineNum">    3613 </span>            :         /* Second stage we look for any autohint contexts and if the device is not already in the hints
<span class="lineNum">    3614 </span>            :          * we create it.
<span class="lineNum">    3615 </span>            :          */
<span class="lineNum">    3616 </span><span class="lineCov">        304 :         type = ast_strdupa(dev_state-&gt;device);</span>
<span class="lineNum">    3617 </span><span class="lineCov">        304 :         if (ast_strlen_zero(type)) {</span>
<span class="lineNum">    3618 </span><span class="lineNoCov">          0 :                 goto end;</span>
<span class="lineNum">    3619 </span>            :         }
<span class="lineNum">    3620 </span>            : 
<span class="lineNum">    3621 </span>            :         /* Determine if this is a virtual/custom device or a real device */
<span class="lineNum">    3622 </span><span class="lineCov">        304 :         virtual_device = strchr(type, ':');</span>
<span class="lineNum">    3623 </span><span class="lineCov">        304 :         device_name = strchr(type, '/');</span>
<span class="lineNum">    3624 </span><span class="lineCov">        304 :         if (virtual_device &amp;&amp; (!device_name || (virtual_device &lt; device_name))) {</span>
<span class="lineNum">    3625 </span><span class="lineCov">         96 :                 device_name = virtual_device;</span>
<span class="lineNum">    3626 </span>            :         }
<span class="lineNum">    3627 </span>            : 
<span class="lineNum">    3628 </span>            :         /* Invalid device state name - not a virtual/custom device and not a real device */
<span class="lineNum">    3629 </span><span class="lineCov">        304 :         if (ast_strlen_zero(device_name)) {</span>
<span class="lineNum">    3630 </span><span class="lineNoCov">          0 :                 goto end;</span>
<span class="lineNum">    3631 </span>            :         }
<span class="lineNum">    3632 </span>            : 
<span class="lineNum">    3633 </span><span class="lineCov">        304 :         *device_name++ = '\0';</span>
<span class="lineNum">    3634 </span>            : 
<span class="lineNum">    3635 </span><span class="lineCov">        304 :         auto_iter = ao2_iterator_init(autohints, 0);</span>
<span class="lineNum">    3636 </span><span class="lineCov">        305 :         for (; (autohint = ao2_iterator_next(&amp;auto_iter)); ao2_t_ref(autohint, -1, &quot;Next autohint&quot;)) {</span>
<span class="lineNum">    3637 </span><span class="lineCov">          1 :                 if (ast_get_hint(NULL, 0, NULL, 0, NULL, autohint-&gt;context, device_name)) {</span>
<span class="lineNum">    3638 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    3639 </span>            :                 }
<span class="lineNum">    3640 </span>            : 
<span class="lineNum">    3641 </span>            :                 /* The device has no hint in the context referenced by this autohint so create one */
<span class="lineNum">    3642 </span><span class="lineCov">          1 :                 ast_add_extension(autohint-&gt;context, 0, device_name,</span>
<span class="lineNum">    3643 </span>            :                         PRIORITY_HINT, NULL, NULL, dev_state-&gt;device,
<span class="lineNum">    3644 </span><span class="lineCov">          1 :                         ast_strdup(dev_state-&gt;device), ast_free_ptr, autohint-&gt;registrar);</span>
<span class="lineNum">    3645 </span>            : 
<span class="lineNum">    3646 </span>            :                 /* Since this hint was just created there are no watchers, so we don't need to notify anyone */
<span class="lineNum">    3647 </span>            :         }
<span class="lineNum">    3648 </span><span class="lineCov">        304 :         ao2_iterator_destroy(&amp;auto_iter);</span>
<span class="lineNum">    3649 </span>            : 
<span class="lineNum">    3650 </span><span class="lineCov">        304 : end:</span>
<span class="lineNum">    3651 </span><span class="lineCov">        304 :         ast_mutex_unlock(&amp;context_merge_lock);</span>
<span class="lineNum">    3652 </span><span class="lineCov">        304 :         ast_free(hint_app);</span>
<span class="lineNum">    3653 </span><span class="lineCov">        304 :         return;</span>
<span class="lineNum">    3654 </span>            : }
<span class="lineNum">    3655 </span>            : 
<span class="lineNum">    3656 </span>            : /*!
<span class="lineNum">    3657 </span>            :  * \internal
<span class="lineNum">    3658 </span>            :  * \brief Destroy the given state callback object.
<span class="lineNum">    3659 </span>            :  *
<span class="lineNum">    3660 </span>            :  * \param doomed State callback to destroy.
<span class="lineNum">    3661 </span>            :  *
<a name="3662"><span class="lineNum">    3662 </span>            :  * \return Nothing</a>
<span class="lineNum">    3663 </span>            :  */
<span class="lineNum">    3664 </span><span class="lineCov">       1121 : static void destroy_state_cb(void *doomed)</span>
<span class="lineNum">    3665 </span>            : {
<span class="lineNum">    3666 </span><span class="lineCov">       1121 :         struct ast_state_cb *state_cb = doomed;</span>
<span class="lineNum">    3667 </span>            : 
<span class="lineNum">    3668 </span><span class="lineCov">       1121 :         if (state_cb-&gt;destroy_cb) {</span>
<span class="lineNum">    3669 </span><span class="lineCov">        103 :                 state_cb-&gt;destroy_cb(state_cb-&gt;id, state_cb-&gt;data);</span>
<span class="lineNum">    3670 </span>            :         }
<span class="lineNum">    3671 </span><span class="lineCov">       1121 : }</span>
<span class="lineNum">    3672 </span>            : 
<span class="lineNum">    3673 </span>            : /*!
<span class="lineNum">    3674 </span>            :  * \internal
<a name="3675"><span class="lineNum">    3675 </span>            :  * \brief Add watcher for extension states with destructor</a>
<span class="lineNum">    3676 </span>            :  */
<span class="lineNum">    3677 </span><span class="lineCov">       1230 : static int extension_state_add_destroy(const char *context, const char *exten,</span>
<span class="lineNum">    3678 </span>            :         ast_state_cb_type change_cb, ast_state_cb_destroy_type destroy_cb, void *data, int extended)
<span class="lineNum">    3679 </span>            : {
<span class="lineNum">    3680 </span>            :         struct ast_hint *hint;
<span class="lineNum">    3681 </span>            :         struct ast_state_cb *state_cb;
<span class="lineNum">    3682 </span>            :         struct ast_exten *e;
<span class="lineNum">    3683 </span>            :         int id;
<span class="lineNum">    3684 </span>            : 
<span class="lineNum">    3685 </span>            :         /* If there's no context and extension:  add callback to statecbs list */
<span class="lineNum">    3686 </span><span class="lineCov">       1230 :         if (!context &amp;&amp; !exten) {</span>
<span class="lineNum">    3687 </span>            :                 /* Prevent multiple adds from adding the same change_cb at the same time. */
<span class="lineNum">    3688 </span><span class="lineCov">       1127 :                 ao2_lock(statecbs);</span>
<span class="lineNum">    3689 </span>            : 
<span class="lineNum">    3690 </span>            :                 /* Remove any existing change_cb. */
<span class="lineNum">    3691 </span><span class="lineCov">       1127 :                 ao2_find(statecbs, change_cb, OBJ_UNLINK | OBJ_NODATA);</span>
<span class="lineNum">    3692 </span>            : 
<span class="lineNum">    3693 </span>            :                 /* Now insert the change_cb */
<span class="lineNum">    3694 </span><span class="lineCov">       1127 :                 if (!(state_cb = ao2_alloc(sizeof(*state_cb), destroy_state_cb))) {</span>
<span class="lineNum">    3695 </span><span class="lineNoCov">          0 :                         ao2_unlock(statecbs);</span>
<span class="lineNum">    3696 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    3697 </span>            :                 }
<span class="lineNum">    3698 </span><span class="lineCov">       1127 :                 state_cb-&gt;id = 0;</span>
<span class="lineNum">    3699 </span><span class="lineCov">       1127 :                 state_cb-&gt;change_cb = change_cb;</span>
<span class="lineNum">    3700 </span><span class="lineCov">       1127 :                 state_cb-&gt;destroy_cb = destroy_cb;</span>
<span class="lineNum">    3701 </span><span class="lineCov">       1127 :                 state_cb-&gt;data = data;</span>
<span class="lineNum">    3702 </span><span class="lineCov">       1127 :                 state_cb-&gt;extended = extended;</span>
<span class="lineNum">    3703 </span><span class="lineCov">       1127 :                 ao2_link(statecbs, state_cb);</span>
<span class="lineNum">    3704 </span>            : 
<span class="lineNum">    3705 </span><span class="lineCov">       1127 :                 ao2_ref(state_cb, -1);</span>
<span class="lineNum">    3706 </span><span class="lineCov">       1127 :                 ao2_unlock(statecbs);</span>
<span class="lineNum">    3707 </span><span class="lineCov">       1127 :                 return 0;</span>
<span class="lineNum">    3708 </span>            :         }
<span class="lineNum">    3709 </span>            : 
<span class="lineNum">    3710 </span><span class="lineCov">        103 :         if (!context || !exten)</span>
<span class="lineNum">    3711 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3712 </span>            : 
<span class="lineNum">    3713 </span>            :         /* This callback type is for only one hint, so get the hint */
<span class="lineNum">    3714 </span><span class="lineCov">        103 :         e = ast_hint_extension(NULL, context, exten);</span>
<span class="lineNum">    3715 </span><span class="lineCov">        103 :         if (!e) {</span>
<span class="lineNum">    3716 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3717 </span>            :         }
<span class="lineNum">    3718 </span>            : 
<span class="lineNum">    3719 </span>            :         /* If this is a pattern, dynamically create a new extension for this
<span class="lineNum">    3720 </span>            :          * particular match.  Note that this will only happen once for each
<span class="lineNum">    3721 </span>            :          * individual extension, because the pattern will no longer match first.
<span class="lineNum">    3722 </span>            :          */
<span class="lineNum">    3723 </span><span class="lineCov">        103 :         if (e-&gt;exten[0] == '_') {</span>
<span class="lineNum">    3724 </span><span class="lineCov">         21 :                 ast_add_extension(e-&gt;parent-&gt;name, 0, exten, e-&gt;priority, e-&gt;label,</span>
<span class="lineNum">    3725 </span><span class="lineCov">         21 :                         e-&gt;matchcid ? e-&gt;cidmatch : NULL, e-&gt;app, ast_strdup(e-&gt;data), ast_free_ptr,</span>
<span class="lineNum">    3726 </span>            :                         e-&gt;registrar);
<span class="lineNum">    3727 </span><span class="lineCov">         21 :                 e = ast_hint_extension(NULL, context, exten);</span>
<span class="lineNum">    3728 </span><span class="lineCov">         21 :                 if (!e || e-&gt;exten[0] == '_') {</span>
<span class="lineNum">    3729 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    3730 </span>            :                 }
<span class="lineNum">    3731 </span>            :         }
<span class="lineNum">    3732 </span>            : 
<span class="lineNum">    3733 </span>            :         /* Find the hint in the hints container */
<span class="lineNum">    3734 </span><span class="lineCov">        103 :         ao2_lock(hints);/* Locked to hold off ast_merge_contexts_and_delete */</span>
<span class="lineNum">    3735 </span><span class="lineCov">        103 :         hint = ao2_find(hints, e, 0);</span>
<span class="lineNum">    3736 </span><span class="lineCov">        103 :         if (!hint) {</span>
<span class="lineNum">    3737 </span><span class="lineNoCov">          0 :                 ao2_unlock(hints);</span>
<span class="lineNum">    3738 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3739 </span>            :         }
<span class="lineNum">    3740 </span>            : 
<span class="lineNum">    3741 </span>            :         /* Now insert the callback in the callback list  */
<span class="lineNum">    3742 </span><span class="lineCov">        103 :         if (!(state_cb = ao2_alloc(sizeof(*state_cb), destroy_state_cb))) {</span>
<span class="lineNum">    3743 </span><span class="lineNoCov">          0 :                 ao2_ref(hint, -1);</span>
<span class="lineNum">    3744 </span><span class="lineNoCov">          0 :                 ao2_unlock(hints);</span>
<span class="lineNum">    3745 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3746 </span>            :         }
<span class="lineNum">    3747 </span>            :         do {
<span class="lineNum">    3748 </span><span class="lineCov">        103 :                 id = stateid++;         /* Unique ID for this callback */</span>
<span class="lineNum">    3749 </span>            :                 /* Do not allow id to ever be -1 or 0. */
<span class="lineNum">    3750 </span><span class="lineCov">        103 :         } while (id == -1 || id == 0);</span>
<span class="lineNum">    3751 </span><span class="lineCov">        103 :         state_cb-&gt;id = id;</span>
<span class="lineNum">    3752 </span><span class="lineCov">        103 :         state_cb-&gt;change_cb = change_cb;     /* Pointer to callback routine */</span>
<span class="lineNum">    3753 </span><span class="lineCov">        103 :         state_cb-&gt;destroy_cb = destroy_cb;</span>
<span class="lineNum">    3754 </span><span class="lineCov">        103 :         state_cb-&gt;data = data;               /* Data for the callback */</span>
<span class="lineNum">    3755 </span><span class="lineCov">        103 :         state_cb-&gt;extended = extended;</span>
<span class="lineNum">    3756 </span><span class="lineCov">        103 :         ao2_link(hint-&gt;callbacks, state_cb);</span>
<span class="lineNum">    3757 </span>            : 
<span class="lineNum">    3758 </span><span class="lineCov">        103 :         ao2_ref(state_cb, -1);</span>
<span class="lineNum">    3759 </span><span class="lineCov">        103 :         ao2_ref(hint, -1);</span>
<span class="lineNum">    3760 </span><span class="lineCov">        103 :         ao2_unlock(hints);</span>
<span class="lineNum">    3761 </span>            : 
<span class="lineNum">    3762 </span><span class="lineCov">        103 :         return id;</span>
<a name="3763"><span class="lineNum">    3763 </span>            : }</a>
<span class="lineNum">    3764 </span>            : 
<span class="lineNum">    3765 </span><span class="lineNoCov">          0 : int ast_extension_state_add_destroy(const char *context, const char *exten,</span>
<span class="lineNum">    3766 </span>            :         ast_state_cb_type change_cb, ast_state_cb_destroy_type destroy_cb, void *data)
<span class="lineNum">    3767 </span>            : {
<span class="lineNum">    3768 </span><span class="lineNoCov">          0 :         return extension_state_add_destroy(context, exten, change_cb, destroy_cb, data, 0);</span>
<a name="3769"><span class="lineNum">    3769 </span>            : }</a>
<span class="lineNum">    3770 </span>            : 
<span class="lineNum">    3771 </span><span class="lineCov">       1127 : int ast_extension_state_add(const char *context, const char *exten,</span>
<span class="lineNum">    3772 </span>            :         ast_state_cb_type change_cb, void *data)
<span class="lineNum">    3773 </span>            : {
<span class="lineNum">    3774 </span><span class="lineCov">       1127 :         return extension_state_add_destroy(context, exten, change_cb, NULL, data, 0);</span>
<a name="3775"><span class="lineNum">    3775 </span>            : }</a>
<span class="lineNum">    3776 </span>            : 
<span class="lineNum">    3777 </span><span class="lineCov">        103 : int ast_extension_state_add_destroy_extended(const char *context, const char *exten,</span>
<span class="lineNum">    3778 </span>            :         ast_state_cb_type change_cb, ast_state_cb_destroy_type destroy_cb, void *data)
<span class="lineNum">    3779 </span>            : {
<span class="lineNum">    3780 </span><span class="lineCov">        103 :         return extension_state_add_destroy(context, exten, change_cb, destroy_cb, data, 1);</span>
<a name="3781"><span class="lineNum">    3781 </span>            : }</a>
<span class="lineNum">    3782 </span>            : 
<span class="lineNum">    3783 </span><span class="lineNoCov">          0 : int ast_extension_state_add_extended(const char *context, const char *exten,</span>
<span class="lineNum">    3784 </span>            :         ast_state_cb_type change_cb, void *data)
<span class="lineNum">    3785 </span>            : {
<span class="lineNum">    3786 </span><span class="lineNoCov">          0 :         return extension_state_add_destroy(context, exten, change_cb, NULL, data, 1);</span>
<span class="lineNum">    3787 </span>            : }
<a name="3788"><span class="lineNum">    3788 </span>            : </a>
<span class="lineNum">    3789 </span>            : /*! \brief Find Hint by callback id */
<span class="lineNum">    3790 </span><span class="lineCov">         33 : static int find_hint_by_cb_id(void *obj, void *arg, int flags)</span>
<span class="lineNum">    3791 </span>            : {
<span class="lineNum">    3792 </span>            :         struct ast_state_cb *state_cb;
<span class="lineNum">    3793 </span><span class="lineCov">         33 :         const struct ast_hint *hint = obj;</span>
<span class="lineNum">    3794 </span><span class="lineCov">         33 :         int *id = arg;</span>
<span class="lineNum">    3795 </span>            : 
<span class="lineNum">    3796 </span><span class="lineCov">         33 :         if ((state_cb = ao2_find(hint-&gt;callbacks, id, 0))) {</span>
<span class="lineNum">    3797 </span><span class="lineCov">         25 :                 ao2_ref(state_cb, -1);</span>
<span class="lineNum">    3798 </span><span class="lineCov">         25 :                 return CMP_MATCH | CMP_STOP;</span>
<span class="lineNum">    3799 </span>            :         }
<span class="lineNum">    3800 </span>            : 
<span class="lineNum">    3801 </span><span class="lineCov">          8 :         return 0;</span>
<a name="3802"><span class="lineNum">    3802 </span>            : }</a>
<span class="lineNum">    3803 </span>            : 
<span class="lineNum">    3804 </span><span class="lineCov">        882 : int ast_extension_state_del(int id, ast_state_cb_type change_cb)</span>
<span class="lineNum">    3805 </span>            : {
<span class="lineNum">    3806 </span>            :         struct ast_state_cb *p_cur;
<span class="lineNum">    3807 </span><span class="lineCov">        882 :         int ret = -1;</span>
<span class="lineNum">    3808 </span>            : 
<span class="lineNum">    3809 </span><span class="lineCov">        882 :         if (!id) {      /* id == 0 is a callback without extension */</span>
<span class="lineNum">    3810 </span><span class="lineCov">        857 :                 if (!change_cb) {</span>
<span class="lineNum">    3811 </span><span class="lineNoCov">          0 :                         return ret;</span>
<span class="lineNum">    3812 </span>            :                 }
<span class="lineNum">    3813 </span><span class="lineCov">        857 :                 p_cur = ao2_find(statecbs, change_cb, OBJ_UNLINK);</span>
<span class="lineNum">    3814 </span><span class="lineCov">        857 :                 if (p_cur) {</span>
<span class="lineNum">    3815 </span><span class="lineCov">          3 :                         ret = 0;</span>
<span class="lineNum">    3816 </span><span class="lineCov">          3 :                         ao2_ref(p_cur, -1);</span>
<span class="lineNum">    3817 </span>            :                 }
<span class="lineNum">    3818 </span>            :         } else { /* callback with extension, find the callback based on ID */
<span class="lineNum">    3819 </span>            :                 struct ast_hint *hint;
<span class="lineNum">    3820 </span>            : 
<span class="lineNum">    3821 </span><span class="lineCov">         25 :                 ao2_lock(hints);/* Locked to hold off ast_merge_contexts_and_delete */</span>
<span class="lineNum">    3822 </span><span class="lineCov">         25 :                 hint = ao2_callback(hints, 0, find_hint_by_cb_id, &amp;id);</span>
<span class="lineNum">    3823 </span><span class="lineCov">         25 :                 if (hint) {</span>
<span class="lineNum">    3824 </span><span class="lineCov">         25 :                         p_cur = ao2_find(hint-&gt;callbacks, &amp;id, OBJ_UNLINK);</span>
<span class="lineNum">    3825 </span><span class="lineCov">         25 :                         if (p_cur) {</span>
<span class="lineNum">    3826 </span><span class="lineCov">         25 :                                 ret = 0;</span>
<span class="lineNum">    3827 </span><span class="lineCov">         25 :                                 ao2_ref(p_cur, -1);</span>
<span class="lineNum">    3828 </span>            :                         }
<span class="lineNum">    3829 </span><span class="lineCov">         25 :                         ao2_ref(hint, -1);</span>
<span class="lineNum">    3830 </span>            :                 }
<span class="lineNum">    3831 </span><span class="lineCov">         25 :                 ao2_unlock(hints);</span>
<span class="lineNum">    3832 </span>            :         }
<span class="lineNum">    3833 </span>            : 
<span class="lineNum">    3834 </span><span class="lineCov">        882 :         return ret;</span>
<a name="3835"><span class="lineNum">    3835 </span>            : }</a>
<span class="lineNum">    3836 </span>            : 
<span class="lineNum">    3837 </span><span class="lineCov">         58 : static int hint_id_cmp(void *obj, void *arg, int flags)</span>
<span class="lineNum">    3838 </span>            : {
<span class="lineNum">    3839 </span><span class="lineCov">         58 :         const struct ast_state_cb *cb = obj;</span>
<span class="lineNum">    3840 </span><span class="lineCov">         58 :         int *id = arg;</span>
<span class="lineNum">    3841 </span>            : 
<span class="lineNum">    3842 </span><span class="lineCov">         58 :         return (cb-&gt;id == *id) ? CMP_MATCH | CMP_STOP : 0;</span>
<span class="lineNum">    3843 </span>            : }
<span class="lineNum">    3844 </span>            : 
<span class="lineNum">    3845 </span>            : /*!
<span class="lineNum">    3846 </span>            :  * \internal
<span class="lineNum">    3847 </span>            :  * \brief Destroy the given hint object.
<span class="lineNum">    3848 </span>            :  *
<span class="lineNum">    3849 </span>            :  * \param obj Hint to destroy.
<span class="lineNum">    3850 </span>            :  *
<a name="3851"><span class="lineNum">    3851 </span>            :  * \return Nothing</a>
<span class="lineNum">    3852 </span>            :  */
<span class="lineNum">    3853 </span><span class="lineCov">        163 : static void destroy_hint(void *obj)</span>
<span class="lineNum">    3854 </span>            : {
<span class="lineNum">    3855 </span><span class="lineCov">        163 :         struct ast_hint *hint = obj;</span>
<span class="lineNum">    3856 </span>            :         int i;
<span class="lineNum">    3857 </span>            : 
<span class="lineNum">    3858 </span><span class="lineCov">        163 :         if (hint-&gt;callbacks) {</span>
<span class="lineNum">    3859 </span>            :                 struct ast_state_cb *state_cb;
<span class="lineNum">    3860 </span>            :                 const char *context_name;
<span class="lineNum">    3861 </span>            :                 const char *exten_name;
<span class="lineNum">    3862 </span>            : 
<span class="lineNum">    3863 </span><span class="lineCov">        163 :                 if (hint-&gt;exten) {</span>
<span class="lineNum">    3864 </span><span class="lineCov">          1 :                         context_name = ast_get_context_name(ast_get_extension_context(hint-&gt;exten));</span>
<span class="lineNum">    3865 </span><span class="lineCov">          1 :                         exten_name = ast_get_extension_name(hint-&gt;exten);</span>
<span class="lineNum">    3866 </span><span class="lineCov">          1 :                         hint-&gt;exten = NULL;</span>
<span class="lineNum">    3867 </span>            :                 } else {
<span class="lineNum">    3868 </span>            :                         /* The extension has already been destroyed */
<span class="lineNum">    3869 </span><span class="lineCov">        162 :                         context_name = hint-&gt;context_name;</span>
<span class="lineNum">    3870 </span><span class="lineCov">        162 :                         exten_name = hint-&gt;exten_name;</span>
<span class="lineNum">    3871 </span>            :                 }
<span class="lineNum">    3872 </span><span class="lineCov">        163 :                 hint-&gt;laststate = AST_EXTENSION_DEACTIVATED;</span>
<span class="lineNum">    3873 </span><span class="lineCov">        241 :                 while ((state_cb = ao2_callback(hint-&gt;callbacks, OBJ_UNLINK, NULL, NULL))) {</span>
<span class="lineNum">    3874 </span>            :                         /* Notify with -1 and remove all callbacks */
<span class="lineNum">    3875 </span><span class="lineCov">         78 :                         execute_state_callback(state_cb-&gt;change_cb,</span>
<span class="lineNum">    3876 </span>            :                                 context_name,
<span class="lineNum">    3877 </span>            :                                 exten_name,
<span class="lineNum">    3878 </span>            :                                 state_cb-&gt;data,
<span class="lineNum">    3879 </span>            :                                 AST_HINT_UPDATE_DEVICE,
<span class="lineNum">    3880 </span>            :                                 hint,
<span class="lineNum">    3881 </span>            :                                 NULL);
<span class="lineNum">    3882 </span><span class="lineCov">         78 :                         ao2_ref(state_cb, -1);</span>
<span class="lineNum">    3883 </span>            :                 }
<span class="lineNum">    3884 </span><span class="lineCov">        163 :                 ao2_ref(hint-&gt;callbacks, -1);</span>
<span class="lineNum">    3885 </span>            :         }
<span class="lineNum">    3886 </span>            : 
<span class="lineNum">    3887 </span><span class="lineCov">        164 :         for (i = 0; i &lt; AST_VECTOR_SIZE(&amp;hint-&gt;devices); i++) {</span>
<span class="lineNum">    3888 </span><span class="lineCov">          1 :                 char *device = AST_VECTOR_GET(&amp;hint-&gt;devices, i);</span>
<span class="lineNum">    3889 </span><span class="lineCov">          1 :                 ast_free(device);</span>
<span class="lineNum">    3890 </span>            :         }
<span class="lineNum">    3891 </span><span class="lineCov">        163 :         AST_VECTOR_FREE(&amp;hint-&gt;devices);</span>
<span class="lineNum">    3892 </span><span class="lineCov">        163 :         ast_free(hint-&gt;last_presence_subtype);</span>
<span class="lineNum">    3893 </span><span class="lineCov">        163 :         ast_free(hint-&gt;last_presence_message);</span>
<span class="lineNum">    3894 </span><span class="lineCov">        163 : }</span>
<a name="3895"><span class="lineNum">    3895 </span>            : </a>
<span class="lineNum">    3896 </span>            : /*! \brief Remove hint from extension */
<span class="lineNum">    3897 </span><span class="lineCov">        162 : static int ast_remove_hint(struct ast_exten *e)</span>
<span class="lineNum">    3898 </span>            : {
<span class="lineNum">    3899 </span>            :         /* Cleanup the Notifys if hint is removed */
<span class="lineNum">    3900 </span>            :         struct ast_hint *hint;
<span class="lineNum">    3901 </span>            : 
<span class="lineNum">    3902 </span><span class="lineCov">        162 :         if (!e) {</span>
<span class="lineNum">    3903 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3904 </span>            :         }
<span class="lineNum">    3905 </span>            : 
<span class="lineNum">    3906 </span><span class="lineCov">        162 :         hint = ao2_find(hints, e, OBJ_UNLINK);</span>
<span class="lineNum">    3907 </span><span class="lineCov">        162 :         if (!hint) {</span>
<span class="lineNum">    3908 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3909 </span>            :         }
<span class="lineNum">    3910 </span>            : 
<span class="lineNum">    3911 </span><span class="lineCov">        162 :         remove_hintdevice(hint);</span>
<span class="lineNum">    3912 </span>            : 
<span class="lineNum">    3913 </span>            :         /*
<span class="lineNum">    3914 </span>            :          * The extension is being destroyed so we must save some
<span class="lineNum">    3915 </span>            :          * information to notify that the extension is deactivated.
<span class="lineNum">    3916 </span>            :          */
<span class="lineNum">    3917 </span><span class="lineCov">        162 :         ao2_lock(hint);</span>
<span class="lineNum">    3918 </span><span class="lineCov">        162 :         ast_copy_string(hint-&gt;context_name,</span>
<span class="lineNum">    3919 </span>            :                 ast_get_context_name(ast_get_extension_context(hint-&gt;exten)),
<span class="lineNum">    3920 </span>            :                 sizeof(hint-&gt;context_name));
<span class="lineNum">    3921 </span><span class="lineCov">        162 :         ast_copy_string(hint-&gt;exten_name, ast_get_extension_name(hint-&gt;exten),</span>
<span class="lineNum">    3922 </span>            :                 sizeof(hint-&gt;exten_name));
<span class="lineNum">    3923 </span><span class="lineCov">        162 :         hint-&gt;exten = NULL;</span>
<span class="lineNum">    3924 </span><span class="lineCov">        162 :         ao2_unlock(hint);</span>
<span class="lineNum">    3925 </span>            : 
<span class="lineNum">    3926 </span><span class="lineCov">        162 :         ao2_ref(hint, -1);</span>
<span class="lineNum">    3927 </span>            : 
<span class="lineNum">    3928 </span><span class="lineCov">        162 :         return 0;</span>
<span class="lineNum">    3929 </span>            : }
<a name="3930"><span class="lineNum">    3930 </span>            : </a>
<span class="lineNum">    3931 </span>            : /*! \brief Add hint to hint list, check initial extension state */
<span class="lineNum">    3932 </span><span class="lineCov">        163 : static int ast_add_hint(struct ast_exten *e)</span>
<span class="lineNum">    3933 </span>            : {
<span class="lineNum">    3934 </span>            :         struct ast_hint *hint_new;
<span class="lineNum">    3935 </span>            :         struct ast_hint *hint_found;
<span class="lineNum">    3936 </span><span class="lineCov">        163 :         char *message = NULL;</span>
<span class="lineNum">    3937 </span><span class="lineCov">        163 :         char *subtype = NULL;</span>
<span class="lineNum">    3938 </span>            :         int presence_state;
<span class="lineNum">    3939 </span>            : 
<span class="lineNum">    3940 </span><span class="lineCov">        163 :         if (!e) {</span>
<span class="lineNum">    3941 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3942 </span>            :         }
<span class="lineNum">    3943 </span>            : 
<span class="lineNum">    3944 </span>            :         /*
<span class="lineNum">    3945 </span>            :          * We must create the hint we wish to add before determining if
<span class="lineNum">    3946 </span>            :          * it is already in the hints container to avoid possible
<span class="lineNum">    3947 </span>            :          * deadlock when getting the current extension state.
<span class="lineNum">    3948 </span>            :          */
<span class="lineNum">    3949 </span><span class="lineCov">        163 :         hint_new = ao2_alloc(sizeof(*hint_new), destroy_hint);</span>
<span class="lineNum">    3950 </span><span class="lineCov">        163 :         if (!hint_new) {</span>
<span class="lineNum">    3951 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3952 </span>            :         }
<span class="lineNum">    3953 </span><span class="lineCov">        163 :         AST_VECTOR_INIT(&amp;hint_new-&gt;devices, 8);</span>
<span class="lineNum">    3954 </span>            : 
<span class="lineNum">    3955 </span>            :         /* Initialize new hint. */
<span class="lineNum">    3956 </span><span class="lineCov">        163 :         hint_new-&gt;callbacks = ao2_container_alloc(1, NULL, hint_id_cmp);</span>
<span class="lineNum">    3957 </span><span class="lineCov">        163 :         if (!hint_new-&gt;callbacks) {</span>
<span class="lineNum">    3958 </span><span class="lineNoCov">          0 :                 ao2_ref(hint_new, -1);</span>
<span class="lineNum">    3959 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3960 </span>            :         }
<span class="lineNum">    3961 </span><span class="lineCov">        163 :         hint_new-&gt;exten = e;</span>
<span class="lineNum">    3962 </span><span class="lineCov">        163 :         if (strstr(e-&gt;app, &quot;${&quot;) &amp;&amp; e-&gt;exten[0] == '_') {</span>
<span class="lineNum">    3963 </span>            :                 /* The hint is dynamic and hasn't been evaluted yet */
<span class="lineNum">    3964 </span><span class="lineCov">          7 :                 hint_new-&gt;laststate = AST_DEVICE_INVALID;</span>
<span class="lineNum">    3965 </span><span class="lineCov">          7 :                 hint_new-&gt;last_presence_state = AST_PRESENCE_INVALID;</span>
<span class="lineNum">    3966 </span>            :         } else {
<span class="lineNum">    3967 </span><span class="lineCov">        156 :                 hint_new-&gt;laststate = ast_extension_state2(e, NULL);</span>
<span class="lineNum">    3968 </span><span class="lineCov">        156 :                 if ((presence_state = extension_presence_state_helper(e, &amp;subtype, &amp;message)) &gt; 0) {</span>
<span class="lineNum">    3969 </span><span class="lineNoCov">          0 :                         hint_new-&gt;last_presence_state = presence_state;</span>
<span class="lineNum">    3970 </span><span class="lineNoCov">          0 :                         hint_new-&gt;last_presence_subtype = subtype;</span>
<span class="lineNum">    3971 </span><span class="lineNoCov">          0 :                         hint_new-&gt;last_presence_message = message;</span>
<span class="lineNum">    3972 </span>            :                 }
<span class="lineNum">    3973 </span>            :         }
<span class="lineNum">    3974 </span>            : 
<span class="lineNum">    3975 </span>            :         /* Prevent multiple add hints from adding the same hint at the same time. */
<span class="lineNum">    3976 </span><span class="lineCov">        163 :         ao2_lock(hints);</span>
<span class="lineNum">    3977 </span>            : 
<span class="lineNum">    3978 </span>            :         /* Search if hint exists, do nothing */
<span class="lineNum">    3979 </span><span class="lineCov">        163 :         hint_found = ao2_find(hints, e, 0);</span>
<span class="lineNum">    3980 </span><span class="lineCov">        163 :         if (hint_found) {</span>
<span class="lineNum">    3981 </span><span class="lineNoCov">          0 :                 ao2_ref(hint_found, -1);</span>
<span class="lineNum">    3982 </span><span class="lineNoCov">          0 :                 ao2_unlock(hints);</span>
<span class="lineNum">    3983 </span><span class="lineNoCov">          0 :                 ao2_ref(hint_new, -1);</span>
<span class="lineNum">    3984 </span><span class="lineNoCov">          0 :                 ast_debug(2, &quot;HINTS: Not re-adding existing hint %s: %s\n&quot;,</span>
<span class="lineNum">    3985 </span>            :                         ast_get_extension_name(e), ast_get_extension_app(e));
<span class="lineNum">    3986 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    3987 </span>            :         }
<span class="lineNum">    3988 </span>            : 
<span class="lineNum">    3989 </span>            :         /* Add new hint to the hints container */
<span class="lineNum">    3990 </span><span class="lineCov">        163 :         ast_debug(2, &quot;HINTS: Adding hint %s: %s\n&quot;,</span>
<span class="lineNum">    3991 </span>            :                 ast_get_extension_name(e), ast_get_extension_app(e));
<span class="lineNum">    3992 </span><span class="lineCov">        163 :         ao2_link(hints, hint_new);</span>
<span class="lineNum">    3993 </span><span class="lineCov">        163 :         if (add_hintdevice(hint_new, ast_get_extension_app(e))) {</span>
<span class="lineNum">    3994 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Could not add devices for hint: %s@%s.\n&quot;,</span>
<span class="lineNum">    3995 </span>            :                         ast_get_extension_name(e),
<span class="lineNum">    3996 </span>            :                         ast_get_context_name(ast_get_extension_context(e)));
<span class="lineNum">    3997 </span>            :         }
<span class="lineNum">    3998 </span>            : 
<span class="lineNum">    3999 </span>            :         /* if not dynamic */
<span class="lineNum">    4000 </span><span class="lineCov">        163 :         if (!(strstr(e-&gt;app, &quot;${&quot;) &amp;&amp; e-&gt;exten[0] == '_')) {</span>
<span class="lineNum">    4001 </span>            :                 struct ast_state_cb *state_cb;
<span class="lineNum">    4002 </span>            :                 struct ao2_iterator cb_iter;
<span class="lineNum">    4003 </span>            : 
<span class="lineNum">    4004 </span>            :                 /* For general callbacks */
<span class="lineNum">    4005 </span><span class="lineCov">        156 :                 cb_iter = ao2_iterator_init(statecbs, 0);</span>
<span class="lineNum">    4006 </span><span class="lineCov">        315 :                 for (; (state_cb = ao2_iterator_next(&amp;cb_iter)); ao2_ref(state_cb, -1)) {</span>
<span class="lineNum">    4007 </span><span class="lineCov">        159 :                         execute_state_callback(state_cb-&gt;change_cb,</span>
<span class="lineNum">    4008 </span>            :                                 ast_get_context_name(ast_get_extension_context(e)),
<span class="lineNum">    4009 </span>            :                                 ast_get_extension_name(e),
<span class="lineNum">    4010 </span>            :                                 state_cb-&gt;data,
<span class="lineNum">    4011 </span>            :                                 AST_HINT_UPDATE_DEVICE,
<span class="lineNum">    4012 </span>            :                                 hint_new,
<span class="lineNum">    4013 </span>            :                                 NULL);
<span class="lineNum">    4014 </span>            :                 }
<span class="lineNum">    4015 </span><span class="lineCov">        156 :                 ao2_iterator_destroy(&amp;cb_iter);</span>
<span class="lineNum">    4016 </span>            :         }
<span class="lineNum">    4017 </span><span class="lineCov">        163 :         ao2_unlock(hints);</span>
<span class="lineNum">    4018 </span><span class="lineCov">        163 :         ao2_ref(hint_new, -1);</span>
<span class="lineNum">    4019 </span>            : 
<span class="lineNum">    4020 </span><span class="lineCov">        163 :         return 0;</span>
<span class="lineNum">    4021 </span>            : }
<a name="4022"><span class="lineNum">    4022 </span>            : </a>
<span class="lineNum">    4023 </span>            : /*! \brief Publish a hint changed event  */
<span class="lineNum">    4024 </span><span class="lineNoCov">          0 : static int publish_hint_change(struct ast_hint *hint, struct ast_exten *ne)</span>
<span class="lineNum">    4025 </span>            : {
<span class="lineNum">    4026 </span>            :         struct stasis_message *message;
<span class="lineNum">    4027 </span>            : 
<span class="lineNum">    4028 </span><span class="lineNoCov">          0 :         if (!hint_change_message_type()) {</span>
<span class="lineNum">    4029 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    4030 </span>            :         }
<span class="lineNum">    4031 </span>            : 
<span class="lineNum">    4032 </span>            :         /* The message is going to be published to two topics so the hint needs two refs */
<span class="lineNum">    4033 </span><span class="lineNoCov">          0 :         if (!(message = stasis_message_create(hint_change_message_type(), ao2_bump(hint)))) {</span>
<span class="lineNum">    4034 </span><span class="lineNoCov">          0 :                 ao2_ref(hint, -1);</span>
<span class="lineNum">    4035 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    4036 </span>            :         }
<span class="lineNum">    4037 </span>            : 
<span class="lineNum">    4038 </span><span class="lineNoCov">          0 :         stasis_publish(ast_device_state_topic_all(), message);</span>
<span class="lineNum">    4039 </span><span class="lineNoCov">          0 :         stasis_publish(ast_presence_state_topic_all(), message);</span>
<span class="lineNum">    4040 </span>            : 
<span class="lineNum">    4041 </span><span class="lineNoCov">          0 :         ao2_ref(message, -1);</span>
<span class="lineNum">    4042 </span>            : 
<span class="lineNum">    4043 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    4044 </span>            : }
<a name="4045"><span class="lineNum">    4045 </span>            : </a>
<span class="lineNum">    4046 </span>            : /*! \brief Change hint for an extension */
<span class="lineNum">    4047 </span><span class="lineNoCov">          0 : static int ast_change_hint(struct ast_exten *oe, struct ast_exten *ne)</span>
<span class="lineNum">    4048 </span>            : {
<span class="lineNum">    4049 </span>            :         struct ast_hint *hint;
<span class="lineNum">    4050 </span>            : 
<span class="lineNum">    4051 </span><span class="lineNoCov">          0 :         if (!oe || !ne) {</span>
<span class="lineNum">    4052 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    4053 </span>            :         }
<span class="lineNum">    4054 </span>            : 
<span class="lineNum">    4055 </span><span class="lineNoCov">          0 :         ao2_lock(hints);/* Locked to hold off others while we move the hint around. */</span>
<span class="lineNum">    4056 </span>            : 
<span class="lineNum">    4057 </span>            :         /*
<span class="lineNum">    4058 </span>            :          * Unlink the hint from the hints container as the extension
<span class="lineNum">    4059 </span>            :          * name (which is the hash value) could change.
<span class="lineNum">    4060 </span>            :          */
<span class="lineNum">    4061 </span><span class="lineNoCov">          0 :         hint = ao2_find(hints, oe, OBJ_UNLINK);</span>
<span class="lineNum">    4062 </span><span class="lineNoCov">          0 :         if (!hint) {</span>
<span class="lineNum">    4063 </span><span class="lineNoCov">          0 :                 ao2_unlock(hints);</span>
<span class="lineNum">    4064 </span><span class="lineNoCov">          0 :                 ast_mutex_unlock(&amp;context_merge_lock);</span>
<span class="lineNum">    4065 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    4066 </span>            :         }
<span class="lineNum">    4067 </span>            : 
<span class="lineNum">    4068 </span><span class="lineNoCov">          0 :         remove_hintdevice(hint);</span>
<span class="lineNum">    4069 </span>            : 
<span class="lineNum">    4070 </span>            :         /* Update the hint and put it back in the hints container. */
<span class="lineNum">    4071 </span><span class="lineNoCov">          0 :         ao2_lock(hint);</span>
<span class="lineNum">    4072 </span><span class="lineNoCov">          0 :         hint-&gt;exten = ne;</span>
<span class="lineNum">    4073 </span>            : 
<span class="lineNum">    4074 </span><span class="lineNoCov">          0 :         ao2_unlock(hint);</span>
<span class="lineNum">    4075 </span>            : 
<span class="lineNum">    4076 </span><span class="lineNoCov">          0 :         ao2_link(hints, hint);</span>
<span class="lineNum">    4077 </span><span class="lineNoCov">          0 :         if (add_hintdevice(hint, ast_get_extension_app(ne))) {</span>
<span class="lineNum">    4078 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Could not add devices for hint: %s@%s.\n&quot;,</span>
<span class="lineNum">    4079 </span>            :                         ast_get_extension_name(ne),
<span class="lineNum">    4080 </span>            :                         ast_get_context_name(ast_get_extension_context(ne)));
<span class="lineNum">    4081 </span>            :         }
<span class="lineNum">    4082 </span><span class="lineNoCov">          0 :         ao2_unlock(hints);</span>
<span class="lineNum">    4083 </span>            : 
<span class="lineNum">    4084 </span><span class="lineNoCov">          0 :         publish_hint_change(hint, ne);</span>
<span class="lineNum">    4085 </span>            : 
<span class="lineNum">    4086 </span><span class="lineNoCov">          0 :         ao2_ref(hint, -1);</span>
<span class="lineNum">    4087 </span>            : 
<span class="lineNum">    4088 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    4089 </span>            : }
<a name="4090"><span class="lineNum">    4090 </span>            : </a>
<span class="lineNum">    4091 </span>            : /*! \brief Get hint for channel */
<span class="lineNum">    4092 </span><span class="lineCov">       1101 : int ast_get_hint(char *hint, int hintsize, char *name, int namesize, struct ast_channel *c, const char *context, const char *exten)</span>
<span class="lineNum">    4093 </span>            : {
<span class="lineNum">    4094 </span><span class="lineCov">       1101 :         struct ast_exten *e = ast_hint_extension(c, context, exten);</span>
<span class="lineNum">    4095 </span>            : 
<span class="lineNum">    4096 </span><span class="lineCov">       1101 :         if (e) {</span>
<span class="lineNum">    4097 </span><span class="lineCov">        211 :                 if (hint)</span>
<span class="lineNum">    4098 </span><span class="lineCov">        199 :                         ast_copy_string(hint, ast_get_extension_app(e), hintsize);</span>
<span class="lineNum">    4099 </span><span class="lineCov">        211 :                 if (name) {</span>
<span class="lineNum">    4100 </span><span class="lineNoCov">          0 :                         const char *tmp = ast_get_extension_app_data(e);</span>
<span class="lineNum">    4101 </span><span class="lineNoCov">          0 :                         if (tmp)</span>
<span class="lineNum">    4102 </span><span class="lineNoCov">          0 :                                 ast_copy_string(name, tmp, namesize);</span>
<span class="lineNum">    4103 </span>            :                 }
<span class="lineNum">    4104 </span><span class="lineCov">        211 :                 return -1;</span>
<span class="lineNum">    4105 </span>            :         }
<span class="lineNum">    4106 </span><span class="lineCov">        890 :         return 0;</span>
<span class="lineNum">    4107 </span>            : }
<a name="4108"><span class="lineNum">    4108 </span>            : </a>
<span class="lineNum">    4109 </span>            : /*! \brief Get hint for channel */
<span class="lineNum">    4110 </span><span class="lineNoCov">          0 : int ast_str_get_hint(struct ast_str **hint, ssize_t hintsize, struct ast_str **name, ssize_t namesize, struct ast_channel *c, const char *context, const char *exten)</span>
<span class="lineNum">    4111 </span>            : {
<span class="lineNum">    4112 </span><span class="lineNoCov">          0 :         struct ast_exten *e = ast_hint_extension(c, context, exten);</span>
<span class="lineNum">    4113 </span>            : 
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 :         if (!e) {</span>
<span class="lineNum">    4115 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    4116 </span>            :         }
<span class="lineNum">    4117 </span>            : 
<span class="lineNum">    4118 </span><span class="lineNoCov">          0 :         if (hint) {</span>
<span class="lineNum">    4119 </span><span class="lineNoCov">          0 :                 ast_str_set(hint, hintsize, &quot;%s&quot;, ast_get_extension_app(e));</span>
<span class="lineNum">    4120 </span>            :         }
<span class="lineNum">    4121 </span><span class="lineNoCov">          0 :         if (name) {</span>
<span class="lineNum">    4122 </span><span class="lineNoCov">          0 :                 const char *tmp = ast_get_extension_app_data(e);</span>
<span class="lineNum">    4123 </span><span class="lineNoCov">          0 :                 if (tmp) {</span>
<span class="lineNum">    4124 </span><span class="lineNoCov">          0 :                         ast_str_set(name, namesize, &quot;%s&quot;, tmp);</span>
<span class="lineNum">    4125 </span>            :                 }
<span class="lineNum">    4126 </span>            :         }
<span class="lineNum">    4127 </span><span class="lineNoCov">          0 :         return -1;</span>
<a name="4128"><span class="lineNum">    4128 </span>            : }</a>
<span class="lineNum">    4129 </span>            : 
<span class="lineNum">    4130 </span><span class="lineCov">       9627 : int ast_exists_extension(struct ast_channel *c, const char *context, const char *exten, int priority, const char *callerid)</span>
<span class="lineNum">    4131 </span>            : {
<span class="lineNum">    4132 </span><span class="lineCov">       9627 :         return pbx_extension_helper(c, NULL, context, exten, priority, NULL, callerid, E_MATCH, 0, 0);</span>
<a name="4133"><span class="lineNum">    4133 </span>            : }</a>
<span class="lineNum">    4134 </span>            : 
<span class="lineNum">    4135 </span><span class="lineCov">        775 : int ast_findlabel_extension(struct ast_channel *c, const char *context, const char *exten, const char *label, const char *callerid)</span>
<span class="lineNum">    4136 </span>            : {
<span class="lineNum">    4137 </span><span class="lineCov">        775 :         return pbx_extension_helper(c, NULL, context, exten, 0, label, callerid, E_FINDLABEL, 0, 0);</span>
<a name="4138"><span class="lineNum">    4138 </span>            : }</a>
<span class="lineNum">    4139 </span>            : 
<span class="lineNum">    4140 </span><span class="lineCov">          2 : int ast_findlabel_extension2(struct ast_channel *c, struct ast_context *con, const char *exten, const char *label, const char *callerid)</span>
<span class="lineNum">    4141 </span>            : {
<span class="lineNum">    4142 </span><span class="lineCov">          2 :         return pbx_extension_helper(c, con, NULL, exten, 0, label, callerid, E_FINDLABEL, 0, 0);</span>
<a name="4143"><span class="lineNum">    4143 </span>            : }</a>
<span class="lineNum">    4144 </span>            : 
<span class="lineNum">    4145 </span><span class="lineCov">        184 : int ast_canmatch_extension(struct ast_channel *c, const char *context, const char *exten, int priority, const char *callerid)</span>
<span class="lineNum">    4146 </span>            : {
<span class="lineNum">    4147 </span><span class="lineCov">        184 :         return pbx_extension_helper(c, NULL, context, exten, priority, NULL, callerid, E_CANMATCH, 0, 0);</span>
<a name="4148"><span class="lineNum">    4148 </span>            : }</a>
<span class="lineNum">    4149 </span>            : 
<span class="lineNum">    4150 </span><span class="lineCov">        240 : int ast_matchmore_extension(struct ast_channel *c, const char *context, const char *exten, int priority, const char *callerid)</span>
<span class="lineNum">    4151 </span>            : {
<span class="lineNum">    4152 </span><span class="lineCov">        240 :         return pbx_extension_helper(c, NULL, context, exten, priority, NULL, callerid, E_MATCHMORE, 0, 0);</span>
<a name="4153"><span class="lineNum">    4153 </span>            : }</a>
<span class="lineNum">    4154 </span>            : 
<span class="lineNum">    4155 </span><span class="lineCov">      17493 : int ast_spawn_extension(struct ast_channel *c, const char *context, const char *exten, int priority, const char *callerid, int *found, int combined_find_spawn)</span>
<span class="lineNum">    4156 </span>            : {
<span class="lineNum">    4157 </span><span class="lineCov">      17493 :         return pbx_extension_helper(c, NULL, context, exten, priority, NULL, callerid, E_SPAWN, found, combined_find_spawn);</span>
<a name="4158"><span class="lineNum">    4158 </span>            : }</a>
<span class="lineNum">    4159 </span>            : 
<span class="lineNum">    4160 </span><span class="lineCov">        479 : void ast_pbx_h_exten_run(struct ast_channel *chan, const char *context)</span>
<span class="lineNum">    4161 </span>            : {
<span class="lineNum">    4162 </span>            :         int autoloopflag;
<span class="lineNum">    4163 </span>            :         int found;
<span class="lineNum">    4164 </span>            :         int spawn_error;
<span class="lineNum">    4165 </span>            : 
<span class="lineNum">    4166 </span><span class="lineCov">        479 :         ast_channel_lock(chan);</span>
<span class="lineNum">    4167 </span>            : 
<span class="lineNum">    4168 </span>            :         /*
<span class="lineNum">    4169 </span>            :          * Make sure that the channel is marked as hungup since we are
<span class="lineNum">    4170 </span>            :          * going to run the h exten on it.
<span class="lineNum">    4171 </span>            :          */
<span class="lineNum">    4172 </span><span class="lineCov">        479 :         ast_softhangup_nolock(chan, AST_SOFTHANGUP_HANGUP_EXEC);</span>
<span class="lineNum">    4173 </span>            : 
<span class="lineNum">    4174 </span>            :         /* Set h exten location */
<span class="lineNum">    4175 </span><span class="lineCov">        479 :         if (context != ast_channel_context(chan)) {</span>
<span class="lineNum">    4176 </span><span class="lineCov">          1 :                 ast_channel_context_set(chan, context);</span>
<span class="lineNum">    4177 </span>            :         }
<span class="lineNum">    4178 </span><span class="lineCov">        479 :         ast_channel_exten_set(chan, &quot;h&quot;);</span>
<span class="lineNum">    4179 </span><span class="lineCov">        479 :         ast_channel_priority_set(chan, 1);</span>
<span class="lineNum">    4180 </span>            : 
<span class="lineNum">    4181 </span>            :         /* Save autoloop flag */
<span class="lineNum">    4182 </span><span class="lineCov">        479 :         autoloopflag = ast_test_flag(ast_channel_flags(chan), AST_FLAG_IN_AUTOLOOP);</span>
<span class="lineNum">    4183 </span><span class="lineCov">        479 :         ast_set_flag(ast_channel_flags(chan), AST_FLAG_IN_AUTOLOOP);</span>
<span class="lineNum">    4184 </span><span class="lineCov">        479 :         ast_channel_unlock(chan);</span>
<span class="lineNum">    4185 </span>            : 
<span class="lineNum">    4186 </span>            :         for (;;) {
<span class="lineNum">    4187 </span><span class="lineCov">       2553 :                 spawn_error = ast_spawn_extension(chan, ast_channel_context(chan),</span>
<span class="lineNum">    4188 </span>            :                         ast_channel_exten(chan), ast_channel_priority(chan),
<span class="lineNum">    4189 </span><span class="lineCov">       1516 :                         S_COR(ast_channel_caller(chan)-&gt;id.number.valid,</span>
<span class="lineNum">    4190 </span>            :                                 ast_channel_caller(chan)-&gt;id.number.str, NULL), &amp;found, 1);
<span class="lineNum">    4191 </span>            : 
<span class="lineNum">    4192 </span><span class="lineCov">       1516 :                 ast_channel_lock(chan);</span>
<span class="lineNum">    4193 </span><span class="lineCov">       1516 :                 if (spawn_error) {</span>
<span class="lineNum">    4194 </span>            :                         /* The code after the loop needs the channel locked. */
<span class="lineNum">    4195 </span><span class="lineCov">        479 :                         break;</span>
<span class="lineNum">    4196 </span>            :                 }
<span class="lineNum">    4197 </span><span class="lineCov">       1037 :                 ast_channel_priority_set(chan, ast_channel_priority(chan) + 1);</span>
<span class="lineNum">    4198 </span><span class="lineCov">       1037 :                 ast_channel_unlock(chan);</span>
<span class="lineNum">    4199 </span>            :         }
<span class="lineNum">    4200 </span><span class="lineCov">        479 :         if (found &amp;&amp; spawn_error) {</span>
<span class="lineNum">    4201 </span>            :                 /* Something bad happened, or a hangup has been requested. */
<span class="lineNum">    4202 </span><span class="lineCov">         49 :                 ast_debug(1, &quot;Spawn extension (%s,%s,%d) exited non-zero on '%s'\n&quot;,</span>
<span class="lineNum">    4203 </span>            :                         ast_channel_context(chan), ast_channel_exten(chan),
<span class="lineNum">    4204 </span>            :                         ast_channel_priority(chan), ast_channel_name(chan));
<span class="lineNum">    4205 </span><span class="lineCov">         49 :                 ast_verb(2, &quot;Spawn extension (%s, %s, %d) exited non-zero on '%s'\n&quot;,</span>
<span class="lineNum">    4206 </span>            :                         ast_channel_context(chan), ast_channel_exten(chan),
<span class="lineNum">    4207 </span>            :                         ast_channel_priority(chan), ast_channel_name(chan));
<span class="lineNum">    4208 </span>            :         }
<span class="lineNum">    4209 </span>            : 
<span class="lineNum">    4210 </span>            :         /* An &quot;h&quot; exten has been run, so indicate that one has been run. */
<span class="lineNum">    4211 </span><span class="lineCov">        479 :         ast_set_flag(ast_channel_flags(chan), AST_FLAG_BRIDGE_HANGUP_RUN);</span>
<span class="lineNum">    4212 </span>            : 
<span class="lineNum">    4213 </span>            :         /* Restore autoloop flag */
<span class="lineNum">    4214 </span><span class="lineCov">        479 :         ast_set2_flag(ast_channel_flags(chan), autoloopflag, AST_FLAG_IN_AUTOLOOP);</span>
<span class="lineNum">    4215 </span><span class="lineCov">        479 :         ast_channel_unlock(chan);</span>
<span class="lineNum">    4216 </span><span class="lineCov">        479 : }</span>
<a name="4217"><span class="lineNum">    4217 </span>            : </a>
<span class="lineNum">    4218 </span>            : /*! helper function to set extension and priority */
<span class="lineNum">    4219 </span><span class="lineCov">         45 : void set_ext_pri(struct ast_channel *c, const char *exten, int pri)</span>
<span class="lineNum">    4220 </span>            : {
<span class="lineNum">    4221 </span><span class="lineCov">         45 :         ast_channel_lock(c);</span>
<span class="lineNum">    4222 </span><span class="lineCov">         45 :         ast_channel_exten_set(c, exten);</span>
<span class="lineNum">    4223 </span><span class="lineCov">         45 :         ast_channel_priority_set(c, pri);</span>
<span class="lineNum">    4224 </span><span class="lineCov">         45 :         ast_channel_unlock(c);</span>
<span class="lineNum">    4225 </span><span class="lineCov">         45 : }</span>
<span class="lineNum">    4226 </span>            : 
<span class="lineNum">    4227 </span>            : /*!
<span class="lineNum">    4228 </span>            :  * \brief collect digits from the channel into the buffer.
<span class="lineNum">    4229 </span>            :  * \param c, buf, buflen, pos
<span class="lineNum">    4230 </span>            :  * \param waittime is in milliseconds
<span class="lineNum">    4231 </span>            :  * \retval 0 on timeout or done.
<a name="4232"><span class="lineNum">    4232 </span>            :  * \retval -1 on error.</a>
<span class="lineNum">    4233 </span>            : */
<span class="lineNum">    4234 </span><span class="lineCov">         46 : static int collect_digits(struct ast_channel *c, int waittime, char *buf, int buflen, int pos)</span>
<span class="lineNum">    4235 </span>            : {
<span class="lineNum">    4236 </span>            :         int digit;
<span class="lineNum">    4237 </span>            : 
<span class="lineNum">    4238 </span><span class="lineCov">         46 :         buf[pos] = '\0';        /* make sure it is properly terminated */</span>
<span class="lineNum">    4239 </span><span class="lineCov">        185 :         while (ast_matchmore_extension(c, ast_channel_context(c), buf, 1,</span>
<span class="lineNum">    4240 </span><span class="lineCov">        139 :                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4241 </span>            :                 /* As long as we're willing to wait, and as long as it's not defined,
<span class="lineNum">    4242 </span>            :                    keep reading digits until we can't possibly get a right answer anymore.  */
<span class="lineNum">    4243 </span><span class="lineCov">         95 :                 digit = ast_waitfordigit(c, waittime);</span>
<span class="lineNum">    4244 </span><span class="lineCov">         95 :                 if (ast_channel_softhangup_internal_flag(c) &amp; AST_SOFTHANGUP_ASYNCGOTO) {</span>
<span class="lineNum">    4245 </span><span class="lineNoCov">          0 :                         ast_channel_clear_softhangup(c, AST_SOFTHANGUP_ASYNCGOTO);</span>
<span class="lineNum">    4246 </span>            :                 } else {
<span class="lineNum">    4247 </span><span class="lineCov">         95 :                         if (!digit)     /* No entry */</span>
<span class="lineNum">    4248 </span><span class="lineCov">          1 :                                 break;</span>
<span class="lineNum">    4249 </span><span class="lineCov">         94 :                         if (digit &lt; 0)       /* Error, maybe a  hangup */</span>
<span class="lineNum">    4250 </span><span class="lineCov">          1 :                                 return -1;</span>
<span class="lineNum">    4251 </span><span class="lineCov">         93 :                         if (pos &lt; buflen - 1) {      /* XXX maybe error otherwise ? */</span>
<span class="lineNum">    4252 </span><span class="lineCov">         93 :                                 buf[pos++] = digit;</span>
<span class="lineNum">    4253 </span><span class="lineCov">         93 :                                 buf[pos] = '\0';</span>
<span class="lineNum">    4254 </span>            :                         }
<span class="lineNum">    4255 </span><span class="lineCov">         93 :                         waittime = ast_channel_pbx(c)-&gt;dtimeoutms;</span>
<span class="lineNum">    4256 </span>            :                 }
<span class="lineNum">    4257 </span>            :         }
<span class="lineNum">    4258 </span><span class="lineCov">         45 :         return 0;</span>
<a name="4259"><span class="lineNum">    4259 </span>            : }</a>
<span class="lineNum">    4260 </span>            : 
<span class="lineNum">    4261 </span><span class="lineCov">       2900 : static enum ast_pbx_result __ast_pbx_run(struct ast_channel *c,</span>
<span class="lineNum">    4262 </span>            :                 struct ast_pbx_args *args)
<span class="lineNum">    4263 </span>            : {
<span class="lineNum">    4264 </span><span class="lineCov">       2900 :         int found = 0;  /* set if we find at least one match */</span>
<span class="lineNum">    4265 </span><span class="lineCov">       2900 :         int res = 0;</span>
<span class="lineNum">    4266 </span>            :         int autoloopflag;
<span class="lineNum">    4267 </span><span class="lineCov">       2900 :         int error = 0;          /* set an error conditions */</span>
<span class="lineNum">    4268 </span>            :         struct ast_pbx *pbx;
<span class="lineNum">    4269 </span>            :         ast_callid callid;
<span class="lineNum">    4270 </span>            : 
<span class="lineNum">    4271 </span>            :         /* A little initial setup here */
<span class="lineNum">    4272 </span><span class="lineCov">       2900 :         if (ast_channel_pbx(c)) {</span>
<span class="lineNum">    4273 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;%s already has PBX structure??\n&quot;, ast_channel_name(c));</span>
<span class="lineNum">    4274 </span>            :                 /* XXX and now what ? */
<span class="lineNum">    4275 </span><span class="lineNoCov">          0 :                 ast_free(ast_channel_pbx(c));</span>
<span class="lineNum">    4276 </span>            :         }
<span class="lineNum">    4277 </span><span class="lineCov">       2900 :         if (!(pbx = ast_calloc(1, sizeof(*pbx)))) {</span>
<span class="lineNum">    4278 </span><span class="lineNoCov">          0 :                 return AST_PBX_FAILED;</span>
<span class="lineNum">    4279 </span>            :         }
<span class="lineNum">    4280 </span>            : 
<span class="lineNum">    4281 </span><span class="lineCov">       2900 :         callid = ast_read_threadstorage_callid();</span>
<span class="lineNum">    4282 </span>            :         /* If the thread isn't already associated with a callid, we should create that association. */
<span class="lineNum">    4283 </span><span class="lineCov">       2900 :         if (!callid) {</span>
<span class="lineNum">    4284 </span>            :                 /* Associate new PBX thread with the channel call id if it is availble.
<span class="lineNum">    4285 </span>            :                  * If not, create a new one instead.
<span class="lineNum">    4286 </span>            :                  */
<span class="lineNum">    4287 </span><span class="lineCov">       2856 :                 callid = ast_channel_callid(c);</span>
<span class="lineNum">    4288 </span><span class="lineCov">       2856 :                 if (!callid) {</span>
<span class="lineNum">    4289 </span><span class="lineCov">       2059 :                         callid = ast_create_callid();</span>
<span class="lineNum">    4290 </span><span class="lineCov">       2059 :                         if (callid) {</span>
<span class="lineNum">    4291 </span><span class="lineCov">       2059 :                                 ast_channel_lock(c);</span>
<span class="lineNum">    4292 </span><span class="lineCov">       2059 :                                 ast_channel_callid_set(c, callid);</span>
<span class="lineNum">    4293 </span><span class="lineCov">       2059 :                                 ast_channel_unlock(c);</span>
<span class="lineNum">    4294 </span>            :                         }
<span class="lineNum">    4295 </span>            :                 }
<span class="lineNum">    4296 </span><span class="lineCov">       2856 :                 ast_callid_threadassoc_add(callid);</span>
<span class="lineNum">    4297 </span><span class="lineCov">       2856 :                 callid = 0;</span>
<span class="lineNum">    4298 </span>            :         }
<span class="lineNum">    4299 </span>            : 
<span class="lineNum">    4300 </span><span class="lineCov">       2900 :         ast_channel_pbx_set(c, pbx);</span>
<span class="lineNum">    4301 </span>            :         /* Set reasonable defaults */
<span class="lineNum">    4302 </span><span class="lineCov">       2900 :         ast_channel_pbx(c)-&gt;rtimeoutms = 10000;</span>
<span class="lineNum">    4303 </span><span class="lineCov">       2900 :         ast_channel_pbx(c)-&gt;dtimeoutms = 5000;</span>
<span class="lineNum">    4304 </span>            : 
<span class="lineNum">    4305 </span><span class="lineCov">       2900 :         ast_channel_lock(c);</span>
<span class="lineNum">    4306 </span><span class="lineCov">       2900 :         autoloopflag = ast_test_flag(ast_channel_flags(c), AST_FLAG_IN_AUTOLOOP);       /* save value to restore at the end */</span>
<span class="lineNum">    4307 </span><span class="lineCov">       2900 :         ast_set_flag(ast_channel_flags(c), AST_FLAG_IN_AUTOLOOP);</span>
<span class="lineNum">    4308 </span><span class="lineCov">       2900 :         ast_channel_unlock(c);</span>
<span class="lineNum">    4309 </span>            : 
<span class="lineNum">    4310 </span><span class="lineCov">       2900 :         if (ast_strlen_zero(ast_channel_exten(c))) {</span>
<span class="lineNum">    4311 </span>            :                 /* If not successful fall back to 's' - but only if there is no given exten  */
<span class="lineNum">    4312 </span><span class="lineNoCov">          0 :                 ast_verb(2, &quot;Starting %s at %s,%s,%d failed so falling back to exten 's'\n&quot;, ast_channel_name(c), ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c));</span>
<span class="lineNum">    4313 </span>            :                 /* XXX the original code used the existing priority in the call to
<span class="lineNum">    4314 </span>            :                  * ast_exists_extension(), and reset it to 1 afterwards.
<span class="lineNum">    4315 </span>            :                  * I believe the correct thing is to set it to 1 immediately.
<span class="lineNum">    4316 </span>            :                 */
<span class="lineNum">    4317 </span><span class="lineNoCov">          0 :                 set_ext_pri(c, &quot;s&quot;, 1);</span>
<span class="lineNum">    4318 </span>            :         }
<span class="lineNum">    4319 </span>            : 
<span class="lineNum">    4320 </span><span class="lineCov">        459 :         for (;;) {</span>
<span class="lineNum">    4321 </span>            :                 char dst_exten[256];    /* buffer to accumulate digits */
<span class="lineNum">    4322 </span><span class="lineCov">       3359 :                 int pos = 0;            /* XXX should check bounds */</span>
<span class="lineNum">    4323 </span><span class="lineCov">       3359 :                 int digit = 0;</span>
<span class="lineNum">    4324 </span><span class="lineCov">       3359 :                 int invalid = 0;</span>
<span class="lineNum">    4325 </span><span class="lineCov">       3359 :                 int timeout = 0;</span>
<span class="lineNum">    4326 </span>            : 
<span class="lineNum">    4327 </span>            :                 /* No digits pressed yet */
<span class="lineNum">    4328 </span><span class="lineCov">       3359 :                 dst_exten[pos] = '\0';</span>
<span class="lineNum">    4329 </span>            : 
<span class="lineNum">    4330 </span>            :                 /* loop on priorities in this context/exten */
<span class="lineNum">    4331 </span><span class="lineCov">      18368 :                 while (!(res = ast_spawn_extension(c, ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c),</span>
<span class="lineNum">    4332 </span><span class="lineCov">      15009 :                         S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL),</span>
<span class="lineNum">    4333 </span>            :                         &amp;found, 1))) {
<span class="lineNum">    4334 </span>            : 
<span class="lineNum">    4335 </span><span class="lineCov">      11903 :                         if (!ast_check_hangup(c)) {</span>
<span class="lineNum">    4336 </span><span class="lineCov">      11630 :                                 ast_channel_priority_set(c, ast_channel_priority(c) + 1);</span>
<span class="lineNum">    4337 </span><span class="lineCov">      11630 :                                 continue;</span>
<span class="lineNum">    4338 </span>            :                         }
<span class="lineNum">    4339 </span>            : 
<span class="lineNum">    4340 </span>            :                         /* Check softhangup flags. */
<span class="lineNum">    4341 </span><span class="lineCov">        273 :                         if (ast_channel_softhangup_internal_flag(c) &amp; AST_SOFTHANGUP_ASYNCGOTO) {</span>
<span class="lineNum">    4342 </span><span class="lineCov">         20 :                                 ast_channel_clear_softhangup(c, AST_SOFTHANGUP_ASYNCGOTO);</span>
<span class="lineNum">    4343 </span><span class="lineCov">         20 :                                 continue;</span>
<span class="lineNum">    4344 </span>            :                         }
<span class="lineNum">    4345 </span><span class="lineCov">        253 :                         if (ast_channel_softhangup_internal_flag(c) &amp; AST_SOFTHANGUP_TIMEOUT) {</span>
<span class="lineNum">    4346 </span><span class="lineNoCov">          0 :                                 if (ast_exists_extension(c, ast_channel_context(c), &quot;T&quot;, 1,</span>
<span class="lineNum">    4347 </span><span class="lineNoCov">          0 :                                         S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4348 </span><span class="lineNoCov">          0 :                                         set_ext_pri(c, &quot;T&quot;, 1);</span>
<span class="lineNum">    4349 </span>            :                                         /* If the AbsoluteTimeout is not reset to 0, we'll get an infinite loop */
<span class="lineNum">    4350 </span><span class="lineNoCov">          0 :                                         memset(ast_channel_whentohangup(c), 0, sizeof(*ast_channel_whentohangup(c)));</span>
<span class="lineNum">    4351 </span><span class="lineNoCov">          0 :                                         ast_channel_clear_softhangup(c, AST_SOFTHANGUP_TIMEOUT);</span>
<span class="lineNum">    4352 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    4353 </span><span class="lineNoCov">          0 :                                 } else if (ast_exists_extension(c, ast_channel_context(c), &quot;e&quot;, 1,</span>
<span class="lineNum">    4354 </span><span class="lineNoCov">          0 :                                         S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4355 </span><span class="lineNoCov">          0 :                                         raise_exception(c, &quot;ABSOLUTETIMEOUT&quot;, 1);</span>
<span class="lineNum">    4356 </span>            :                                         /* If the AbsoluteTimeout is not reset to 0, we'll get an infinite loop */
<span class="lineNum">    4357 </span><span class="lineNoCov">          0 :                                         memset(ast_channel_whentohangup(c), 0, sizeof(*ast_channel_whentohangup(c)));</span>
<span class="lineNum">    4358 </span><span class="lineNoCov">          0 :                                         ast_channel_clear_softhangup(c, AST_SOFTHANGUP_TIMEOUT);</span>
<span class="lineNum">    4359 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    4360 </span>            :                                 }
<span class="lineNum">    4361 </span>            : 
<span class="lineNum">    4362 </span>            :                                 /* Call timed out with no special extension to jump to. */
<span class="lineNum">    4363 </span><span class="lineNoCov">          0 :                                 error = 1;</span>
<span class="lineNum">    4364 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    4365 </span>            :                         }
<span class="lineNum">    4366 </span><span class="lineCov">        253 :                         ast_debug(1, &quot;Extension %s, priority %d returned normally even though call was hung up\n&quot;,</span>
<span class="lineNum">    4367 </span>            :                                 ast_channel_exten(c), ast_channel_priority(c));
<span class="lineNum">    4368 </span><span class="lineCov">        253 :                         error = 1;</span>
<span class="lineNum">    4369 </span><span class="lineCov">        253 :                         break;</span>
<span class="lineNum">    4370 </span>            :                 } /* end while  - from here on we can use 'break' to go out */
<span class="lineNum">    4371 </span><span class="lineCov">       3359 :                 if (found &amp;&amp; res) {</span>
<span class="lineNum">    4372 </span>            :                         /* Something bad happened, or a hangup has been requested. */
<span class="lineNum">    4373 </span><span class="lineCov">       2968 :                         if (strchr(&quot;0123456789ABCDEF*#&quot;, res)) {</span>
<span class="lineNum">    4374 </span><span class="lineCov">         45 :                                 ast_debug(1, &quot;Oooh, got something to jump out with ('%c')!\n&quot;, res);</span>
<span class="lineNum">    4375 </span><span class="lineCov">         45 :                                 pos = 0;</span>
<span class="lineNum">    4376 </span><span class="lineCov">         45 :                                 dst_exten[pos++] = digit = res;</span>
<span class="lineNum">    4377 </span><span class="lineCov">         45 :                                 dst_exten[pos] = '\0';</span>
<span class="lineNum">    4378 </span><span class="lineCov">       2923 :                         } else if (res == AST_PBX_INCOMPLETE) {</span>
<span class="lineNum">    4379 </span><span class="lineCov">          1 :                                 ast_debug(1, &quot;Spawn extension (%s,%s,%d) exited INCOMPLETE on '%s'\n&quot;, ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c), ast_channel_name(c));</span>
<span class="lineNum">    4380 </span><span class="lineCov">          1 :                                 ast_verb(2, &quot;Spawn extension (%s, %s, %d) exited INCOMPLETE on '%s'\n&quot;, ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c), ast_channel_name(c));</span>
<span class="lineNum">    4381 </span>            : 
<span class="lineNum">    4382 </span>            :                                 /* Don't cycle on incomplete - this will happen if the only extension that matches is our &quot;incomplete&quot; extension */
<span class="lineNum">    4383 </span><span class="lineCov">          1 :                                 if (!ast_matchmore_extension(c, ast_channel_context(c), ast_channel_exten(c), 1,</span>
<span class="lineNum">    4384 </span><span class="lineCov">          1 :                                         S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4385 </span><span class="lineNoCov">          0 :                                         invalid = 1;</span>
<span class="lineNum">    4386 </span>            :                                 } else {
<span class="lineNum">    4387 </span><span class="lineCov">          1 :                                         ast_copy_string(dst_exten, ast_channel_exten(c), sizeof(dst_exten));</span>
<span class="lineNum">    4388 </span><span class="lineCov">          1 :                                         digit = 1;</span>
<span class="lineNum">    4389 </span><span class="lineCov">          1 :                                         pos = strlen(dst_exten);</span>
<span class="lineNum">    4390 </span>            :                                 }
<span class="lineNum">    4391 </span>            :                         } else {
<span class="lineNum">    4392 </span><span class="lineCov">       2922 :                                 ast_debug(1, &quot;Spawn extension (%s,%s,%d) exited non-zero on '%s'\n&quot;, ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c), ast_channel_name(c));</span>
<span class="lineNum">    4393 </span><span class="lineCov">       2922 :                                 ast_verb(2, &quot;Spawn extension (%s, %s, %d) exited non-zero on '%s'\n&quot;, ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c), ast_channel_name(c));</span>
<span class="lineNum">    4394 </span>            : 
<span class="lineNum">    4395 </span><span class="lineCov">       2922 :                                 if ((res == AST_PBX_ERROR)</span>
<span class="lineNum">    4396 </span><span class="lineNoCov">          0 :                                         &amp;&amp; ast_exists_extension(c, ast_channel_context(c), &quot;e&quot;, 1,</span>
<span class="lineNum">    4397 </span><span class="lineNoCov">          0 :                                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4398 </span>            :                                         /* if we are already on the 'e' exten, don't jump to it again */
<span class="lineNum">    4399 </span><span class="lineNoCov">          0 :                                         if (!strcmp(ast_channel_exten(c), &quot;e&quot;)) {</span>
<span class="lineNum">    4400 </span><span class="lineNoCov">          0 :                                                 ast_verb(2, &quot;Spawn extension (%s, %s, %d) exited ERROR while already on 'e' exten on '%s'\n&quot;, ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c), ast_channel_name(c));</span>
<span class="lineNum">    4401 </span><span class="lineNoCov">          0 :                                                 error = 1;</span>
<span class="lineNum">    4402 </span>            :                                         } else {
<span class="lineNum">    4403 </span><span class="lineNoCov">          0 :                                                 raise_exception(c, &quot;ERROR&quot;, 1);</span>
<span class="lineNum">    4404 </span><span class="lineCov">        414 :                                                 continue;</span>
<span class="lineNum">    4405 </span>            :                                         }
<span class="lineNum">    4406 </span>            :                                 }
<span class="lineNum">    4407 </span>            : 
<span class="lineNum">    4408 </span><span class="lineCov">       2922 :                                 if (ast_channel_softhangup_internal_flag(c) &amp; AST_SOFTHANGUP_ASYNCGOTO) {</span>
<span class="lineNum">    4409 </span><span class="lineCov">        414 :                                         ast_channel_clear_softhangup(c, AST_SOFTHANGUP_ASYNCGOTO);</span>
<span class="lineNum">    4410 </span><span class="lineCov">        414 :                                         continue;</span>
<span class="lineNum">    4411 </span>            :                                 }
<span class="lineNum">    4412 </span><span class="lineCov">       2508 :                                 if (ast_channel_softhangup_internal_flag(c) &amp; AST_SOFTHANGUP_TIMEOUT) {</span>
<span class="lineNum">    4413 </span><span class="lineCov">          3 :                                         if (ast_exists_extension(c, ast_channel_context(c), &quot;T&quot;, 1,</span>
<span class="lineNum">    4414 </span><span class="lineCov">          3 :                                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4415 </span><span class="lineNoCov">          0 :                                                 set_ext_pri(c, &quot;T&quot;, 1);</span>
<span class="lineNum">    4416 </span>            :                                                 /* If the AbsoluteTimeout is not reset to 0, we'll get an infinite loop */
<span class="lineNum">    4417 </span><span class="lineNoCov">          0 :                                                 memset(ast_channel_whentohangup(c), 0, sizeof(*ast_channel_whentohangup(c)));</span>
<span class="lineNum">    4418 </span><span class="lineNoCov">          0 :                                                 ast_channel_clear_softhangup(c, AST_SOFTHANGUP_TIMEOUT);</span>
<span class="lineNum">    4419 </span><span class="lineNoCov">          0 :                                                 continue;</span>
<span class="lineNum">    4420 </span><span class="lineCov">          3 :                                         } else if (ast_exists_extension(c, ast_channel_context(c), &quot;e&quot;, 1,</span>
<span class="lineNum">    4421 </span><span class="lineCov">          3 :                                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4422 </span><span class="lineNoCov">          0 :                                                 raise_exception(c, &quot;ABSOLUTETIMEOUT&quot;, 1);</span>
<span class="lineNum">    4423 </span>            :                                                 /* If the AbsoluteTimeout is not reset to 0, we'll get an infinite loop */
<span class="lineNum">    4424 </span><span class="lineNoCov">          0 :                                                 memset(ast_channel_whentohangup(c), 0, sizeof(*ast_channel_whentohangup(c)));</span>
<span class="lineNum">    4425 </span><span class="lineNoCov">          0 :                                                 ast_channel_clear_softhangup(c, AST_SOFTHANGUP_TIMEOUT);</span>
<span class="lineNum">    4426 </span><span class="lineNoCov">          0 :                                                 continue;</span>
<span class="lineNum">    4427 </span>            :                                         }
<span class="lineNum">    4428 </span>            :                                         /* Call timed out with no special extension to jump to. */
<span class="lineNum">    4429 </span>            :                                 }
<span class="lineNum">    4430 </span><span class="lineCov">       2508 :                                 error = 1;</span>
<span class="lineNum">    4431 </span><span class="lineCov">       2508 :                                 break;</span>
<span class="lineNum">    4432 </span>            :                         }
<span class="lineNum">    4433 </span>            :                 }
<span class="lineNum">    4434 </span><span class="lineCov">        437 :                 if (error)</span>
<span class="lineNum">    4435 </span><span class="lineCov">        253 :                         break;</span>
<span class="lineNum">    4436 </span>            : 
<span class="lineNum">    4437 </span>            :                 /*!\note
<span class="lineNum">    4438 </span>            :                  * We get here on a failure of some kind:  non-existing extension or
<span class="lineNum">    4439 </span>            :                  * hangup.  We have options, here.  We can either catch the failure
<span class="lineNum">    4440 </span>            :                  * and continue, or we can drop out entirely. */
<span class="lineNum">    4441 </span>            : 
<span class="lineNum">    4442 </span><span class="lineCov">        184 :                 if (invalid</span>
<span class="lineNum">    4443 </span><span class="lineCov">        322 :                         || (ast_strlen_zero(dst_exten) &amp;&amp;</span>
<span class="lineNum">    4444 </span><span class="lineCov">        138 :                                 !ast_exists_extension(c, ast_channel_context(c), ast_channel_exten(c), 1,</span>
<span class="lineNum">    4445 </span><span class="lineCov">        138 :                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL)))) {</span>
<span class="lineNum">    4446 </span>            :                         /*!\note
<span class="lineNum">    4447 </span>            :                          * If there is no match at priority 1, it is not a valid extension anymore.
<span class="lineNum">    4448 </span>            :                          * Try to continue at &quot;i&quot; (for invalid) or &quot;e&quot; (for exception) or exit if
<span class="lineNum">    4449 </span>            :                          * neither exist.
<span class="lineNum">    4450 </span>            :                          */
<span class="lineNum">    4451 </span><span class="lineNoCov">          0 :                         if (ast_exists_extension(c, ast_channel_context(c), &quot;i&quot;, 1,</span>
<span class="lineNum">    4452 </span><span class="lineNoCov">          0 :                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4453 </span><span class="lineNoCov">          0 :                                 ast_verb(3, &quot;Channel '%s' sent to invalid extension: context,exten,priority=%s,%s,%d\n&quot;,</span>
<span class="lineNum">    4454 </span>            :                                         ast_channel_name(c), ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c));
<span class="lineNum">    4455 </span><span class="lineNoCov">          0 :                                 pbx_builtin_setvar_helper(c, &quot;INVALID_EXTEN&quot;, ast_channel_exten(c));</span>
<span class="lineNum">    4456 </span><span class="lineNoCov">          0 :                                 set_ext_pri(c, &quot;i&quot;, 1);</span>
<span class="lineNum">    4457 </span><span class="lineNoCov">          0 :                         } else if (ast_exists_extension(c, ast_channel_context(c), &quot;e&quot;, 1,</span>
<span class="lineNum">    4458 </span><span class="lineNoCov">          0 :                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4459 </span><span class="lineNoCov">          0 :                                 raise_exception(c, &quot;INVALID&quot;, 1);</span>
<span class="lineNum">    4460 </span>            :                         } else {
<span class="lineNum">    4461 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;Channel '%s' sent to invalid extension but no invalid handler: context,exten,priority=%s,%s,%d\n&quot;,</span>
<span class="lineNum">    4462 </span>            :                                         ast_channel_name(c), ast_channel_context(c), ast_channel_exten(c), ast_channel_priority(c));
<span class="lineNum">    4463 </span><span class="lineNoCov">          0 :                                 error = 1; /* we know what to do with it */</span>
<span class="lineNum">    4464 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    4465 </span>            :                         }
<span class="lineNum">    4466 </span><span class="lineCov">        184 :                 } else if (ast_channel_softhangup_internal_flag(c) &amp; AST_SOFTHANGUP_TIMEOUT) {</span>
<span class="lineNum">    4467 </span>            :                         /* If we get this far with AST_SOFTHANGUP_TIMEOUT, then we know that the &quot;T&quot; extension is next. */
<span class="lineNum">    4468 </span><span class="lineNoCov">          0 :                         ast_channel_clear_softhangup(c, AST_SOFTHANGUP_TIMEOUT);</span>
<span class="lineNum">    4469 </span>            :                 } else {        /* keypress received, get more digits for a full extension */
<span class="lineNum">    4470 </span><span class="lineCov">        184 :                         int waittime = 0;</span>
<span class="lineNum">    4471 </span><span class="lineCov">        184 :                         if (digit)</span>
<span class="lineNum">    4472 </span><span class="lineCov">         46 :                                 waittime = ast_channel_pbx(c)-&gt;dtimeoutms;</span>
<span class="lineNum">    4473 </span><span class="lineCov">        138 :                         else if (!autofallthrough)</span>
<span class="lineNum">    4474 </span><span class="lineNoCov">          0 :                                 waittime = ast_channel_pbx(c)-&gt;rtimeoutms;</span>
<span class="lineNum">    4475 </span><span class="lineCov">        184 :                         if (!waittime) {</span>
<span class="lineNum">    4476 </span><span class="lineCov">        138 :                                 const char *status = pbx_builtin_getvar_helper(c, &quot;DIALSTATUS&quot;);</span>
<span class="lineNum">    4477 </span><span class="lineCov">        138 :                                 if (!status)</span>
<span class="lineNum">    4478 </span><span class="lineCov">         93 :                                         status = &quot;UNKNOWN&quot;;</span>
<span class="lineNum">    4479 </span><span class="lineCov">        138 :                                 ast_verb(3, &quot;Auto fallthrough, channel '%s' status is '%s'\n&quot;, ast_channel_name(c), status);</span>
<span class="lineNum">    4480 </span><span class="lineCov">        138 :                                 if (!strcasecmp(status, &quot;CONGESTION&quot;))</span>
<span class="lineNum">    4481 </span><span class="lineCov">         25 :                                         res = indicate_congestion(c, &quot;10&quot;);</span>
<span class="lineNum">    4482 </span><span class="lineCov">        113 :                                 else if (!strcasecmp(status, &quot;CHANUNAVAIL&quot;))</span>
<span class="lineNum">    4483 </span><span class="lineCov">          2 :                                         res = indicate_congestion(c, &quot;10&quot;);</span>
<span class="lineNum">    4484 </span><span class="lineCov">        111 :                                 else if (!strcasecmp(status, &quot;BUSY&quot;))</span>
<span class="lineNum">    4485 </span><span class="lineCov">         14 :                                         res = indicate_busy(c, &quot;10&quot;);</span>
<span class="lineNum">    4486 </span><span class="lineCov">        138 :                                 error = 1; /* XXX disable message */</span>
<span class="lineNum">    4487 </span><span class="lineCov">        138 :                                 break;  /* exit from the 'for' loop */</span>
<span class="lineNum">    4488 </span>            :                         }
<span class="lineNum">    4489 </span>            : 
<span class="lineNum">    4490 </span><span class="lineCov">         46 :                         if (collect_digits(c, waittime, dst_exten, sizeof(dst_exten), pos))</span>
<span class="lineNum">    4491 </span><span class="lineCov">          1 :                                 break;</span>
<span class="lineNum">    4492 </span><span class="lineCov">         45 :                         if (res == AST_PBX_INCOMPLETE &amp;&amp; ast_strlen_zero(&amp;dst_exten[pos]))</span>
<span class="lineNum">    4493 </span><span class="lineNoCov">          0 :                                 timeout = 1;</span>
<span class="lineNum">    4494 </span><span class="lineCov">         45 :                         if (!timeout</span>
<span class="lineNum">    4495 </span><span class="lineCov">         45 :                                 &amp;&amp; ast_exists_extension(c, ast_channel_context(c), dst_exten, 1,</span>
<span class="lineNum">    4496 </span><span class="lineCov">         45 :                                         S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) { /* Prepare the next cycle */</span>
<span class="lineNum">    4497 </span><span class="lineCov">         45 :                                 set_ext_pri(c, dst_exten, 1);</span>
<span class="lineNum">    4498 </span>            :                         } else {
<span class="lineNum">    4499 </span>            :                                 /* No such extension */
<span class="lineNum">    4500 </span><span class="lineNoCov">          0 :                                 if (!timeout &amp;&amp; !ast_strlen_zero(dst_exten)) {</span>
<span class="lineNum">    4501 </span>            :                                         /* An invalid extension */
<span class="lineNum">    4502 </span><span class="lineNoCov">          0 :                                         if (ast_exists_extension(c, ast_channel_context(c), &quot;i&quot;, 1,</span>
<span class="lineNum">    4503 </span><span class="lineNoCov">          0 :                                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4504 </span><span class="lineNoCov">          0 :                                                 ast_verb(3, &quot;Invalid extension '%s' in context '%s' on %s\n&quot;, dst_exten, ast_channel_context(c), ast_channel_name(c));</span>
<span class="lineNum">    4505 </span><span class="lineNoCov">          0 :                                                 pbx_builtin_setvar_helper(c, &quot;INVALID_EXTEN&quot;, dst_exten);</span>
<span class="lineNum">    4506 </span><span class="lineNoCov">          0 :                                                 set_ext_pri(c, &quot;i&quot;, 1);</span>
<span class="lineNum">    4507 </span><span class="lineNoCov">          0 :                                         } else if (ast_exists_extension(c, ast_channel_context(c), &quot;e&quot;, 1,</span>
<span class="lineNum">    4508 </span><span class="lineNoCov">          0 :                                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4509 </span><span class="lineNoCov">          0 :                                                 raise_exception(c, &quot;INVALID&quot;, 1);</span>
<span class="lineNum">    4510 </span>            :                                         } else {
<span class="lineNum">    4511 </span><span class="lineNoCov">          0 :                                                 ast_log(LOG_WARNING,</span>
<span class="lineNum">    4512 </span>            :                                                         &quot;Invalid extension '%s', but no rule 'i' or 'e' in context '%s'\n&quot;,
<span class="lineNum">    4513 </span>            :                                                         dst_exten, ast_channel_context(c));
<span class="lineNum">    4514 </span><span class="lineNoCov">          0 :                                                 found = 1; /* XXX disable message */</span>
<span class="lineNum">    4515 </span><span class="lineNoCov">          0 :                                                 break;</span>
<span class="lineNum">    4516 </span>            :                                         }
<span class="lineNum">    4517 </span>            :                                 } else {
<span class="lineNum">    4518 </span>            :                                         /* A simple timeout */
<span class="lineNum">    4519 </span><span class="lineNoCov">          0 :                                         if (ast_exists_extension(c, ast_channel_context(c), &quot;t&quot;, 1,</span>
<span class="lineNum">    4520 </span><span class="lineNoCov">          0 :                                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4521 </span><span class="lineNoCov">          0 :                                                 ast_verb(3, &quot;Timeout on %s\n&quot;, ast_channel_name(c));</span>
<span class="lineNum">    4522 </span><span class="lineNoCov">          0 :                                                 set_ext_pri(c, &quot;t&quot;, 1);</span>
<span class="lineNum">    4523 </span><span class="lineNoCov">          0 :                                         } else if (ast_exists_extension(c, ast_channel_context(c), &quot;e&quot;, 1,</span>
<span class="lineNum">    4524 </span><span class="lineNoCov">          0 :                                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid, ast_channel_caller(c)-&gt;id.number.str, NULL))) {</span>
<span class="lineNum">    4525 </span><span class="lineNoCov">          0 :                                                 raise_exception(c, &quot;RESPONSETIMEOUT&quot;, 1);</span>
<span class="lineNum">    4526 </span>            :                                         } else {
<span class="lineNum">    4527 </span><span class="lineNoCov">          0 :                                                 ast_log(LOG_WARNING,</span>
<span class="lineNum">    4528 </span>            :                                                         &quot;Timeout, but no rule 't' or 'e' in context '%s'\n&quot;,
<span class="lineNum">    4529 </span>            :                                                         ast_channel_context(c));
<span class="lineNum">    4530 </span><span class="lineNoCov">          0 :                                                 found = 1; /* XXX disable message */</span>
<span class="lineNum">    4531 </span><span class="lineNoCov">          0 :                                                 break;</span>
<span class="lineNum">    4532 </span>            :                                         }
<span class="lineNum">    4533 </span>            :                                 }
<span class="lineNum">    4534 </span>            :                         }
<span class="lineNum">    4535 </span>            :                 }
<span class="lineNum">    4536 </span>            :         }
<span class="lineNum">    4537 </span>            : 
<span class="lineNum">    4538 </span><span class="lineCov">       2900 :         if (!found &amp;&amp; !error) {</span>
<span class="lineNum">    4539 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Don't know what to do with '%s'\n&quot;, ast_channel_name(c));</span>
<span class="lineNum">    4540 </span>            :         }
<span class="lineNum">    4541 </span>            : 
<span class="lineNum">    4542 </span><span class="lineCov">       2900 :         if (!args || !args-&gt;no_hangup_chan) {</span>
<span class="lineNum">    4543 </span><span class="lineCov">       2877 :                 ast_softhangup(c, AST_SOFTHANGUP_APPUNLOAD);</span>
<span class="lineNum">    4544 </span><span class="lineCov">       2877 :                 if (!ast_test_flag(ast_channel_flags(c), AST_FLAG_BRIDGE_HANGUP_RUN)</span>
<span class="lineNum">    4545 </span><span class="lineCov">       2877 :                         &amp;&amp; ast_exists_extension(c, ast_channel_context(c), &quot;h&quot;, 1,</span>
<span class="lineNum">    4546 </span><span class="lineCov">       2877 :                                 S_COR(ast_channel_caller(c)-&gt;id.number.valid,</span>
<span class="lineNum">    4547 </span>            :                                         ast_channel_caller(c)-&gt;id.number.str, NULL))) {
<span class="lineNum">    4548 </span><span class="lineCov">        478 :                         ast_pbx_h_exten_run(c, ast_channel_context(c));</span>
<span class="lineNum">    4549 </span>            :                 }
<span class="lineNum">    4550 </span><span class="lineCov">       2877 :                 ast_pbx_hangup_handler_run(c);</span>
<span class="lineNum">    4551 </span>            :         }
<span class="lineNum">    4552 </span>            : 
<span class="lineNum">    4553 </span><span class="lineCov">       2900 :         ast_channel_lock(c);</span>
<span class="lineNum">    4554 </span><span class="lineCov">       2900 :         ast_set2_flag(ast_channel_flags(c), autoloopflag, AST_FLAG_IN_AUTOLOOP);</span>
<span class="lineNum">    4555 </span><span class="lineCov">       2900 :         ast_clear_flag(ast_channel_flags(c), AST_FLAG_BRIDGE_HANGUP_RUN); /* from one round to the next, make sure this gets cleared */</span>
<span class="lineNum">    4556 </span><span class="lineCov">       2900 :         ast_channel_unlock(c);</span>
<span class="lineNum">    4557 </span><span class="lineCov">       2900 :         pbx_destroy(ast_channel_pbx(c));</span>
<span class="lineNum">    4558 </span><span class="lineCov">       2900 :         ast_channel_pbx_set(c, NULL);</span>
<span class="lineNum">    4559 </span>            : 
<span class="lineNum">    4560 </span><span class="lineCov">       2900 :         if (!args || !args-&gt;no_hangup_chan) {</span>
<span class="lineNum">    4561 </span><span class="lineCov">       2877 :                 ast_hangup(c);</span>
<span class="lineNum">    4562 </span>            :         }
<span class="lineNum">    4563 </span>            : 
<span class="lineNum">    4564 </span><span class="lineCov">       2900 :         return AST_PBX_SUCCESS;</span>
<span class="lineNum">    4565 </span>            : }
<span class="lineNum">    4566 </span>            : 
<span class="lineNum">    4567 </span>            : /*!
<span class="lineNum">    4568 </span>            :  * \brief Increase call count for channel
<span class="lineNum">    4569 </span>            :  * \retval 0 on success
<a name="4570"><span class="lineNum">    4570 </span>            :  * \retval non-zero if a configured limit (maxcalls, maxload, minmemfree) was reached</a>
<span class="lineNum">    4571 </span>            : */
<span class="lineNum">    4572 </span><span class="lineCov">       2900 : static int increase_call_count(const struct ast_channel *c)</span>
<span class="lineNum">    4573 </span>            : {
<span class="lineNum">    4574 </span><span class="lineCov">       2900 :         int failed = 0;</span>
<span class="lineNum">    4575 </span>            :         double curloadavg;
<span class="lineNum">    4576 </span>            : #if defined(HAVE_SYSINFO)
<span class="lineNum">    4577 </span>            :         long curfreemem;
<span class="lineNum">    4578 </span>            :         struct sysinfo sys_info;
<span class="lineNum">    4579 </span>            : #endif
<span class="lineNum">    4580 </span>            : 
<span class="lineNum">    4581 </span><span class="lineCov">       2900 :         ast_mutex_lock(&amp;maxcalllock);</span>
<span class="lineNum">    4582 </span><span class="lineCov">       2900 :         if (ast_option_maxcalls) {</span>
<span class="lineNum">    4583 </span><span class="lineNoCov">          0 :                 if (countcalls &gt;= ast_option_maxcalls) {</span>
<span class="lineNum">    4584 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Maximum call limit of %d calls exceeded by '%s'!\n&quot;, ast_option_maxcalls, ast_channel_name(c));</span>
<span class="lineNum">    4585 </span><span class="lineNoCov">          0 :                         failed = -1;</span>
<span class="lineNum">    4586 </span>            :                 }
<span class="lineNum">    4587 </span>            :         }
<span class="lineNum">    4588 </span><span class="lineCov">       2900 :         if (ast_option_maxload) {</span>
<span class="lineNum">    4589 </span><span class="lineNoCov">          0 :                 getloadavg(&amp;curloadavg, 1);</span>
<span class="lineNum">    4590 </span><span class="lineNoCov">          0 :                 if (curloadavg &gt;= ast_option_maxload) {</span>
<span class="lineNum">    4591 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Maximum loadavg limit of %f load exceeded by '%s' (currently %f)!\n&quot;, ast_option_maxload, ast_channel_name(c), curloadavg);</span>
<span class="lineNum">    4592 </span><span class="lineNoCov">          0 :                         failed = -1;</span>
<span class="lineNum">    4593 </span>            :                 }
<span class="lineNum">    4594 </span>            :         }
<span class="lineNum">    4595 </span>            : #if defined(HAVE_SYSINFO)
<span class="lineNum">    4596 </span><span class="lineCov">       2900 :         if (option_minmemfree) {</span>
<span class="lineNum">    4597 </span><span class="lineNoCov">          0 :                 if (!sysinfo(&amp;sys_info)) {</span>
<span class="lineNum">    4598 </span>            :                         /* make sure that the free system memory is above the configured low watermark
<span class="lineNum">    4599 </span>            :                          * convert the amount of freeram from mem_units to MB */
<span class="lineNum">    4600 </span><span class="lineNoCov">          0 :                         curfreemem = sys_info.freeram * sys_info.mem_unit;</span>
<span class="lineNum">    4601 </span><span class="lineNoCov">          0 :                         curfreemem /= 1024 * 1024;</span>
<span class="lineNum">    4602 </span><span class="lineNoCov">          0 :                         if (curfreemem &lt; option_minmemfree) {</span>
<span class="lineNum">    4603 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING, &quot;Available system memory (~%ldMB) is below the configured low watermark (%ldMB)\n&quot;, curfreemem, option_minmemfree);</span>
<span class="lineNum">    4604 </span><span class="lineNoCov">          0 :                                 failed = -1;</span>
<span class="lineNum">    4605 </span>            :                         }
<span class="lineNum">    4606 </span>            :                 }
<span class="lineNum">    4607 </span>            :         }
<span class="lineNum">    4608 </span>            : #endif
<span class="lineNum">    4609 </span>            : 
<span class="lineNum">    4610 </span><span class="lineCov">       2900 :         if (!failed) {</span>
<span class="lineNum">    4611 </span><span class="lineCov">       2900 :                 countcalls++;</span>
<span class="lineNum">    4612 </span><span class="lineCov">       2900 :                 totalcalls++;</span>
<span class="lineNum">    4613 </span>            :         }
<span class="lineNum">    4614 </span><span class="lineCov">       2900 :         ast_mutex_unlock(&amp;maxcalllock);</span>
<span class="lineNum">    4615 </span>            : 
<span class="lineNum">    4616 </span><span class="lineCov">       2900 :         return failed;</span>
<a name="4617"><span class="lineNum">    4617 </span>            : }</a>
<span class="lineNum">    4618 </span>            : 
<span class="lineNum">    4619 </span><span class="lineCov">       2900 : static void decrease_call_count(void)</span>
<span class="lineNum">    4620 </span>            : {
<span class="lineNum">    4621 </span><span class="lineCov">       2900 :         ast_mutex_lock(&amp;maxcalllock);</span>
<span class="lineNum">    4622 </span><span class="lineCov">       2900 :         if (countcalls &gt; 0)</span>
<span class="lineNum">    4623 </span><span class="lineCov">       2900 :                 countcalls--;</span>
<span class="lineNum">    4624 </span><span class="lineCov">       2900 :         ast_mutex_unlock(&amp;maxcalllock);</span>
<a name="4625"><span class="lineNum">    4625 </span><span class="lineCov">       2900 : }</span></a>
<span class="lineNum">    4626 </span>            : 
<span class="lineNum">    4627 </span><span class="lineCov">      71128 : static void destroy_exten(struct ast_exten *e)</span>
<span class="lineNum">    4628 </span>            : {
<span class="lineNum">    4629 </span><span class="lineCov">      71128 :         if (e-&gt;priority == PRIORITY_HINT)</span>
<span class="lineNum">    4630 </span><span class="lineCov">        162 :                 ast_remove_hint(e);</span>
<span class="lineNum">    4631 </span>            : 
<span class="lineNum">    4632 </span><span class="lineCov">      71128 :         if (e-&gt;peer_table)</span>
<span class="lineNum">    4633 </span><span class="lineCov">      52571 :                 ast_hashtab_destroy(e-&gt;peer_table,0);</span>
<span class="lineNum">    4634 </span><span class="lineCov">      71128 :         if (e-&gt;peer_label_table)</span>
<span class="lineNum">    4635 </span><span class="lineCov">      52571 :                 ast_hashtab_destroy(e-&gt;peer_label_table, 0);</span>
<span class="lineNum">    4636 </span><span class="lineCov">      71128 :         if (e-&gt;datad)</span>
<span class="lineNum">    4637 </span><span class="lineCov">      64383 :                 e-&gt;datad(e-&gt;data);</span>
<span class="lineNum">    4638 </span><span class="lineCov">      71128 :         ast_free(e);</span>
<a name="4639"><span class="lineNum">    4639 </span><span class="lineCov">      71128 : }</span></a>
<span class="lineNum">    4640 </span>            : 
<span class="lineNum">    4641 </span><span class="lineCov">       2191 : static void *pbx_thread(void *data)</span>
<span class="lineNum">    4642 </span>            : {
<span class="lineNum">    4643 </span>            :         /* Oh joyeous kernel, we're a new thread, with nothing to do but
<span class="lineNum">    4644 </span>            :            answer this channel and get it going.
<span class="lineNum">    4645 </span>            :         */
<span class="lineNum">    4646 </span>            :         /* NOTE:
<span class="lineNum">    4647 </span>            :            The launcher of this function _MUST_ increment 'countcalls'
<span class="lineNum">    4648 </span>            :            before invoking the function; it will be decremented when the
<span class="lineNum">    4649 </span>            :            PBX has finished running on the channel
<span class="lineNum">    4650 </span>            :          */
<span class="lineNum">    4651 </span><span class="lineCov">       2191 :         struct ast_channel *c = data;</span>
<span class="lineNum">    4652 </span>            : 
<span class="lineNum">    4653 </span><span class="lineCov">       2191 :         __ast_pbx_run(c, NULL);</span>
<span class="lineNum">    4654 </span><span class="lineCov">       2191 :         decrease_call_count();</span>
<span class="lineNum">    4655 </span>            : 
<span class="lineNum">    4656 </span><span class="lineCov">       2191 :         pthread_exit(NULL);</span>
<span class="lineNum">    4657 </span>            : 
<span class="lineNum">    4658 </span>            :         return NULL;
<a name="4659"><span class="lineNum">    4659 </span>            : }</a>
<span class="lineNum">    4660 </span>            : 
<span class="lineNum">    4661 </span><span class="lineCov">       2191 : enum ast_pbx_result ast_pbx_start(struct ast_channel *c)</span>
<span class="lineNum">    4662 </span>            : {
<span class="lineNum">    4663 </span>            :         pthread_t t;
<span class="lineNum">    4664 </span>            : 
<span class="lineNum">    4665 </span><span class="lineCov">       2191 :         if (!c) {</span>
<span class="lineNum">    4666 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Asked to start thread on NULL channel?\n&quot;);</span>
<span class="lineNum">    4667 </span><span class="lineNoCov">          0 :                 return AST_PBX_FAILED;</span>
<span class="lineNum">    4668 </span>            :         }
<span class="lineNum">    4669 </span>            : 
<span class="lineNum">    4670 </span><span class="lineCov">       2191 :         if (!ast_test_flag(&amp;ast_options, AST_OPT_FLAG_FULLY_BOOTED)) {</span>
<span class="lineNum">    4671 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;PBX requires Asterisk to be fully booted\n&quot;);</span>
<span class="lineNum">    4672 </span><span class="lineNoCov">          0 :                 return AST_PBX_FAILED;</span>
<span class="lineNum">    4673 </span>            :         }
<span class="lineNum">    4674 </span>            : 
<span class="lineNum">    4675 </span><span class="lineCov">       2191 :         if (increase_call_count(c))</span>
<span class="lineNum">    4676 </span><span class="lineNoCov">          0 :                 return AST_PBX_CALL_LIMIT;</span>
<span class="lineNum">    4677 </span>            : 
<span class="lineNum">    4678 </span>            :         /* Start a new thread, and get something handling this channel. */
<span class="lineNum">    4679 </span><span class="lineCov">       2191 :         if (ast_pthread_create_detached(&amp;t, NULL, pbx_thread, c)) {</span>
<span class="lineNum">    4680 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Failed to create new channel thread\n&quot;);</span>
<span class="lineNum">    4681 </span><span class="lineNoCov">          0 :                 decrease_call_count();</span>
<span class="lineNum">    4682 </span><span class="lineNoCov">          0 :                 return AST_PBX_FAILED;</span>
<span class="lineNum">    4683 </span>            :         }
<span class="lineNum">    4684 </span>            : 
<span class="lineNum">    4685 </span><span class="lineCov">       2191 :         return AST_PBX_SUCCESS;</span>
<a name="4686"><span class="lineNum">    4686 </span>            : }</a>
<span class="lineNum">    4687 </span>            : 
<span class="lineNum">    4688 </span><span class="lineCov">        709 : enum ast_pbx_result ast_pbx_run_args(struct ast_channel *c, struct ast_pbx_args *args)</span>
<span class="lineNum">    4689 </span>            : {
<span class="lineNum">    4690 </span><span class="lineCov">        709 :         enum ast_pbx_result res = AST_PBX_SUCCESS;</span>
<span class="lineNum">    4691 </span>            : 
<span class="lineNum">    4692 </span><span class="lineCov">        709 :         if (!ast_test_flag(&amp;ast_options, AST_OPT_FLAG_FULLY_BOOTED)) {</span>
<span class="lineNum">    4693 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;PBX requires Asterisk to be fully booted\n&quot;);</span>
<span class="lineNum">    4694 </span><span class="lineNoCov">          0 :                 return AST_PBX_FAILED;</span>
<span class="lineNum">    4695 </span>            :         }
<span class="lineNum">    4696 </span>            : 
<span class="lineNum">    4697 </span><span class="lineCov">        709 :         if (increase_call_count(c)) {</span>
<span class="lineNum">    4698 </span><span class="lineNoCov">          0 :                 return AST_PBX_CALL_LIMIT;</span>
<span class="lineNum">    4699 </span>            :         }
<span class="lineNum">    4700 </span>            : 
<span class="lineNum">    4701 </span><span class="lineCov">        709 :         res = __ast_pbx_run(c, args);</span>
<span class="lineNum">    4702 </span>            : 
<span class="lineNum">    4703 </span><span class="lineCov">        709 :         decrease_call_count();</span>
<span class="lineNum">    4704 </span>            : 
<span class="lineNum">    4705 </span><span class="lineCov">        709 :         return res;</span>
<a name="4706"><span class="lineNum">    4706 </span>            : }</a>
<span class="lineNum">    4707 </span>            : 
<span class="lineNum">    4708 </span><span class="lineCov">        686 : enum ast_pbx_result ast_pbx_run(struct ast_channel *c)</span>
<span class="lineNum">    4709 </span>            : {
<span class="lineNum">    4710 </span><span class="lineCov">        686 :         return ast_pbx_run_args(c, NULL);</span>
<a name="4711"><span class="lineNum">    4711 </span>            : }</a>
<span class="lineNum">    4712 </span>            : 
<span class="lineNum">    4713 </span><span class="lineCov">         40 : int ast_active_calls(void)</span>
<span class="lineNum">    4714 </span>            : {
<span class="lineNum">    4715 </span><span class="lineCov">         40 :         return countcalls;</span>
<a name="4716"><span class="lineNum">    4716 </span>            : }</a>
<span class="lineNum">    4717 </span>            : 
<span class="lineNum">    4718 </span><span class="lineCov">         40 : int ast_processed_calls(void)</span>
<span class="lineNum">    4719 </span>            : {
<span class="lineNum">    4720 </span><span class="lineCov">         40 :         return totalcalls;</span>
<a name="4721"><span class="lineNum">    4721 </span>            : }</a>
<span class="lineNum">    4722 </span>            : 
<span class="lineNum">    4723 </span><span class="lineCov">       1125 : int pbx_set_autofallthrough(int newval)</span>
<span class="lineNum">    4724 </span>            : {
<span class="lineNum">    4725 </span><span class="lineCov">       1125 :         int oldval = autofallthrough;</span>
<span class="lineNum">    4726 </span><span class="lineCov">       1125 :         autofallthrough = newval;</span>
<span class="lineNum">    4727 </span><span class="lineCov">       1125 :         return oldval;</span>
<a name="4728"><span class="lineNum">    4728 </span>            : }</a>
<span class="lineNum">    4729 </span>            : 
<span class="lineNum">    4730 </span><span class="lineCov">       1127 : int pbx_set_extenpatternmatchnew(int newval)</span>
<span class="lineNum">    4731 </span>            : {
<span class="lineNum">    4732 </span><span class="lineCov">       1127 :         int oldval = extenpatternmatchnew;</span>
<span class="lineNum">    4733 </span><span class="lineCov">       1127 :         extenpatternmatchnew = newval;</span>
<span class="lineNum">    4734 </span><span class="lineCov">       1127 :         return oldval;</span>
<a name="4735"><span class="lineNum">    4735 </span>            : }</a>
<span class="lineNum">    4736 </span>            : 
<span class="lineNum">    4737 </span><span class="lineCov">       1125 : void pbx_set_overrideswitch(const char *newval)</span>
<span class="lineNum">    4738 </span>            : {
<span class="lineNum">    4739 </span><span class="lineCov">       1125 :         if (overrideswitch) {</span>
<span class="lineNum">    4740 </span><span class="lineNoCov">          0 :                 ast_free(overrideswitch);</span>
<span class="lineNum">    4741 </span>            :         }
<span class="lineNum">    4742 </span><span class="lineCov">       1125 :         if (!ast_strlen_zero(newval)) {</span>
<span class="lineNum">    4743 </span><span class="lineNoCov">          0 :                 overrideswitch = ast_strdup(newval);</span>
<span class="lineNum">    4744 </span>            :         } else {
<span class="lineNum">    4745 </span><span class="lineCov">       1125 :                 overrideswitch = NULL;</span>
<span class="lineNum">    4746 </span>            :         }
<span class="lineNum">    4747 </span><span class="lineCov">       1125 : }</span>
<span class="lineNum">    4748 </span>            : 
<span class="lineNum">    4749 </span>            : /*!
<span class="lineNum">    4750 </span>            :  * \brief lookup for a context with a given name,
<a name="4751"><span class="lineNum">    4751 </span>            :  * \retval found context or NULL if not found.</a>
<span class="lineNum">    4752 </span>            :  */
<span class="lineNum">    4753 </span><span class="lineCov">      53753 : static struct ast_context *find_context(const char *context)</span>
<span class="lineNum">    4754 </span>            : {
<span class="lineNum">    4755 </span>            :         struct fake_context item;
<span class="lineNum">    4756 </span>            : 
<span class="lineNum">    4757 </span><span class="lineCov">      53753 :         ast_copy_string(item.name, context, sizeof(item.name));</span>
<span class="lineNum">    4758 </span>            : 
<span class="lineNum">    4759 </span><span class="lineCov">      53753 :         return ast_hashtab_lookup(contexts_table, &amp;item);</span>
<span class="lineNum">    4760 </span>            : }
<span class="lineNum">    4761 </span>            : 
<span class="lineNum">    4762 </span>            : /*!
<span class="lineNum">    4763 </span>            :  * \brief lookup for a context with a given name,
<span class="lineNum">    4764 </span>            :  * \retval with conlock held if found.
<a name="4765"><span class="lineNum">    4765 </span>            :  * \retval NULL if not found.</a>
<span class="lineNum">    4766 </span>            :  */
<span class="lineNum">    4767 </span><span class="lineCov">       6774 : static struct ast_context *find_context_locked(const char *context)</span>
<span class="lineNum">    4768 </span>            : {
<span class="lineNum">    4769 </span>            :         struct ast_context *c;
<span class="lineNum">    4770 </span>            :         struct fake_context item;
<span class="lineNum">    4771 </span>            : 
<span class="lineNum">    4772 </span><span class="lineCov">       6774 :         ast_copy_string(item.name, context, sizeof(item.name));</span>
<span class="lineNum">    4773 </span>            : 
<span class="lineNum">    4774 </span><span class="lineCov">       6774 :         ast_rdlock_contexts();</span>
<span class="lineNum">    4775 </span><span class="lineCov">       6774 :         c = ast_hashtab_lookup(contexts_table, &amp;item);</span>
<span class="lineNum">    4776 </span><span class="lineCov">       6774 :         if (!c) {</span>
<span class="lineNum">    4777 </span><span class="lineNoCov">          0 :                 ast_unlock_contexts();</span>
<span class="lineNum">    4778 </span>            :         }
<span class="lineNum">    4779 </span>            : 
<span class="lineNum">    4780 </span><span class="lineCov">       6774 :         return c;</span>
<span class="lineNum">    4781 </span>            : }
<span class="lineNum">    4782 </span>            : 
<span class="lineNum">    4783 </span>            : /*!
<span class="lineNum">    4784 </span>            :  * \brief Remove included contexts.
<span class="lineNum">    4785 </span>            :  * This function locks contexts list by &amp;conlist, search for the right context
<span class="lineNum">    4786 </span>            :  * structure, leave context list locked and call ast_context_remove_include2
<a name="4787"><span class="lineNum">    4787 </span>            :  * which removes include, unlock contexts list and return ...</a>
<span class="lineNum">    4788 </span>            :  */
<span class="lineNum">    4789 </span><span class="lineNoCov">          0 : int ast_context_remove_include(const char *context, const char *include, const char *registrar)</span>
<span class="lineNum">    4790 </span>            : {
<span class="lineNum">    4791 </span><span class="lineNoCov">          0 :         int ret = -1;</span>
<span class="lineNum">    4792 </span>            :         struct ast_context *c;
<span class="lineNum">    4793 </span>            : 
<span class="lineNum">    4794 </span><span class="lineNoCov">          0 :         c = find_context_locked(context);</span>
<span class="lineNum">    4795 </span><span class="lineNoCov">          0 :         if (c) {</span>
<span class="lineNum">    4796 </span>            :                 /* found, remove include from this context ... */
<span class="lineNum">    4797 </span><span class="lineNoCov">          0 :                 ret = ast_context_remove_include2(c, include, registrar);</span>
<span class="lineNum">    4798 </span><span class="lineNoCov">          0 :                 ast_unlock_contexts();</span>
<span class="lineNum">    4799 </span>            :         }
<span class="lineNum">    4800 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    4801 </span>            : }
<span class="lineNum">    4802 </span>            : 
<span class="lineNum">    4803 </span>            : /*!
<span class="lineNum">    4804 </span>            :  * \brief Locks context, remove included contexts, unlocks context.
<span class="lineNum">    4805 </span>            :  * When we call this function, &amp;conlock lock must be locked, because when
<span class="lineNum">    4806 </span>            :  * we giving *con argument, some process can remove/change this context
<span class="lineNum">    4807 </span>            :  * and after that there can be segfault.
<span class="lineNum">    4808 </span>            :  *
<span class="lineNum">    4809 </span>            :  * \retval 0 on success.
<a name="4810"><span class="lineNum">    4810 </span>            :  * \retval -1 on failure.</a>
<span class="lineNum">    4811 </span>            :  */
<span class="lineNum">    4812 </span><span class="lineNoCov">          0 : int ast_context_remove_include2(struct ast_context *con, const char *include, const char *registrar)</span>
<span class="lineNum">    4813 </span>            : {
<span class="lineNum">    4814 </span><span class="lineNoCov">          0 :         int ret = -1;</span>
<span class="lineNum">    4815 </span>            :         int idx;
<span class="lineNum">    4816 </span>            : 
<span class="lineNum">    4817 </span><span class="lineNoCov">          0 :         ast_wrlock_context(con);</span>
<span class="lineNum">    4818 </span>            : 
<span class="lineNum">    4819 </span>            :         /* find our include */
<span class="lineNum">    4820 </span><span class="lineNoCov">          0 :         for (idx = 0; idx &lt; ast_context_includes_count(con); idx++) {</span>
<span class="lineNum">    4821 </span><span class="lineNoCov">          0 :                 struct ast_include *i = AST_VECTOR_GET(&amp;con-&gt;includes, idx);</span>
<span class="lineNum">    4822 </span>            : 
<span class="lineNum">    4823 </span><span class="lineNoCov">          0 :                 if (!strcmp(ast_get_include_name(i), include) &amp;&amp;</span>
<span class="lineNum">    4824 </span><span class="lineNoCov">          0 :                                 (!registrar || !strcmp(ast_get_include_registrar(i), registrar))) {</span>
<span class="lineNum">    4825 </span>            : 
<span class="lineNum">    4826 </span>            :                         /* remove from list */
<span class="lineNum">    4827 </span><span class="lineNoCov">          0 :                         ast_verb(3, &quot;Removing inclusion of context '%s' in context '%s; registrar=%s'\n&quot;, include, ast_get_context_name(con), registrar);</span>
<span class="lineNum">    4828 </span><span class="lineNoCov">          0 :                         AST_VECTOR_REMOVE_ORDERED(&amp;con-&gt;includes, idx);</span>
<span class="lineNum">    4829 </span>            : 
<span class="lineNum">    4830 </span>            :                         /* free include and return */
<span class="lineNum">    4831 </span><span class="lineNoCov">          0 :                         include_free(i);</span>
<span class="lineNum">    4832 </span><span class="lineNoCov">          0 :                         ret = 0;</span>
<span class="lineNum">    4833 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    4834 </span>            :                 }
<span class="lineNum">    4835 </span>            :         }
<span class="lineNum">    4836 </span>            : 
<span class="lineNum">    4837 </span><span class="lineNoCov">          0 :         ast_unlock_context(con);</span>
<span class="lineNum">    4838 </span>            : 
<span class="lineNum">    4839 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    4840 </span>            : }
<span class="lineNum">    4841 </span>            : 
<span class="lineNum">    4842 </span>            : /*!
<span class="lineNum">    4843 </span>            :  * \note This function locks contexts list by &amp;conlist, search for the rigt context
<span class="lineNum">    4844 </span>            :  * structure, leave context list locked and call ast_context_remove_switch2
<a name="4845"><span class="lineNum">    4845 </span>            :  * which removes switch, unlock contexts list and return ...</a>
<span class="lineNum">    4846 </span>            :  */
<span class="lineNum">    4847 </span><span class="lineNoCov">          0 : int ast_context_remove_switch(const char *context, const char *sw, const char *data, const char *registrar)</span>
<span class="lineNum">    4848 </span>            : {
<span class="lineNum">    4849 </span><span class="lineNoCov">          0 :         int ret = -1; /* default error return */</span>
<span class="lineNum">    4850 </span>            :         struct ast_context *c;
<span class="lineNum">    4851 </span>            : 
<span class="lineNum">    4852 </span><span class="lineNoCov">          0 :         c = find_context_locked(context);</span>
<span class="lineNum">    4853 </span><span class="lineNoCov">          0 :         if (c) {</span>
<span class="lineNum">    4854 </span>            :                 /* remove switch from this context ... */
<span class="lineNum">    4855 </span><span class="lineNoCov">          0 :                 ret = ast_context_remove_switch2(c, sw, data, registrar);</span>
<span class="lineNum">    4856 </span><span class="lineNoCov">          0 :                 ast_unlock_contexts();</span>
<span class="lineNum">    4857 </span>            :         }
<span class="lineNum">    4858 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    4859 </span>            : }
<span class="lineNum">    4860 </span>            : 
<span class="lineNum">    4861 </span>            : /*!
<span class="lineNum">    4862 </span>            :  * \brief This function locks given context, removes switch, unlock context and
<span class="lineNum">    4863 </span>            :  * return.
<span class="lineNum">    4864 </span>            :  * \note When we call this function, &amp;conlock lock must be locked, because when
<span class="lineNum">    4865 </span>            :  * we giving *con argument, some process can remove/change this context
<span class="lineNum">    4866 </span>            :  * and after that there can be segfault.
<a name="4867"><span class="lineNum">    4867 </span>            :  *</a>
<span class="lineNum">    4868 </span>            :  */
<span class="lineNum">    4869 </span><span class="lineNoCov">          0 : int ast_context_remove_switch2(struct ast_context *con, const char *sw, const char *data, const char *registrar)</span>
<span class="lineNum">    4870 </span>            : {
<span class="lineNum">    4871 </span>            :         int idx;
<span class="lineNum">    4872 </span><span class="lineNoCov">          0 :         int ret = -1;</span>
<span class="lineNum">    4873 </span>            : 
<span class="lineNum">    4874 </span><span class="lineNoCov">          0 :         ast_wrlock_context(con);</span>
<span class="lineNum">    4875 </span>            : 
<span class="lineNum">    4876 </span>            :         /* walk switches */
<span class="lineNum">    4877 </span><span class="lineNoCov">          0 :         for (idx = 0; idx &lt; ast_context_switches_count(con); idx++) {</span>
<span class="lineNum">    4878 </span><span class="lineNoCov">          0 :                 struct ast_sw *i = AST_VECTOR_GET(&amp;con-&gt;alts, idx);</span>
<span class="lineNum">    4879 </span>            : 
<span class="lineNum">    4880 </span><span class="lineNoCov">          0 :                 if (!strcmp(ast_get_switch_name(i), sw) &amp;&amp;</span>
<span class="lineNum">    4881 </span><span class="lineNoCov">          0 :                         !strcmp(ast_get_switch_data(i), data) &amp;&amp;</span>
<span class="lineNum">    4882 </span><span class="lineNoCov">          0 :                         (!registrar || !strcmp(ast_get_switch_registrar(i), registrar))) {</span>
<span class="lineNum">    4883 </span>            : 
<span class="lineNum">    4884 </span>            :                         /* found, remove from list */
<span class="lineNum">    4885 </span><span class="lineNoCov">          0 :                         ast_verb(3, &quot;Removing switch '%s' from context '%s; registrar=%s'\n&quot;, sw, ast_get_context_name(con), registrar);</span>
<span class="lineNum">    4886 </span><span class="lineNoCov">          0 :                         AST_VECTOR_REMOVE_ORDERED(&amp;con-&gt;alts, idx);</span>
<span class="lineNum">    4887 </span>            : 
<span class="lineNum">    4888 </span>            :                         /* free switch and return */
<span class="lineNum">    4889 </span><span class="lineNoCov">          0 :                         sw_free(i);</span>
<span class="lineNum">    4890 </span><span class="lineNoCov">          0 :                         ret = 0;</span>
<span class="lineNum">    4891 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    4892 </span>            :                 }
<span class="lineNum">    4893 </span>            :         }
<span class="lineNum">    4894 </span>            : 
<span class="lineNum">    4895 </span><span class="lineNoCov">          0 :         ast_unlock_context(con);</span>
<span class="lineNum">    4896 </span>            : 
<span class="lineNum">    4897 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    4898 </span>            : }
<a name="4899"><span class="lineNum">    4899 </span>            : </a>
<span class="lineNum">    4900 </span>            : /*! \note This function will lock conlock. */
<span class="lineNum">    4901 </span><span class="lineCov">          3 : int ast_context_remove_extension(const char *context, const char *extension, int priority, const char *registrar)</span>
<span class="lineNum">    4902 </span>            : {
<span class="lineNum">    4903 </span><span class="lineCov">          3 :         return ast_context_remove_extension_callerid(context, extension, priority, NULL, AST_EXT_MATCHCID_ANY, registrar);</span>
<a name="4904"><span class="lineNum">    4904 </span>            : }</a>
<span class="lineNum">    4905 </span>            : 
<span class="lineNum">    4906 </span><span class="lineCov">          7 : int ast_context_remove_extension_callerid(const char *context, const char *extension, int priority, const char *callerid, int matchcallerid, const char *registrar)</span>
<span class="lineNum">    4907 </span>            : {
<span class="lineNum">    4908 </span><span class="lineCov">          7 :         int ret = -1; /* default error return */</span>
<span class="lineNum">    4909 </span>            :         struct ast_context *c;
<span class="lineNum">    4910 </span>            : 
<span class="lineNum">    4911 </span><span class="lineCov">          7 :         c = find_context_locked(context);</span>
<span class="lineNum">    4912 </span><span class="lineCov">          7 :         if (c) { /* ... remove extension ... */</span>
<span class="lineNum">    4913 </span><span class="lineCov">          7 :                 ret = ast_context_remove_extension_callerid2(c, extension, priority, callerid,</span>
<span class="lineNum">    4914 </span>            :                         matchcallerid, registrar, 0);
<span class="lineNum">    4915 </span><span class="lineCov">          7 :                 ast_unlock_contexts();</span>
<span class="lineNum">    4916 </span>            :         }
<span class="lineNum">    4917 </span>            : 
<span class="lineNum">    4918 </span><span class="lineCov">          7 :         return ret;</span>
<span class="lineNum">    4919 </span>            : }
<span class="lineNum">    4920 </span>            : 
<span class="lineNum">    4921 </span>            : /*!
<span class="lineNum">    4922 </span>            :  * \brief This functionc locks given context, search for the right extension and
<span class="lineNum">    4923 </span>            :  * fires out all peer in this extensions with given priority. If priority
<span class="lineNum">    4924 </span>            :  * is set to 0, all peers are removed. After that, unlock context and
<span class="lineNum">    4925 </span>            :  * return.
<span class="lineNum">    4926 </span>            :  * \note When do you want to call this function, make sure that &amp;conlock is locked,
<span class="lineNum">    4927 </span>            :  * because some process can handle with your *con context before you lock
<span class="lineNum">    4928 </span>            :  * it.
<a name="4929"><span class="lineNum">    4929 </span>            :  *</a>
<span class="lineNum">    4930 </span>            :  */
<span class="lineNum">    4931 </span><span class="lineNoCov">          0 : int ast_context_remove_extension2(struct ast_context *con, const char *extension, int priority, const char *registrar, int already_locked)</span>
<span class="lineNum">    4932 </span>            : {
<span class="lineNum">    4933 </span><span class="lineNoCov">          0 :         return ast_context_remove_extension_callerid2(con, extension, priority, NULL, AST_EXT_MATCHCID_ANY, registrar, already_locked);</span>
<a name="4934"><span class="lineNum">    4934 </span>            : }</a>
<span class="lineNum">    4935 </span>            : 
<span class="lineNum">    4936 </span><span class="lineCov">      40716 : int ast_context_remove_extension_callerid2(struct ast_context *con, const char *extension, int priority, const char *callerid, int matchcallerid, const char *registrar, int already_locked)</span>
<span class="lineNum">    4937 </span>            : {
<span class="lineNum">    4938 </span><span class="lineCov">      40716 :         struct ast_exten *exten, *prev_exten = NULL;</span>
<span class="lineNum">    4939 </span>            :         struct ast_exten *peer;
<span class="lineNum">    4940 </span>            :         struct ast_exten ex, *exten2, *exten3;
<span class="lineNum">    4941 </span>            :         char dummy_name[1024];
<span class="lineNum">    4942 </span>            :         char dummy_cid[1024];
<span class="lineNum">    4943 </span><span class="lineCov">      40716 :         struct ast_exten *previous_peer = NULL;</span>
<span class="lineNum">    4944 </span><span class="lineCov">      40716 :         struct ast_exten *next_peer = NULL;</span>
<span class="lineNum">    4945 </span><span class="lineCov">      40716 :         int found = 0;</span>
<span class="lineNum">    4946 </span>            : 
<span class="lineNum">    4947 </span><span class="lineCov">      40716 :         if (!already_locked)</span>
<span class="lineNum">    4948 </span><span class="lineCov">          7 :                 ast_wrlock_context(con);</span>
<span class="lineNum">    4949 </span>            : 
<span class="lineNum">    4950 </span>            : #ifdef NEED_DEBUG
<span class="lineNum">    4951 </span>            :         ast_verb(3,&quot;Removing %s/%s/%d%s%s from trees, registrar=%s\n&quot;, con-&gt;name, extension, priority, matchcallerid ? &quot;/&quot; : &quot;&quot;, matchcallerid ? callerid : &quot;&quot;, registrar);
<span class="lineNum">    4952 </span>            : #endif
<span class="lineNum">    4953 </span>            : #ifdef CONTEXT_DEBUG
<span class="lineNum">    4954 </span>            :         check_contexts(__FILE__, __LINE__);
<span class="lineNum">    4955 </span>            : #endif
<span class="lineNum">    4956 </span>            :         /* find this particular extension */
<span class="lineNum">    4957 </span><span class="lineCov">      40716 :         ex.exten = dummy_name;</span>
<span class="lineNum">    4958 </span><span class="lineCov">      40716 :         ext_strncpy(dummy_name, extension, sizeof(dummy_name), 1);</span>
<span class="lineNum">    4959 </span><span class="lineCov">      40716 :         ex.matchcid = matchcallerid;</span>
<span class="lineNum">    4960 </span><span class="lineCov">      40716 :         if (callerid) {</span>
<span class="lineNum">    4961 </span><span class="lineCov">      40711 :                 ex.cidmatch = dummy_cid;</span>
<span class="lineNum">    4962 </span><span class="lineCov">      40711 :                 ext_strncpy(dummy_cid, callerid, sizeof(dummy_cid), 1);</span>
<span class="lineNum">    4963 </span>            :         } else {
<span class="lineNum">    4964 </span><span class="lineCov">          5 :                 ex.cidmatch = NULL;</span>
<span class="lineNum">    4965 </span>            :         }
<span class="lineNum">    4966 </span><span class="lineCov">      40716 :         exten = ast_hashtab_lookup(con-&gt;root_table, &amp;ex);</span>
<span class="lineNum">    4967 </span><span class="lineCov">      40716 :         if (exten) {</span>
<span class="lineNum">    4968 </span><span class="lineCov">      40699 :                 if (priority == 0) {</span>
<span class="lineNum">    4969 </span><span class="lineCov">          1 :                         exten2 = ast_hashtab_remove_this_object(con-&gt;root_table, exten);</span>
<span class="lineNum">    4970 </span><span class="lineCov">          1 :                         if (!exten2)</span>
<span class="lineNum">    4971 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_ERROR,&quot;Trying to delete the exten %s from context %s, but could not remove from the root_table\n&quot;, extension, con-&gt;name);</span>
<span class="lineNum">    4972 </span><span class="lineCov">          1 :                         if (con-&gt;pattern_tree) {</span>
<span class="lineNum">    4973 </span><span class="lineNoCov">          0 :                                 struct match_char *x = add_exten_to_pattern_tree(con, exten, 1);</span>
<span class="lineNum">    4974 </span>            : 
<span class="lineNum">    4975 </span><span class="lineNoCov">          0 :                                 if (x-&gt;exten) { /* this test for safety purposes */</span>
<span class="lineNum">    4976 </span><span class="lineNoCov">          0 :                                         x-&gt;deleted = 1; /* with this marked as deleted, it will never show up in the scoreboard, and therefore never be found */</span>
<span class="lineNum">    4977 </span><span class="lineNoCov">          0 :                                         x-&gt;exten = 0; /* get rid of what will become a bad pointer */</span>
<span class="lineNum">    4978 </span>            :                                 } else {
<span class="lineNum">    4979 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_WARNING,&quot;Trying to delete an exten from a context, but the pattern tree node returned isn't a full extension\n&quot;);</span>
<span class="lineNum">    4980 </span>            :                                 }
<span class="lineNum">    4981 </span>            :                         }
<span class="lineNum">    4982 </span>            :                 } else {
<span class="lineNum">    4983 </span><span class="lineCov">      40698 :                         ex.priority = priority;</span>
<span class="lineNum">    4984 </span><span class="lineCov">      40698 :                         exten2 = ast_hashtab_lookup(exten-&gt;peer_table, &amp;ex);</span>
<span class="lineNum">    4985 </span><span class="lineCov">      40698 :                         if (exten2) {</span>
<span class="lineNum">    4986 </span><span class="lineCov">      40698 :                                 if (exten2-&gt;label) { /* if this exten has a label, remove that, too */</span>
<span class="lineNum">    4987 </span><span class="lineCov">        309 :                                         exten3 = ast_hashtab_remove_this_object(exten-&gt;peer_label_table,exten2);</span>
<span class="lineNum">    4988 </span><span class="lineCov">        309 :                                         if (!exten3) {</span>
<span class="lineNum">    4989 </span><span class="lineNoCov">          0 :                                                 ast_log(LOG_ERROR, &quot;Did not remove this priority label (%d/%s) &quot;</span>
<span class="lineNum">    4990 </span>            :                                                         &quot;from the peer_label_table of context %s, extension %s!\n&quot;,
<span class="lineNum">    4991 </span><span class="lineNoCov">          0 :                                                         priority, exten2-&gt;label, con-&gt;name, exten2-&gt;name);</span>
<span class="lineNum">    4992 </span>            :                                         }
<span class="lineNum">    4993 </span>            :                                 }
<span class="lineNum">    4994 </span>            : 
<span class="lineNum">    4995 </span><span class="lineCov">      40698 :                                 exten3 = ast_hashtab_remove_this_object(exten-&gt;peer_table, exten2);</span>
<span class="lineNum">    4996 </span><span class="lineCov">      40698 :                                 if (!exten3) {</span>
<span class="lineNum">    4997 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_ERROR, &quot;Did not remove this priority (%d) from the &quot;</span>
<span class="lineNum">    4998 </span>            :                                                 &quot;peer_table of context %s, extension %s!\n&quot;,
<span class="lineNum">    4999 </span><span class="lineNoCov">          0 :                                                 priority, con-&gt;name, exten2-&gt;name);</span>
<span class="lineNum">    5000 </span>            :                                 }
<span class="lineNum">    5001 </span><span class="lineCov">      40698 :                                 if (exten2 == exten &amp;&amp; exten2-&gt;peer) {</span>
<span class="lineNum">    5002 </span><span class="lineCov">       5604 :                                         exten2 = ast_hashtab_remove_this_object(con-&gt;root_table, exten);</span>
<span class="lineNum">    5003 </span><span class="lineCov">       5604 :                                         ast_hashtab_insert_immediate(con-&gt;root_table, exten2-&gt;peer);</span>
<span class="lineNum">    5004 </span>            :                                 }
<span class="lineNum">    5005 </span><span class="lineCov">      40698 :                                 if (ast_hashtab_size(exten-&gt;peer_table) == 0) {</span>
<span class="lineNum">    5006 </span>            :                                         /* well, if the last priority of an exten is to be removed,
<span class="lineNum">    5007 </span>            :                                            then, the extension is removed, too! */
<span class="lineNum">    5008 </span><span class="lineCov">      27653 :                                         exten3 = ast_hashtab_remove_this_object(con-&gt;root_table, exten);</span>
<span class="lineNum">    5009 </span><span class="lineCov">      27653 :                                         if (!exten3) {</span>
<span class="lineNum">    5010 </span><span class="lineCov">          3 :                                                 ast_log(LOG_ERROR, &quot;Did not remove this exten (%s) from the &quot;</span>
<span class="lineNum">    5011 </span>            :                                                         &quot;context root_table (%s) (priority %d)\n&quot;,
<span class="lineNum">    5012 </span><span class="lineCov">          3 :                                                         exten-&gt;name, con-&gt;name, priority);</span>
<span class="lineNum">    5013 </span>            :                                         }
<span class="lineNum">    5014 </span><span class="lineCov">      27653 :                                         if (con-&gt;pattern_tree) {</span>
<span class="lineNum">    5015 </span><span class="lineCov">       3018 :                                                 struct match_char *x = add_exten_to_pattern_tree(con, exten, 1);</span>
<span class="lineNum">    5016 </span><span class="lineCov">       3018 :                                                 if (x-&gt;exten) { /* this test for safety purposes */</span>
<span class="lineNum">    5017 </span><span class="lineCov">       3018 :                                                         x-&gt;deleted = 1; /* with this marked as deleted, it will never show up in the scoreboard, and therefore never be found */</span>
<span class="lineNum">    5018 </span><span class="lineCov">       3018 :                                                         x-&gt;exten = 0; /* get rid of what will become a bad pointer */</span>
<span class="lineNum">    5019 </span>            :                                                 }
<span class="lineNum">    5020 </span>            :                                         }
<span class="lineNum">    5021 </span>            :                                 }
<span class="lineNum">    5022 </span>            :                         } else {
<span class="lineNum">    5023 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_ERROR,&quot;Could not find priority %d of exten %s in context %s!\n&quot;,</span>
<span class="lineNum">    5024 </span><span class="lineNoCov">          0 :                                                 priority, exten-&gt;name, con-&gt;name);</span>
<span class="lineNum">    5025 </span>            :                         }
<span class="lineNum">    5026 </span>            :                 }
<span class="lineNum">    5027 </span>            :         } else {
<span class="lineNum">    5028 </span>            :                 /* hmmm? this exten is not in this pattern tree? */
<span class="lineNum">    5029 </span><span class="lineCov">         17 :                 ast_log(LOG_WARNING,&quot;Cannot find extension %s in root_table in context %s\n&quot;,</span>
<span class="lineNum">    5030 </span><span class="lineCov">         17 :                                 extension, con-&gt;name);</span>
<span class="lineNum">    5031 </span>            :         }
<span class="lineNum">    5032 </span>            : #ifdef NEED_DEBUG
<span class="lineNum">    5033 </span>            :         if (con-&gt;pattern_tree) {
<span class="lineNum">    5034 </span>            :                 ast_log(LOG_NOTICE,&quot;match char tree after exten removal:\n&quot;);
<span class="lineNum">    5035 </span>            :                 log_match_char_tree(con-&gt;pattern_tree, &quot; &quot;);
<span class="lineNum">    5036 </span>            :         }
<span class="lineNum">    5037 </span>            : #endif
<span class="lineNum">    5038 </span>            : 
<span class="lineNum">    5039 </span>            :         /* scan the extension list to find first matching extension-registrar */
<span class="lineNum">    5040 </span><span class="lineCov">      74895 :         for (exten = con-&gt;root; exten; prev_exten = exten, exten = exten-&gt;next) {</span>
<span class="lineNum">    5041 </span><span class="lineCov">      74878 :                 if (!strcmp(exten-&gt;exten, ex.exten) &amp;&amp;</span>
<span class="lineNum">    5042 </span><span class="lineCov">         69 :                         (!matchcallerid ||</span>
<span class="lineNum">    5043 </span><span class="lineCov">        158 :                                 (!ast_strlen_zero(ex.cidmatch) &amp;&amp; !ast_strlen_zero(exten-&gt;cidmatch) &amp;&amp; !strcmp(exten-&gt;cidmatch, ex.cidmatch)) ||</span>
<span class="lineNum">    5044 </span><span class="lineCov">         66 :                                 (ast_strlen_zero(ex.cidmatch) &amp;&amp; ast_strlen_zero(exten-&gt;cidmatch)))) {</span>
<span class="lineNum">    5045 </span>            :                         break;
<span class="lineNum">    5046 </span>            :                 }
<span class="lineNum">    5047 </span>            :         }
<span class="lineNum">    5048 </span><span class="lineCov">      40716 :         if (!exten) {</span>
<span class="lineNum">    5049 </span>            :                 /* we can't find right extension */
<span class="lineNum">    5050 </span><span class="lineCov">         17 :                 if (!already_locked)</span>
<span class="lineNum">    5051 </span><span class="lineCov">          1 :                         ast_unlock_context(con);</span>
<span class="lineNum">    5052 </span><span class="lineCov">         17 :                 return -1;</span>
<span class="lineNum">    5053 </span>            :         }
<span class="lineNum">    5054 </span>            : 
<span class="lineNum">    5055 </span>            :         /* scan the priority list to remove extension with exten-&gt;priority == priority */
<span class="lineNum">    5056 </span><span class="lineCov">     125778 :         for (peer = exten, next_peer = exten-&gt;peer ? exten-&gt;peer : exten-&gt;next;</span>
<span class="lineNum">    5057 </span><span class="lineCov">     107505 :                  peer &amp;&amp; !strcmp(peer-&gt;exten, ex.exten) &amp;&amp;</span>
<span class="lineNum">    5058 </span><span class="lineCov">      85103 :                         (!callerid || (!matchcallerid &amp;&amp; !peer-&gt;matchcid) || (matchcallerid &amp;&amp; peer-&gt;matchcid &amp;&amp; !strcmp(peer-&gt;cidmatch, ex.cidmatch))) ;</span>
<span class="lineNum">    5059 </span><span class="lineCov">      85079 :                         peer = next_peer, next_peer = next_peer ? (next_peer-&gt;peer ? next_peer-&gt;peer : next_peer-&gt;next) : NULL) {</span>
<span class="lineNum">    5060 </span>            : 
<span class="lineNum">    5061 </span><span class="lineCov">      85079 :                 if ((priority == 0 || peer-&gt;priority == priority) &amp;&amp;</span>
<span class="lineNum">    5062 </span><span class="lineCov">          6 :                                 (!registrar || !strcmp(peer-&gt;registrar, registrar) )) {</span>
<span class="lineNum">    5063 </span><span class="lineCov">      40576 :                         found = 1;</span>
<span class="lineNum">    5064 </span>            : 
<span class="lineNum">    5065 </span>            :                         /* we are first priority extension? */
<span class="lineNum">    5066 </span><span class="lineCov">      40576 :                         if (!previous_peer) {</span>
<span class="lineNum">    5067 </span>            :                                 /*
<span class="lineNum">    5068 </span>            :                                  * We are first in the priority chain, so must update the extension chain.
<span class="lineNum">    5069 </span>            :                                  * The next node is either the next priority or the next extension
<span class="lineNum">    5070 </span>            :                                  */
<span class="lineNum">    5071 </span><span class="lineCov">      33249 :                                 struct ast_exten *next_node = peer-&gt;peer ? peer-&gt;peer : peer-&gt;next;</span>
<span class="lineNum">    5072 </span><span class="lineCov">      33249 :                                 if (peer-&gt;peer) {</span>
<span class="lineNum">    5073 </span>            :                                         /* move the peer_table and peer_label_table down to the next peer, if
<span class="lineNum">    5074 </span>            :                                            it is there */
<span class="lineNum">    5075 </span><span class="lineCov">       5604 :                                         peer-&gt;peer-&gt;peer_table = peer-&gt;peer_table;</span>
<span class="lineNum">    5076 </span><span class="lineCov">       5604 :                                         peer-&gt;peer-&gt;peer_label_table = peer-&gt;peer_label_table;</span>
<span class="lineNum">    5077 </span><span class="lineCov">       5604 :                                         peer-&gt;peer_table = NULL;</span>
<span class="lineNum">    5078 </span><span class="lineCov">       5604 :                                         peer-&gt;peer_label_table = NULL;</span>
<span class="lineNum">    5079 </span>            :                                 }
<span class="lineNum">    5080 </span><span class="lineCov">      33249 :                                 if (!prev_exten) {      /* change the root... */</span>
<span class="lineNum">    5081 </span><span class="lineCov">       9440 :                                         con-&gt;root = next_node;</span>
<span class="lineNum">    5082 </span>            :                                 } else {
<span class="lineNum">    5083 </span><span class="lineCov">      23809 :                                         prev_exten-&gt;next = next_node; /* unlink */</span>
<span class="lineNum">    5084 </span>            :                                 }
<span class="lineNum">    5085 </span><span class="lineCov">      33249 :                                 if (peer-&gt;peer)      { /* update the new head of the pri list */</span>
<span class="lineNum">    5086 </span><span class="lineCov">       5604 :                                         peer-&gt;peer-&gt;next = peer-&gt;next;</span>
<span class="lineNum">    5087 </span>            :                                 }
<span class="lineNum">    5088 </span>            :                         } else { /* easy, we are not first priority in extension */
<span class="lineNum">    5089 </span><span class="lineCov">       7327 :                                 previous_peer-&gt;peer = peer-&gt;peer;</span>
<span class="lineNum">    5090 </span>            :                         }
<span class="lineNum">    5091 </span>            : 
<span class="lineNum">    5092 </span>            : 
<span class="lineNum">    5093 </span>            :                         /* now, free whole priority extension */
<span class="lineNum">    5094 </span><span class="lineCov">      40576 :                         destroy_exten(peer);</span>
<span class="lineNum">    5095 </span>            :                 } else {
<span class="lineNum">    5096 </span><span class="lineCov">      44503 :                         previous_peer = peer;</span>
<span class="lineNum">    5097 </span>            :                 }
<span class="lineNum">    5098 </span>            :         }
<span class="lineNum">    5099 </span><span class="lineCov">      40699 :         if (!already_locked)</span>
<span class="lineNum">    5100 </span><span class="lineCov">          6 :                 ast_unlock_context(con);</span>
<span class="lineNum">    5101 </span><span class="lineCov">      40699 :         return found ? 0 : -1;</span>
<span class="lineNum">    5102 </span>            : }
<span class="lineNum">    5103 </span>            : 
<span class="lineNum">    5104 </span>            : 
<span class="lineNum">    5105 </span>            : /*!
<span class="lineNum">    5106 </span>            :  * \note This function locks contexts list by &amp;conlist, searches for the right context
<span class="lineNum">    5107 </span>            :  * structure, and locks the macrolock mutex in that context.
<span class="lineNum">    5108 </span>            :  * macrolock is used to limit a macro to be executed by one call at a time.
<a name="5109"><span class="lineNum">    5109 </span>            :  * \param context The context</a>
<span class="lineNum">    5110 </span>            :  */
<span class="lineNum">    5111 </span><span class="lineNoCov">          0 : int ast_context_lockmacro(const char *context)</span>
<span class="lineNum">    5112 </span>            : {
<span class="lineNum">    5113 </span>            :         struct ast_context *c;
<span class="lineNum">    5114 </span><span class="lineNoCov">          0 :         int ret = -1;</span>
<span class="lineNum">    5115 </span>            : 
<span class="lineNum">    5116 </span><span class="lineNoCov">          0 :         c = find_context_locked(context);</span>
<span class="lineNum">    5117 </span><span class="lineNoCov">          0 :         if (c) {</span>
<span class="lineNum">    5118 </span><span class="lineNoCov">          0 :                 ast_unlock_contexts();</span>
<span class="lineNum">    5119 </span>            : 
<span class="lineNum">    5120 </span>            :                 /* if we found context, lock macrolock */
<span class="lineNum">    5121 </span><span class="lineNoCov">          0 :                 ret = ast_mutex_lock(&amp;c-&gt;macrolock);</span>
<span class="lineNum">    5122 </span>            :         }
<span class="lineNum">    5123 </span>            : 
<span class="lineNum">    5124 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    5125 </span>            : }
<span class="lineNum">    5126 </span>            : 
<span class="lineNum">    5127 </span>            : /*!
<span class="lineNum">    5128 </span>            :  * \note This function locks contexts list by &amp;conlist, searches for the right context
<span class="lineNum">    5129 </span>            :  * structure, and unlocks the macrolock mutex in that context.
<span class="lineNum">    5130 </span>            :  * macrolock is used to limit a macro to be executed by one call at a time.
<a name="5131"><span class="lineNum">    5131 </span>            :  * \param context The context</a>
<span class="lineNum">    5132 </span>            :  */
<span class="lineNum">    5133 </span><span class="lineNoCov">          0 : int ast_context_unlockmacro(const char *context)</span>
<span class="lineNum">    5134 </span>            : {
<span class="lineNum">    5135 </span>            :         struct ast_context *c;
<span class="lineNum">    5136 </span><span class="lineNoCov">          0 :         int ret = -1;</span>
<span class="lineNum">    5137 </span>            : 
<span class="lineNum">    5138 </span><span class="lineNoCov">          0 :         c = find_context_locked(context);</span>
<span class="lineNum">    5139 </span><span class="lineNoCov">          0 :         if (c) {</span>
<span class="lineNum">    5140 </span><span class="lineNoCov">          0 :                 ast_unlock_contexts();</span>
<span class="lineNum">    5141 </span>            : 
<span class="lineNum">    5142 </span>            :                 /* if we found context, unlock macrolock */
<span class="lineNum">    5143 </span><span class="lineNoCov">          0 :                 ret = ast_mutex_unlock(&amp;c-&gt;macrolock);</span>
<span class="lineNum">    5144 </span>            :         }
<span class="lineNum">    5145 </span>            : 
<span class="lineNum">    5146 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    5147 </span>            : }
<span class="lineNum">    5148 </span>            : 
<span class="lineNum">    5149 </span>            : /*
<span class="lineNum">    5150 </span>            :  * Help for CLI commands ...
<span class="lineNum">    5151 </span>            :  */
<a name="5152"><span class="lineNum">    5152 </span>            : </a>
<span class="lineNum">    5153 </span>            : /*! \brief  handle_show_hints: CLI support for listing registered dial plan hints */
<span class="lineNum">    5154 </span><span class="lineCov">       1124 : static char *handle_show_hints(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)</span>
<span class="lineNum">    5155 </span>            : {
<span class="lineNum">    5156 </span>            :         struct ast_hint *hint;
<span class="lineNum">    5157 </span><span class="lineCov">       1124 :         int num = 0;</span>
<span class="lineNum">    5158 </span>            :         int watchers;
<span class="lineNum">    5159 </span>            :         struct ao2_iterator i;
<span class="lineNum">    5160 </span>            :         char buf[AST_MAX_EXTENSION+AST_MAX_CONTEXT+2];
<span class="lineNum">    5161 </span>            : 
<span class="lineNum">    5162 </span><span class="lineCov">       1124 :         switch (cmd) {</span>
<span class="lineNum">    5163 </span><span class="lineCov">       1124 :         case CLI_INIT:</span>
<span class="lineNum">    5164 </span><span class="lineCov">       1124 :                 e-&gt;command = &quot;core show hints&quot;;</span>
<span class="lineNum">    5165 </span><span class="lineCov">       1124 :                 e-&gt;usage =</span>
<span class="lineNum">    5166 </span>            :                         &quot;Usage: core show hints\n&quot;
<span class="lineNum">    5167 </span>            :                         &quot;       List registered hints.\n&quot;
<span class="lineNum">    5168 </span>            :                         &quot;       Hint details are shown in five columns. In order from left to right, they are:\n&quot;
<span class="lineNum">    5169 </span>            :                         &quot;       1. Hint extension URI.\n&quot;
<span class="lineNum">    5170 </span>            :                         &quot;       2. List of mapped device or presence state identifiers.\n&quot;
<span class="lineNum">    5171 </span>            :                         &quot;       3. Current extension state. The aggregate of mapped device states.\n&quot;
<span class="lineNum">    5172 </span>            :                         &quot;       4. Current presence state for the mapped presence state provider.\n&quot;
<span class="lineNum">    5173 </span>            :                         &quot;       5. Watchers - number of subscriptions and other entities watching this hint.\n&quot;;
<span class="lineNum">    5174 </span><span class="lineCov">       1124 :                 return NULL;</span>
<span class="lineNum">    5175 </span><span class="lineNoCov">          0 :         case CLI_GENERATE:</span>
<span class="lineNum">    5176 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    5177 </span>            :         }
<span class="lineNum">    5178 </span>            : 
<span class="lineNum">    5179 </span><span class="lineNoCov">          0 :         if (ao2_container_count(hints) == 0) {</span>
<span class="lineNum">    5180 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;There are no registered dialplan hints\n&quot;);</span>
<span class="lineNum">    5181 </span><span class="lineNoCov">          0 :                 return CLI_SUCCESS;</span>
<span class="lineNum">    5182 </span>            :         }
<span class="lineNum">    5183 </span>            :         /* ... we have hints ... */
<span class="lineNum">    5184 </span><span class="lineNoCov">          0 :         ast_cli(a-&gt;fd, &quot;\n    -= Registered Asterisk Dial Plan Hints =-\n&quot;);</span>
<span class="lineNum">    5185 </span>            : 
<span class="lineNum">    5186 </span><span class="lineNoCov">          0 :         i = ao2_iterator_init(hints, 0);</span>
<span class="lineNum">    5187 </span><span class="lineNoCov">          0 :         for (; (hint = ao2_iterator_next(&amp;i)); ao2_ref(hint, -1)) {</span>
<span class="lineNum">    5188 </span><span class="lineNoCov">          0 :                 ao2_lock(hint);</span>
<span class="lineNum">    5189 </span><span class="lineNoCov">          0 :                 if (!hint-&gt;exten) {</span>
<span class="lineNum">    5190 </span>            :                         /* The extension has already been destroyed */
<span class="lineNum">    5191 </span><span class="lineNoCov">          0 :                         ao2_unlock(hint);</span>
<span class="lineNum">    5192 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    5193 </span>            :                 }
<span class="lineNum">    5194 </span><span class="lineNoCov">          0 :                 watchers = ao2_container_count(hint-&gt;callbacks);</span>
<span class="lineNum">    5195 </span><span class="lineNoCov">          0 :                 snprintf(buf, sizeof(buf), &quot;%s@%s&quot;,</span>
<span class="lineNum">    5196 </span>            :                         ast_get_extension_name(hint-&gt;exten),
<span class="lineNum">    5197 </span>            :                         ast_get_context_name(ast_get_extension_context(hint-&gt;exten)));
<span class="lineNum">    5198 </span>            : 
<span class="lineNum">    5199 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;%-20.20s: %-20.20s  State:%-15.15s Presence:%-15.15s Watchers %2d\n&quot;,</span>
<span class="lineNum">    5200 </span>            :                         buf,
<span class="lineNum">    5201 </span>            :                         ast_get_extension_app(hint-&gt;exten),
<span class="lineNum">    5202 </span>            :                         ast_extension_state2str(hint-&gt;laststate),
<span class="lineNum">    5203 </span><span class="lineNoCov">          0 :                         ast_presence_state2str(hint-&gt;last_presence_state),</span>
<span class="lineNum">    5204 </span>            :                         watchers);
<span class="lineNum">    5205 </span>            : 
<span class="lineNum">    5206 </span><span class="lineNoCov">          0 :                 ao2_unlock(hint);</span>
<span class="lineNum">    5207 </span><span class="lineNoCov">          0 :                 num++;</span>
<span class="lineNum">    5208 </span>            :         }
<span class="lineNum">    5209 </span><span class="lineNoCov">          0 :         ao2_iterator_destroy(&amp;i);</span>
<span class="lineNum">    5210 </span>            : 
<span class="lineNum">    5211 </span><span class="lineNoCov">          0 :         ast_cli(a-&gt;fd, &quot;----------------\n&quot;);</span>
<span class="lineNum">    5212 </span><span class="lineNoCov">          0 :         ast_cli(a-&gt;fd, &quot;- %d hints registered\n&quot;, num);</span>
<span class="lineNum">    5213 </span><span class="lineNoCov">          0 :         return CLI_SUCCESS;</span>
<span class="lineNum">    5214 </span>            : }
<a name="5215"><span class="lineNum">    5215 </span>            : </a>
<span class="lineNum">    5216 </span>            : /*! \brief autocomplete for CLI command 'core show hint' */
<span class="lineNum">    5217 </span><span class="lineNoCov">          0 : static char *complete_core_show_hint(const char *line, const char *word, int pos, int state)</span>
<span class="lineNum">    5218 </span>            : {
<span class="lineNum">    5219 </span>            :         struct ast_hint *hint;
<span class="lineNum">    5220 </span><span class="lineNoCov">          0 :         char *ret = NULL;</span>
<span class="lineNum">    5221 </span><span class="lineNoCov">          0 :         int which = 0;</span>
<span class="lineNum">    5222 </span>            :         int wordlen;
<span class="lineNum">    5223 </span>            :         struct ao2_iterator i;
<span class="lineNum">    5224 </span>            : 
<span class="lineNum">    5225 </span><span class="lineNoCov">          0 :         if (pos != 3)</span>
<span class="lineNum">    5226 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    5227 </span>            : 
<span class="lineNum">    5228 </span><span class="lineNoCov">          0 :         wordlen = strlen(word);</span>
<span class="lineNum">    5229 </span>            : 
<span class="lineNum">    5230 </span>            :         /* walk through all hints */
<span class="lineNum">    5231 </span><span class="lineNoCov">          0 :         i = ao2_iterator_init(hints, 0);</span>
<span class="lineNum">    5232 </span><span class="lineNoCov">          0 :         for (; (hint = ao2_iterator_next(&amp;i)); ao2_ref(hint, -1)) {</span>
<span class="lineNum">    5233 </span><span class="lineNoCov">          0 :                 ao2_lock(hint);</span>
<span class="lineNum">    5234 </span><span class="lineNoCov">          0 :                 if (!hint-&gt;exten) {</span>
<span class="lineNum">    5235 </span>            :                         /* The extension has already been destroyed */
<span class="lineNum">    5236 </span><span class="lineNoCov">          0 :                         ao2_unlock(hint);</span>
<span class="lineNum">    5237 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    5238 </span>            :                 }
<span class="lineNum">    5239 </span><span class="lineNoCov">          0 :                 if (!strncasecmp(word, ast_get_extension_name(hint-&gt;exten), wordlen) &amp;&amp; ++which &gt; state) {</span>
<span class="lineNum">    5240 </span><span class="lineNoCov">          0 :                         ret = ast_strdup(ast_get_extension_name(hint-&gt;exten));</span>
<span class="lineNum">    5241 </span><span class="lineNoCov">          0 :                         ao2_unlock(hint);</span>
<span class="lineNum">    5242 </span><span class="lineNoCov">          0 :                         ao2_ref(hint, -1);</span>
<span class="lineNum">    5243 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    5244 </span>            :                 }
<span class="lineNum">    5245 </span><span class="lineNoCov">          0 :                 ao2_unlock(hint);</span>
<span class="lineNum">    5246 </span>            :         }
<span class="lineNum">    5247 </span><span class="lineNoCov">          0 :         ao2_iterator_destroy(&amp;i);</span>
<span class="lineNum">    5248 </span>            : 
<span class="lineNum">    5249 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    5250 </span>            : }
<a name="5251"><span class="lineNum">    5251 </span>            : </a>
<span class="lineNum">    5252 </span>            : /*! \brief  handle_show_hint: CLI support for listing registered dial plan hint */
<span class="lineNum">    5253 </span><span class="lineCov">       1124 : static char *handle_show_hint(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)</span>
<span class="lineNum">    5254 </span>            : {
<span class="lineNum">    5255 </span>            :         struct ast_hint *hint;
<span class="lineNum">    5256 </span>            :         int watchers;
<span class="lineNum">    5257 </span><span class="lineCov">       1124 :         int num = 0, extenlen;</span>
<span class="lineNum">    5258 </span>            :         struct ao2_iterator i;
<span class="lineNum">    5259 </span>            :         char buf[AST_MAX_EXTENSION+AST_MAX_CONTEXT+2];
<span class="lineNum">    5260 </span>            : 
<span class="lineNum">    5261 </span><span class="lineCov">       1124 :         switch (cmd) {</span>
<span class="lineNum">    5262 </span><span class="lineCov">       1124 :         case CLI_INIT:</span>
<span class="lineNum">    5263 </span><span class="lineCov">       1124 :                 e-&gt;command = &quot;core show hint&quot;;</span>
<span class="lineNum">    5264 </span><span class="lineCov">       1124 :                 e-&gt;usage =</span>
<span class="lineNum">    5265 </span>            :                         &quot;Usage: core show hint &lt;exten&gt;\n&quot;
<span class="lineNum">    5266 </span>            :                         &quot;       List registered hint.\n&quot;
<span class="lineNum">    5267 </span>            :                         &quot;       Hint details are shown in five columns. In order from left to right, they are:\n&quot;
<span class="lineNum">    5268 </span>            :                         &quot;       1. Hint extension URI.\n&quot;
<span class="lineNum">    5269 </span>            :                         &quot;       2. List of mapped device or presence state identifiers.\n&quot;
<span class="lineNum">    5270 </span>            :                         &quot;       3. Current extension state. The aggregate of mapped device states.\n&quot;
<span class="lineNum">    5271 </span>            :                         &quot;       4. Current presence state for the mapped presence state provider.\n&quot;
<span class="lineNum">    5272 </span>            :                         &quot;       5. Watchers - number of subscriptions and other entities watching this hint.\n&quot;;
<span class="lineNum">    5273 </span><span class="lineCov">       1124 :                 return NULL;</span>
<span class="lineNum">    5274 </span><span class="lineNoCov">          0 :         case CLI_GENERATE:</span>
<span class="lineNum">    5275 </span><span class="lineNoCov">          0 :                 return complete_core_show_hint(a-&gt;line, a-&gt;word, a-&gt;pos, a-&gt;n);</span>
<span class="lineNum">    5276 </span>            :         }
<span class="lineNum">    5277 </span>            : 
<span class="lineNum">    5278 </span><span class="lineNoCov">          0 :         if (a-&gt;argc &lt; 4)</span>
<span class="lineNum">    5279 </span><span class="lineNoCov">          0 :                 return CLI_SHOWUSAGE;</span>
<span class="lineNum">    5280 </span>            : 
<span class="lineNum">    5281 </span><span class="lineNoCov">          0 :         if (ao2_container_count(hints) == 0) {</span>
<span class="lineNum">    5282 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;There are no registered dialplan hints\n&quot;);</span>
<span class="lineNum">    5283 </span><span class="lineNoCov">          0 :                 return CLI_SUCCESS;</span>
<span class="lineNum">    5284 </span>            :         }
<span class="lineNum">    5285 </span>            : 
<span class="lineNum">    5286 </span><span class="lineNoCov">          0 :         extenlen = strlen(a-&gt;argv[3]);</span>
<span class="lineNum">    5287 </span><span class="lineNoCov">          0 :         i = ao2_iterator_init(hints, 0);</span>
<span class="lineNum">    5288 </span><span class="lineNoCov">          0 :         for (; (hint = ao2_iterator_next(&amp;i)); ao2_ref(hint, -1)) {</span>
<span class="lineNum">    5289 </span><span class="lineNoCov">          0 :                 ao2_lock(hint);</span>
<span class="lineNum">    5290 </span><span class="lineNoCov">          0 :                 if (!hint-&gt;exten) {</span>
<span class="lineNum">    5291 </span>            :                         /* The extension has already been destroyed */
<span class="lineNum">    5292 </span><span class="lineNoCov">          0 :                         ao2_unlock(hint);</span>
<span class="lineNum">    5293 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    5294 </span>            :                 }
<span class="lineNum">    5295 </span><span class="lineNoCov">          0 :                 if (!strncasecmp(ast_get_extension_name(hint-&gt;exten), a-&gt;argv[3], extenlen)) {</span>
<span class="lineNum">    5296 </span><span class="lineNoCov">          0 :                         watchers = ao2_container_count(hint-&gt;callbacks);</span>
<span class="lineNum">    5297 </span><span class="lineNoCov">          0 :                         sprintf(buf, &quot;%s@%s&quot;,</span>
<span class="lineNum">    5298 </span>            :                                 ast_get_extension_name(hint-&gt;exten),
<span class="lineNum">    5299 </span>            :                                 ast_get_context_name(ast_get_extension_context(hint-&gt;exten)));
<span class="lineNum">    5300 </span><span class="lineNoCov">          0 :                         ast_cli(a-&gt;fd, &quot;%-20.20s: %-20.20s  State:%-15.15s Presence:%-15.15s Watchers %2d\n&quot;,</span>
<span class="lineNum">    5301 </span>            :                                 buf,
<span class="lineNum">    5302 </span>            :                                 ast_get_extension_app(hint-&gt;exten),
<span class="lineNum">    5303 </span>            :                                 ast_extension_state2str(hint-&gt;laststate),
<span class="lineNum">    5304 </span><span class="lineNoCov">          0 :                                 ast_presence_state2str(hint-&gt;last_presence_state),</span>
<span class="lineNum">    5305 </span>            :                                 watchers);
<span class="lineNum">    5306 </span><span class="lineNoCov">          0 :                         num++;</span>
<span class="lineNum">    5307 </span>            :                 }
<span class="lineNum">    5308 </span><span class="lineNoCov">          0 :                 ao2_unlock(hint);</span>
<span class="lineNum">    5309 </span>            :         }
<span class="lineNum">    5310 </span><span class="lineNoCov">          0 :         ao2_iterator_destroy(&amp;i);</span>
<span class="lineNum">    5311 </span><span class="lineNoCov">          0 :         if (!num)</span>
<span class="lineNum">    5312 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;No hints matching extension %s\n&quot;, a-&gt;argv[3]);</span>
<span class="lineNum">    5313 </span>            :         else
<span class="lineNum">    5314 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;%d hint%s matching extension %s\n&quot;, num, (num!=1 ? &quot;s&quot;:&quot;&quot;), a-&gt;argv[3]);</span>
<span class="lineNum">    5315 </span><span class="lineNoCov">          0 :         return CLI_SUCCESS;</span>
<span class="lineNum">    5316 </span>            : }
<span class="lineNum">    5317 </span>            : 
<span class="lineNum">    5318 </span>            : #if 0
<span class="lineNum">    5319 </span>            : /* This code can be used to test if the system survives running out of memory.
<span class="lineNum">    5320 </span>            :  * It might be an idea to put this in only if ENABLE_AUTODESTRUCT_TESTS is enabled.
<span class="lineNum">    5321 </span>            :  *
<span class="lineNum">    5322 </span>            :  * If you want to test this, these Linux sysctl flags might be appropriate:
<span class="lineNum">    5323 </span>            :  *   vm.overcommit_memory = 2
<span class="lineNum">    5324 </span>            :  *   vm.swappiness = 0
<span class="lineNum">    5325 </span>            :  *
<span class="lineNum">    5326 </span>            :  * &lt;@Corydon76-home&gt; I envision 'core eat disk space' and 'core eat file descriptors' now
<span class="lineNum">    5327 </span>            :  * &lt;@mjordan&gt; egads
<span class="lineNum">    5328 </span>            :  * &lt;@mjordan&gt; it's literally the 'big red' auto-destruct button
<span class="lineNum">    5329 </span>            :  * &lt;@mjordan&gt; if you were wondering who even builds such a thing.... well, now you know
<span class="lineNum">    5330 </span>            :  * ...
<span class="lineNum">    5331 </span>            :  * &lt;@Corydon76-home&gt; What about if they lived only if you defined TEST_FRAMEWORK?  Shouldn't have those on production machines
<span class="lineNum">    5332 </span>            :  * &lt;@mjordan&gt; I think accompanied with an update to one of our README files that &quot;no, really, TEST_FRAMEWORK isn't for you&quot;, I'd be fine
<span class="lineNum">    5333 </span>            :  */
<span class="lineNum">    5334 </span>            : static char *handle_eat_memory(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)
<span class="lineNum">    5335 </span>            : {
<span class="lineNum">    5336 </span>            :         void **blocks;
<span class="lineNum">    5337 </span>            :         int blocks_pos = 0;
<span class="lineNum">    5338 </span>            :         const int blocks_max = 50000;
<span class="lineNum">    5339 </span>            :         long long int allocated = 0;
<span class="lineNum">    5340 </span>            :         int sizes[] = {
<span class="lineNum">    5341 </span>            :                 100 * 1024 * 1024,
<span class="lineNum">    5342 </span>            :                 100 * 1024,
<span class="lineNum">    5343 </span>            :                 2 * 1024,
<span class="lineNum">    5344 </span>            :                 400,
<span class="lineNum">    5345 </span>            :                 0
<span class="lineNum">    5346 </span>            :         };
<span class="lineNum">    5347 </span>            :         int i;
<span class="lineNum">    5348 </span>            : 
<span class="lineNum">    5349 </span>            :         switch (cmd) {
<span class="lineNum">    5350 </span>            :         case CLI_INIT:
<span class="lineNum">    5351 </span>            :                 /* To do: add method to free memory again? 5 minutes? */
<span class="lineNum">    5352 </span>            :                 e-&gt;command = &quot;core eat memory&quot;;
<span class="lineNum">    5353 </span>            :                 e-&gt;usage =
<span class="lineNum">    5354 </span>            :                         &quot;Usage: core eat memory\n&quot;
<span class="lineNum">    5355 </span>            :                         &quot;       Eats all available memory so you can test if the system survives\n&quot;;
<span class="lineNum">    5356 </span>            :                 return NULL;
<span class="lineNum">    5357 </span>            :         case CLI_GENERATE:
<span class="lineNum">    5358 </span>            :                 return NULL;
<span class="lineNum">    5359 </span>            :         }
<span class="lineNum">    5360 </span>            : 
<span class="lineNum">    5361 </span>            :         blocks = ast_malloc(sizeof(void*) * blocks_max);
<span class="lineNum">    5362 </span>            :         if (!blocks) {
<span class="lineNum">    5363 </span>            :                 ast_log(LOG_ERROR, &quot;Already out of mem?\n&quot;);
<span class="lineNum">    5364 </span>            :                 return CLI_SUCCESS;
<span class="lineNum">    5365 </span>            :         }
<span class="lineNum">    5366 </span>            : 
<span class="lineNum">    5367 </span>            :         for (i = 0; sizes[i]; ++i) {
<span class="lineNum">    5368 </span>            :                 int alloc_size = sizes[i];
<span class="lineNum">    5369 </span>            :                 ast_log(LOG_WARNING, &quot;Allocating %d sized blocks (got %d blocks already)\n&quot;, alloc_size, blocks_pos);
<span class="lineNum">    5370 </span>            :                 while (1) {
<span class="lineNum">    5371 </span>            :                         void *block;
<span class="lineNum">    5372 </span>            :                         if (blocks_pos &gt;= blocks_max) {
<span class="lineNum">    5373 </span>            :                                 ast_log(LOG_ERROR, &quot;Memory buffer too small? Run me again :)\n&quot;);
<span class="lineNum">    5374 </span>            :                                 break;
<span class="lineNum">    5375 </span>            :                         }
<span class="lineNum">    5376 </span>            : 
<span class="lineNum">    5377 </span>            :                         block = ast_malloc(alloc_size);
<span class="lineNum">    5378 </span>            :                         if (!block) {
<span class="lineNum">    5379 </span>            :                                 break;
<span class="lineNum">    5380 </span>            :                         }
<span class="lineNum">    5381 </span>            : 
<span class="lineNum">    5382 </span>            :                         blocks[blocks_pos++] = block;
<span class="lineNum">    5383 </span>            :                         allocated += alloc_size;
<span class="lineNum">    5384 </span>            :                 }
<span class="lineNum">    5385 </span>            :         }
<span class="lineNum">    5386 </span>            : 
<span class="lineNum">    5387 </span>            :         /* No freeing of the mem! */
<span class="lineNum">    5388 </span>            :         ast_log(LOG_WARNING, &quot;Allocated %lld bytes total!\n&quot;, allocated);
<span class="lineNum">    5389 </span>            :         return CLI_SUCCESS;
<span class="lineNum">    5390 </span>            : }
<span class="lineNum">    5391 </span>            : #endif
<span class="lineNum">    5392 </span>            : 
<span class="lineNum">    5393 </span>            : /*
<a name="5394"><span class="lineNum">    5394 </span>            :  * 'show dialplan' CLI command implementation functions ...</a>
<span class="lineNum">    5395 </span>            :  */
<span class="lineNum">    5396 </span><span class="lineNoCov">          0 : static char *complete_show_dialplan_context(const char *line, const char *word, int pos,</span>
<span class="lineNum">    5397 </span>            :         int state)
<span class="lineNum">    5398 </span>            : {
<span class="lineNum">    5399 </span><span class="lineNoCov">          0 :         struct ast_context *c = NULL;</span>
<span class="lineNum">    5400 </span><span class="lineNoCov">          0 :         char *ret = NULL;</span>
<span class="lineNum">    5401 </span><span class="lineNoCov">          0 :         int which = 0;</span>
<span class="lineNum">    5402 </span>            :         int wordlen;
<span class="lineNum">    5403 </span>            : 
<span class="lineNum">    5404 </span>            :         /* we are do completion of [exten@]context on second position only */
<span class="lineNum">    5405 </span><span class="lineNoCov">          0 :         if (pos != 2)</span>
<span class="lineNum">    5406 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    5407 </span>            : 
<span class="lineNum">    5408 </span><span class="lineNoCov">          0 :         ast_rdlock_contexts();</span>
<span class="lineNum">    5409 </span>            : 
<span class="lineNum">    5410 </span><span class="lineNoCov">          0 :         wordlen = strlen(word);</span>
<span class="lineNum">    5411 </span>            : 
<span class="lineNum">    5412 </span>            :         /* walk through all contexts and return the n-th match */
<span class="lineNum">    5413 </span><span class="lineNoCov">          0 :         while ( (c = ast_walk_contexts(c)) ) {</span>
<span class="lineNum">    5414 </span><span class="lineNoCov">          0 :                 if (!strncasecmp(word, ast_get_context_name(c), wordlen) &amp;&amp; ++which &gt; state) {</span>
<span class="lineNum">    5415 </span><span class="lineNoCov">          0 :                         ret = ast_strdup(ast_get_context_name(c));</span>
<span class="lineNum">    5416 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    5417 </span>            :                 }
<span class="lineNum">    5418 </span>            :         }
<span class="lineNum">    5419 </span>            : 
<span class="lineNum">    5420 </span><span class="lineNoCov">          0 :         ast_unlock_contexts();</span>
<span class="lineNum">    5421 </span>            : 
<span class="lineNum">    5422 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    5423 </span>            : }
<span class="lineNum">    5424 </span>            : 
<span class="lineNum">    5425 </span>            : /*! \brief Counters for the show dialplan manager command */
<span class="lineNum">    5426 </span>            : struct dialplan_counters {
<span class="lineNum">    5427 </span>            :         int total_items;
<span class="lineNum">    5428 </span>            :         int total_context;
<span class="lineNum">    5429 </span>            :         int total_exten;
<span class="lineNum">    5430 </span>            :         int total_prio;
<span class="lineNum">    5431 </span>            :         int context_existence;
<span class="lineNum">    5432 </span>            :         int extension_existence;
<span class="lineNum">    5433 </span>            : };
<a name="5434"><span class="lineNum">    5434 </span>            : </a>
<span class="lineNum">    5435 </span>            : /*! \brief helper function to print an extension */
<span class="lineNum">    5436 </span><span class="lineCov">          4 : static void print_ext(struct ast_exten *e, char * buf, int buflen)</span>
<span class="lineNum">    5437 </span>            : {
<span class="lineNum">    5438 </span><span class="lineCov">          4 :         int prio = ast_get_extension_priority(e);</span>
<span class="lineNum">    5439 </span><span class="lineCov">          4 :         if (prio == PRIORITY_HINT) {</span>
<span class="lineNum">    5440 </span><span class="lineCov">          2 :                 snprintf(buf, buflen, &quot;hint: %s&quot;,</span>
<span class="lineNum">    5441 </span>            :                         ast_get_extension_app(e));
<span class="lineNum">    5442 </span>            :         } else {
<span class="lineNum">    5443 </span><span class="lineCov">          2 :                 snprintf(buf, buflen, &quot;%d. %s(%s)&quot;,</span>
<span class="lineNum">    5444 </span>            :                         prio, ast_get_extension_app(e),
<span class="lineNum">    5445 </span><span class="lineCov">          2 :                         (!ast_strlen_zero(ast_get_extension_app_data(e)) ? (char *)ast_get_extension_app_data(e) : &quot;&quot;));</span>
<span class="lineNum">    5446 </span>            :         }
<span class="lineNum">    5447 </span><span class="lineCov">          4 : }</span>
<a name="5448"><span class="lineNum">    5448 </span>            : </a>
<span class="lineNum">    5449 </span>            : /*! \brief Writes CLI output of a single extension for show dialplan */
<span class="lineNum">    5450 </span><span class="lineCov">          4 : static void show_dialplan_helper_extension_output(int fd, char *buf1, char *buf2, struct ast_exten *exten)</span>
<span class="lineNum">    5451 </span>            : {
<span class="lineNum">    5452 </span><span class="lineCov">          4 :         if (ast_get_extension_registrar_file(exten)) {</span>
<span class="lineNum">    5453 </span><span class="lineCov">          4 :                 ast_cli(fd, &quot;  %-17s %-45s [%s:%d]\n&quot;,</span>
<span class="lineNum">    5454 </span>            :                         buf1, buf2,
<span class="lineNum">    5455 </span>            :                         ast_get_extension_registrar_file(exten),
<span class="lineNum">    5456 </span>            :                         ast_get_extension_registrar_line(exten));
<span class="lineNum">    5457 </span><span class="lineCov">          4 :                 return;</span>
<span class="lineNum">    5458 </span>            :         }
<span class="lineNum">    5459 </span>            : 
<span class="lineNum">    5460 </span><span class="lineNoCov">          0 :         ast_cli(fd, &quot;  %-17s %-45s [%s]\n&quot;,</span>
<span class="lineNum">    5461 </span>            :                 buf1, buf2, ast_get_extension_registrar(exten));
<span class="lineNum">    5462 </span>            : }
<a name="5463"><span class="lineNum">    5463 </span>            : </a>
<span class="lineNum">    5464 </span>            : /* XXX not verified */
<span class="lineNum">    5465 </span><span class="lineCov">          1 : static int show_dialplan_helper(int fd, const char *context, const char *exten, struct dialplan_counters *dpc, const struct ast_include *rinclude, int includecount, const char *includes[])</span>
<span class="lineNum">    5466 </span>            : {
<span class="lineNum">    5467 </span><span class="lineCov">          1 :         struct ast_context *c = NULL;</span>
<span class="lineNum">    5468 </span><span class="lineCov">          1 :         int res = 0, old_total_exten = dpc-&gt;total_exten;</span>
<span class="lineNum">    5469 </span>            : 
<span class="lineNum">    5470 </span><span class="lineCov">          1 :         ast_rdlock_contexts();</span>
<span class="lineNum">    5471 </span>            : 
<span class="lineNum">    5472 </span>            :         /* walk all contexts ... */
<span class="lineNum">    5473 </span><span class="lineCov">          4 :         while ( (c = ast_walk_contexts(c)) ) {</span>
<span class="lineNum">    5474 </span>            :                 int idx;
<span class="lineNum">    5475 </span>            :                 struct ast_exten *e;
<span class="lineNum">    5476 </span>            : #ifndef LOW_MEMORY
<span class="lineNum">    5477 </span>            :                 char buf[1024], buf2[1024];
<span class="lineNum">    5478 </span>            : #else
<span class="lineNum">    5479 </span>            :                 char buf[256], buf2[256];
<span class="lineNum">    5480 </span>            : #endif
<span class="lineNum">    5481 </span><span class="lineCov">          3 :                 int context_info_printed = 0;</span>
<span class="lineNum">    5482 </span>            : 
<span class="lineNum">    5483 </span><span class="lineCov">          3 :                 if (context &amp;&amp; strcmp(ast_get_context_name(c), context))</span>
<span class="lineNum">    5484 </span><span class="lineCov">          2 :                         continue;       /* skip this one, name doesn't match */</span>
<span class="lineNum">    5485 </span>            : 
<span class="lineNum">    5486 </span><span class="lineCov">          1 :                 dpc-&gt;context_existence = 1;</span>
<span class="lineNum">    5487 </span>            : 
<span class="lineNum">    5488 </span><span class="lineCov">          1 :                 ast_rdlock_context(c);</span>
<span class="lineNum">    5489 </span>            : 
<span class="lineNum">    5490 </span>            :                 /* are we looking for exten too? if yes, we print context
<span class="lineNum">    5491 </span>            :                  * only if we find our extension.
<span class="lineNum">    5492 </span>            :                  * Otherwise print context even if empty ?
<span class="lineNum">    5493 </span>            :                  * XXX i am not sure how the rinclude is handled.
<span class="lineNum">    5494 </span>            :                  * I think it ought to go inside.
<span class="lineNum">    5495 </span>            :                  */
<span class="lineNum">    5496 </span><span class="lineCov">          1 :                 if (!exten) {</span>
<span class="lineNum">    5497 </span><span class="lineCov">          1 :                         dpc-&gt;total_context++;</span>
<span class="lineNum">    5498 </span><span class="lineCov">          1 :                         ast_cli(fd, &quot;[ Context '%s' created by '%s' ]\n&quot;,</span>
<span class="lineNum">    5499 </span>            :                                 ast_get_context_name(c), ast_get_context_registrar(c));
<span class="lineNum">    5500 </span><span class="lineCov">          1 :                         if (c-&gt;autohints) {</span>
<span class="lineNum">    5501 </span><span class="lineNoCov">          0 :                                 ast_cli(fd, &quot;Autohints support enabled\n&quot;);</span>
<span class="lineNum">    5502 </span>            :                         }
<span class="lineNum">    5503 </span><span class="lineCov">          1 :                         context_info_printed = 1;</span>
<span class="lineNum">    5504 </span>            :                 }
<span class="lineNum">    5505 </span>            : 
<span class="lineNum">    5506 </span>            :                 /* walk extensions ... */
<span class="lineNum">    5507 </span><span class="lineCov">          1 :                 e = NULL;</span>
<span class="lineNum">    5508 </span><span class="lineCov">          5 :                 while ( (e = ast_walk_context_extensions(c, e)) ) {</span>
<span class="lineNum">    5509 </span>            :                         struct ast_exten *p;
<span class="lineNum">    5510 </span>            : 
<span class="lineNum">    5511 </span><span class="lineCov">          4 :                         if (exten &amp;&amp; !ast_extension_match(ast_get_extension_name(e), exten))</span>
<span class="lineNum">    5512 </span><span class="lineNoCov">          0 :                                 continue;       /* skip, extension match failed */</span>
<span class="lineNum">    5513 </span>            : 
<span class="lineNum">    5514 </span><span class="lineCov">          4 :                         dpc-&gt;extension_existence = 1;</span>
<span class="lineNum">    5515 </span>            : 
<span class="lineNum">    5516 </span>            :                         /* may we print context info? */
<span class="lineNum">    5517 </span><span class="lineCov">          4 :                         if (!context_info_printed) {</span>
<span class="lineNum">    5518 </span><span class="lineNoCov">          0 :                                 dpc-&gt;total_context++;</span>
<span class="lineNum">    5519 </span><span class="lineNoCov">          0 :                                 if (rinclude) { /* TODO Print more info about rinclude */</span>
<span class="lineNum">    5520 </span><span class="lineNoCov">          0 :                                         ast_cli(fd, &quot;[ Included context '%s' created by '%s' ]\n&quot;,</span>
<span class="lineNum">    5521 </span>            :                                                 ast_get_context_name(c), ast_get_context_registrar(c));
<span class="lineNum">    5522 </span>            :                                 } else {
<span class="lineNum">    5523 </span><span class="lineNoCov">          0 :                                         ast_cli(fd, &quot;[ Context '%s' created by '%s' ]\n&quot;,</span>
<span class="lineNum">    5524 </span>            :                                                 ast_get_context_name(c), ast_get_context_registrar(c));
<span class="lineNum">    5525 </span><span class="lineNoCov">          0 :                                         if (c-&gt;autohints) {</span>
<span class="lineNum">    5526 </span><span class="lineNoCov">          0 :                                                 ast_cli(fd, &quot;Autohints support enabled\n&quot;);</span>
<span class="lineNum">    5527 </span>            :                                         }
<span class="lineNum">    5528 </span>            :                                 }
<span class="lineNum">    5529 </span><span class="lineNoCov">          0 :                                 context_info_printed = 1;</span>
<span class="lineNum">    5530 </span>            :                         }
<span class="lineNum">    5531 </span><span class="lineCov">          4 :                         dpc-&gt;total_prio++;</span>
<span class="lineNum">    5532 </span>            : 
<span class="lineNum">    5533 </span>            :                         /* write extension name and first peer */
<span class="lineNum">    5534 </span><span class="lineCov">          4 :                         if (e-&gt;matchcid == AST_EXT_MATCHCID_ON)</span>
<span class="lineNum">    5535 </span><span class="lineCov">          1 :                                 snprintf(buf, sizeof(buf), &quot;'%s' (CID match '%s') =&gt; &quot;, ast_get_extension_name(e), e-&gt;cidmatch);</span>
<span class="lineNum">    5536 </span>            :                         else
<span class="lineNum">    5537 </span><span class="lineCov">          3 :                                 snprintf(buf, sizeof(buf), &quot;'%s' =&gt;&quot;, ast_get_extension_name(e));</span>
<span class="lineNum">    5538 </span>            : 
<span class="lineNum">    5539 </span><span class="lineCov">          4 :                         print_ext(e, buf2, sizeof(buf2));</span>
<span class="lineNum">    5540 </span>            : 
<span class="lineNum">    5541 </span><span class="lineCov">          4 :                         show_dialplan_helper_extension_output(fd, buf, buf2, e);</span>
<span class="lineNum">    5542 </span>            : 
<span class="lineNum">    5543 </span><span class="lineCov">          4 :                         dpc-&gt;total_exten++;</span>
<span class="lineNum">    5544 </span>            :                         /* walk next extension peers */
<span class="lineNum">    5545 </span><span class="lineCov">          4 :                         p = e;  /* skip the first one, we already got it */</span>
<span class="lineNum">    5546 </span><span class="lineCov">          4 :                         while ( (p = ast_walk_extension_priorities(e, p)) ) {</span>
<span class="lineNum">    5547 </span><span class="lineNoCov">          0 :                                 const char *el = ast_get_extension_label(p);</span>
<span class="lineNum">    5548 </span><span class="lineNoCov">          0 :                                 dpc-&gt;total_prio++;</span>
<span class="lineNum">    5549 </span><span class="lineNoCov">          0 :                                 if (el)</span>
<span class="lineNum">    5550 </span><span class="lineNoCov">          0 :                                         snprintf(buf, sizeof(buf), &quot;   [%s]&quot;, el);</span>
<span class="lineNum">    5551 </span>            :                                 else
<span class="lineNum">    5552 </span><span class="lineNoCov">          0 :                                         buf[0] = '\0';</span>
<span class="lineNum">    5553 </span><span class="lineNoCov">          0 :                                 print_ext(p, buf2, sizeof(buf2));</span>
<span class="lineNum">    5554 </span>            : 
<span class="lineNum">    5555 </span><span class="lineNoCov">          0 :                                 show_dialplan_helper_extension_output(fd, buf, buf2, p);</span>
<span class="lineNum">    5556 </span>            :                         }
<span class="lineNum">    5557 </span>            :                 }
<span class="lineNum">    5558 </span>            : 
<span class="lineNum">    5559 </span>            :                 /* walk included and write info ... */
<span class="lineNum">    5560 </span><span class="lineCov">          1 :                 for (idx = 0; idx &lt; ast_context_includes_count(c); idx++) {</span>
<span class="lineNum">    5561 </span><span class="lineNoCov">          0 :                         const struct ast_include *i = ast_context_includes_get(c, idx);</span>
<span class="lineNum">    5562 </span>            : 
<span class="lineNum">    5563 </span><span class="lineNoCov">          0 :                         snprintf(buf, sizeof(buf), &quot;'%s'&quot;, ast_get_include_name(i));</span>
<span class="lineNum">    5564 </span><span class="lineNoCov">          0 :                         if (exten) {</span>
<span class="lineNum">    5565 </span>            :                                 /* Check all includes for the requested extension */
<span class="lineNum">    5566 </span><span class="lineNoCov">          0 :                                 if (includecount &gt;= AST_PBX_MAX_STACK) {</span>
<span class="lineNum">    5567 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_WARNING, &quot;Maximum include depth exceeded!\n&quot;);</span>
<span class="lineNum">    5568 </span>            :                                 } else {
<span class="lineNum">    5569 </span><span class="lineNoCov">          0 :                                         int dupe = 0;</span>
<span class="lineNum">    5570 </span>            :                                         int x;
<span class="lineNum">    5571 </span><span class="lineNoCov">          0 :                                         for (x = 0; x &lt; includecount; x++) {</span>
<span class="lineNum">    5572 </span><span class="lineNoCov">          0 :                                                 if (!strcasecmp(includes[x], ast_get_include_name(i))) {</span>
<span class="lineNum">    5573 </span><span class="lineNoCov">          0 :                                                         dupe++;</span>
<span class="lineNum">    5574 </span><span class="lineNoCov">          0 :                                                         break;</span>
<span class="lineNum">    5575 </span>            :                                                 }
<span class="lineNum">    5576 </span>            :                                         }
<span class="lineNum">    5577 </span><span class="lineNoCov">          0 :                                         if (!dupe) {</span>
<span class="lineNum">    5578 </span><span class="lineNoCov">          0 :                                                 includes[includecount] = ast_get_include_name(i);</span>
<span class="lineNum">    5579 </span><span class="lineNoCov">          0 :                                                 show_dialplan_helper(fd, ast_get_include_name(i), exten, dpc, i, includecount + 1, includes);</span>
<span class="lineNum">    5580 </span>            :                                         } else {
<span class="lineNum">    5581 </span><span class="lineNoCov">          0 :                                                 ast_log(LOG_WARNING, &quot;Avoiding circular include of %s within %s\n&quot;, ast_get_include_name(i), context);</span>
<span class="lineNum">    5582 </span>            :                                         }
<span class="lineNum">    5583 </span>            :                                 }
<span class="lineNum">    5584 </span>            :                         } else {
<span class="lineNum">    5585 </span><span class="lineNoCov">          0 :                                 ast_cli(fd, &quot;  Include =&gt;        %-45s [%s]\n&quot;,</span>
<span class="lineNum">    5586 </span>            :                                         buf, ast_get_include_registrar(i));
<span class="lineNum">    5587 </span>            :                         }
<span class="lineNum">    5588 </span>            :                 }
<span class="lineNum">    5589 </span>            : 
<span class="lineNum">    5590 </span>            :                 /* walk ignore patterns and write info ... */
<span class="lineNum">    5591 </span><span class="lineCov">          1 :                 for (idx = 0; idx &lt; ast_context_ignorepats_count(c); idx++) {</span>
<span class="lineNum">    5592 </span><span class="lineNoCov">          0 :                         const struct ast_ignorepat *ip = ast_context_ignorepats_get(c, idx);</span>
<span class="lineNum">    5593 </span><span class="lineNoCov">          0 :                         const char *ipname = ast_get_ignorepat_name(ip);</span>
<span class="lineNum">    5594 </span>            :                         char ignorepat[AST_MAX_EXTENSION];
<span class="lineNum">    5595 </span>            : 
<span class="lineNum">    5596 </span><span class="lineNoCov">          0 :                         snprintf(buf, sizeof(buf), &quot;'%s'&quot;, ipname);</span>
<span class="lineNum">    5597 </span><span class="lineNoCov">          0 :                         snprintf(ignorepat, sizeof(ignorepat), &quot;_%s.&quot;, ipname);</span>
<span class="lineNum">    5598 </span><span class="lineNoCov">          0 :                         if (!exten || ast_extension_match(ignorepat, exten)) {</span>
<span class="lineNum">    5599 </span><span class="lineNoCov">          0 :                                 ast_cli(fd, &quot;  Ignore pattern =&gt; %-45s [%s]\n&quot;,</span>
<span class="lineNum">    5600 </span>            :                                         buf, ast_get_ignorepat_registrar(ip));
<span class="lineNum">    5601 </span>            :                         }
<span class="lineNum">    5602 </span>            :                 }
<span class="lineNum">    5603 </span><span class="lineCov">          1 :                 if (!rinclude) {</span>
<span class="lineNum">    5604 </span><span class="lineCov">          1 :                         for (idx = 0; idx &lt; ast_context_switches_count(c); idx++) {</span>
<span class="lineNum">    5605 </span><span class="lineNoCov">          0 :                                 const struct ast_sw *sw = ast_context_switches_get(c, idx);</span>
<span class="lineNum">    5606 </span>            : 
<span class="lineNum">    5607 </span><span class="lineNoCov">          0 :                                 snprintf(buf, sizeof(buf), &quot;'%s/%s'&quot;,</span>
<span class="lineNum">    5608 </span>            :                                         ast_get_switch_name(sw),
<span class="lineNum">    5609 </span>            :                                         ast_get_switch_data(sw));
<span class="lineNum">    5610 </span><span class="lineNoCov">          0 :                                 ast_cli(fd, &quot;  Alt. Switch =&gt;    %-45s [%s]\n&quot;,</span>
<span class="lineNum">    5611 </span>            :                                         buf, ast_get_switch_registrar(sw));
<span class="lineNum">    5612 </span>            :                         }
<span class="lineNum">    5613 </span>            :                 }
<span class="lineNum">    5614 </span>            : 
<span class="lineNum">    5615 </span><span class="lineCov">          1 :                 ast_unlock_context(c);</span>
<span class="lineNum">    5616 </span>            : 
<span class="lineNum">    5617 </span>            :                 /* if we print something in context, make an empty line */
<span class="lineNum">    5618 </span><span class="lineCov">          1 :                 if (context_info_printed)</span>
<span class="lineNum">    5619 </span><span class="lineCov">          1 :                         ast_cli(fd, &quot;\n&quot;);</span>
<span class="lineNum">    5620 </span>            :         }
<span class="lineNum">    5621 </span><span class="lineCov">          1 :         ast_unlock_contexts();</span>
<span class="lineNum">    5622 </span>            : 
<span class="lineNum">    5623 </span><span class="lineCov">          1 :         return (dpc-&gt;total_exten == old_total_exten) ? -1 : res;</span>
<a name="5624"><span class="lineNum">    5624 </span>            : }</a>
<span class="lineNum">    5625 </span>            : 
<span class="lineNum">    5626 </span><span class="lineNoCov">          0 : static int show_debug_helper(int fd, const char *context, const char *exten, struct dialplan_counters *dpc, struct ast_include *rinclude, int includecount, const char *includes[])</span>
<span class="lineNum">    5627 </span>            : {
<span class="lineNum">    5628 </span><span class="lineNoCov">          0 :         struct ast_context *c = NULL;</span>
<span class="lineNum">    5629 </span><span class="lineNoCov">          0 :         int res = 0, old_total_exten = dpc-&gt;total_exten;</span>
<span class="lineNum">    5630 </span>            : 
<span class="lineNum">    5631 </span><span class="lineNoCov">          0 :         ast_cli(fd,&quot;\n     In-mem exten Trie for Fast Extension Pattern Matching:\n\n&quot;);</span>
<span class="lineNum">    5632 </span>            : 
<span class="lineNum">    5633 </span><span class="lineNoCov">          0 :         ast_cli(fd,&quot;\n           Explanation: Node Contents Format = &lt;char(s) to match&gt;:&lt;pattern?&gt;:&lt;specif&gt;:[matched extension]\n&quot;);</span>
<span class="lineNum">    5634 </span><span class="lineNoCov">          0 :         ast_cli(fd,    &quot;                        Where &lt;char(s) to match&gt; is a set of chars, any one of which should match the current character\n&quot;);</span>
<span class="lineNum">    5635 </span><span class="lineNoCov">          0 :         ast_cli(fd,    &quot;                              &lt;pattern?&gt;: Y if this a pattern match (eg. _XZN[5-7]), N otherwise\n&quot;);</span>
<span class="lineNum">    5636 </span><span class="lineNoCov">          0 :         ast_cli(fd,    &quot;                              &lt;specif&gt;: an assigned 'exactness' number for this matching char. The lower the number, the more exact the match\n&quot;);</span>
<span class="lineNum">    5637 </span><span class="lineNoCov">          0 :         ast_cli(fd,    &quot;                              [matched exten]: If all chars matched to this point, which extension this matches. In form: EXTEN:&lt;exten string&gt;\n&quot;);</span>
<span class="lineNum">    5638 </span><span class="lineNoCov">          0 :         ast_cli(fd,    &quot;                        In general, you match a trie node to a string character, from left to right. All possible matching chars\n&quot;);</span>
<span class="lineNum">    5639 </span><span class="lineNoCov">          0 :         ast_cli(fd,    &quot;                        are in a string vertically, separated by an unbroken string of '+' characters.\n\n&quot;);</span>
<span class="lineNum">    5640 </span><span class="lineNoCov">          0 :         ast_rdlock_contexts();</span>
<span class="lineNum">    5641 </span>            : 
<span class="lineNum">    5642 </span>            :         /* walk all contexts ... */
<span class="lineNum">    5643 </span><span class="lineNoCov">          0 :         while ( (c = ast_walk_contexts(c)) ) {</span>
<span class="lineNum">    5644 </span><span class="lineNoCov">          0 :                 int context_info_printed = 0;</span>
<span class="lineNum">    5645 </span>            : 
<span class="lineNum">    5646 </span><span class="lineNoCov">          0 :                 if (context &amp;&amp; strcmp(ast_get_context_name(c), context))</span>
<span class="lineNum">    5647 </span><span class="lineNoCov">          0 :                         continue;       /* skip this one, name doesn't match */</span>
<span class="lineNum">    5648 </span>            : 
<span class="lineNum">    5649 </span><span class="lineNoCov">          0 :                 dpc-&gt;context_existence = 1;</span>
<span class="lineNum">    5650 </span>            : 
<span class="lineNum">    5651 </span><span class="lineNoCov">          0 :                 if (!c-&gt;pattern_tree) {</span>
<span class="lineNum">    5652 </span>            :                         /* Ignore check_return warning from Coverity for ast_exists_extension below */
<span class="lineNum">    5653 </span><span class="lineNoCov">          0 :                         ast_exists_extension(NULL, c-&gt;name, &quot;s&quot;, 1, &quot;&quot;); /* do this to force the trie to built, if it is not already */</span>
<span class="lineNum">    5654 </span>            :                 }
<span class="lineNum">    5655 </span>            : 
<span class="lineNum">    5656 </span><span class="lineNoCov">          0 :                 ast_rdlock_context(c);</span>
<span class="lineNum">    5657 </span>            : 
<span class="lineNum">    5658 </span><span class="lineNoCov">          0 :                 dpc-&gt;total_context++;</span>
<span class="lineNum">    5659 </span><span class="lineNoCov">          0 :                 ast_cli(fd, &quot;[ Context '%s' created by '%s' ]\n&quot;,</span>
<span class="lineNum">    5660 </span>            :                         ast_get_context_name(c), ast_get_context_registrar(c));
<span class="lineNum">    5661 </span><span class="lineNoCov">          0 :                 context_info_printed = 1;</span>
<span class="lineNum">    5662 </span>            : 
<span class="lineNum">    5663 </span><span class="lineNoCov">          0 :                 if (c-&gt;pattern_tree)</span>
<span class="lineNum">    5664 </span>            :                 {
<span class="lineNum">    5665 </span><span class="lineNoCov">          0 :                         cli_match_char_tree(c-&gt;pattern_tree, &quot; &quot;, fd);</span>
<span class="lineNum">    5666 </span>            :                 } else {
<span class="lineNum">    5667 </span><span class="lineNoCov">          0 :                         ast_cli(fd,&quot;\n     No Pattern Trie present. Perhaps the context is empty...or there is trouble...\n\n&quot;);</span>
<span class="lineNum">    5668 </span>            :                 }
<span class="lineNum">    5669 </span>            : 
<span class="lineNum">    5670 </span><span class="lineNoCov">          0 :                 ast_unlock_context(c);</span>
<span class="lineNum">    5671 </span>            : 
<span class="lineNum">    5672 </span>            :                 /* if we print something in context, make an empty line */
<span class="lineNum">    5673 </span><span class="lineNoCov">          0 :                 if (context_info_printed)</span>
<span class="lineNum">    5674 </span><span class="lineNoCov">          0 :                         ast_cli(fd, &quot;\n&quot;);</span>
<span class="lineNum">    5675 </span>            :         }
<span class="lineNum">    5676 </span><span class="lineNoCov">          0 :         ast_unlock_contexts();</span>
<span class="lineNum">    5677 </span>            : 
<span class="lineNum">    5678 </span><span class="lineNoCov">          0 :         return (dpc-&gt;total_exten == old_total_exten) ? -1 : res;</span>
<a name="5679"><span class="lineNum">    5679 </span>            : }</a>
<span class="lineNum">    5680 </span>            : 
<span class="lineNum">    5681 </span><span class="lineCov">       1125 : static char *handle_show_dialplan(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)</span>
<span class="lineNum">    5682 </span>            : {
<span class="lineNum">    5683 </span><span class="lineCov">       1125 :         char *exten = NULL, *context = NULL;</span>
<span class="lineNum">    5684 </span>            :         /* Variables used for different counters */
<span class="lineNum">    5685 </span>            :         struct dialplan_counters counters;
<span class="lineNum">    5686 </span>            :         const char *incstack[AST_PBX_MAX_STACK];
<span class="lineNum">    5687 </span>            : 
<span class="lineNum">    5688 </span><span class="lineCov">       1125 :         switch (cmd) {</span>
<span class="lineNum">    5689 </span><span class="lineCov">       1124 :         case CLI_INIT:</span>
<span class="lineNum">    5690 </span><span class="lineCov">       1124 :                 e-&gt;command = &quot;dialplan show&quot;;</span>
<span class="lineNum">    5691 </span><span class="lineCov">       1124 :                 e-&gt;usage =</span>
<span class="lineNum">    5692 </span>            :                         &quot;Usage: dialplan show [[exten@]context]\n&quot;
<span class="lineNum">    5693 </span>            :                         &quot;       Show dialplan\n&quot;;
<span class="lineNum">    5694 </span><span class="lineCov">       1124 :                 return NULL;</span>
<span class="lineNum">    5695 </span><span class="lineNoCov">          0 :         case CLI_GENERATE:</span>
<span class="lineNum">    5696 </span><span class="lineNoCov">          0 :                 return complete_show_dialplan_context(a-&gt;line, a-&gt;word, a-&gt;pos, a-&gt;n);</span>
<span class="lineNum">    5697 </span>            :         }
<span class="lineNum">    5698 </span>            : 
<span class="lineNum">    5699 </span><span class="lineCov">          1 :         memset(&amp;counters, 0, sizeof(counters));</span>
<span class="lineNum">    5700 </span>            : 
<span class="lineNum">    5701 </span><span class="lineCov">          1 :         if (a-&gt;argc != 2 &amp;&amp; a-&gt;argc != 3)</span>
<span class="lineNum">    5702 </span><span class="lineNoCov">          0 :                 return CLI_SHOWUSAGE;</span>
<span class="lineNum">    5703 </span>            : 
<span class="lineNum">    5704 </span>            :         /* we obtain [exten@]context? if yes, split them ... */
<span class="lineNum">    5705 </span><span class="lineCov">          1 :         if (a-&gt;argc == 3) {</span>
<span class="lineNum">    5706 </span><span class="lineCov">          1 :                 if (strchr(a-&gt;argv[2], '@')) {       /* split into exten &amp; context */</span>
<span class="lineNum">    5707 </span><span class="lineNoCov">          0 :                         context = ast_strdupa(a-&gt;argv[2]);</span>
<span class="lineNum">    5708 </span><span class="lineNoCov">          0 :                         exten = strsep(&amp;context, &quot;@&quot;);</span>
<span class="lineNum">    5709 </span>            :                         /* change empty strings to NULL */
<span class="lineNum">    5710 </span><span class="lineNoCov">          0 :                         if (ast_strlen_zero(exten))</span>
<span class="lineNum">    5711 </span><span class="lineNoCov">          0 :                                 exten = NULL;</span>
<span class="lineNum">    5712 </span>            :                 } else { /* no '@' char, only context given */
<span class="lineNum">    5713 </span><span class="lineCov">          1 :                         context = ast_strdupa(a-&gt;argv[2]);</span>
<span class="lineNum">    5714 </span>            :                 }
<span class="lineNum">    5715 </span><span class="lineCov">          1 :                 if (ast_strlen_zero(context))</span>
<span class="lineNum">    5716 </span><span class="lineNoCov">          0 :                         context = NULL;</span>
<span class="lineNum">    5717 </span>            :         }
<span class="lineNum">    5718 </span>            :         /* else Show complete dial plan, context and exten are NULL */
<span class="lineNum">    5719 </span><span class="lineCov">          1 :         show_dialplan_helper(a-&gt;fd, context, exten, &amp;counters, NULL, 0, incstack);</span>
<span class="lineNum">    5720 </span>            : 
<span class="lineNum">    5721 </span>            :         /* check for input failure and throw some error messages */
<span class="lineNum">    5722 </span><span class="lineCov">          1 :         if (context &amp;&amp; !counters.context_existence) {</span>
<span class="lineNum">    5723 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;There is no existence of '%s' context\n&quot;, context);</span>
<span class="lineNum">    5724 </span><span class="lineNoCov">          0 :                 return CLI_FAILURE;</span>
<span class="lineNum">    5725 </span>            :         }
<span class="lineNum">    5726 </span>            : 
<span class="lineNum">    5727 </span><span class="lineCov">          1 :         if (exten &amp;&amp; !counters.extension_existence) {</span>
<span class="lineNum">    5728 </span><span class="lineNoCov">          0 :                 if (context)</span>
<span class="lineNum">    5729 </span><span class="lineNoCov">          0 :                         ast_cli(a-&gt;fd, &quot;There is no existence of %s@%s extension\n&quot;,</span>
<span class="lineNum">    5730 </span>            :                                 exten, context);
<span class="lineNum">    5731 </span>            :                 else
<span class="lineNum">    5732 </span><span class="lineNoCov">          0 :                         ast_cli(a-&gt;fd,</span>
<span class="lineNum">    5733 </span>            :                                 &quot;There is no existence of '%s' extension in all contexts\n&quot;,
<span class="lineNum">    5734 </span>            :                                 exten);
<span class="lineNum">    5735 </span><span class="lineNoCov">          0 :                 return CLI_FAILURE;</span>
<span class="lineNum">    5736 </span>            :         }
<span class="lineNum">    5737 </span>            : 
<span class="lineNum">    5738 </span><span class="lineCov">          3 :         ast_cli(a-&gt;fd,&quot;-= %d %s (%d %s) in %d %s. =-\n&quot;,</span>
<span class="lineNum">    5739 </span><span class="lineCov">          1 :                                 counters.total_exten, counters.total_exten == 1 ? &quot;extension&quot; : &quot;extensions&quot;,</span>
<span class="lineNum">    5740 </span><span class="lineCov">          1 :                                 counters.total_prio, counters.total_prio == 1 ? &quot;priority&quot; : &quot;priorities&quot;,</span>
<span class="lineNum">    5741 </span><span class="lineCov">          1 :                                 counters.total_context, counters.total_context == 1 ? &quot;context&quot; : &quot;contexts&quot;);</span>
<span class="lineNum">    5742 </span>            : 
<span class="lineNum">    5743 </span>            :         /* everything ok */
<span class="lineNum">    5744 </span><span class="lineCov">          1 :         return CLI_SUCCESS;</span>
<span class="lineNum">    5745 </span>            : }
<a name="5746"><span class="lineNum">    5746 </span>            : </a>
<span class="lineNum">    5747 </span>            : /*! \brief Send ack once */
<span class="lineNum">    5748 </span><span class="lineCov">       1124 : static char *handle_debug_dialplan(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)</span>
<span class="lineNum">    5749 </span>            : {
<span class="lineNum">    5750 </span><span class="lineCov">       1124 :         char *exten = NULL, *context = NULL;</span>
<span class="lineNum">    5751 </span>            :         /* Variables used for different counters */
<span class="lineNum">    5752 </span>            :         struct dialplan_counters counters;
<span class="lineNum">    5753 </span>            :         const char *incstack[AST_PBX_MAX_STACK];
<span class="lineNum">    5754 </span>            : 
<span class="lineNum">    5755 </span><span class="lineCov">       1124 :         switch (cmd) {</span>
<span class="lineNum">    5756 </span><span class="lineCov">       1124 :         case CLI_INIT:</span>
<span class="lineNum">    5757 </span><span class="lineCov">       1124 :                 e-&gt;command = &quot;dialplan debug&quot;;</span>
<span class="lineNum">    5758 </span><span class="lineCov">       1124 :                 e-&gt;usage =</span>
<span class="lineNum">    5759 </span>            :                         &quot;Usage: dialplan debug [context]\n&quot;
<span class="lineNum">    5760 </span>            :                         &quot;       Show dialplan context Trie(s). Usually only useful to folks debugging the deep internals of the fast pattern matcher\n&quot;;
<span class="lineNum">    5761 </span><span class="lineCov">       1124 :                 return NULL;</span>
<span class="lineNum">    5762 </span><span class="lineNoCov">          0 :         case CLI_GENERATE:</span>
<span class="lineNum">    5763 </span><span class="lineNoCov">          0 :                 return complete_show_dialplan_context(a-&gt;line, a-&gt;word, a-&gt;pos, a-&gt;n);</span>
<span class="lineNum">    5764 </span>            :         }
<span class="lineNum">    5765 </span>            : 
<span class="lineNum">    5766 </span><span class="lineNoCov">          0 :         memset(&amp;counters, 0, sizeof(counters));</span>
<span class="lineNum">    5767 </span>            : 
<span class="lineNum">    5768 </span><span class="lineNoCov">          0 :         if (a-&gt;argc != 2 &amp;&amp; a-&gt;argc != 3)</span>
<span class="lineNum">    5769 </span><span class="lineNoCov">          0 :                 return CLI_SHOWUSAGE;</span>
<span class="lineNum">    5770 </span>            : 
<span class="lineNum">    5771 </span>            :         /* we obtain [exten@]context? if yes, split them ... */
<span class="lineNum">    5772 </span>            :         /* note: we ignore the exten totally here .... */
<span class="lineNum">    5773 </span><span class="lineNoCov">          0 :         if (a-&gt;argc == 3) {</span>
<span class="lineNum">    5774 </span><span class="lineNoCov">          0 :                 if (strchr(a-&gt;argv[2], '@')) {       /* split into exten &amp; context */</span>
<span class="lineNum">    5775 </span><span class="lineNoCov">          0 :                         context = ast_strdupa(a-&gt;argv[2]);</span>
<span class="lineNum">    5776 </span><span class="lineNoCov">          0 :                         exten = strsep(&amp;context, &quot;@&quot;);</span>
<span class="lineNum">    5777 </span>            :                         /* change empty strings to NULL */
<span class="lineNum">    5778 </span><span class="lineNoCov">          0 :                         if (ast_strlen_zero(exten))</span>
<span class="lineNum">    5779 </span><span class="lineNoCov">          0 :                                 exten = NULL;</span>
<span class="lineNum">    5780 </span>            :                 } else { /* no '@' char, only context given */
<span class="lineNum">    5781 </span><span class="lineNoCov">          0 :                         context = ast_strdupa(a-&gt;argv[2]);</span>
<span class="lineNum">    5782 </span>            :                 }
<span class="lineNum">    5783 </span><span class="lineNoCov">          0 :                 if (ast_strlen_zero(context))</span>
<span class="lineNum">    5784 </span><span class="lineNoCov">          0 :                         context = NULL;</span>
<span class="lineNum">    5785 </span>            :         }
<span class="lineNum">    5786 </span>            :         /* else Show complete dial plan, context and exten are NULL */
<span class="lineNum">    5787 </span><span class="lineNoCov">          0 :         show_debug_helper(a-&gt;fd, context, exten, &amp;counters, NULL, 0, incstack);</span>
<span class="lineNum">    5788 </span>            : 
<span class="lineNum">    5789 </span>            :         /* check for input failure and throw some error messages */
<span class="lineNum">    5790 </span><span class="lineNoCov">          0 :         if (context &amp;&amp; !counters.context_existence) {</span>
<span class="lineNum">    5791 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;There is no existence of '%s' context\n&quot;, context);</span>
<span class="lineNum">    5792 </span><span class="lineNoCov">          0 :                 return CLI_FAILURE;</span>
<span class="lineNum">    5793 </span>            :         }
<span class="lineNum">    5794 </span>            : 
<span class="lineNum">    5795 </span>            : 
<span class="lineNum">    5796 </span><span class="lineNoCov">          0 :         ast_cli(a-&gt;fd,&quot;-= %d %s. =-\n&quot;,</span>
<span class="lineNum">    5797 </span><span class="lineNoCov">          0 :                         counters.total_context, counters.total_context == 1 ? &quot;context&quot; : &quot;contexts&quot;);</span>
<span class="lineNum">    5798 </span>            : 
<span class="lineNum">    5799 </span>            :         /* everything ok */
<span class="lineNum">    5800 </span><span class="lineNoCov">          0 :         return CLI_SUCCESS;</span>
<span class="lineNum">    5801 </span>            : }
<a name="5802"><span class="lineNum">    5802 </span>            : </a>
<span class="lineNum">    5803 </span>            : /*! \brief Send ack once */
<span class="lineNum">    5804 </span><span class="lineCov">          4 : static void manager_dpsendack(struct mansession *s, const struct message *m)</span>
<span class="lineNum">    5805 </span>            : {
<span class="lineNum">    5806 </span><span class="lineCov">          4 :         astman_send_listack(s, m, &quot;DialPlan list will follow&quot;, &quot;start&quot;);</span>
<span class="lineNum">    5807 </span><span class="lineCov">          4 : }</span>
<span class="lineNum">    5808 </span>            : 
<span class="lineNum">    5809 </span>            : /*! \brief Show dialplan extensions
<span class="lineNum">    5810 </span>            :  * XXX this function is similar but not exactly the same as the CLI's
<a name="5811"><span class="lineNum">    5811 </span>            :  * show dialplan. Must check whether the difference is intentional or not.</a>
<span class="lineNum">    5812 </span>            :  */
<span class="lineNum">    5813 </span><span class="lineCov">          4 : static int manager_show_dialplan_helper(struct mansession *s, const struct message *m,</span>
<span class="lineNum">    5814 </span>            :                                         const char *actionidtext, const char *context,
<span class="lineNum">    5815 </span>            :                                         const char *exten, struct dialplan_counters *dpc,
<span class="lineNum">    5816 </span>            :                                         const struct ast_include *rinclude,
<span class="lineNum">    5817 </span>            :                                         int includecount, const char *includes[])
<span class="lineNum">    5818 </span>            : {
<span class="lineNum">    5819 </span>            :         struct ast_context *c;
<span class="lineNum">    5820 </span><span class="lineCov">          4 :         int res = 0, old_total_exten = dpc-&gt;total_exten;</span>
<span class="lineNum">    5821 </span>            : 
<span class="lineNum">    5822 </span><span class="lineCov">          4 :         if (ast_strlen_zero(exten))</span>
<span class="lineNum">    5823 </span><span class="lineCov">          3 :                 exten = NULL;</span>
<span class="lineNum">    5824 </span><span class="lineCov">          4 :         if (ast_strlen_zero(context))</span>
<span class="lineNum">    5825 </span><span class="lineNoCov">          0 :                 context = NULL;</span>
<span class="lineNum">    5826 </span>            : 
<span class="lineNum">    5827 </span><span class="lineCov">          4 :         ast_debug(3, &quot;manager_show_dialplan: Context: -%s- Extension: -%s-\n&quot;, context, exten);</span>
<span class="lineNum">    5828 </span>            : 
<span class="lineNum">    5829 </span>            :         /* try to lock contexts */
<span class="lineNum">    5830 </span><span class="lineCov">          4 :         if (ast_rdlock_contexts()) {</span>
<span class="lineNum">    5831 </span><span class="lineNoCov">          0 :                 astman_send_error(s, m, &quot;Failed to lock contexts&quot;);</span>
<span class="lineNum">    5832 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Failed to lock contexts list for manager: listdialplan\n&quot;);</span>
<span class="lineNum">    5833 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    5834 </span>            :         }
<span class="lineNum">    5835 </span>            : 
<span class="lineNum">    5836 </span><span class="lineCov">          4 :         c = NULL;               /* walk all contexts ... */</span>
<span class="lineNum">    5837 </span><span class="lineCov">         21 :         while ( (c = ast_walk_contexts(c)) ) {</span>
<span class="lineNum">    5838 </span>            :                 int idx;
<span class="lineNum">    5839 </span>            :                 struct ast_exten *e;
<span class="lineNum">    5840 </span>            : 
<span class="lineNum">    5841 </span><span class="lineCov">         17 :                 if (context &amp;&amp; strcmp(ast_get_context_name(c), context) != 0)</span>
<span class="lineNum">    5842 </span><span class="lineCov">         13 :                         continue;       /* not the name we want */</span>
<span class="lineNum">    5843 </span>            : 
<span class="lineNum">    5844 </span><span class="lineCov">          4 :                 dpc-&gt;context_existence = 1;</span>
<span class="lineNum">    5845 </span><span class="lineCov">          4 :                 dpc-&gt;total_context++;</span>
<span class="lineNum">    5846 </span>            : 
<span class="lineNum">    5847 </span><span class="lineCov">          4 :                 ast_debug(3, &quot;manager_show_dialplan: Found Context: %s \n&quot;, ast_get_context_name(c));</span>
<span class="lineNum">    5848 </span>            : 
<span class="lineNum">    5849 </span><span class="lineCov">          4 :                 if (ast_rdlock_context(c)) {    /* failed to lock */</span>
<span class="lineNum">    5850 </span><span class="lineNoCov">          0 :                         ast_debug(3, &quot;manager_show_dialplan: Failed to lock context\n&quot;);</span>
<span class="lineNum">    5851 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    5852 </span>            :                 }
<span class="lineNum">    5853 </span>            : 
<span class="lineNum">    5854 </span>            :                 /* XXX note- an empty context is not printed */
<span class="lineNum">    5855 </span><span class="lineCov">          4 :                 e = NULL;               /* walk extensions in context  */</span>
<span class="lineNum">    5856 </span><span class="lineCov">          7 :                 while ( (e = ast_walk_context_extensions(c, e)) ) {</span>
<span class="lineNum">    5857 </span>            :                         struct ast_exten *p;
<span class="lineNum">    5858 </span>            : 
<span class="lineNum">    5859 </span>            :                         /* looking for extension? is this our extension? */
<span class="lineNum">    5860 </span><span class="lineCov">          3 :                         if (exten &amp;&amp; !ast_extension_match(ast_get_extension_name(e), exten)) {</span>
<span class="lineNum">    5861 </span>            :                                 /* not the one we are looking for, continue */
<span class="lineNum">    5862 </span><span class="lineNoCov">          0 :                                 ast_debug(3, &quot;manager_show_dialplan: Skipping extension %s\n&quot;, ast_get_extension_name(e));</span>
<span class="lineNum">    5863 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    5864 </span>            :                         }
<span class="lineNum">    5865 </span><span class="lineCov">          3 :                         ast_debug(3, &quot;manager_show_dialplan: Found Extension: %s \n&quot;, ast_get_extension_name(e));</span>
<span class="lineNum">    5866 </span>            : 
<span class="lineNum">    5867 </span><span class="lineCov">          3 :                         dpc-&gt;extension_existence = 1;</span>
<span class="lineNum">    5868 </span>            : 
<span class="lineNum">    5869 </span><span class="lineCov">          3 :                         dpc-&gt;total_exten++;</span>
<span class="lineNum">    5870 </span>            : 
<span class="lineNum">    5871 </span><span class="lineCov">          3 :                         p = NULL;               /* walk next extension peers */</span>
<span class="lineNum">    5872 </span><span class="lineCov">          7 :                         while ( (p = ast_walk_extension_priorities(e, p)) ) {</span>
<span class="lineNum">    5873 </span><span class="lineCov">          4 :                                 int prio = ast_get_extension_priority(p);</span>
<span class="lineNum">    5874 </span>            : 
<span class="lineNum">    5875 </span><span class="lineCov">          4 :                                 dpc-&gt;total_prio++;</span>
<span class="lineNum">    5876 </span><span class="lineCov">          4 :                                 if (!dpc-&gt;total_items++)</span>
<span class="lineNum">    5877 </span><span class="lineCov">          3 :                                         manager_dpsendack(s, m);</span>
<span class="lineNum">    5878 </span><span class="lineCov">          4 :                                 astman_append(s, &quot;Event: ListDialplan\r\n%s&quot;, actionidtext);</span>
<span class="lineNum">    5879 </span><span class="lineCov">          4 :                                 astman_append(s, &quot;Context: %s\r\nExtension: %s\r\n&quot;, ast_get_context_name(c), ast_get_extension_name(e) );</span>
<span class="lineNum">    5880 </span>            : 
<span class="lineNum">    5881 </span>            :                                 /* XXX maybe make this conditional, if p != e ? */
<span class="lineNum">    5882 </span><span class="lineCov">          4 :                                 if (ast_get_extension_label(p))</span>
<span class="lineNum">    5883 </span><span class="lineNoCov">          0 :                                         astman_append(s, &quot;ExtensionLabel: %s\r\n&quot;, ast_get_extension_label(p));</span>
<span class="lineNum">    5884 </span>            : 
<span class="lineNum">    5885 </span><span class="lineCov">          4 :                                 if (prio == PRIORITY_HINT) {</span>
<span class="lineNum">    5886 </span><span class="lineCov">          1 :                                         astman_append(s, &quot;Priority: hint\r\nApplication: %s\r\n&quot;, ast_get_extension_app(p));</span>
<span class="lineNum">    5887 </span>            :                                 } else {
<span class="lineNum">    5888 </span><span class="lineCov">          3 :                                         astman_append(s, &quot;Priority: %d\r\nApplication: %s\r\nAppData: %s\r\n&quot;, prio, ast_get_extension_app(p), (char *) ast_get_extension_app_data(p));</span>
<span class="lineNum">    5889 </span>            :                                 }
<span class="lineNum">    5890 </span><span class="lineCov">          4 :                                 astman_append(s, &quot;Registrar: %s\r\n\r\n&quot;, ast_get_extension_registrar(e));</span>
<span class="lineNum">    5891 </span>            :                         }
<span class="lineNum">    5892 </span>            :                 }
<span class="lineNum">    5893 </span>            : 
<span class="lineNum">    5894 </span><span class="lineCov">          4 :                 for (idx = 0; idx &lt; ast_context_includes_count(c); idx++) {</span>
<span class="lineNum">    5895 </span><span class="lineNoCov">          0 :                         const struct ast_include *i = ast_context_includes_get(c, idx);</span>
<span class="lineNum">    5896 </span>            : 
<span class="lineNum">    5897 </span><span class="lineNoCov">          0 :                         if (exten) {</span>
<span class="lineNum">    5898 </span>            :                                 /* Check all includes for the requested extension */
<span class="lineNum">    5899 </span><span class="lineNoCov">          0 :                                 if (includecount &gt;= AST_PBX_MAX_STACK) {</span>
<span class="lineNum">    5900 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_WARNING, &quot;Maximum include depth exceeded!\n&quot;);</span>
<span class="lineNum">    5901 </span>            :                                 } else {
<span class="lineNum">    5902 </span><span class="lineNoCov">          0 :                                         int dupe = 0;</span>
<span class="lineNum">    5903 </span>            :                                         int x;
<span class="lineNum">    5904 </span><span class="lineNoCov">          0 :                                         for (x = 0; x &lt; includecount; x++) {</span>
<span class="lineNum">    5905 </span><span class="lineNoCov">          0 :                                                 if (!strcasecmp(includes[x], ast_get_include_name(i))) {</span>
<span class="lineNum">    5906 </span><span class="lineNoCov">          0 :                                                         dupe++;</span>
<span class="lineNum">    5907 </span><span class="lineNoCov">          0 :                                                         break;</span>
<span class="lineNum">    5908 </span>            :                                                 }
<span class="lineNum">    5909 </span>            :                                         }
<span class="lineNum">    5910 </span><span class="lineNoCov">          0 :                                         if (!dupe) {</span>
<span class="lineNum">    5911 </span><span class="lineNoCov">          0 :                                                 includes[includecount] = ast_get_include_name(i);</span>
<span class="lineNum">    5912 </span><span class="lineNoCov">          0 :                                                 manager_show_dialplan_helper(s, m, actionidtext, ast_get_include_name(i), exten, dpc, i, includecount + 1, includes);</span>
<span class="lineNum">    5913 </span>            :                                         } else {
<span class="lineNum">    5914 </span><span class="lineNoCov">          0 :                                                 ast_log(LOG_WARNING, &quot;Avoiding circular include of %s within %s\n&quot;, ast_get_include_name(i), context);</span>
<span class="lineNum">    5915 </span>            :                                         }
<span class="lineNum">    5916 </span>            :                                 }
<span class="lineNum">    5917 </span>            :                         } else {
<span class="lineNum">    5918 </span><span class="lineNoCov">          0 :                                 if (!dpc-&gt;total_items++)</span>
<span class="lineNum">    5919 </span><span class="lineNoCov">          0 :                                         manager_dpsendack(s, m);</span>
<span class="lineNum">    5920 </span><span class="lineNoCov">          0 :                                 astman_append(s, &quot;Event: ListDialplan\r\n%s&quot;, actionidtext);</span>
<span class="lineNum">    5921 </span><span class="lineNoCov">          0 :                                 astman_append(s, &quot;Context: %s\r\nIncludeContext: %s\r\nRegistrar: %s\r\n&quot;, ast_get_context_name(c), ast_get_include_name(i), ast_get_include_registrar(i));</span>
<span class="lineNum">    5922 </span><span class="lineNoCov">          0 :                                 astman_append(s, &quot;\r\n&quot;);</span>
<span class="lineNum">    5923 </span><span class="lineNoCov">          0 :                                 ast_debug(3, &quot;manager_show_dialplan: Found Included context: %s \n&quot;, ast_get_include_name(i));</span>
<span class="lineNum">    5924 </span>            :                         }
<span class="lineNum">    5925 </span>            :                 }
<span class="lineNum">    5926 </span>            : 
<span class="lineNum">    5927 </span><span class="lineCov">          4 :                 for (idx = 0; idx &lt; ast_context_ignorepats_count(c); idx++) {</span>
<span class="lineNum">    5928 </span><span class="lineNoCov">          0 :                         const struct ast_ignorepat *ip = ast_context_ignorepats_get(c, idx);</span>
<span class="lineNum">    5929 </span><span class="lineNoCov">          0 :                         const char *ipname = ast_get_ignorepat_name(ip);</span>
<span class="lineNum">    5930 </span>            :                         char ignorepat[AST_MAX_EXTENSION];
<span class="lineNum">    5931 </span>            : 
<span class="lineNum">    5932 </span><span class="lineNoCov">          0 :                         snprintf(ignorepat, sizeof(ignorepat), &quot;_%s.&quot;, ipname);</span>
<span class="lineNum">    5933 </span><span class="lineNoCov">          0 :                         if (!exten || ast_extension_match(ignorepat, exten)) {</span>
<span class="lineNum">    5934 </span><span class="lineNoCov">          0 :                                 if (!dpc-&gt;total_items++)</span>
<span class="lineNum">    5935 </span><span class="lineNoCov">          0 :                                         manager_dpsendack(s, m);</span>
<span class="lineNum">    5936 </span><span class="lineNoCov">          0 :                                 astman_append(s, &quot;Event: ListDialplan\r\n%s&quot;, actionidtext);</span>
<span class="lineNum">    5937 </span><span class="lineNoCov">          0 :                                 astman_append(s, &quot;Context: %s\r\nIgnorePattern: %s\r\nRegistrar: %s\r\n&quot;, ast_get_context_name(c), ipname, ast_get_ignorepat_registrar(ip));</span>
<span class="lineNum">    5938 </span><span class="lineNoCov">          0 :                                 astman_append(s, &quot;\r\n&quot;);</span>
<span class="lineNum">    5939 </span>            :                         }
<span class="lineNum">    5940 </span>            :                 }
<span class="lineNum">    5941 </span><span class="lineCov">          4 :                 if (!rinclude) {</span>
<span class="lineNum">    5942 </span><span class="lineCov">          4 :                         for (idx = 0; idx &lt; ast_context_switches_count(c); idx++) {</span>
<span class="lineNum">    5943 </span><span class="lineNoCov">          0 :                                 const struct ast_sw *sw = ast_context_switches_get(c, idx);</span>
<span class="lineNum">    5944 </span>            : 
<span class="lineNum">    5945 </span><span class="lineNoCov">          0 :                                 if (!dpc-&gt;total_items++)</span>
<span class="lineNum">    5946 </span><span class="lineNoCov">          0 :                                         manager_dpsendack(s, m);</span>
<span class="lineNum">    5947 </span><span class="lineNoCov">          0 :                                 astman_append(s, &quot;Event: ListDialplan\r\n%s&quot;, actionidtext);</span>
<span class="lineNum">    5948 </span><span class="lineNoCov">          0 :                                 astman_append(s, &quot;Context: %s\r\nSwitch: %s/%s\r\nRegistrar: %s\r\n&quot;, ast_get_context_name(c), ast_get_switch_name(sw), ast_get_switch_data(sw), ast_get_switch_registrar(sw));</span>
<span class="lineNum">    5949 </span><span class="lineNoCov">          0 :                                 astman_append(s, &quot;\r\n&quot;);</span>
<span class="lineNum">    5950 </span><span class="lineNoCov">          0 :                                 ast_debug(3, &quot;manager_show_dialplan: Found Switch : %s \n&quot;, ast_get_switch_name(sw));</span>
<span class="lineNum">    5951 </span>            :                         }
<span class="lineNum">    5952 </span>            :                 }
<span class="lineNum">    5953 </span>            : 
<span class="lineNum">    5954 </span><span class="lineCov">          4 :                 ast_unlock_context(c);</span>
<span class="lineNum">    5955 </span>            :         }
<span class="lineNum">    5956 </span><span class="lineCov">          4 :         ast_unlock_contexts();</span>
<span class="lineNum">    5957 </span>            : 
<span class="lineNum">    5958 </span><span class="lineCov">          4 :         if (dpc-&gt;total_exten == old_total_exten) {</span>
<span class="lineNum">    5959 </span><span class="lineCov">          1 :                 ast_debug(3, &quot;manager_show_dialplan: Found nothing new\n&quot;);</span>
<span class="lineNum">    5960 </span>            :                 /* Nothing new under the sun */
<span class="lineNum">    5961 </span><span class="lineCov">          1 :                 return -1;</span>
<span class="lineNum">    5962 </span>            :         } else {
<span class="lineNum">    5963 </span><span class="lineCov">          3 :                 return res;</span>
<span class="lineNum">    5964 </span>            :         }
<span class="lineNum">    5965 </span>            : }
<a name="5966"><span class="lineNum">    5966 </span>            : </a>
<span class="lineNum">    5967 </span>            : /*! \brief  Manager listing of dial plan */
<span class="lineNum">    5968 </span><span class="lineCov">          4 : static int manager_show_dialplan(struct mansession *s, const struct message *m)</span>
<span class="lineNum">    5969 </span>            : {
<span class="lineNum">    5970 </span>            :         const char *exten, *context;
<span class="lineNum">    5971 </span><span class="lineCov">          4 :         const char *id = astman_get_header(m, &quot;ActionID&quot;);</span>
<span class="lineNum">    5972 </span>            :         const char *incstack[AST_PBX_MAX_STACK];
<span class="lineNum">    5973 </span>            :         char idtext[256];
<span class="lineNum">    5974 </span>            : 
<span class="lineNum">    5975 </span>            :         /* Variables used for different counters */
<span class="lineNum">    5976 </span>            :         struct dialplan_counters counters;
<span class="lineNum">    5977 </span>            : 
<span class="lineNum">    5978 </span><span class="lineCov">          4 :         if (!ast_strlen_zero(id))</span>
<span class="lineNum">    5979 </span><span class="lineCov">          4 :                 snprintf(idtext, sizeof(idtext), &quot;ActionID: %s\r\n&quot;, id);</span>
<span class="lineNum">    5980 </span>            :         else
<span class="lineNum">    5981 </span><span class="lineNoCov">          0 :                 idtext[0] = '\0';</span>
<span class="lineNum">    5982 </span>            : 
<span class="lineNum">    5983 </span><span class="lineCov">          4 :         memset(&amp;counters, 0, sizeof(counters));</span>
<span class="lineNum">    5984 </span>            : 
<span class="lineNum">    5985 </span><span class="lineCov">          4 :         exten = astman_get_header(m, &quot;Extension&quot;);</span>
<span class="lineNum">    5986 </span><span class="lineCov">          4 :         context = astman_get_header(m, &quot;Context&quot;);</span>
<span class="lineNum">    5987 </span>            : 
<span class="lineNum">    5988 </span><span class="lineCov">          4 :         manager_show_dialplan_helper(s, m, idtext, context, exten, &amp;counters, NULL, 0, incstack);</span>
<span class="lineNum">    5989 </span>            : 
<span class="lineNum">    5990 </span><span class="lineCov">          4 :         if (!ast_strlen_zero(context) &amp;&amp; !counters.context_existence) {</span>
<span class="lineNum">    5991 </span>            :                 char errorbuf[BUFSIZ];
<span class="lineNum">    5992 </span>            : 
<span class="lineNum">    5993 </span><span class="lineNoCov">          0 :                 snprintf(errorbuf, sizeof(errorbuf), &quot;Did not find context %s&quot;, context);</span>
<span class="lineNum">    5994 </span><span class="lineNoCov">          0 :                 astman_send_error(s, m, errorbuf);</span>
<span class="lineNum">    5995 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    5996 </span>            :         }
<span class="lineNum">    5997 </span><span class="lineCov">          4 :         if (!ast_strlen_zero(exten) &amp;&amp; !counters.extension_existence) {</span>
<span class="lineNum">    5998 </span>            :                 char errorbuf[BUFSIZ];
<span class="lineNum">    5999 </span>            : 
<span class="lineNum">    6000 </span><span class="lineNoCov">          0 :                 if (!ast_strlen_zero(context))</span>
<span class="lineNum">    6001 </span><span class="lineNoCov">          0 :                         snprintf(errorbuf, sizeof(errorbuf), &quot;Did not find extension %s@%s&quot;, exten, context);</span>
<span class="lineNum">    6002 </span>            :                 else
<span class="lineNum">    6003 </span><span class="lineNoCov">          0 :                         snprintf(errorbuf, sizeof(errorbuf), &quot;Did not find extension %s in any context&quot;, exten);</span>
<span class="lineNum">    6004 </span><span class="lineNoCov">          0 :                 astman_send_error(s, m, errorbuf);</span>
<span class="lineNum">    6005 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    6006 </span>            :         }
<span class="lineNum">    6007 </span>            : 
<span class="lineNum">    6008 </span><span class="lineCov">          4 :         if (!counters.total_items) {</span>
<span class="lineNum">    6009 </span><span class="lineCov">          1 :                 manager_dpsendack(s, m);</span>
<span class="lineNum">    6010 </span>            :         }
<span class="lineNum">    6011 </span>            : 
<span class="lineNum">    6012 </span><span class="lineCov">          4 :         astman_send_list_complete_start(s, m, &quot;ShowDialPlanComplete&quot;, counters.total_items);</span>
<span class="lineNum">    6013 </span><span class="lineCov">          4 :         astman_append(s,</span>
<span class="lineNum">    6014 </span>            :                 &quot;ListExtensions: %d\r\n&quot;
<span class="lineNum">    6015 </span>            :                 &quot;ListPriorities: %d\r\n&quot;
<span class="lineNum">    6016 </span>            :                 &quot;ListContexts: %d\r\n&quot;,
<span class="lineNum">    6017 </span>            :                 counters.total_exten, counters.total_prio, counters.total_context);
<span class="lineNum">    6018 </span><span class="lineCov">          4 :         astman_send_list_complete_end(s);</span>
<span class="lineNum">    6019 </span>            : 
<span class="lineNum">    6020 </span>            :         /* everything ok */
<span class="lineNum">    6021 </span><span class="lineCov">          4 :         return 0;</span>
<span class="lineNum">    6022 </span>            : }
<a name="6023"><span class="lineNum">    6023 </span>            : </a>
<span class="lineNum">    6024 </span>            : #ifdef AST_DEVMODE
<span class="lineNum">    6025 </span><span class="lineCov">       1124 : static char *handle_show_device2extenstate(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)</span>
<span class="lineNum">    6026 </span>            : {
<span class="lineNum">    6027 </span>            :         struct ast_devstate_aggregate agg;
<span class="lineNum">    6028 </span>            :         int i, j, exten, combined;
<span class="lineNum">    6029 </span>            : 
<span class="lineNum">    6030 </span><span class="lineCov">       1124 :         switch (cmd) {</span>
<span class="lineNum">    6031 </span><span class="lineCov">       1124 :         case CLI_INIT:</span>
<span class="lineNum">    6032 </span><span class="lineCov">       1124 :                 e-&gt;command = &quot;core show device2extenstate&quot;;</span>
<span class="lineNum">    6033 </span><span class="lineCov">       1124 :                 e-&gt;usage =</span>
<span class="lineNum">    6034 </span>            :                         &quot;Usage: core show device2extenstate\n&quot;
<span class="lineNum">    6035 </span>            :                         &quot;       Lists device state to extension state combinations.\n&quot;;
<span class="lineNum">    6036 </span><span class="lineCov">       1124 :         case CLI_GENERATE:</span>
<span class="lineNum">    6037 </span><span class="lineCov">       1124 :                 return NULL;</span>
<span class="lineNum">    6038 </span>            :         }
<span class="lineNum">    6039 </span><span class="lineNoCov">          0 :         for (i = 0; i &lt; AST_DEVICE_TOTAL; i++) {</span>
<span class="lineNum">    6040 </span><span class="lineNoCov">          0 :                 for (j = 0; j &lt; AST_DEVICE_TOTAL; j++) {</span>
<span class="lineNum">    6041 </span><span class="lineNoCov">          0 :                         ast_devstate_aggregate_init(&amp;agg);</span>
<span class="lineNum">    6042 </span><span class="lineNoCov">          0 :                         ast_devstate_aggregate_add(&amp;agg, i);</span>
<span class="lineNum">    6043 </span><span class="lineNoCov">          0 :                         ast_devstate_aggregate_add(&amp;agg, j);</span>
<span class="lineNum">    6044 </span><span class="lineNoCov">          0 :                         combined = ast_devstate_aggregate_result(&amp;agg);</span>
<span class="lineNum">    6045 </span><span class="lineNoCov">          0 :                         exten = ast_devstate_to_extenstate(combined);</span>
<span class="lineNum">    6046 </span><span class="lineNoCov">          0 :                         ast_cli(a-&gt;fd, &quot;\n Exten:%14s  CombinedDevice:%12s  Dev1:%12s  Dev2:%12s&quot;, ast_extension_state2str(exten), ast_devstate_str(combined), ast_devstate_str(j), ast_devstate_str(i));</span>
<span class="lineNum">    6047 </span>            :                 }
<span class="lineNum">    6048 </span>            :         }
<span class="lineNum">    6049 </span><span class="lineNoCov">          0 :         ast_cli(a-&gt;fd, &quot;\n&quot;);</span>
<span class="lineNum">    6050 </span><span class="lineNoCov">          0 :         return CLI_SUCCESS;</span>
<span class="lineNum">    6051 </span>            : }
<a name="6052"><span class="lineNum">    6052 </span>            : #endif</a>
<span class="lineNum">    6053 </span>            : 
<span class="lineNum">    6054 </span><span class="lineCov">       1124 : static char *handle_set_extenpatternmatchnew(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)</span>
<span class="lineNum">    6055 </span>            : {
<span class="lineNum">    6056 </span><span class="lineCov">       1124 :         int oldval = 0;</span>
<span class="lineNum">    6057 </span>            : 
<span class="lineNum">    6058 </span><span class="lineCov">       1124 :         switch (cmd) {</span>
<span class="lineNum">    6059 </span><span class="lineCov">       1124 :         case CLI_INIT:</span>
<span class="lineNum">    6060 </span><span class="lineCov">       1124 :                 e-&gt;command = &quot;dialplan set extenpatternmatchnew true&quot;;</span>
<span class="lineNum">    6061 </span><span class="lineCov">       1124 :                 e-&gt;usage =</span>
<span class="lineNum">    6062 </span>            :                         &quot;Usage: dialplan set extenpatternmatchnew true|false\n&quot;
<span class="lineNum">    6063 </span>            :                         &quot;       Use the NEW extension pattern matching algorithm, true or false.\n&quot;;
<span class="lineNum">    6064 </span><span class="lineCov">       1124 :                 return NULL;</span>
<span class="lineNum">    6065 </span><span class="lineNoCov">          0 :         case CLI_GENERATE:</span>
<span class="lineNum">    6066 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    6067 </span>            :         }
<span class="lineNum">    6068 </span>            : 
<span class="lineNum">    6069 </span><span class="lineNoCov">          0 :         if (a-&gt;argc != 4)</span>
<span class="lineNum">    6070 </span><span class="lineNoCov">          0 :                 return CLI_SHOWUSAGE;</span>
<span class="lineNum">    6071 </span>            : 
<span class="lineNum">    6072 </span><span class="lineNoCov">          0 :         oldval =  pbx_set_extenpatternmatchnew(1);</span>
<span class="lineNum">    6073 </span>            : 
<span class="lineNum">    6074 </span><span class="lineNoCov">          0 :         if (oldval)</span>
<span class="lineNum">    6075 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;\n    -- Still using the NEW pattern match algorithm for extension names in the dialplan.\n&quot;);</span>
<span class="lineNum">    6076 </span>            :         else
<span class="lineNum">    6077 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;\n    -- Switched to using the NEW pattern match algorithm for extension names in the dialplan.\n&quot;);</span>
<span class="lineNum">    6078 </span>            : 
<span class="lineNum">    6079 </span><span class="lineNoCov">          0 :         return CLI_SUCCESS;</span>
<a name="6080"><span class="lineNum">    6080 </span>            : }</a>
<span class="lineNum">    6081 </span>            : 
<span class="lineNum">    6082 </span><span class="lineCov">       1124 : static char *handle_unset_extenpatternmatchnew(struct ast_cli_entry *e, int cmd, struct ast_cli_args *a)</span>
<span class="lineNum">    6083 </span>            : {
<span class="lineNum">    6084 </span><span class="lineCov">       1124 :         int oldval = 0;</span>
<span class="lineNum">    6085 </span>            : 
<span class="lineNum">    6086 </span><span class="lineCov">       1124 :         switch (cmd) {</span>
<span class="lineNum">    6087 </span><span class="lineCov">       1124 :         case CLI_INIT:</span>
<span class="lineNum">    6088 </span><span class="lineCov">       1124 :                 e-&gt;command = &quot;dialplan set extenpatternmatchnew false&quot;;</span>
<span class="lineNum">    6089 </span><span class="lineCov">       1124 :                 e-&gt;usage =</span>
<span class="lineNum">    6090 </span>            :                         &quot;Usage: dialplan set extenpatternmatchnew true|false\n&quot;
<span class="lineNum">    6091 </span>            :                         &quot;       Use the NEW extension pattern matching algorithm, true or false.\n&quot;;
<span class="lineNum">    6092 </span><span class="lineCov">       1124 :                 return NULL;</span>
<span class="lineNum">    6093 </span><span class="lineNoCov">          0 :         case CLI_GENERATE:</span>
<span class="lineNum">    6094 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    6095 </span>            :         }
<span class="lineNum">    6096 </span>            : 
<span class="lineNum">    6097 </span><span class="lineNoCov">          0 :         if (a-&gt;argc != 4)</span>
<span class="lineNum">    6098 </span><span class="lineNoCov">          0 :                 return CLI_SHOWUSAGE;</span>
<span class="lineNum">    6099 </span>            : 
<span class="lineNum">    6100 </span><span class="lineNoCov">          0 :         oldval =  pbx_set_extenpatternmatchnew(0);</span>
<span class="lineNum">    6101 </span>            : 
<span class="lineNum">    6102 </span><span class="lineNoCov">          0 :         if (!oldval)</span>
<span class="lineNum">    6103 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;\n    -- Still using the OLD pattern match algorithm for extension names in the dialplan.\n&quot;);</span>
<span class="lineNum">    6104 </span>            :         else
<span class="lineNum">    6105 </span><span class="lineNoCov">          0 :                 ast_cli(a-&gt;fd, &quot;\n    -- Switched to using the OLD pattern match algorithm for extension names in the dialplan.\n&quot;);</span>
<span class="lineNum">    6106 </span>            : 
<span class="lineNum">    6107 </span><span class="lineNoCov">          0 :         return CLI_SUCCESS;</span>
<span class="lineNum">    6108 </span>            : }
<span class="lineNum">    6109 </span>            : 
<span class="lineNum">    6110 </span>            : /*
<span class="lineNum">    6111 </span>            :  * CLI entries for upper commands ...
<span class="lineNum">    6112 </span>            :  */
<span class="lineNum">    6113 </span>            : static struct ast_cli_entry pbx_cli[] = {
<span class="lineNum">    6114 </span>            : #if 0
<span class="lineNum">    6115 </span>            :         AST_CLI_DEFINE(handle_eat_memory, &quot;Eats all available memory&quot;),
<span class="lineNum">    6116 </span>            : #endif
<span class="lineNum">    6117 </span>            :         AST_CLI_DEFINE(handle_show_hints, &quot;Show dialplan hints&quot;),
<span class="lineNum">    6118 </span>            :         AST_CLI_DEFINE(handle_show_hint, &quot;Show dialplan hint&quot;),
<span class="lineNum">    6119 </span>            : #ifdef AST_DEVMODE
<span class="lineNum">    6120 </span>            :         AST_CLI_DEFINE(handle_show_device2extenstate, &quot;Show expected exten state from multiple device states&quot;),
<span class="lineNum">    6121 </span>            : #endif
<span class="lineNum">    6122 </span>            :         AST_CLI_DEFINE(handle_show_dialplan, &quot;Show dialplan&quot;),
<span class="lineNum">    6123 </span>            :         AST_CLI_DEFINE(handle_debug_dialplan, &quot;Show fast extension pattern matching data structures&quot;),
<span class="lineNum">    6124 </span>            :         AST_CLI_DEFINE(handle_unset_extenpatternmatchnew, &quot;Use the Old extension pattern matching algorithm.&quot;),
<span class="lineNum">    6125 </span>            :         AST_CLI_DEFINE(handle_set_extenpatternmatchnew, &quot;Use the New extension pattern matching algorithm.&quot;),
<a name="6126"><span class="lineNum">    6126 </span>            : };</a>
<span class="lineNum">    6127 </span>            : 
<span class="lineNum">    6128 </span><span class="lineCov">     135762 : void unreference_cached_app(struct ast_app *app)</span>
<span class="lineNum">    6129 </span>            : {
<span class="lineNum">    6130 </span><span class="lineCov">     135762 :         struct ast_context *context = NULL;</span>
<span class="lineNum">    6131 </span><span class="lineCov">     135762 :         struct ast_exten *eroot = NULL, *e = NULL;</span>
<span class="lineNum">    6132 </span>            : 
<span class="lineNum">    6133 </span><span class="lineCov">     135762 :         ast_rdlock_contexts();</span>
<span class="lineNum">    6134 </span><span class="lineCov">     358130 :         while ((context = ast_walk_contexts(context))) {</span>
<span class="lineNum">    6135 </span><span class="lineCov">    1983767 :                 while ((eroot = ast_walk_context_extensions(context, eroot))) {</span>
<span class="lineNum">    6136 </span><span class="lineCov">    3959377 :                         while ((e = ast_walk_extension_priorities(eroot, e))) {</span>
<span class="lineNum">    6137 </span><span class="lineCov">    2197978 :                                 if (e-&gt;cached_app == app)</span>
<span class="lineNum">    6138 </span><span class="lineCov">        193 :                                         e-&gt;cached_app = NULL;</span>
<span class="lineNum">    6139 </span>            :                         }
<span class="lineNum">    6140 </span>            :                 }
<span class="lineNum">    6141 </span>            :         }
<span class="lineNum">    6142 </span><span class="lineCov">     135762 :         ast_unlock_contexts();</span>
<span class="lineNum">    6143 </span>            : 
<span class="lineNum">    6144 </span><span class="lineCov">     135762 :         return;</span>
<a name="6145"><span class="lineNum">    6145 </span>            : }</a>
<span class="lineNum">    6146 </span>            : 
<span class="lineNum">    6147 </span><span class="lineCov">       5923 : struct ast_context *ast_context_find_or_create(struct ast_context **extcontexts, struct ast_hashtab *exttable, const char *name, const char *registrar)</span>
<span class="lineNum">    6148 </span>            : {
<span class="lineNum">    6149 </span>            :         struct ast_context *tmp, **local_contexts;
<span class="lineNum">    6150 </span>            :         struct fake_context search;
<span class="lineNum">    6151 </span><span class="lineCov">       5923 :         int length = sizeof(struct ast_context) + strlen(name) + 1;</span>
<span class="lineNum">    6152 </span>            : 
<span class="lineNum">    6153 </span><span class="lineCov">       5923 :         if (!contexts_table) {</span>
<span class="lineNum">    6154 </span>            :                 /* Protect creation of contexts_table from reentrancy. */
<span class="lineNum">    6155 </span><span class="lineCov">       1124 :                 ast_wrlock_contexts();</span>
<span class="lineNum">    6156 </span><span class="lineCov">       1124 :                 if (!contexts_table) {</span>
<span class="lineNum">    6157 </span><span class="lineCov">       1124 :                         contexts_table = ast_hashtab_create(17,</span>
<span class="lineNum">    6158 </span>            :                                 ast_hashtab_compare_contexts,
<span class="lineNum">    6159 </span>            :                                 ast_hashtab_resize_java,
<span class="lineNum">    6160 </span>            :                                 ast_hashtab_newsize_java,
<span class="lineNum">    6161 </span>            :                                 ast_hashtab_hash_contexts,
<span class="lineNum">    6162 </span>            :                                 0);
<span class="lineNum">    6163 </span>            :                 }
<span class="lineNum">    6164 </span><span class="lineCov">       1124 :                 ast_unlock_contexts();</span>
<span class="lineNum">    6165 </span>            :         }
<span class="lineNum">    6166 </span>            : 
<span class="lineNum">    6167 </span><span class="lineCov">       5923 :         ast_copy_string(search.name, name, sizeof(search.name));</span>
<span class="lineNum">    6168 </span><span class="lineCov">       5923 :         if (!extcontexts) {</span>
<span class="lineNum">    6169 </span><span class="lineCov">       2281 :                 ast_rdlock_contexts();</span>
<span class="lineNum">    6170 </span><span class="lineCov">       2281 :                 local_contexts = &amp;contexts;</span>
<span class="lineNum">    6171 </span><span class="lineCov">       2281 :                 tmp = ast_hashtab_lookup(contexts_table, &amp;search);</span>
<span class="lineNum">    6172 </span><span class="lineCov">       2281 :                 if (tmp) {</span>
<span class="lineNum">    6173 </span><span class="lineCov">         25 :                         tmp-&gt;refcount++;</span>
<span class="lineNum">    6174 </span><span class="lineCov">         25 :                         ast_unlock_contexts();</span>
<span class="lineNum">    6175 </span><span class="lineCov">         25 :                         return tmp;</span>
<span class="lineNum">    6176 </span>            :                 }
<span class="lineNum">    6177 </span>            :         } else { /* local contexts just in a linked list; search there for the new context; slow, linear search, but not frequent */
<span class="lineNum">    6178 </span><span class="lineCov">       3642 :                 local_contexts = extcontexts;</span>
<span class="lineNum">    6179 </span><span class="lineCov">       3642 :                 tmp = ast_hashtab_lookup(exttable, &amp;search);</span>
<span class="lineNum">    6180 </span><span class="lineCov">       3642 :                 if (tmp) {</span>
<span class="lineNum">    6181 </span><span class="lineCov">          5 :                         tmp-&gt;refcount++;</span>
<span class="lineNum">    6182 </span><span class="lineCov">          5 :                         return tmp;</span>
<span class="lineNum">    6183 </span>            :                 }
<span class="lineNum">    6184 </span>            :         }
<span class="lineNum">    6185 </span>            : 
<span class="lineNum">    6186 </span><span class="lineCov">       5893 :         if ((tmp = ast_calloc(1, length))) {</span>
<span class="lineNum">    6187 </span><span class="lineCov">       5893 :                 ast_rwlock_init(&amp;tmp-&gt;lock);</span>
<span class="lineNum">    6188 </span><span class="lineCov">       5893 :                 ast_mutex_init(&amp;tmp-&gt;macrolock);</span>
<span class="lineNum">    6189 </span><span class="lineCov">       5893 :                 strcpy(tmp-&gt;name, name);</span>
<span class="lineNum">    6190 </span><span class="lineCov">       5893 :                 tmp-&gt;root = NULL;</span>
<span class="lineNum">    6191 </span><span class="lineCov">       5893 :                 tmp-&gt;root_table = NULL;</span>
<span class="lineNum">    6192 </span><span class="lineCov">       5893 :                 tmp-&gt;registrar = ast_strdup(registrar);</span>
<span class="lineNum">    6193 </span><span class="lineCov">       5893 :                 AST_VECTOR_INIT(&amp;tmp-&gt;includes, 0);</span>
<span class="lineNum">    6194 </span><span class="lineCov">       5893 :                 AST_VECTOR_INIT(&amp;tmp-&gt;ignorepats, 0);</span>
<span class="lineNum">    6195 </span><span class="lineCov">       5893 :                 AST_VECTOR_INIT(&amp;tmp-&gt;alts, 0);</span>
<span class="lineNum">    6196 </span><span class="lineCov">       5893 :                 tmp-&gt;refcount = 1;</span>
<span class="lineNum">    6197 </span>            :         } else {
<span class="lineNum">    6198 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR, &quot;Danger! We failed to allocate a context for %s!\n&quot;, name);</span>
<span class="lineNum">    6199 </span><span class="lineNoCov">          0 :                 if (!extcontexts) {</span>
<span class="lineNum">    6200 </span><span class="lineNoCov">          0 :                         ast_unlock_contexts();</span>
<span class="lineNum">    6201 </span>            :                 }
<span class="lineNum">    6202 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    6203 </span>            :         }
<span class="lineNum">    6204 </span>            : 
<span class="lineNum">    6205 </span><span class="lineCov">       5893 :         if (!extcontexts) {</span>
<span class="lineNum">    6206 </span><span class="lineCov">       2256 :                 tmp-&gt;next = *local_contexts;</span>
<span class="lineNum">    6207 </span><span class="lineCov">       2256 :                 *local_contexts = tmp;</span>
<span class="lineNum">    6208 </span><span class="lineCov">       2256 :                 ast_hashtab_insert_safe(contexts_table, tmp); /*put this context into the tree */</span>
<span class="lineNum">    6209 </span><span class="lineCov">       2256 :                 ast_unlock_contexts();</span>
<span class="lineNum">    6210 </span>            :         } else {
<span class="lineNum">    6211 </span><span class="lineCov">       3637 :                 tmp-&gt;next = *local_contexts;</span>
<span class="lineNum">    6212 </span><span class="lineCov">       3637 :                 if (exttable)</span>
<span class="lineNum">    6213 </span><span class="lineCov">       3637 :                         ast_hashtab_insert_immediate(exttable, tmp); /*put this context into the tree */</span>
<span class="lineNum">    6214 </span>            : 
<span class="lineNum">    6215 </span><span class="lineCov">       3637 :                 *local_contexts = tmp;</span>
<span class="lineNum">    6216 </span>            :         }
<span class="lineNum">    6217 </span><span class="lineCov">       5893 :         ast_debug(1, &quot;Registered extension context '%s'; registrar: %s\n&quot;, tmp-&gt;name, registrar);</span>
<span class="lineNum">    6218 </span><span class="lineCov">       5893 :         return tmp;</span>
<a name="6219"><span class="lineNum">    6219 </span>            : }</a>
<span class="lineNum">    6220 </span>            : 
<span class="lineNum">    6221 </span><span class="lineCov">          1 : void ast_context_set_autohints(struct ast_context *con, int enabled)</span>
<span class="lineNum">    6222 </span>            : {
<span class="lineNum">    6223 </span><span class="lineCov">          1 :         con-&gt;autohints = enabled;</span>
<span class="lineNum">    6224 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    6225 </span>            : 
<span class="lineNum">    6226 </span>            : void __ast_context_destroy(struct ast_context *list, struct ast_hashtab *contexttab, struct ast_context *con, const char *registrar);
<span class="lineNum">    6227 </span>            : 
<span class="lineNum">    6228 </span>            : struct store_hint {
<span class="lineNum">    6229 </span>            :         char *context;
<span class="lineNum">    6230 </span>            :         char *exten;
<span class="lineNum">    6231 </span>            :         AST_LIST_HEAD_NOLOCK(, ast_state_cb) callbacks;
<span class="lineNum">    6232 </span>            :         int laststate;
<span class="lineNum">    6233 </span>            :         int last_presence_state;
<span class="lineNum">    6234 </span>            :         char *last_presence_subtype;
<span class="lineNum">    6235 </span>            :         char *last_presence_message;
<span class="lineNum">    6236 </span>            : 
<span class="lineNum">    6237 </span>            :         AST_LIST_ENTRY(store_hint) list;
<span class="lineNum">    6238 </span>            :         char data[0];
<span class="lineNum">    6239 </span>            : };
<span class="lineNum">    6240 </span>            : 
<a name="6241"><span class="lineNum">    6241 </span>            : AST_LIST_HEAD_NOLOCK(store_hints, store_hint);</a>
<span class="lineNum">    6242 </span>            : 
<span class="lineNum">    6243 </span><span class="lineCov">       2253 : static void context_merge_incls_swits_igps_other_registrars(struct ast_context *new, struct ast_context *old, const char *registrar)</span>
<span class="lineNum">    6244 </span>            : {
<span class="lineNum">    6245 </span>            :         int idx;
<span class="lineNum">    6246 </span>            : 
<span class="lineNum">    6247 </span><span class="lineCov">       2253 :         ast_debug(1, &quot;merging incls/swits/igpats from old(%s) to new(%s) context, registrar = %s\n&quot;, ast_get_context_name(old), ast_get_context_name(new), registrar);</span>
<span class="lineNum">    6248 </span>            :         /* copy in the includes, switches, and ignorepats */
<span class="lineNum">    6249 </span>            :         /* walk through includes */
<span class="lineNum">    6250 </span><span class="lineCov">       2253 :         for (idx = 0; idx &lt; ast_context_includes_count(old); idx++) {</span>
<span class="lineNum">    6251 </span><span class="lineNoCov">          0 :                 const struct ast_include *i = ast_context_includes_get(old, idx);</span>
<span class="lineNum">    6252 </span>            : 
<span class="lineNum">    6253 </span><span class="lineNoCov">          0 :                 if (!strcmp(ast_get_include_registrar(i), registrar)) {</span>
<span class="lineNum">    6254 </span><span class="lineNoCov">          0 :                         continue; /* not mine */</span>
<span class="lineNum">    6255 </span>            :                 }
<span class="lineNum">    6256 </span><span class="lineNoCov">          0 :                 ast_context_add_include2(new, ast_get_include_name(i), ast_get_include_registrar(i));</span>
<span class="lineNum">    6257 </span>            :         }
<span class="lineNum">    6258 </span>            : 
<span class="lineNum">    6259 </span>            :         /* walk through switches */
<span class="lineNum">    6260 </span><span class="lineCov">       2253 :         for (idx = 0; idx &lt; ast_context_switches_count(old); idx++) {</span>
<span class="lineNum">    6261 </span><span class="lineNoCov">          0 :                 const struct ast_sw *sw = ast_context_switches_get(old, idx);</span>
<span class="lineNum">    6262 </span>            : 
<span class="lineNum">    6263 </span><span class="lineNoCov">          0 :                 if (!strcmp(ast_get_switch_registrar(sw), registrar)) {</span>
<span class="lineNum">    6264 </span><span class="lineNoCov">          0 :                         continue; /* not mine */</span>
<span class="lineNum">    6265 </span>            :                 }
<span class="lineNum">    6266 </span><span class="lineNoCov">          0 :                 ast_context_add_switch2(new, ast_get_switch_name(sw), ast_get_switch_data(sw), ast_get_switch_eval(sw), ast_get_switch_registrar(sw));</span>
<span class="lineNum">    6267 </span>            :         }
<span class="lineNum">    6268 </span>            : 
<span class="lineNum">    6269 </span>            :         /* walk thru ignorepats ... */
<span class="lineNum">    6270 </span><span class="lineCov">       2253 :         for (idx = 0; idx &lt; ast_context_ignorepats_count(old); idx++) {</span>
<span class="lineNum">    6271 </span><span class="lineNoCov">          0 :                 const struct ast_ignorepat *ip = ast_context_ignorepats_get(old, idx);</span>
<span class="lineNum">    6272 </span>            : 
<span class="lineNum">    6273 </span><span class="lineNoCov">          0 :                 if (strcmp(ast_get_ignorepat_registrar(ip), registrar) == 0) {</span>
<span class="lineNum">    6274 </span><span class="lineNoCov">          0 :                         continue; /* not mine */</span>
<span class="lineNum">    6275 </span>            :                 }
<span class="lineNum">    6276 </span><span class="lineNoCov">          0 :                 ast_context_add_ignorepat2(new, ast_get_ignorepat_name(ip), ast_get_ignorepat_registrar(ip));</span>
<span class="lineNum">    6277 </span>            :         }
<span class="lineNum">    6278 </span><span class="lineCov">       2253 : }</span>
<a name="6279"><span class="lineNum">    6279 </span>            : </a>
<span class="lineNum">    6280 </span>            : /*! Set up an autohint placeholder in the hints container */
<span class="lineNum">    6281 </span><span class="lineCov">       1127 : static void context_table_create_autohints(struct ast_hashtab *table)</span>
<span class="lineNum">    6282 </span>            : {
<span class="lineNum">    6283 </span>            :         struct ast_context *con;
<span class="lineNum">    6284 </span>            :         struct ast_hashtab_iter *iter;
<span class="lineNum">    6285 </span>            : 
<span class="lineNum">    6286 </span>            :         /* Remove all autohints as the below iteration will recreate them */
<span class="lineNum">    6287 </span><span class="lineCov">       1127 :         ao2_callback(autohints, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);</span>
<span class="lineNum">    6288 </span>            : 
<span class="lineNum">    6289 </span><span class="lineCov">       1127 :         iter = ast_hashtab_start_traversal(table);</span>
<span class="lineNum">    6290 </span><span class="lineCov">       4764 :         while ((con = ast_hashtab_next(iter))) {</span>
<span class="lineNum">    6291 </span><span class="lineCov">       3637 :                 size_t name_len = strlen(con-&gt;name) + 1;</span>
<span class="lineNum">    6292 </span><span class="lineCov">       3637 :                 size_t registrar_len = strlen(con-&gt;registrar) + 1;</span>
<span class="lineNum">    6293 </span>            :                 struct ast_autohint *autohint;
<span class="lineNum">    6294 </span>            : 
<span class="lineNum">    6295 </span><span class="lineCov">       3637 :                 if (!con-&gt;autohints) {</span>
<span class="lineNum">    6296 </span><span class="lineCov">       3636 :                         continue;</span>
<span class="lineNum">    6297 </span>            :                 }
<span class="lineNum">    6298 </span>            : 
<span class="lineNum">    6299 </span><span class="lineCov">          1 :                 autohint = ao2_alloc_options(sizeof(*autohint) + name_len + registrar_len, NULL, AO2_ALLOC_OPT_LOCK_NOLOCK);</span>
<span class="lineNum">    6300 </span><span class="lineCov">          1 :                 if (!autohint) {</span>
<span class="lineNum">    6301 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    6302 </span>            :                 }
<span class="lineNum">    6303 </span>            : 
<span class="lineNum">    6304 </span><span class="lineCov">          1 :                 ast_copy_string(autohint-&gt;context, con-&gt;name, name_len);</span>
<span class="lineNum">    6305 </span><span class="lineCov">          1 :                 autohint-&gt;registrar = autohint-&gt;context + name_len;</span>
<span class="lineNum">    6306 </span><span class="lineCov">          1 :                 ast_copy_string(autohint-&gt;registrar, con-&gt;registrar, registrar_len);</span>
<span class="lineNum">    6307 </span>            : 
<span class="lineNum">    6308 </span><span class="lineCov">          1 :                 ao2_link(autohints, autohint);</span>
<span class="lineNum">    6309 </span><span class="lineCov">          1 :                 ao2_ref(autohint, -1);</span>
<span class="lineNum">    6310 </span>            : 
<span class="lineNum">    6311 </span><span class="lineCov">          1 :                 ast_verb(3, &quot;Enabled autohints support on context '%s'\n&quot;, con-&gt;name);</span>
<span class="lineNum">    6312 </span>            :         }
<span class="lineNum">    6313 </span><span class="lineCov">       1127 :         ast_hashtab_end_traversal(iter);</span>
<span class="lineNum">    6314 </span><span class="lineCov">       1127 : }</span>
<span class="lineNum">    6315 </span>            : 
<a name="6316"><span class="lineNum">    6316 </span>            : /* the purpose of this routine is to duplicate a context, with all its substructure,</a>
<span class="lineNum">    6317 </span>            :    except for any extens that have a matching registrar */
<span class="lineNum">    6318 </span><span class="lineCov">       2254 : static void context_merge(struct ast_context **extcontexts, struct ast_hashtab *exttable, struct ast_context *context, const char *registrar)</span>
<span class="lineNum">    6319 </span>            : {
<span class="lineNum">    6320 </span><span class="lineCov">       2254 :         struct ast_context *new = ast_hashtab_lookup(exttable, context); /* is there a match in the new set? */</span>
<span class="lineNum">    6321 </span>            :         struct ast_exten *exten_item, *prio_item, *new_exten_item, *new_prio_item;
<span class="lineNum">    6322 </span>            :         struct ast_hashtab_iter *exten_iter;
<span class="lineNum">    6323 </span>            :         struct ast_hashtab_iter *prio_iter;
<span class="lineNum">    6324 </span><span class="lineCov">       2254 :         int insert_count = 0;</span>
<span class="lineNum">    6325 </span><span class="lineCov">       2254 :         int first = 1;</span>
<span class="lineNum">    6326 </span>            : 
<span class="lineNum">    6327 </span>            :         /* We'll traverse all the extensions/prios, and see which are not registrar'd with
<span class="lineNum">    6328 </span>            :            the current registrar, and copy them to the new context. If the new context does not
<span class="lineNum">    6329 </span>            :            exist, we'll create it &quot;on demand&quot;. If no items are in this context to copy, then we'll
<span class="lineNum">    6330 </span>            :            only create the empty matching context if the old one meets the criteria */
<span class="lineNum">    6331 </span>            : 
<span class="lineNum">    6332 </span><span class="lineCov">       2254 :         if (context-&gt;root_table) {</span>
<span class="lineNum">    6333 </span><span class="lineCov">       2253 :                 exten_iter = ast_hashtab_start_traversal(context-&gt;root_table);</span>
<span class="lineNum">    6334 </span><span class="lineCov">      27179 :                 while ((exten_item=ast_hashtab_next(exten_iter))) {</span>
<span class="lineNum">    6335 </span><span class="lineCov">      24926 :                         if (new) {</span>
<span class="lineNum">    6336 </span><span class="lineCov">      22674 :                                 new_exten_item = ast_hashtab_lookup(new-&gt;root_table, exten_item);</span>
<span class="lineNum">    6337 </span>            :                         } else {
<span class="lineNum">    6338 </span><span class="lineCov">       2252 :                                 new_exten_item = NULL;</span>
<span class="lineNum">    6339 </span>            :                         }
<span class="lineNum">    6340 </span><span class="lineCov">      24926 :                         prio_iter = ast_hashtab_start_traversal(exten_item-&gt;peer_table);</span>
<span class="lineNum">    6341 </span><span class="lineCov">      55478 :                         while ((prio_item=ast_hashtab_next(prio_iter))) {</span>
<span class="lineNum">    6342 </span>            :                                 int res1;
<span class="lineNum">    6343 </span>            :                                 char *dupdstr;
<span class="lineNum">    6344 </span>            : 
<span class="lineNum">    6345 </span><span class="lineCov">      30552 :                                 if (new_exten_item) {</span>
<span class="lineNum">    6346 </span><span class="lineCov">          1 :                                         new_prio_item = ast_hashtab_lookup(new_exten_item-&gt;peer_table, prio_item);</span>
<span class="lineNum">    6347 </span>            :                                 } else {
<span class="lineNum">    6348 </span><span class="lineCov">      30551 :                                         new_prio_item = NULL;</span>
<span class="lineNum">    6349 </span>            :                                 }
<span class="lineNum">    6350 </span><span class="lineCov">      30552 :                                 if (strcmp(prio_item-&gt;registrar,registrar) == 0) {</span>
<span class="lineNum">    6351 </span><span class="lineCov">          1 :                                         continue;</span>
<span class="lineNum">    6352 </span>            :                                 }
<span class="lineNum">    6353 </span>            :                                 /* make sure the new context exists, so we have somewhere to stick this exten/prio */
<span class="lineNum">    6354 </span><span class="lineCov">      30551 :                                 if (!new) {</span>
<span class="lineNum">    6355 </span><span class="lineCov">       2252 :                                         new = ast_context_find_or_create(extcontexts, exttable, context-&gt;name, prio_item-&gt;registrar); /* a new context created via priority from a different context in the old dialplan, gets its registrar from the prio's registrar */</span>
<span class="lineNum">    6356 </span><span class="lineCov">       2252 :                                         if (new) {</span>
<span class="lineNum">    6357 </span><span class="lineCov">       2252 :                                                 new-&gt;autohints = context-&gt;autohints;</span>
<span class="lineNum">    6358 </span>            :                                         }
<span class="lineNum">    6359 </span>            :                                 }
<span class="lineNum">    6360 </span>            : 
<span class="lineNum">    6361 </span>            :                                 /* copy in the includes, switches, and ignorepats */
<span class="lineNum">    6362 </span><span class="lineCov">      30551 :                                 if (first) { /* but, only need to do this once */</span>
<span class="lineNum">    6363 </span><span class="lineCov">       2252 :                                         context_merge_incls_swits_igps_other_registrars(new, context, registrar);</span>
<span class="lineNum">    6364 </span><span class="lineCov">       2252 :                                         first = 0;</span>
<span class="lineNum">    6365 </span>            :                                 }
<span class="lineNum">    6366 </span>            : 
<span class="lineNum">    6367 </span><span class="lineCov">      30551 :                                 if (!new) {</span>
<span class="lineNum">    6368 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_ERROR,&quot;Could not allocate a new context for %s in merge_and_delete! Danger!\n&quot;, context-&gt;name);</span>
<span class="lineNum">    6369 </span><span class="lineNoCov">          0 :                                         ast_hashtab_end_traversal(prio_iter);</span>
<span class="lineNum">    6370 </span><span class="lineNoCov">          0 :                                         ast_hashtab_end_traversal(exten_iter);</span>
<span class="lineNum">    6371 </span><span class="lineNoCov">          0 :                                         return; /* no sense continuing. */</span>
<span class="lineNum">    6372 </span>            :                                 }
<span class="lineNum">    6373 </span>            :                                 /* we will not replace existing entries in the new context with stuff from the old context.
<span class="lineNum">    6374 </span>            :                                    but, if this is because of some sort of registrar conflict, we ought to say something... */
<span class="lineNum">    6375 </span>            : 
<span class="lineNum">    6376 </span><span class="lineCov">      30551 :                                 dupdstr = ast_strdup(prio_item-&gt;data);</span>
<span class="lineNum">    6377 </span>            : 
<span class="lineNum">    6378 </span><span class="lineCov">      30551 :                                 res1 = ast_add_extension2(new, 0, prio_item-&gt;name, prio_item-&gt;priority, prio_item-&gt;label,</span>
<span class="lineNum">    6379 </span><span class="lineCov">      30551 :                                                                                   prio_item-&gt;matchcid ? prio_item-&gt;cidmatch : NULL, prio_item-&gt;app, dupdstr, ast_free_ptr, prio_item-&gt;registrar,</span>
<span class="lineNum">    6380 </span>            :                                                                                   prio_item-&gt;registrar_file, prio_item-&gt;registrar_line);
<span class="lineNum">    6381 </span><span class="lineCov">      30551 :                                 if (!res1 &amp;&amp; new_exten_item &amp;&amp; new_prio_item){</span>
<span class="lineNum">    6382 </span><span class="lineNoCov">          0 :                                         ast_verb(3,&quot;Dropping old dialplan item %s/%s/%d [%s(%s)] (registrar=%s) due to conflict with new dialplan\n&quot;,</span>
<span class="lineNum">    6383 </span>            :                                                         context-&gt;name, prio_item-&gt;name, prio_item-&gt;priority, prio_item-&gt;app, (char*)prio_item-&gt;data, prio_item-&gt;registrar);
<span class="lineNum">    6384 </span>            :                                 } else {
<span class="lineNum">    6385 </span>            :                                         /* we do NOT pass the priority data from the old to the new -- we pass a copy of it, so no changes to the current dialplan take place,
<span class="lineNum">    6386 </span>            :                                          and no double frees take place, either! */
<span class="lineNum">    6387 </span><span class="lineCov">      30551 :                                         insert_count++;</span>
<span class="lineNum">    6388 </span>            :                                 }
<span class="lineNum">    6389 </span>            :                         }
<span class="lineNum">    6390 </span><span class="lineCov">      24926 :                         ast_hashtab_end_traversal(prio_iter);</span>
<span class="lineNum">    6391 </span>            :                 }
<span class="lineNum">    6392 </span><span class="lineCov">       2253 :                 ast_hashtab_end_traversal(exten_iter);</span>
<span class="lineNum">    6393 </span><span class="lineCov">          1 :         } else if (new) {</span>
<span class="lineNum">    6394 </span>            :                 /* If the context existed but had no extensions, we still want to merge
<span class="lineNum">    6395 </span>            :                  * the includes, switches and ignore patterns.
<span class="lineNum">    6396 </span>            :                  */
<span class="lineNum">    6397 </span><span class="lineNoCov">          0 :                 context_merge_incls_swits_igps_other_registrars(new, context, registrar);</span>
<span class="lineNum">    6398 </span>            :         }
<span class="lineNum">    6399 </span>            : 
<span class="lineNum">    6400 </span><span class="lineCov">       2254 :         if (!insert_count &amp;&amp; !new &amp;&amp; (strcmp(context-&gt;registrar, registrar) != 0 ||</span>
<span class="lineNum">    6401 </span><span class="lineNoCov">          0 :                   (strcmp(context-&gt;registrar, registrar) == 0 &amp;&amp; context-&gt;refcount &gt; 1))) {</span>
<span class="lineNum">    6402 </span>            :                 /* we could have given it the registrar of the other module who incremented the refcount,
<span class="lineNum">    6403 </span>            :                    but that's not available, so we give it the registrar we know about */
<span class="lineNum">    6404 </span><span class="lineCov">          1 :                 new = ast_context_find_or_create(extcontexts, exttable, context-&gt;name, context-&gt;registrar);</span>
<span class="lineNum">    6405 </span>            : 
<span class="lineNum">    6406 </span><span class="lineCov">          1 :                 if (new) {</span>
<span class="lineNum">    6407 </span><span class="lineCov">          1 :                         new-&gt;autohints = context-&gt;autohints;</span>
<span class="lineNum">    6408 </span>            :                 }
<span class="lineNum">    6409 </span>            : 
<span class="lineNum">    6410 </span>            :                 /* copy in the includes, switches, and ignorepats */
<span class="lineNum">    6411 </span><span class="lineCov">          1 :                 context_merge_incls_swits_igps_other_registrars(new, context, registrar);</span>
<span class="lineNum">    6412 </span>            :         }
<span class="lineNum">    6413 </span>            : }
<span class="lineNum">    6414 </span>            : 
<a name="6415"><span class="lineNum">    6415 </span>            : </a>
<span class="lineNum">    6416 </span>            : /* XXX this does not check that multiple contexts are merged */
<span class="lineNum">    6417 </span><span class="lineCov">       1127 : void ast_merge_contexts_and_delete(struct ast_context **extcontexts, struct ast_hashtab *exttable, const char *registrar)</span>
<span class="lineNum">    6418 </span>            : {
<span class="lineNum">    6419 </span>            :         double ft;
<span class="lineNum">    6420 </span>            :         struct ast_context *tmp;
<span class="lineNum">    6421 </span>            :         struct ast_context *oldcontextslist;
<span class="lineNum">    6422 </span>            :         struct ast_hashtab *oldtable;
<span class="lineNum">    6423 </span><span class="lineCov">       1127 :         struct store_hints hints_stored = AST_LIST_HEAD_NOLOCK_INIT_VALUE;</span>
<span class="lineNum">    6424 </span><span class="lineCov">       1127 :         struct store_hints hints_removed = AST_LIST_HEAD_NOLOCK_INIT_VALUE;</span>
<span class="lineNum">    6425 </span>            :         struct store_hint *saved_hint;
<span class="lineNum">    6426 </span>            :         struct ast_hint *hint;
<span class="lineNum">    6427 </span>            :         struct ast_exten *exten;
<span class="lineNum">    6428 </span>            :         int length;
<span class="lineNum">    6429 </span>            :         struct ast_state_cb *thiscb;
<span class="lineNum">    6430 </span>            :         struct ast_hashtab_iter *iter;
<span class="lineNum">    6431 </span>            :         struct ao2_iterator i;
<span class="lineNum">    6432 </span><span class="lineCov">       1127 :         int ctx_count = 0;</span>
<span class="lineNum">    6433 </span>            :         struct timeval begintime;
<span class="lineNum">    6434 </span>            :         struct timeval writelocktime;
<span class="lineNum">    6435 </span>            :         struct timeval endlocktime;
<span class="lineNum">    6436 </span>            :         struct timeval enddeltime;
<span class="lineNum">    6437 </span>            : 
<span class="lineNum">    6438 </span>            :         /*
<span class="lineNum">    6439 </span>            :          * It is very important that this function hold the hints
<span class="lineNum">    6440 </span>            :          * container lock _and_ the conlock during its operation; not
<span class="lineNum">    6441 </span>            :          * only do we need to ensure that the list of contexts and
<span class="lineNum">    6442 </span>            :          * extensions does not change, but also that no hint callbacks
<span class="lineNum">    6443 </span>            :          * (watchers) are added or removed during the merge/delete
<span class="lineNum">    6444 </span>            :          * process
<span class="lineNum">    6445 </span>            :          *
<span class="lineNum">    6446 </span>            :          * In addition, the locks _must_ be taken in this order, because
<span class="lineNum">    6447 </span>            :          * there are already other code paths that use this order
<span class="lineNum">    6448 </span>            :          */
<span class="lineNum">    6449 </span>            : 
<span class="lineNum">    6450 </span><span class="lineCov">       1127 :         begintime = ast_tvnow();</span>
<span class="lineNum">    6451 </span><span class="lineCov">       1127 :         ast_mutex_lock(&amp;context_merge_lock);/* Serialize ast_merge_contexts_and_delete */</span>
<span class="lineNum">    6452 </span><span class="lineCov">       1127 :         ast_wrlock_contexts();</span>
<span class="lineNum">    6453 </span>            : 
<span class="lineNum">    6454 </span><span class="lineCov">       1127 :         if (!contexts_table) {</span>
<span class="lineNum">    6455 </span>            :                 /* Create any autohint contexts */
<span class="lineNum">    6456 </span><span class="lineNoCov">          0 :                 context_table_create_autohints(exttable);</span>
<span class="lineNum">    6457 </span>            : 
<span class="lineNum">    6458 </span>            :                 /* Well, that's odd. There are no contexts. */
<span class="lineNum">    6459 </span><span class="lineNoCov">          0 :                 contexts_table = exttable;</span>
<span class="lineNum">    6460 </span><span class="lineNoCov">          0 :                 contexts = *extcontexts;</span>
<span class="lineNum">    6461 </span><span class="lineNoCov">          0 :                 ast_unlock_contexts();</span>
<span class="lineNum">    6462 </span><span class="lineNoCov">          0 :                 ast_mutex_unlock(&amp;context_merge_lock);</span>
<span class="lineNum">    6463 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    6464 </span>            :         }
<span class="lineNum">    6465 </span>            : 
<span class="lineNum">    6466 </span><span class="lineCov">       1127 :         iter = ast_hashtab_start_traversal(contexts_table);</span>
<span class="lineNum">    6467 </span><span class="lineCov">       3381 :         while ((tmp = ast_hashtab_next(iter))) {</span>
<span class="lineNum">    6468 </span><span class="lineCov">       2254 :                 ++ctx_count;</span>
<span class="lineNum">    6469 </span><span class="lineCov">       2254 :                 context_merge(extcontexts, exttable, tmp, registrar);</span>
<span class="lineNum">    6470 </span>            :         }
<span class="lineNum">    6471 </span><span class="lineCov">       1127 :         ast_hashtab_end_traversal(iter);</span>
<span class="lineNum">    6472 </span>            : 
<span class="lineNum">    6473 </span><span class="lineCov">       1127 :         ao2_lock(hints);</span>
<span class="lineNum">    6474 </span><span class="lineCov">       1127 :         writelocktime = ast_tvnow();</span>
<span class="lineNum">    6475 </span>            : 
<span class="lineNum">    6476 </span>            :         /* preserve all watchers for hints */
<span class="lineNum">    6477 </span><span class="lineCov">       1127 :         i = ao2_iterator_init(hints, AO2_ITERATOR_DONTLOCK);</span>
<span class="lineNum">    6478 </span><span class="lineCov">       1271 :         for (; (hint = ao2_iterator_next(&amp;i)); ao2_ref(hint, -1)) {</span>
<span class="lineNum">    6479 </span><span class="lineCov">        144 :                 if (ao2_container_count(hint-&gt;callbacks)) {</span>
<span class="lineNum">    6480 </span><span class="lineNoCov">          0 :                         ao2_lock(hint);</span>
<span class="lineNum">    6481 </span><span class="lineNoCov">          0 :                         if (!hint-&gt;exten) {</span>
<span class="lineNum">    6482 </span>            :                                 /* The extension has already been destroyed. (Should never happen here) */
<span class="lineNum">    6483 </span><span class="lineNoCov">          0 :                                 ao2_unlock(hint);</span>
<span class="lineNum">    6484 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    6485 </span>            :                         }
<span class="lineNum">    6486 </span>            : 
<span class="lineNum">    6487 </span><span class="lineNoCov">          0 :                         length = strlen(hint-&gt;exten-&gt;exten) + strlen(hint-&gt;exten-&gt;parent-&gt;name) + 2</span>
<span class="lineNum">    6488 </span><span class="lineNoCov">          0 :                                 + sizeof(*saved_hint);</span>
<span class="lineNum">    6489 </span><span class="lineNoCov">          0 :                         if (!(saved_hint = ast_calloc(1, length))) {</span>
<span class="lineNum">    6490 </span><span class="lineNoCov">          0 :                                 ao2_unlock(hint);</span>
<span class="lineNum">    6491 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    6492 </span>            :                         }
<span class="lineNum">    6493 </span>            : 
<span class="lineNum">    6494 </span>            :                         /* This removes all the callbacks from the hint into saved_hint. */
<span class="lineNum">    6495 </span><span class="lineNoCov">          0 :                         while ((thiscb = ao2_callback(hint-&gt;callbacks, OBJ_UNLINK, NULL, NULL))) {</span>
<span class="lineNum">    6496 </span><span class="lineNoCov">          0 :                                 AST_LIST_INSERT_TAIL(&amp;saved_hint-&gt;callbacks, thiscb, entry);</span>
<span class="lineNum">    6497 </span>            :                                 /*
<span class="lineNum">    6498 </span>            :                                  * We intentionally do not unref thiscb to account for the
<span class="lineNum">    6499 </span>            :                                  * non-ao2 reference in saved_hint-&gt;callbacks
<span class="lineNum">    6500 </span>            :                                  */
<span class="lineNum">    6501 </span>            :                         }
<span class="lineNum">    6502 </span>            : 
<span class="lineNum">    6503 </span><span class="lineNoCov">          0 :                         saved_hint-&gt;laststate = hint-&gt;laststate;</span>
<span class="lineNum">    6504 </span><span class="lineNoCov">          0 :                         saved_hint-&gt;context = saved_hint-&gt;data;</span>
<span class="lineNum">    6505 </span><span class="lineNoCov">          0 :                         strcpy(saved_hint-&gt;data, hint-&gt;exten-&gt;parent-&gt;name);</span>
<span class="lineNum">    6506 </span><span class="lineNoCov">          0 :                         saved_hint-&gt;exten = saved_hint-&gt;data + strlen(saved_hint-&gt;context) + 1;</span>
<span class="lineNum">    6507 </span><span class="lineNoCov">          0 :                         strcpy(saved_hint-&gt;exten, hint-&gt;exten-&gt;exten);</span>
<span class="lineNum">    6508 </span><span class="lineNoCov">          0 :                         if (hint-&gt;last_presence_subtype) {</span>
<span class="lineNum">    6509 </span><span class="lineNoCov">          0 :                                 saved_hint-&gt;last_presence_subtype = ast_strdup(hint-&gt;last_presence_subtype);</span>
<span class="lineNum">    6510 </span>            :                         }
<span class="lineNum">    6511 </span><span class="lineNoCov">          0 :                         if (hint-&gt;last_presence_message) {</span>
<span class="lineNum">    6512 </span><span class="lineNoCov">          0 :                                 saved_hint-&gt;last_presence_message = ast_strdup(hint-&gt;last_presence_message);</span>
<span class="lineNum">    6513 </span>            :                         }
<span class="lineNum">    6514 </span><span class="lineNoCov">          0 :                         saved_hint-&gt;last_presence_state = hint-&gt;last_presence_state;</span>
<span class="lineNum">    6515 </span><span class="lineNoCov">          0 :                         ao2_unlock(hint);</span>
<span class="lineNum">    6516 </span><span class="lineNoCov">          0 :                         AST_LIST_INSERT_HEAD(&amp;hints_stored, saved_hint, list);</span>
<span class="lineNum">    6517 </span>            :                 }
<span class="lineNum">    6518 </span>            :         }
<span class="lineNum">    6519 </span><span class="lineCov">       1127 :         ao2_iterator_destroy(&amp;i);</span>
<span class="lineNum">    6520 </span>            : 
<span class="lineNum">    6521 </span>            :         /* save the old table and list */
<span class="lineNum">    6522 </span><span class="lineCov">       1127 :         oldtable = contexts_table;</span>
<span class="lineNum">    6523 </span><span class="lineCov">       1127 :         oldcontextslist = contexts;</span>
<span class="lineNum">    6524 </span>            : 
<span class="lineNum">    6525 </span>            :         /* move in the new table and list */
<span class="lineNum">    6526 </span><span class="lineCov">       1127 :         contexts_table = exttable;</span>
<span class="lineNum">    6527 </span><span class="lineCov">       1127 :         contexts = *extcontexts;</span>
<span class="lineNum">    6528 </span>            : 
<span class="lineNum">    6529 </span>            :         /*
<span class="lineNum">    6530 </span>            :          * Restore the watchers for hints that can be found; notify
<span class="lineNum">    6531 </span>            :          * those that cannot be restored.
<span class="lineNum">    6532 </span>            :          */
<span class="lineNum">    6533 </span><span class="lineCov">       1127 :         while ((saved_hint = AST_LIST_REMOVE_HEAD(&amp;hints_stored, list))) {</span>
<span class="lineNum">    6534 </span><span class="lineNoCov">          0 :                 struct pbx_find_info q = { .stacklen = 0 };</span>
<span class="lineNum">    6535 </span>            : 
<span class="lineNum">    6536 </span><span class="lineNoCov">          0 :                 exten = pbx_find_extension(NULL, NULL, &amp;q, saved_hint-&gt;context, saved_hint-&gt;exten,</span>
<span class="lineNum">    6537 </span>            :                         PRIORITY_HINT, NULL, &quot;&quot;, E_MATCH);
<span class="lineNum">    6538 </span>            :                 /*
<span class="lineNum">    6539 </span>            :                  * If this is a pattern, dynamically create a new extension for this
<span class="lineNum">    6540 </span>            :                  * particular match.  Note that this will only happen once for each
<span class="lineNum">    6541 </span>            :                  * individual extension, because the pattern will no longer match first.
<span class="lineNum">    6542 </span>            :                  */
<span class="lineNum">    6543 </span><span class="lineNoCov">          0 :                 if (exten &amp;&amp; exten-&gt;exten[0] == '_') {</span>
<span class="lineNum">    6544 </span><span class="lineNoCov">          0 :                         ast_add_extension_nolock(exten-&gt;parent-&gt;name, 0, saved_hint-&gt;exten,</span>
<span class="lineNum">    6545 </span><span class="lineNoCov">          0 :                                 PRIORITY_HINT, NULL, 0, exten-&gt;app, ast_strdup(exten-&gt;data), ast_free_ptr,</span>
<span class="lineNum">    6546 </span>            :                                 exten-&gt;registrar);
<span class="lineNum">    6547 </span>            :                         /* rwlocks are not recursive locks */
<span class="lineNum">    6548 </span><span class="lineNoCov">          0 :                         exten = ast_hint_extension_nolock(NULL, saved_hint-&gt;context,</span>
<span class="lineNum">    6549 </span><span class="lineNoCov">          0 :                                 saved_hint-&gt;exten);</span>
<span class="lineNum">    6550 </span>            :                 }
<span class="lineNum">    6551 </span>            : 
<span class="lineNum">    6552 </span>            :                 /* Find the hint in the hints container */
<span class="lineNum">    6553 </span><span class="lineNoCov">          0 :                 hint = exten ? ao2_find(hints, exten, 0) : NULL;</span>
<span class="lineNum">    6554 </span><span class="lineNoCov">          0 :                 if (!hint) {</span>
<span class="lineNum">    6555 </span>            :                         /*
<span class="lineNum">    6556 </span>            :                          * Notify watchers of this removed hint later when we aren't
<span class="lineNum">    6557 </span>            :                          * encumberd by so many locks.
<span class="lineNum">    6558 </span>            :                          */
<span class="lineNum">    6559 </span><span class="lineNoCov">          0 :                         AST_LIST_INSERT_HEAD(&amp;hints_removed, saved_hint, list);</span>
<span class="lineNum">    6560 </span>            :                 } else {
<span class="lineNum">    6561 </span><span class="lineNoCov">          0 :                         ao2_lock(hint);</span>
<span class="lineNum">    6562 </span><span class="lineNoCov">          0 :                         while ((thiscb = AST_LIST_REMOVE_HEAD(&amp;saved_hint-&gt;callbacks, entry))) {</span>
<span class="lineNum">    6563 </span><span class="lineNoCov">          0 :                                 ao2_link(hint-&gt;callbacks, thiscb);</span>
<span class="lineNum">    6564 </span>            :                                 /* Ref that we added when putting into saved_hint-&gt;callbacks */
<span class="lineNum">    6565 </span><span class="lineNoCov">          0 :                                 ao2_ref(thiscb, -1);</span>
<span class="lineNum">    6566 </span>            :                         }
<span class="lineNum">    6567 </span><span class="lineNoCov">          0 :                         hint-&gt;laststate = saved_hint-&gt;laststate;</span>
<span class="lineNum">    6568 </span><span class="lineNoCov">          0 :                         hint-&gt;last_presence_state = saved_hint-&gt;last_presence_state;</span>
<span class="lineNum">    6569 </span><span class="lineNoCov">          0 :                         hint-&gt;last_presence_subtype = saved_hint-&gt;last_presence_subtype;</span>
<span class="lineNum">    6570 </span><span class="lineNoCov">          0 :                         hint-&gt;last_presence_message = saved_hint-&gt;last_presence_message;</span>
<span class="lineNum">    6571 </span><span class="lineNoCov">          0 :                         ao2_unlock(hint);</span>
<span class="lineNum">    6572 </span><span class="lineNoCov">          0 :                         ao2_ref(hint, -1);</span>
<span class="lineNum">    6573 </span>            :                         /*
<span class="lineNum">    6574 </span>            :                          * The free of saved_hint-&gt;last_presence_subtype and
<span class="lineNum">    6575 </span>            :                          * saved_hint-&gt;last_presence_message is not necessary here.
<span class="lineNum">    6576 </span>            :                          */
<span class="lineNum">    6577 </span><span class="lineNoCov">          0 :                         ast_free(saved_hint);</span>
<span class="lineNum">    6578 </span>            :                 }
<span class="lineNum">    6579 </span>            :         }
<span class="lineNum">    6580 </span>            : 
<span class="lineNum">    6581 </span>            :         /* Create all applicable autohint contexts */
<span class="lineNum">    6582 </span><span class="lineCov">       1127 :         context_table_create_autohints(contexts_table);</span>
<span class="lineNum">    6583 </span>            : 
<span class="lineNum">    6584 </span><span class="lineCov">       1127 :         ao2_unlock(hints);</span>
<span class="lineNum">    6585 </span><span class="lineCov">       1127 :         ast_unlock_contexts();</span>
<span class="lineNum">    6586 </span>            : 
<span class="lineNum">    6587 </span>            :         /*
<span class="lineNum">    6588 </span>            :          * Notify watchers of all removed hints with the same lock
<span class="lineNum">    6589 </span>            :          * environment as device_state_cb().
<span class="lineNum">    6590 </span>            :          */
<span class="lineNum">    6591 </span><span class="lineCov">       1127 :         while ((saved_hint = AST_LIST_REMOVE_HEAD(&amp;hints_removed, list))) {</span>
<span class="lineNum">    6592 </span>            :                 /* this hint has been removed, notify the watchers */
<span class="lineNum">    6593 </span><span class="lineNoCov">          0 :                 while ((thiscb = AST_LIST_REMOVE_HEAD(&amp;saved_hint-&gt;callbacks, entry))) {</span>
<span class="lineNum">    6594 </span><span class="lineNoCov">          0 :                         execute_state_callback(thiscb-&gt;change_cb,</span>
<span class="lineNum">    6595 </span><span class="lineNoCov">          0 :                                 saved_hint-&gt;context,</span>
<span class="lineNum">    6596 </span><span class="lineNoCov">          0 :                                 saved_hint-&gt;exten,</span>
<span class="lineNum">    6597 </span>            :                                 thiscb-&gt;data,
<span class="lineNum">    6598 </span>            :                                 AST_HINT_UPDATE_DEVICE,
<span class="lineNum">    6599 </span>            :                                 NULL,
<span class="lineNum">    6600 </span>            :                                 NULL);
<span class="lineNum">    6601 </span>            :                         /* Ref that we added when putting into saved_hint-&gt;callbacks */
<span class="lineNum">    6602 </span><span class="lineNoCov">          0 :                         ao2_ref(thiscb, -1);</span>
<span class="lineNum">    6603 </span>            :                 }
<span class="lineNum">    6604 </span><span class="lineNoCov">          0 :                 ast_free(saved_hint-&gt;last_presence_subtype);</span>
<span class="lineNum">    6605 </span><span class="lineNoCov">          0 :                 ast_free(saved_hint-&gt;last_presence_message);</span>
<span class="lineNum">    6606 </span><span class="lineNoCov">          0 :                 ast_free(saved_hint);</span>
<span class="lineNum">    6607 </span>            :         }
<span class="lineNum">    6608 </span>            : 
<span class="lineNum">    6609 </span><span class="lineCov">       1127 :         ast_mutex_unlock(&amp;context_merge_lock);</span>
<span class="lineNum">    6610 </span><span class="lineCov">       1127 :         endlocktime = ast_tvnow();</span>
<span class="lineNum">    6611 </span>            : 
<span class="lineNum">    6612 </span>            :         /*
<span class="lineNum">    6613 </span>            :          * The old list and hashtab no longer are relevant, delete them
<span class="lineNum">    6614 </span>            :          * while the rest of asterisk is now freely using the new stuff
<span class="lineNum">    6615 </span>            :          * instead.
<span class="lineNum">    6616 </span>            :          */
<span class="lineNum">    6617 </span>            : 
<span class="lineNum">    6618 </span><span class="lineCov">       1127 :         ast_hashtab_destroy(oldtable, NULL);</span>
<span class="lineNum">    6619 </span>            : 
<span class="lineNum">    6620 </span><span class="lineCov">       3381 :         for (tmp = oldcontextslist; tmp; ) {</span>
<span class="lineNum">    6621 </span>            :                 struct ast_context *next;       /* next starting point */
<span class="lineNum">    6622 </span>            : 
<span class="lineNum">    6623 </span><span class="lineCov">       2254 :                 next = tmp-&gt;next;</span>
<span class="lineNum">    6624 </span><span class="lineCov">       2254 :                 __ast_internal_context_destroy(tmp);</span>
<span class="lineNum">    6625 </span><span class="lineCov">       2254 :                 tmp = next;</span>
<span class="lineNum">    6626 </span>            :         }
<span class="lineNum">    6627 </span><span class="lineCov">       1127 :         enddeltime = ast_tvnow();</span>
<span class="lineNum">    6628 </span>            : 
<span class="lineNum">    6629 </span><span class="lineCov">       1127 :         ft = ast_tvdiff_us(writelocktime, begintime);</span>
<span class="lineNum">    6630 </span><span class="lineCov">       1127 :         ft /= 1000000.0;</span>
<span class="lineNum">    6631 </span><span class="lineCov">       1127 :         ast_verb(3,&quot;Time to scan old dialplan and merge leftovers back into the new: %8.6f sec\n&quot;, ft);</span>
<span class="lineNum">    6632 </span>            : 
<span class="lineNum">    6633 </span><span class="lineCov">       1127 :         ft = ast_tvdiff_us(endlocktime, writelocktime);</span>
<span class="lineNum">    6634 </span><span class="lineCov">       1127 :         ft /= 1000000.0;</span>
<span class="lineNum">    6635 </span><span class="lineCov">       1127 :         ast_verb(3,&quot;Time to restore hints and swap in new dialplan: %8.6f sec\n&quot;, ft);</span>
<span class="lineNum">    6636 </span>            : 
<span class="lineNum">    6637 </span><span class="lineCov">       1127 :         ft = ast_tvdiff_us(enddeltime, endlocktime);</span>
<span class="lineNum">    6638 </span><span class="lineCov">       1127 :         ft /= 1000000.0;</span>
<span class="lineNum">    6639 </span><span class="lineCov">       1127 :         ast_verb(3,&quot;Time to delete the old dialplan: %8.6f sec\n&quot;, ft);</span>
<span class="lineNum">    6640 </span>            : 
<span class="lineNum">    6641 </span><span class="lineCov">       1127 :         ft = ast_tvdiff_us(enddeltime, begintime);</span>
<span class="lineNum">    6642 </span><span class="lineCov">       1127 :         ft /= 1000000.0;</span>
<span class="lineNum">    6643 </span><span class="lineCov">       1127 :         ast_verb(3,&quot;Total time merge_contexts_delete: %8.6f sec\n&quot;, ft);</span>
<span class="lineNum">    6644 </span><span class="lineCov">       1127 :         ast_verb(3, &quot;%s successfully loaded %d contexts (enable debug for details).\n&quot;, registrar, ctx_count);</span>
<span class="lineNum">    6645 </span>            : }
<span class="lineNum">    6646 </span>            : 
<span class="lineNum">    6647 </span>            : /*
<span class="lineNum">    6648 </span>            :  * errno values
<span class="lineNum">    6649 </span>            :  *  EBUSY  - can't lock
<a name="6650"><span class="lineNum">    6650 </span>            :  *  ENOENT - no existence of context</a>
<span class="lineNum">    6651 </span>            :  */
<span class="lineNum">    6652 </span><span class="lineCov">          1 : int ast_context_add_include(const char *context, const char *include, const char *registrar)</span>
<span class="lineNum">    6653 </span>            : {
<span class="lineNum">    6654 </span><span class="lineCov">          1 :         int ret = -1;</span>
<span class="lineNum">    6655 </span>            :         struct ast_context *c;
<span class="lineNum">    6656 </span>            : 
<span class="lineNum">    6657 </span><span class="lineCov">          1 :         c = find_context_locked(context);</span>
<span class="lineNum">    6658 </span><span class="lineCov">          1 :         if (c) {</span>
<span class="lineNum">    6659 </span><span class="lineCov">          1 :                 ret = ast_context_add_include2(c, include, registrar);</span>
<span class="lineNum">    6660 </span><span class="lineCov">          1 :                 ast_unlock_contexts();</span>
<span class="lineNum">    6661 </span>            :         }
<span class="lineNum">    6662 </span><span class="lineCov">          1 :         return ret;</span>
<span class="lineNum">    6663 </span>            : }
<span class="lineNum">    6664 </span>            : 
<span class="lineNum">    6665 </span>            : /*
<span class="lineNum">    6666 </span>            :  * errno values
<span class="lineNum">    6667 </span>            :  *  ENOMEM - out of memory
<span class="lineNum">    6668 </span>            :  *  EBUSY  - can't lock
<span class="lineNum">    6669 </span>            :  *  EEXIST - already included
<a name="6670"><span class="lineNum">    6670 </span>            :  *  EINVAL - there is no existence of context for inclusion</a>
<span class="lineNum">    6671 </span>            :  */
<span class="lineNum">    6672 </span><span class="lineCov">          4 : int ast_context_add_include2(struct ast_context *con, const char *value,</span>
<span class="lineNum">    6673 </span>            :         const char *registrar)
<span class="lineNum">    6674 </span>            : {
<span class="lineNum">    6675 </span>            :         struct ast_include *new_include;
<span class="lineNum">    6676 </span>            :         int idx;
<span class="lineNum">    6677 </span>            : 
<span class="lineNum">    6678 </span>            :         /* allocate new include structure ... */
<span class="lineNum">    6679 </span><span class="lineCov">          4 :         new_include = include_alloc(value, registrar);</span>
<span class="lineNum">    6680 </span><span class="lineCov">          4 :         if (!new_include) {</span>
<span class="lineNum">    6681 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    6682 </span>            :         }
<span class="lineNum">    6683 </span>            : 
<span class="lineNum">    6684 </span><span class="lineCov">          4 :         ast_wrlock_context(con);</span>
<span class="lineNum">    6685 </span>            : 
<span class="lineNum">    6686 </span>            :         /* ... go to last include and check if context is already included too... */
<span class="lineNum">    6687 </span><span class="lineCov">          5 :         for (idx = 0; idx &lt; ast_context_includes_count(con); idx++) {</span>
<span class="lineNum">    6688 </span><span class="lineCov">          1 :                 const struct ast_include *i = ast_context_includes_get(con, idx);</span>
<span class="lineNum">    6689 </span>            : 
<span class="lineNum">    6690 </span><span class="lineCov">          1 :                 if (!strcasecmp(ast_get_include_name(i), ast_get_include_name(new_include))) {</span>
<span class="lineNum">    6691 </span><span class="lineNoCov">          0 :                         include_free(new_include);</span>
<span class="lineNum">    6692 </span><span class="lineNoCov">          0 :                         ast_unlock_context(con);</span>
<span class="lineNum">    6693 </span><span class="lineNoCov">          0 :                         errno = EEXIST;</span>
<span class="lineNum">    6694 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    6695 </span>            :                 }
<span class="lineNum">    6696 </span>            :         }
<span class="lineNum">    6697 </span>            : 
<span class="lineNum">    6698 </span>            :         /* ... include new context into context list, unlock, return */
<span class="lineNum">    6699 </span><span class="lineCov">          4 :         if (AST_VECTOR_APPEND(&amp;con-&gt;includes, new_include)) {</span>
<span class="lineNum">    6700 </span><span class="lineNoCov">          0 :                 include_free(new_include);</span>
<span class="lineNum">    6701 </span><span class="lineNoCov">          0 :                 ast_unlock_context(con);</span>
<span class="lineNum">    6702 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    6703 </span>            :         }
<span class="lineNum">    6704 </span><span class="lineCov">          4 :         ast_debug(1, &quot;Including context '%s' in context '%s'\n&quot;,</span>
<span class="lineNum">    6705 </span>            :                 ast_get_include_name(new_include), ast_get_context_name(con));
<span class="lineNum">    6706 </span>            : 
<span class="lineNum">    6707 </span><span class="lineCov">          4 :         ast_unlock_context(con);</span>
<span class="lineNum">    6708 </span>            : 
<span class="lineNum">    6709 </span><span class="lineCov">          4 :         return 0;</span>
<span class="lineNum">    6710 </span>            : }
<span class="lineNum">    6711 </span>            : 
<span class="lineNum">    6712 </span>            : /*
<span class="lineNum">    6713 </span>            :  * errno values
<span class="lineNum">    6714 </span>            :  *  EBUSY  - can't lock
<a name="6715"><span class="lineNum">    6715 </span>            :  *  ENOENT - no existence of context</a>
<span class="lineNum">    6716 </span>            :  */
<span class="lineNum">    6717 </span><span class="lineNoCov">          0 : int ast_context_add_switch(const char *context, const char *sw, const char *data, int eval, const char *registrar)</span>
<span class="lineNum">    6718 </span>            : {
<span class="lineNum">    6719 </span><span class="lineNoCov">          0 :         int ret = -1;</span>
<span class="lineNum">    6720 </span>            :         struct ast_context *c;
<span class="lineNum">    6721 </span>            : 
<span class="lineNum">    6722 </span><span class="lineNoCov">          0 :         c = find_context_locked(context);</span>
<span class="lineNum">    6723 </span><span class="lineNoCov">          0 :         if (c) { /* found, add switch to this context */</span>
<span class="lineNum">    6724 </span><span class="lineNoCov">          0 :                 ret = ast_context_add_switch2(c, sw, data, eval, registrar);</span>
<span class="lineNum">    6725 </span><span class="lineNoCov">          0 :                 ast_unlock_contexts();</span>
<span class="lineNum">    6726 </span>            :         }
<span class="lineNum">    6727 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    6728 </span>            : }
<span class="lineNum">    6729 </span>            : 
<span class="lineNum">    6730 </span>            : /*
<span class="lineNum">    6731 </span>            :  * errno values
<span class="lineNum">    6732 </span>            :  *  ENOMEM - out of memory
<span class="lineNum">    6733 </span>            :  *  EBUSY  - can't lock
<span class="lineNum">    6734 </span>            :  *  EEXIST - already included
<a name="6735"><span class="lineNum">    6735 </span>            :  *  EINVAL - there is no existence of context for inclusion</a>
<span class="lineNum">    6736 </span>            :  */
<span class="lineNum">    6737 </span><span class="lineCov">          1 : int ast_context_add_switch2(struct ast_context *con, const char *value,</span>
<span class="lineNum">    6738 </span>            :         const char *data, int eval, const char *registrar)
<span class="lineNum">    6739 </span>            : {
<span class="lineNum">    6740 </span>            :         int idx;
<span class="lineNum">    6741 </span>            :         struct ast_sw *new_sw;
<span class="lineNum">    6742 </span>            : 
<span class="lineNum">    6743 </span>            :         /* allocate new sw structure ... */
<span class="lineNum">    6744 </span><span class="lineCov">          1 :         if (!(new_sw = sw_alloc(value, data, eval, registrar))) {</span>
<span class="lineNum">    6745 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    6746 </span>            :         }
<span class="lineNum">    6747 </span>            : 
<span class="lineNum">    6748 </span>            :         /* ... try to lock this context ... */
<span class="lineNum">    6749 </span><span class="lineCov">          1 :         ast_wrlock_context(con);</span>
<span class="lineNum">    6750 </span>            : 
<span class="lineNum">    6751 </span>            :         /* ... go to last sw and check if context is already swd too... */
<span class="lineNum">    6752 </span><span class="lineCov">          1 :         for (idx = 0; idx &lt; ast_context_switches_count(con); idx++) {</span>
<span class="lineNum">    6753 </span><span class="lineNoCov">          0 :                 const struct ast_sw *i = ast_context_switches_get(con, idx);</span>
<span class="lineNum">    6754 </span>            : 
<span class="lineNum">    6755 </span><span class="lineNoCov">          0 :                 if (!strcasecmp(ast_get_switch_name(i), ast_get_switch_name(new_sw)) &amp;&amp;</span>
<span class="lineNum">    6756 </span><span class="lineNoCov">          0 :                         !strcasecmp(ast_get_switch_data(i), ast_get_switch_data(new_sw))) {</span>
<span class="lineNum">    6757 </span><span class="lineNoCov">          0 :                         sw_free(new_sw);</span>
<span class="lineNum">    6758 </span><span class="lineNoCov">          0 :                         ast_unlock_context(con);</span>
<span class="lineNum">    6759 </span><span class="lineNoCov">          0 :                         errno = EEXIST;</span>
<span class="lineNum">    6760 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    6761 </span>            :                 }
<span class="lineNum">    6762 </span>            :         }
<span class="lineNum">    6763 </span>            : 
<span class="lineNum">    6764 </span>            :         /* ... sw new context into context list, unlock, return */
<span class="lineNum">    6765 </span><span class="lineCov">          1 :         if (AST_VECTOR_APPEND(&amp;con-&gt;alts, new_sw)) {</span>
<span class="lineNum">    6766 </span><span class="lineNoCov">          0 :                 sw_free(new_sw);</span>
<span class="lineNum">    6767 </span><span class="lineNoCov">          0 :                 ast_unlock_context(con);</span>
<span class="lineNum">    6768 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    6769 </span>            :         }
<span class="lineNum">    6770 </span>            : 
<span class="lineNum">    6771 </span><span class="lineCov">          1 :         ast_verb(3, &quot;Including switch '%s/%s' in context '%s'\n&quot;,</span>
<span class="lineNum">    6772 </span>            :                 ast_get_switch_name(new_sw), ast_get_switch_data(new_sw), ast_get_context_name(con));
<span class="lineNum">    6773 </span>            : 
<span class="lineNum">    6774 </span><span class="lineCov">          1 :         ast_unlock_context(con);</span>
<span class="lineNum">    6775 </span>            : 
<span class="lineNum">    6776 </span><span class="lineCov">          1 :         return 0;</span>
<span class="lineNum">    6777 </span>            : }
<span class="lineNum">    6778 </span>            : 
<span class="lineNum">    6779 </span>            : /*
<span class="lineNum">    6780 </span>            :  * EBUSY  - can't lock
<a name="6781"><span class="lineNum">    6781 </span>            :  * ENOENT - there is not context existence</a>
<span class="lineNum">    6782 </span>            :  */
<span class="lineNum">    6783 </span><span class="lineNoCov">          0 : int ast_context_remove_ignorepat(const char *context, const char *ignorepat, const char *registrar)</span>
<span class="lineNum">    6784 </span>            : {
<span class="lineNum">    6785 </span><span class="lineNoCov">          0 :         int ret = -1;</span>
<span class="lineNum">    6786 </span>            :         struct ast_context *c;
<span class="lineNum">    6787 </span>            : 
<span class="lineNum">    6788 </span><span class="lineNoCov">          0 :         c = find_context_locked(context);</span>
<span class="lineNum">    6789 </span><span class="lineNoCov">          0 :         if (c) {</span>
<span class="lineNum">    6790 </span><span class="lineNoCov">          0 :                 ret = ast_context_remove_ignorepat2(c, ignorepat, registrar);</span>
<span class="lineNum">    6791 </span><span class="lineNoCov">          0 :                 ast_unlock_contexts();</span>
<span class="lineNum">    6792 </span>            :         }
<span class="lineNum">    6793 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="6794"><span class="lineNum">    6794 </span>            : }</a>
<span class="lineNum">    6795 </span>            : 
<span class="lineNum">    6796 </span><span class="lineNoCov">          0 : int ast_context_remove_ignorepat2(struct ast_context *con, const char *ignorepat, const char *registrar)</span>
<span class="lineNum">    6797 </span>            : {
<span class="lineNum">    6798 </span>            :         int idx;
<span class="lineNum">    6799 </span>            : 
<span class="lineNum">    6800 </span><span class="lineNoCov">          0 :         ast_wrlock_context(con);</span>
<span class="lineNum">    6801 </span>            : 
<span class="lineNum">    6802 </span><span class="lineNoCov">          0 :         for (idx = 0; idx &lt; ast_context_ignorepats_count(con); idx++) {</span>
<span class="lineNum">    6803 </span><span class="lineNoCov">          0 :                 struct ast_ignorepat *ip = AST_VECTOR_GET(&amp;con-&gt;ignorepats, idx);</span>
<span class="lineNum">    6804 </span>            : 
<span class="lineNum">    6805 </span><span class="lineNoCov">          0 :                 if (!strcmp(ast_get_ignorepat_name(ip), ignorepat) &amp;&amp;</span>
<span class="lineNum">    6806 </span><span class="lineNoCov">          0 :                         (!registrar || (registrar == ast_get_ignorepat_registrar(ip)))) {</span>
<span class="lineNum">    6807 </span><span class="lineNoCov">          0 :                         AST_VECTOR_REMOVE_ORDERED(&amp;con-&gt;ignorepats, idx);</span>
<span class="lineNum">    6808 </span><span class="lineNoCov">          0 :                         ignorepat_free(ip);</span>
<span class="lineNum">    6809 </span><span class="lineNoCov">          0 :                         ast_unlock_context(con);</span>
<span class="lineNum">    6810 </span><span class="lineNoCov">          0 :                         return 0;</span>
<span class="lineNum">    6811 </span>            :                 }
<span class="lineNum">    6812 </span>            :         }
<span class="lineNum">    6813 </span>            : 
<span class="lineNum">    6814 </span><span class="lineNoCov">          0 :         ast_unlock_context(con);</span>
<span class="lineNum">    6815 </span><span class="lineNoCov">          0 :         errno = EINVAL;</span>
<span class="lineNum">    6816 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    6817 </span>            : }
<span class="lineNum">    6818 </span>            : 
<span class="lineNum">    6819 </span>            : /*
<span class="lineNum">    6820 </span>            :  * EBUSY - can't lock
<a name="6821"><span class="lineNum">    6821 </span>            :  * ENOENT - there is no existence of context</a>
<span class="lineNum">    6822 </span>            :  */
<span class="lineNum">    6823 </span><span class="lineNoCov">          0 : int ast_context_add_ignorepat(const char *context, const char *value, const char *registrar)</span>
<span class="lineNum">    6824 </span>            : {
<span class="lineNum">    6825 </span><span class="lineNoCov">          0 :         int ret = -1;</span>
<span class="lineNum">    6826 </span>            :         struct ast_context *c;
<span class="lineNum">    6827 </span>            : 
<span class="lineNum">    6828 </span><span class="lineNoCov">          0 :         c = find_context_locked(context);</span>
<span class="lineNum">    6829 </span><span class="lineNoCov">          0 :         if (c) {</span>
<span class="lineNum">    6830 </span><span class="lineNoCov">          0 :                 ret = ast_context_add_ignorepat2(c, value, registrar);</span>
<span class="lineNum">    6831 </span><span class="lineNoCov">          0 :                 ast_unlock_contexts();</span>
<span class="lineNum">    6832 </span>            :         }
<span class="lineNum">    6833 </span><span class="lineNoCov">          0 :         return ret;</span>
<a name="6834"><span class="lineNum">    6834 </span>            : }</a>
<span class="lineNum">    6835 </span>            : 
<span class="lineNum">    6836 </span><span class="lineNoCov">          0 : int ast_context_add_ignorepat2(struct ast_context *con, const char *value, const char *registrar)</span>
<span class="lineNum">    6837 </span>            : {
<span class="lineNum">    6838 </span><span class="lineNoCov">          0 :         struct ast_ignorepat *ignorepat = ignorepat_alloc(value, registrar);</span>
<span class="lineNum">    6839 </span>            :         int idx;
<span class="lineNum">    6840 </span>            : 
<span class="lineNum">    6841 </span><span class="lineNoCov">          0 :         if (!ignorepat) {</span>
<span class="lineNum">    6842 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    6843 </span>            :         }
<span class="lineNum">    6844 </span>            : 
<span class="lineNum">    6845 </span><span class="lineNoCov">          0 :         ast_wrlock_context(con);</span>
<span class="lineNum">    6846 </span><span class="lineNoCov">          0 :         for (idx = 0; idx &lt; ast_context_ignorepats_count(con); idx++) {</span>
<span class="lineNum">    6847 </span><span class="lineNoCov">          0 :                 const struct ast_ignorepat *i = ast_context_ignorepats_get(con, idx);</span>
<span class="lineNum">    6848 </span>            : 
<span class="lineNum">    6849 </span><span class="lineNoCov">          0 :                 if (!strcasecmp(ast_get_ignorepat_name(i), value)) {</span>
<span class="lineNum">    6850 </span>            :                         /* Already there */
<span class="lineNum">    6851 </span><span class="lineNoCov">          0 :                         ast_unlock_context(con);</span>
<span class="lineNum">    6852 </span><span class="lineNoCov">          0 :                         ignorepat_free(ignorepat);</span>
<span class="lineNum">    6853 </span><span class="lineNoCov">          0 :                         errno = EEXIST;</span>
<span class="lineNum">    6854 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    6855 </span>            :                 }
<span class="lineNum">    6856 </span>            :         }
<span class="lineNum">    6857 </span><span class="lineNoCov">          0 :         if (AST_VECTOR_APPEND(&amp;con-&gt;ignorepats, ignorepat)) {</span>
<span class="lineNum">    6858 </span><span class="lineNoCov">          0 :                 ignorepat_free(ignorepat);</span>
<span class="lineNum">    6859 </span><span class="lineNoCov">          0 :                 ast_unlock_context(con);</span>
<span class="lineNum">    6860 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    6861 </span>            :         }
<span class="lineNum">    6862 </span><span class="lineNoCov">          0 :         ast_unlock_context(con);</span>
<span class="lineNum">    6863 </span>            : 
<span class="lineNum">    6864 </span><span class="lineNoCov">          0 :         return 0;</span>
<a name="6865"><span class="lineNum">    6865 </span>            : }</a>
<span class="lineNum">    6866 </span>            : 
<span class="lineNum">    6867 </span><span class="lineCov">        127 : int ast_ignore_pattern(const char *context, const char *pattern)</span>
<span class="lineNum">    6868 </span>            : {
<span class="lineNum">    6869 </span><span class="lineCov">        127 :         int ret = 0;</span>
<span class="lineNum">    6870 </span>            :         struct ast_context *con;
<span class="lineNum">    6871 </span>            : 
<span class="lineNum">    6872 </span><span class="lineCov">        127 :         ast_rdlock_contexts();</span>
<span class="lineNum">    6873 </span><span class="lineCov">        127 :         con = ast_context_find(context);</span>
<span class="lineNum">    6874 </span><span class="lineCov">        127 :         if (con) {</span>
<span class="lineNum">    6875 </span>            :                 int idx;
<span class="lineNum">    6876 </span>            : 
<span class="lineNum">    6877 </span><span class="lineCov">        127 :                 for (idx = 0; idx &lt; ast_context_ignorepats_count(con); idx++) {</span>
<span class="lineNum">    6878 </span><span class="lineNoCov">          0 :                         const struct ast_ignorepat *pat = ast_context_ignorepats_get(con, idx);</span>
<span class="lineNum">    6879 </span>            : 
<span class="lineNum">    6880 </span><span class="lineNoCov">          0 :                         if (ast_extension_match(ast_get_ignorepat_name(pat), pattern)) {</span>
<span class="lineNum">    6881 </span><span class="lineNoCov">          0 :                                 ret = 1;</span>
<span class="lineNum">    6882 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    6883 </span>            :                         }
<span class="lineNum">    6884 </span>            :                 }
<span class="lineNum">    6885 </span>            :         }
<span class="lineNum">    6886 </span><span class="lineCov">        127 :         ast_unlock_contexts();</span>
<span class="lineNum">    6887 </span>            : 
<span class="lineNum">    6888 </span><span class="lineCov">        127 :         return ret;</span>
<span class="lineNum">    6889 </span>            : }
<span class="lineNum">    6890 </span>            : 
<span class="lineNum">    6891 </span>            : /*
<span class="lineNum">    6892 </span>            :  * ast_add_extension_nolock -- use only in situations where the conlock is already held
<span class="lineNum">    6893 </span>            :  * ENOENT  - no existence of context
<a name="6894"><span class="lineNum">    6894 </span>            :  *</a>
<span class="lineNum">    6895 </span>            :  */
<span class="lineNum">    6896 </span><span class="lineNoCov">          0 : static int ast_add_extension_nolock(const char *context, int replace, const char *extension,</span>
<span class="lineNum">    6897 </span>            :         int priority, const char *label, const char *callerid,
<span class="lineNum">    6898 </span>            :         const char *application, void *data, void (*datad)(void *), const char *registrar)
<span class="lineNum">    6899 </span>            : {
<span class="lineNum">    6900 </span><span class="lineNoCov">          0 :         int ret = -1;</span>
<span class="lineNum">    6901 </span>            :         struct ast_context *c;
<span class="lineNum">    6902 </span>            : 
<span class="lineNum">    6903 </span><span class="lineNoCov">          0 :         c = find_context(context);</span>
<span class="lineNum">    6904 </span><span class="lineNoCov">          0 :         if (c) {</span>
<span class="lineNum">    6905 </span><span class="lineNoCov">          0 :                 ret = ast_add_extension2_lockopt(c, replace, extension, priority, label, callerid,</span>
<span class="lineNum">    6906 </span>            :                         application, data, datad, registrar, NULL, 0, 1);
<span class="lineNum">    6907 </span>            :         }
<span class="lineNum">    6908 </span>            : 
<span class="lineNum">    6909 </span><span class="lineNoCov">          0 :         return ret;</span>
<span class="lineNum">    6910 </span>            : }
<span class="lineNum">    6911 </span>            : /*
<span class="lineNum">    6912 </span>            :  * EBUSY   - can't lock
<span class="lineNum">    6913 </span>            :  * ENOENT  - no existence of context
<a name="6914"><span class="lineNum">    6914 </span>            :  *</a>
<span class="lineNum">    6915 </span>            :  */
<span class="lineNum">    6916 </span><span class="lineCov">       6766 : int ast_add_extension(const char *context, int replace, const char *extension,</span>
<span class="lineNum">    6917 </span>            :         int priority, const char *label, const char *callerid,
<span class="lineNum">    6918 </span>            :         const char *application, void *data, void (*datad)(void *), const char *registrar)
<span class="lineNum">    6919 </span>            : {
<span class="lineNum">    6920 </span><span class="lineCov">       6766 :         int ret = -1;</span>
<span class="lineNum">    6921 </span>            :         struct ast_context *c;
<span class="lineNum">    6922 </span>            : 
<span class="lineNum">    6923 </span><span class="lineCov">       6766 :         c = find_context_locked(context);</span>
<span class="lineNum">    6924 </span><span class="lineCov">       6766 :         if (c) {</span>
<span class="lineNum">    6925 </span><span class="lineCov">       6766 :                 ret = ast_add_extension2(c, replace, extension, priority, label, callerid,</span>
<span class="lineNum">    6926 </span>            :                         application, data, datad, registrar, NULL, 0);
<span class="lineNum">    6927 </span><span class="lineCov">       6766 :                 ast_unlock_contexts();</span>
<span class="lineNum">    6928 </span>            :         }
<span class="lineNum">    6929 </span>            : 
<span class="lineNum">    6930 </span><span class="lineCov">       6766 :         return ret;</span>
<a name="6931"><span class="lineNum">    6931 </span>            : }</a>
<span class="lineNum">    6932 </span>            : 
<span class="lineNum">    6933 </span><span class="lineCov">       2213 : int ast_explicit_goto(struct ast_channel *chan, const char *context, const char *exten, int priority)</span>
<span class="lineNum">    6934 </span>            : {
<span class="lineNum">    6935 </span><span class="lineCov">       2213 :         if (!chan)</span>
<span class="lineNum">    6936 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    6937 </span>            : 
<span class="lineNum">    6938 </span><span class="lineCov">       2213 :         ast_channel_lock(chan);</span>
<span class="lineNum">    6939 </span>            : 
<span class="lineNum">    6940 </span><span class="lineCov">       2213 :         if (!ast_strlen_zero(context))</span>
<span class="lineNum">    6941 </span><span class="lineCov">       1470 :                 ast_channel_context_set(chan, context);</span>
<span class="lineNum">    6942 </span><span class="lineCov">       2213 :         if (!ast_strlen_zero(exten))</span>
<span class="lineNum">    6943 </span><span class="lineCov">       1546 :                 ast_channel_exten_set(chan, exten);</span>
<span class="lineNum">    6944 </span><span class="lineCov">       2213 :         if (priority &gt; -1) {</span>
<span class="lineNum">    6945 </span>            :                 /* see flag description in channel.h for explanation */
<span class="lineNum">    6946 </span><span class="lineCov">       2213 :                 if (ast_test_flag(ast_channel_flags(chan), AST_FLAG_IN_AUTOLOOP)) {</span>
<span class="lineNum">    6947 </span><span class="lineCov">       2124 :                         --priority;</span>
<span class="lineNum">    6948 </span>            :                 }
<span class="lineNum">    6949 </span><span class="lineCov">       2213 :                 ast_channel_priority_set(chan, priority);</span>
<span class="lineNum">    6950 </span>            :         }
<span class="lineNum">    6951 </span>            : 
<span class="lineNum">    6952 </span><span class="lineCov">       2213 :         ast_channel_unlock(chan);</span>
<span class="lineNum">    6953 </span>            : 
<span class="lineNum">    6954 </span><span class="lineCov">       2213 :         return 0;</span>
<a name="6955"><span class="lineNum">    6955 </span>            : }</a>
<span class="lineNum">    6956 </span>            : 
<span class="lineNum">    6957 </span><span class="lineCov">        469 : int ast_async_goto(struct ast_channel *chan, const char *context, const char *exten, int priority)</span>
<span class="lineNum">    6958 </span>            : {
<span class="lineNum">    6959 </span>            :         struct ast_channel *newchan;
<span class="lineNum">    6960 </span>            : 
<span class="lineNum">    6961 </span><span class="lineCov">        469 :         ast_channel_lock(chan);</span>
<span class="lineNum">    6962 </span>            :         /* Channels in a bridge or running a PBX can be sent directly to the specified destination */
<span class="lineNum">    6963 </span><span class="lineCov">        469 :         if (ast_channel_is_bridged(chan) || ast_channel_pbx(chan)) {</span>
<span class="lineNum">    6964 </span><span class="lineCov">        464 :                 if (ast_test_flag(ast_channel_flags(chan), AST_FLAG_IN_AUTOLOOP)) {</span>
<span class="lineNum">    6965 </span><span class="lineCov">        432 :                         priority += 1;</span>
<span class="lineNum">    6966 </span>            :                 }
<span class="lineNum">    6967 </span><span class="lineCov">        464 :                 ast_explicit_goto(chan, context, exten, priority);</span>
<span class="lineNum">    6968 </span><span class="lineCov">        464 :                 ast_softhangup_nolock(chan, AST_SOFTHANGUP_ASYNCGOTO);</span>
<span class="lineNum">    6969 </span><span class="lineCov">        464 :                 ast_channel_unlock(chan);</span>
<span class="lineNum">    6970 </span><span class="lineCov">        464 :                 return 0;</span>
<span class="lineNum">    6971 </span>            :         }
<span class="lineNum">    6972 </span><span class="lineCov">          5 :         ast_channel_unlock(chan);</span>
<span class="lineNum">    6973 </span>            : 
<span class="lineNum">    6974 </span>            :         /* Otherwise, we need to gain control of the channel first */
<span class="lineNum">    6975 </span><span class="lineCov">          5 :         newchan = ast_channel_yank(chan);</span>
<span class="lineNum">    6976 </span><span class="lineCov">          5 :         if (!newchan) {</span>
<span class="lineNum">    6977 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unable to gain control of channel %s\n&quot;, ast_channel_name(chan));</span>
<span class="lineNum">    6978 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    6979 </span>            :         }
<span class="lineNum">    6980 </span><span class="lineCov">          5 :         ast_explicit_goto(newchan, context, exten, priority);</span>
<span class="lineNum">    6981 </span><span class="lineCov">          5 :         if (ast_pbx_start(newchan)) {</span>
<span class="lineNum">    6982 </span><span class="lineNoCov">          0 :                 ast_hangup(newchan);</span>
<span class="lineNum">    6983 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Unable to start PBX on %s\n&quot;, ast_channel_name(newchan));</span>
<span class="lineNum">    6984 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    6985 </span>            :         }
<span class="lineNum">    6986 </span>            : 
<span class="lineNum">    6987 </span><span class="lineCov">          5 :         return 0;</span>
<a name="6988"><span class="lineNum">    6988 </span>            : }</a>
<span class="lineNum">    6989 </span>            : 
<span class="lineNum">    6990 </span><span class="lineNoCov">          0 : int ast_async_goto_by_name(const char *channame, const char *context, const char *exten, int priority)</span>
<span class="lineNum">    6991 </span>            : {
<span class="lineNum">    6992 </span>            :         struct ast_channel *chan;
<span class="lineNum">    6993 </span><span class="lineNoCov">          0 :         int res = -1;</span>
<span class="lineNum">    6994 </span>            : 
<span class="lineNum">    6995 </span><span class="lineNoCov">          0 :         if ((chan = ast_channel_get_by_name(channame))) {</span>
<span class="lineNum">    6996 </span><span class="lineNoCov">          0 :                 res = ast_async_goto(chan, context, exten, priority);</span>
<span class="lineNum">    6997 </span><span class="lineNoCov">          0 :                 chan = ast_channel_unref(chan);</span>
<span class="lineNum">    6998 </span>            :         }
<span class="lineNum">    6999 </span>            : 
<span class="lineNum">    7000 </span><span class="lineNoCov">          0 :         return res;</span>
<span class="lineNum">    7001 </span>            : }
<span class="lineNum">    7002 </span>            : 
<span class="lineNum">    7003 </span>            : /*!
<span class="lineNum">    7004 </span>            :  * \internal
<span class="lineNum">    7005 </span>            :  * \brief Copy a string skipping whitespace and optionally dashes.
<span class="lineNum">    7006 </span>            :  *
<span class="lineNum">    7007 </span>            :  * \param dst Destination buffer to copy src string.
<span class="lineNum">    7008 </span>            :  * \param src Null terminated string to copy.
<span class="lineNum">    7009 </span>            :  * \param dst_size Number of bytes in the dst buffer.
<span class="lineNum">    7010 </span>            :  * \param nofluf Nonzero if '-' chars are not copied.
<span class="lineNum">    7011 </span>            :  *
<a name="7012"><span class="lineNum">    7012 </span>            :  * \return Number of bytes written to dst including null terminator.</a>
<span class="lineNum">    7013 </span>            :  */
<span class="lineNum">    7014 </span><span class="lineCov">     175783 : static unsigned int ext_strncpy(char *dst, const char *src, size_t dst_size, int nofluff)</span>
<span class="lineNum">    7015 </span>            : {
<span class="lineNum">    7016 </span>            :         unsigned int count;
<span class="lineNum">    7017 </span>            :         unsigned int insquares;
<span class="lineNum">    7018 </span>            :         unsigned int is_pattern;
<span class="lineNum">    7019 </span>            : 
<span class="lineNum">    7020 </span><span class="lineCov">     175783 :         if (!dst_size--) {</span>
<span class="lineNum">    7021 </span>            :                 /* There really is no dst buffer */
<span class="lineNum">    7022 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    7023 </span>            :         }
<span class="lineNum">    7024 </span>            : 
<span class="lineNum">    7025 </span><span class="lineCov">     175783 :         count = 0;</span>
<span class="lineNum">    7026 </span><span class="lineCov">     175783 :         insquares = 0;</span>
<span class="lineNum">    7027 </span><span class="lineCov">     175783 :         is_pattern = *src == '_';</span>
<span class="lineNum">    7028 </span><span class="lineCov">    1029231 :         while (*src &amp;&amp; count &lt; dst_size) {</span>
<span class="lineNum">    7029 </span><span class="lineCov">     853448 :                 if (*src == '[') {</span>
<span class="lineNum">    7030 </span><span class="lineCov">        288 :                         if (is_pattern) {</span>
<span class="lineNum">    7031 </span><span class="lineCov">        288 :                                 insquares = 1;</span>
<span class="lineNum">    7032 </span>            :                         }
<span class="lineNum">    7033 </span><span class="lineCov">     853160 :                 } else if (*src == ']') {</span>
<span class="lineNum">    7034 </span><span class="lineCov">        288 :                         insquares = 0;</span>
<span class="lineNum">    7035 </span><span class="lineCov">     852872 :                 } else if (*src == ' ' &amp;&amp; !insquares) {</span>
<span class="lineNum">    7036 </span><span class="lineNoCov">          0 :                         ++src;</span>
<span class="lineNum">    7037 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    7038 </span><span class="lineCov">     852872 :                 } else if (*src == '-' &amp;&amp; !insquares &amp;&amp; nofluff) {</span>
<span class="lineNum">    7039 </span><span class="lineCov">        303 :                         ++src;</span>
<span class="lineNum">    7040 </span><span class="lineCov">        303 :                         continue;</span>
<span class="lineNum">    7041 </span>            :                 }
<span class="lineNum">    7042 </span><span class="lineCov">     853145 :                 *dst++ = *src++;</span>
<span class="lineNum">    7043 </span><span class="lineCov">     853145 :                 ++count;</span>
<span class="lineNum">    7044 </span>            :         }
<span class="lineNum">    7045 </span><span class="lineCov">     175783 :         *dst = '\0';</span>
<span class="lineNum">    7046 </span>            : 
<span class="lineNum">    7047 </span><span class="lineCov">     175783 :         return count + 1;</span>
<span class="lineNum">    7048 </span>            : }
<span class="lineNum">    7049 </span>            : 
<span class="lineNum">    7050 </span>            : /*!
<span class="lineNum">    7051 </span>            :  * \brief add the extension in the priority chain.
<span class="lineNum">    7052 </span>            :  * \retval 0 on success.
<a name="7053"><span class="lineNum">    7053 </span>            :  * \retval -1 on failure.</a>
<span class="lineNum">    7054 </span>            : */
<span class="lineNum">    7055 </span><span class="lineCov">      18722 : static int add_priority(struct ast_context *con, struct ast_exten *tmp,</span>
<span class="lineNum">    7056 </span>            :         struct ast_exten *el, struct ast_exten *e, int replace)
<span class="lineNum">    7057 </span>            : {
<span class="lineNum">    7058 </span>            :         struct ast_exten *ep;
<span class="lineNum">    7059 </span><span class="lineCov">      18722 :         struct ast_exten *eh=e;</span>
<span class="lineNum">    7060 </span><span class="lineCov">      18722 :         int repeated_label = 0; /* Track if this label is a repeat, assume no. */</span>
<span class="lineNum">    7061 </span>            : 
<span class="lineNum">    7062 </span><span class="lineCov">      63857 :         for (ep = NULL; e ; ep = e, e = e-&gt;peer) {</span>
<span class="lineNum">    7063 </span><span class="lineCov">      50784 :                 if (e-&gt;label &amp;&amp; tmp-&gt;label &amp;&amp; e-&gt;priority != tmp-&gt;priority &amp;&amp; !strcmp(e-&gt;label, tmp-&gt;label)) {</span>
<span class="lineNum">    7064 </span><span class="lineNoCov">          0 :                         if (strcmp(e-&gt;name, tmp-&gt;name)) {</span>
<span class="lineNum">    7065 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING,</span>
<span class="lineNum">    7066 </span>            :                                         &quot;Extension '%s' priority %d in '%s', label '%s' already in use at aliased extension '%s' priority %d\n&quot;,
<span class="lineNum">    7067 </span><span class="lineNoCov">          0 :                                         tmp-&gt;name, tmp-&gt;priority, con-&gt;name, tmp-&gt;label, e-&gt;name, e-&gt;priority);</span>
<span class="lineNum">    7068 </span>            :                         } else {
<span class="lineNum">    7069 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING,</span>
<span class="lineNum">    7070 </span>            :                                         &quot;Extension '%s' priority %d in '%s', label '%s' already in use at priority %d\n&quot;,
<span class="lineNum">    7071 </span><span class="lineNoCov">          0 :                                         tmp-&gt;name, tmp-&gt;priority, con-&gt;name, tmp-&gt;label, e-&gt;priority);</span>
<span class="lineNum">    7072 </span>            :                         }
<span class="lineNum">    7073 </span><span class="lineNoCov">          0 :                         repeated_label = 1;</span>
<span class="lineNum">    7074 </span>            :                 }
<span class="lineNum">    7075 </span><span class="lineCov">      50784 :                 if (e-&gt;priority &gt;= tmp-&gt;priority) {</span>
<span class="lineNum">    7076 </span><span class="lineCov">       5649 :                         break;</span>
<span class="lineNum">    7077 </span>            :                 }
<span class="lineNum">    7078 </span>            :         }
<span class="lineNum">    7079 </span>            : 
<span class="lineNum">    7080 </span><span class="lineCov">      18722 :         if (repeated_label) {   /* Discard the label since it's a repeat. */</span>
<span class="lineNum">    7081 </span><span class="lineNoCov">          0 :                 tmp-&gt;label = NULL;</span>
<span class="lineNum">    7082 </span>            :         }
<span class="lineNum">    7083 </span>            : 
<span class="lineNum">    7084 </span><span class="lineCov">      18722 :         if (!e) {       /* go at the end, and ep is surely set because the list is not empty */</span>
<span class="lineNum">    7085 </span><span class="lineCov">      13073 :                 ast_hashtab_insert_safe(eh-&gt;peer_table, tmp);</span>
<span class="lineNum">    7086 </span>            : 
<span class="lineNum">    7087 </span><span class="lineCov">      13073 :                 if (tmp-&gt;label) {</span>
<span class="lineNum">    7088 </span><span class="lineCov">        309 :                         ast_hashtab_insert_safe(eh-&gt;peer_label_table, tmp);</span>
<span class="lineNum">    7089 </span>            :                 }
<span class="lineNum">    7090 </span><span class="lineCov">      13073 :                 ep-&gt;peer = tmp;</span>
<span class="lineNum">    7091 </span><span class="lineCov">      13073 :                 return 0;       /* success */</span>
<span class="lineNum">    7092 </span>            :         }
<span class="lineNum">    7093 </span><span class="lineCov">       5649 :         if (e-&gt;priority == tmp-&gt;priority) {</span>
<span class="lineNum">    7094 </span>            :                 /* Can't have something exactly the same.  Is this a
<span class="lineNum">    7095 </span>            :                    replacement?  If so, replace, otherwise, bonk. */
<span class="lineNum">    7096 </span><span class="lineCov">         37 :                 if (!replace) {</span>
<span class="lineNum">    7097 </span><span class="lineCov">         32 :                         if (strcmp(e-&gt;name, tmp-&gt;name)) {</span>
<span class="lineNum">    7098 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_WARNING,</span>
<span class="lineNum">    7099 </span>            :                                         &quot;Unable to register extension '%s' priority %d in '%s', already in use by aliased extension '%s'\n&quot;,
<span class="lineNum">    7100 </span><span class="lineNoCov">          0 :                                         tmp-&gt;name, tmp-&gt;priority, con-&gt;name, e-&gt;name);</span>
<span class="lineNum">    7101 </span>            :                         } else {
<span class="lineNum">    7102 </span><span class="lineCov">         32 :                                 ast_log(LOG_WARNING,</span>
<span class="lineNum">    7103 </span>            :                                         &quot;Unable to register extension '%s' priority %d in '%s', already in use\n&quot;,
<span class="lineNum">    7104 </span><span class="lineCov">         32 :                                         tmp-&gt;name, tmp-&gt;priority, con-&gt;name);</span>
<span class="lineNum">    7105 </span>            :                         }
<span class="lineNum">    7106 </span>            : 
<span class="lineNum">    7107 </span><span class="lineCov">         32 :                         return -1;</span>
<span class="lineNum">    7108 </span>            :                 }
<span class="lineNum">    7109 </span>            :                 /* we are replacing e, so copy the link fields and then update
<span class="lineNum">    7110 </span>            :                  * whoever pointed to e to point to us
<span class="lineNum">    7111 </span>            :                  */
<span class="lineNum">    7112 </span><span class="lineCov">          5 :                 tmp-&gt;next = e-&gt;next;      /* not meaningful if we are not first in the peer list */</span>
<span class="lineNum">    7113 </span><span class="lineCov">          5 :                 tmp-&gt;peer = e-&gt;peer;      /* always meaningful */</span>
<span class="lineNum">    7114 </span><span class="lineCov">          5 :                 if (ep) {               /* We're in the peer list, just insert ourselves */</span>
<span class="lineNum">    7115 </span><span class="lineCov">          1 :                         ast_hashtab_remove_object_via_lookup(eh-&gt;peer_table,e);</span>
<span class="lineNum">    7116 </span>            : 
<span class="lineNum">    7117 </span><span class="lineCov">          1 :                         if (e-&gt;label) {</span>
<span class="lineNum">    7118 </span><span class="lineNoCov">          0 :                                 ast_hashtab_remove_object_via_lookup(eh-&gt;peer_label_table,e);</span>
<span class="lineNum">    7119 </span>            :                         }
<span class="lineNum">    7120 </span>            : 
<span class="lineNum">    7121 </span><span class="lineCov">          1 :                         ast_hashtab_insert_safe(eh-&gt;peer_table,tmp);</span>
<span class="lineNum">    7122 </span><span class="lineCov">          1 :                         if (tmp-&gt;label) {</span>
<span class="lineNum">    7123 </span><span class="lineNoCov">          0 :                                 ast_hashtab_insert_safe(eh-&gt;peer_label_table,tmp);</span>
<span class="lineNum">    7124 </span>            :                         }
<span class="lineNum">    7125 </span>            : 
<span class="lineNum">    7126 </span><span class="lineCov">          1 :                         ep-&gt;peer = tmp;</span>
<span class="lineNum">    7127 </span><span class="lineCov">          4 :                 } else if (el) {                /* We're the first extension. Take over e's functions */</span>
<span class="lineNum">    7128 </span><span class="lineNoCov">          0 :                         struct match_char *x = add_exten_to_pattern_tree(con, e, 1);</span>
<span class="lineNum">    7129 </span><span class="lineNoCov">          0 :                         tmp-&gt;peer_table = e-&gt;peer_table;</span>
<span class="lineNum">    7130 </span><span class="lineNoCov">          0 :                         tmp-&gt;peer_label_table = e-&gt;peer_label_table;</span>
<span class="lineNum">    7131 </span><span class="lineNoCov">          0 :                         ast_hashtab_remove_object_via_lookup(tmp-&gt;peer_table,e);</span>
<span class="lineNum">    7132 </span><span class="lineNoCov">          0 :                         ast_hashtab_insert_safe(tmp-&gt;peer_table,tmp);</span>
<span class="lineNum">    7133 </span><span class="lineNoCov">          0 :                         if (e-&gt;label) {</span>
<span class="lineNum">    7134 </span><span class="lineNoCov">          0 :                                 ast_hashtab_remove_object_via_lookup(tmp-&gt;peer_label_table, e);</span>
<span class="lineNum">    7135 </span>            :                         }
<span class="lineNum">    7136 </span><span class="lineNoCov">          0 :                         if (tmp-&gt;label) {</span>
<span class="lineNum">    7137 </span><span class="lineNoCov">          0 :                                 ast_hashtab_insert_safe(tmp-&gt;peer_label_table, tmp);</span>
<span class="lineNum">    7138 </span>            :                         }
<span class="lineNum">    7139 </span>            : 
<span class="lineNum">    7140 </span><span class="lineNoCov">          0 :                         ast_hashtab_remove_object_via_lookup(con-&gt;root_table, e);</span>
<span class="lineNum">    7141 </span><span class="lineNoCov">          0 :                         ast_hashtab_insert_safe(con-&gt;root_table, tmp);</span>
<span class="lineNum">    7142 </span><span class="lineNoCov">          0 :                         el-&gt;next = tmp;</span>
<span class="lineNum">    7143 </span>            :                         /* The pattern trie points to this exten; replace the pointer,
<span class="lineNum">    7144 </span>            :                            and all will be well */
<span class="lineNum">    7145 </span><span class="lineNoCov">          0 :                         if (x) { /* if the trie isn't formed yet, don't sweat this */</span>
<span class="lineNum">    7146 </span><span class="lineNoCov">          0 :                                 if (x-&gt;exten) { /* this test for safety purposes */</span>
<span class="lineNum">    7147 </span><span class="lineNoCov">          0 :                                         x-&gt;exten = tmp; /* replace what would become a bad pointer */</span>
<span class="lineNum">    7148 </span>            :                                 } else {
<span class="lineNum">    7149 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_ERROR,&quot;Trying to delete an exten from a context, but the pattern tree node returned isn't an extension\n&quot;);</span>
<span class="lineNum">    7150 </span>            :                                 }
<span class="lineNum">    7151 </span>            :                         }
<span class="lineNum">    7152 </span>            :                 } else {                        /* We're the very first extension.  */
<span class="lineNum">    7153 </span><span class="lineCov">          4 :                         struct match_char *x = add_exten_to_pattern_tree(con, e, 1);</span>
<span class="lineNum">    7154 </span><span class="lineCov">          4 :                         ast_hashtab_remove_object_via_lookup(con-&gt;root_table, e);</span>
<span class="lineNum">    7155 </span><span class="lineCov">          4 :                         ast_hashtab_insert_safe(con-&gt;root_table, tmp);</span>
<span class="lineNum">    7156 </span><span class="lineCov">          4 :                         tmp-&gt;peer_table = e-&gt;peer_table;</span>
<span class="lineNum">    7157 </span><span class="lineCov">          4 :                         tmp-&gt;peer_label_table = e-&gt;peer_label_table;</span>
<span class="lineNum">    7158 </span><span class="lineCov">          4 :                         ast_hashtab_remove_object_via_lookup(tmp-&gt;peer_table, e);</span>
<span class="lineNum">    7159 </span><span class="lineCov">          4 :                         ast_hashtab_insert_safe(tmp-&gt;peer_table, tmp);</span>
<span class="lineNum">    7160 </span><span class="lineCov">          4 :                         if (e-&gt;label) {</span>
<span class="lineNum">    7161 </span><span class="lineNoCov">          0 :                                 ast_hashtab_remove_object_via_lookup(tmp-&gt;peer_label_table, e);</span>
<span class="lineNum">    7162 </span>            :                         }
<span class="lineNum">    7163 </span><span class="lineCov">          4 :                         if (tmp-&gt;label) {</span>
<span class="lineNum">    7164 </span><span class="lineNoCov">          0 :                                 ast_hashtab_insert_safe(tmp-&gt;peer_label_table, tmp);</span>
<span class="lineNum">    7165 </span>            :                         }
<span class="lineNum">    7166 </span>            : 
<span class="lineNum">    7167 </span><span class="lineCov">          4 :                         ast_hashtab_remove_object_via_lookup(con-&gt;root_table, e);</span>
<span class="lineNum">    7168 </span><span class="lineCov">          4 :                         ast_hashtab_insert_safe(con-&gt;root_table, tmp);</span>
<span class="lineNum">    7169 </span><span class="lineCov">          4 :                         con-&gt;root = tmp;</span>
<span class="lineNum">    7170 </span>            :                         /* The pattern trie points to this exten; replace the pointer,
<span class="lineNum">    7171 </span>            :                            and all will be well */
<span class="lineNum">    7172 </span><span class="lineCov">          4 :                         if (x) { /* if the trie isn't formed yet; no problem */</span>
<span class="lineNum">    7173 </span><span class="lineCov">          4 :                                 if (x-&gt;exten) { /* this test for safety purposes */</span>
<span class="lineNum">    7174 </span><span class="lineCov">          4 :                                         x-&gt;exten = tmp; /* replace what would become a bad pointer */</span>
<span class="lineNum">    7175 </span>            :                                 } else {
<span class="lineNum">    7176 </span><span class="lineNoCov">          0 :                                         ast_log(LOG_ERROR,&quot;Trying to delete an exten from a context, but the pattern tree node returned isn't an extension\n&quot;);</span>
<span class="lineNum">    7177 </span>            :                                 }
<span class="lineNum">    7178 </span>            :                         }
<span class="lineNum">    7179 </span>            :                 }
<span class="lineNum">    7180 </span><span class="lineCov">          5 :                 if (tmp-&gt;priority == PRIORITY_HINT)</span>
<span class="lineNum">    7181 </span><span class="lineNoCov">          0 :                         ast_change_hint(e,tmp);</span>
<span class="lineNum">    7182 </span>            :                 /* Destroy the old one */
<span class="lineNum">    7183 </span><span class="lineCov">          5 :                 if (e-&gt;datad)</span>
<span class="lineNum">    7184 </span><span class="lineCov">          5 :                         e-&gt;datad(e-&gt;data);</span>
<span class="lineNum">    7185 </span><span class="lineCov">          5 :                 ast_free(e);</span>
<span class="lineNum">    7186 </span>            :         } else {        /* Slip ourselves in just before e */
<span class="lineNum">    7187 </span><span class="lineCov">       5612 :                 tmp-&gt;peer = e;</span>
<span class="lineNum">    7188 </span><span class="lineCov">       5612 :                 tmp-&gt;next = e-&gt;next;      /* extension chain, or NULL if e is not the first extension */</span>
<span class="lineNum">    7189 </span><span class="lineCov">       5612 :                 if (ep) {                       /* Easy enough, we're just in the peer list */</span>
<span class="lineNum">    7190 </span><span class="lineNoCov">          0 :                         if (tmp-&gt;label) {</span>
<span class="lineNum">    7191 </span><span class="lineNoCov">          0 :                                 ast_hashtab_insert_safe(eh-&gt;peer_label_table, tmp);</span>
<span class="lineNum">    7192 </span>            :                         }
<span class="lineNum">    7193 </span><span class="lineNoCov">          0 :                         ast_hashtab_insert_safe(eh-&gt;peer_table, tmp);</span>
<span class="lineNum">    7194 </span><span class="lineNoCov">          0 :                         ep-&gt;peer = tmp;</span>
<span class="lineNum">    7195 </span>            :                 } else {                        /* we are the first in some peer list, so link in the ext list */
<span class="lineNum">    7196 </span><span class="lineCov">       5612 :                         tmp-&gt;peer_table = e-&gt;peer_table;</span>
<span class="lineNum">    7197 </span><span class="lineCov">       5612 :                         tmp-&gt;peer_label_table = e-&gt;peer_label_table;</span>
<span class="lineNum">    7198 </span><span class="lineCov">       5612 :                         e-&gt;peer_table = 0;</span>
<span class="lineNum">    7199 </span><span class="lineCov">       5612 :                         e-&gt;peer_label_table = 0;</span>
<span class="lineNum">    7200 </span><span class="lineCov">       5612 :                         ast_hashtab_insert_safe(tmp-&gt;peer_table, tmp);</span>
<span class="lineNum">    7201 </span><span class="lineCov">       5612 :                         if (tmp-&gt;label) {</span>
<span class="lineNum">    7202 </span><span class="lineNoCov">          0 :                                 ast_hashtab_insert_safe(tmp-&gt;peer_label_table, tmp);</span>
<span class="lineNum">    7203 </span>            :                         }
<span class="lineNum">    7204 </span><span class="lineCov">       5612 :                         ast_hashtab_remove_object_via_lookup(con-&gt;root_table, e);</span>
<span class="lineNum">    7205 </span><span class="lineCov">       5612 :                         ast_hashtab_insert_safe(con-&gt;root_table, tmp);</span>
<span class="lineNum">    7206 </span><span class="lineCov">       5612 :                         if (el)</span>
<span class="lineNum">    7207 </span><span class="lineNoCov">          0 :                                 el-&gt;next = tmp;      /* in the middle... */</span>
<span class="lineNum">    7208 </span>            :                         else
<span class="lineNum">    7209 </span><span class="lineCov">       5612 :                                 con-&gt;root = tmp; /* ... or at the head */</span>
<span class="lineNum">    7210 </span><span class="lineCov">       5612 :                         e-&gt;next = NULL;      /* e is no more at the head, so e-&gt;next must be reset */</span>
<span class="lineNum">    7211 </span>            :                 }
<span class="lineNum">    7212 </span>            :                 /* And immediately return success. */
<span class="lineNum">    7213 </span><span class="lineCov">       5612 :                 if (tmp-&gt;priority == PRIORITY_HINT) {</span>
<span class="lineNum">    7214 </span><span class="lineCov">          1 :                         ast_add_hint(tmp);</span>
<span class="lineNum">    7215 </span>            :                 }
<span class="lineNum">    7216 </span>            :         }
<span class="lineNum">    7217 </span><span class="lineCov">       5617 :         return 0;</span>
<span class="lineNum">    7218 </span>            : }
<span class="lineNum">    7219 </span>            : 
<span class="lineNum">    7220 </span>            : /*! \brief
<span class="lineNum">    7221 </span>            :  * Main interface to add extensions to the list for out context.
<span class="lineNum">    7222 </span>            :  *
<span class="lineNum">    7223 </span>            :  * We sort extensions in order of matching preference, so that we can
<span class="lineNum">    7224 </span>            :  * stop the search as soon as we find a suitable match.
<span class="lineNum">    7225 </span>            :  * This ordering also takes care of wildcards such as '.' (meaning
<span class="lineNum">    7226 </span>            :  * &quot;one or more of any character&quot;) and '!' (which is 'earlymatch',
<span class="lineNum">    7227 </span>            :  * meaning &quot;zero or more of any character&quot; but also impacts the
<span class="lineNum">    7228 </span>            :  * return value from CANMATCH and EARLYMATCH.
<span class="lineNum">    7229 </span>            :  *
<span class="lineNum">    7230 </span>            :  * The extension match rules defined in the devmeeting 2006.05.05 are
<span class="lineNum">    7231 </span>            :  * quite simple: WE SELECT THE LONGEST MATCH.
<span class="lineNum">    7232 </span>            :  * In detail, &quot;longest&quot; means the number of matched characters in
<span class="lineNum">    7233 </span>            :  * the extension. In case of ties (e.g. _XXX and 333) in the length
<span class="lineNum">    7234 </span>            :  * of a pattern, we give priority to entries with the smallest cardinality
<span class="lineNum">    7235 </span>            :  * (e.g, [5-9] comes before [2-8] before the former has only 5 elements,
<span class="lineNum">    7236 </span>            :  * while the latter has 7, etc.
<span class="lineNum">    7237 </span>            :  * In case of same cardinality, the first element in the range counts.
<span class="lineNum">    7238 </span>            :  * If we still have a tie, any final '!' will make this as a possibly
<span class="lineNum">    7239 </span>            :  * less specific pattern.
<span class="lineNum">    7240 </span>            :  *
<span class="lineNum">    7241 </span>            :  * EBUSY - can't lock
<span class="lineNum">    7242 </span>            :  * EEXIST - extension with the same priority exist and no replace is set
<a name="7243"><span class="lineNum">    7243 </span>            :  *</a>
<span class="lineNum">    7244 </span>            :  */
<span class="lineNum">    7245 </span><span class="lineCov">      47554 : int ast_add_extension2(struct ast_context *con,</span>
<span class="lineNum">    7246 </span>            :         int replace, const char *extension, int priority, const char *label, const char *callerid,
<span class="lineNum">    7247 </span>            :         const char *application, void *data, void (*datad)(void *),
<span class="lineNum">    7248 </span>            :         const char *registrar, const char *registrar_file, int registrar_line)
<span class="lineNum">    7249 </span>            : {
<span class="lineNum">    7250 </span><span class="lineCov">      47554 :         return ast_add_extension2_lockopt(con, replace, extension, priority, label, callerid,</span>
<span class="lineNum">    7251 </span>            :                 application, data, datad, registrar, registrar_file, registrar_line, 1);
<a name="7252"><span class="lineNum">    7252 </span>            : }</a>
<span class="lineNum">    7253 </span>            : 
<span class="lineNum">    7254 </span><span class="lineCov">      23809 : int ast_add_extension2_nolock(struct ast_context *con,</span>
<span class="lineNum">    7255 </span>            :         int replace, const char *extension, int priority, const char *label, const char *callerid,
<span class="lineNum">    7256 </span>            :         const char *application, void *data, void (*datad)(void *),
<span class="lineNum">    7257 </span>            :         const char *registrar, const char *registrar_file, int registrar_line)
<span class="lineNum">    7258 </span>            : {
<span class="lineNum">    7259 </span><span class="lineCov">      23809 :         return ast_add_extension2_lockopt(con, replace, extension, priority, label, callerid,</span>
<span class="lineNum">    7260 </span>            :                 application, data, datad, registrar, registrar_file, registrar_line, 0);
<span class="lineNum">    7261 </span>            : }
<span class="lineNum">    7262 </span>            : 
<span class="lineNum">    7263 </span>            : 
<span class="lineNum">    7264 </span>            : /*!
<span class="lineNum">    7265 </span>            :  * \brief Same as ast_add_extension2() but controls the context locking.
<span class="lineNum">    7266 </span>            :  *
<span class="lineNum">    7267 </span>            :  * \details
<span class="lineNum">    7268 </span>            :  * Does all the work of ast_add_extension2, but adds an arg to
<a name="7269"><span class="lineNum">    7269 </span>            :  * determine if context locking should be done.</a>
<span class="lineNum">    7270 </span>            :  */
<span class="lineNum">    7271 </span><span class="lineCov">      71363 : static int ast_add_extension2_lockopt(struct ast_context *con,</span>
<span class="lineNum">    7272 </span>            :         int replace, const char *extension, int priority, const char *label, const char *callerid,
<span class="lineNum">    7273 </span>            :         const char *application, void *data, void (*datad)(void *),
<span class="lineNum">    7274 </span>            :         const char *registrar, const char *registrar_file, int registrar_line, int lock_context)
<span class="lineNum">    7275 </span>            : {
<span class="lineNum">    7276 </span>            :         /*
<span class="lineNum">    7277 </span>            :          * Sort extensions (or patterns) according to the rules indicated above.
<span class="lineNum">    7278 </span>            :          * These are implemented by the function ext_cmp()).
<span class="lineNum">    7279 </span>            :          * All priorities for the same ext/pattern/cid are kept in a list,
<span class="lineNum">    7280 </span>            :          * using the 'peer' field  as a link field..
<span class="lineNum">    7281 </span>            :          */
<span class="lineNum">    7282 </span><span class="lineCov">      71363 :         struct ast_exten *tmp, *tmp2, *e, *el = NULL;</span>
<span class="lineNum">    7283 </span>            :         int res;
<span class="lineNum">    7284 </span>            :         int length;
<span class="lineNum">    7285 </span>            :         char *p;
<span class="lineNum">    7286 </span>            :         char expand_buf[VAR_BUF_SIZE];
<span class="lineNum">    7287 </span><span class="lineCov">      71363 :         struct ast_exten dummy_exten = {0};</span>
<span class="lineNum">    7288 </span>            :         char dummy_name[1024];
<span class="lineNum">    7289 </span>            :         int exten_fluff;
<span class="lineNum">    7290 </span>            :         int callerid_fluff;
<span class="lineNum">    7291 </span>            : 
<span class="lineNum">    7292 </span><span class="lineCov">      71363 :         if (ast_strlen_zero(extension)) {</span>
<span class="lineNum">    7293 </span><span class="lineNoCov">          0 :                 ast_log(LOG_ERROR,&quot;You have to be kidding-- add exten '' to context %s? Figure out a name and call me back. Action ignored.\n&quot;,</span>
<span class="lineNum">    7294 </span><span class="lineNoCov">          0 :                                 con-&gt;name);</span>
<span class="lineNum">    7295 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    7296 </span>            :         }
<span class="lineNum">    7297 </span>            : 
<span class="lineNum">    7298 </span>            :         /* If we are adding a hint evalulate in variables and global variables */
<span class="lineNum">    7299 </span><span class="lineCov">      71363 :         if (priority == PRIORITY_HINT &amp;&amp; strstr(application, &quot;${&quot;) &amp;&amp; extension[0] != '_') {</span>
<span class="lineNum">    7300 </span>            :                 int inhibited;
<span class="lineNum">    7301 </span><span class="lineCov">         21 :                 struct ast_channel *c = ast_dummy_channel_alloc();</span>
<span class="lineNum">    7302 </span>            : 
<span class="lineNum">    7303 </span><span class="lineCov">         21 :                 if (c) {</span>
<span class="lineNum">    7304 </span><span class="lineCov">         21 :                         ast_channel_exten_set(c, extension);</span>
<span class="lineNum">    7305 </span><span class="lineCov">         21 :                         ast_channel_context_set(c, con-&gt;name);</span>
<span class="lineNum">    7306 </span>            :                 }
<span class="lineNum">    7307 </span>            : 
<span class="lineNum">    7308 </span>            :                 /*
<span class="lineNum">    7309 </span>            :                  * We can allow dangerous functions when adding a hint since
<span class="lineNum">    7310 </span>            :                  * altering dialplan is itself a privileged activity.  Otherwise,
<span class="lineNum">    7311 </span>            :                  * we could never execute dangerous functions.
<span class="lineNum">    7312 </span>            :                  */
<span class="lineNum">    7313 </span><span class="lineCov">         21 :                 inhibited = ast_thread_inhibit_escalations_swap(0);</span>
<span class="lineNum">    7314 </span><span class="lineCov">         21 :                 pbx_substitute_variables_helper(c, application, expand_buf, sizeof(expand_buf));</span>
<span class="lineNum">    7315 </span><span class="lineCov">         21 :                 if (0 &lt; inhibited) {</span>
<span class="lineNum">    7316 </span><span class="lineNoCov">          0 :                         ast_thread_inhibit_escalations();</span>
<span class="lineNum">    7317 </span>            :                 }
<span class="lineNum">    7318 </span>            : 
<span class="lineNum">    7319 </span><span class="lineCov">         21 :                 application = expand_buf;</span>
<span class="lineNum">    7320 </span><span class="lineCov">         21 :                 if (c) {</span>
<span class="lineNum">    7321 </span><span class="lineCov">         21 :                         ast_channel_unref(c);</span>
<span class="lineNum">    7322 </span>            :                 }
<span class="lineNum">    7323 </span>            :         }
<span class="lineNum">    7324 </span>            : 
<span class="lineNum">    7325 </span><span class="lineCov">      71363 :         exten_fluff = ext_fluff_count(extension);</span>
<span class="lineNum">    7326 </span><span class="lineCov">      71363 :         callerid_fluff = callerid ? ext_fluff_count(callerid) : 0;</span>
<span class="lineNum">    7327 </span>            : 
<span class="lineNum">    7328 </span><span class="lineCov">      71363 :         length = sizeof(struct ast_exten);</span>
<span class="lineNum">    7329 </span><span class="lineCov">      71363 :         length += strlen(extension) + 1;</span>
<span class="lineNum">    7330 </span><span class="lineCov">      71363 :         if (exten_fluff) {</span>
<span class="lineNum">    7331 </span><span class="lineCov">        247 :                 length += strlen(extension) + 1 - exten_fluff;</span>
<span class="lineNum">    7332 </span>            :         }
<span class="lineNum">    7333 </span><span class="lineCov">      71363 :         length += strlen(application) + 1;</span>
<span class="lineNum">    7334 </span><span class="lineCov">      71363 :         if (label) {</span>
<span class="lineNum">    7335 </span><span class="lineCov">        309 :                 length += strlen(label) + 1;</span>
<span class="lineNum">    7336 </span>            :         }
<span class="lineNum">    7337 </span><span class="lineCov">      71363 :         if (callerid) {</span>
<span class="lineNum">    7338 </span><span class="lineCov">         46 :                 length += strlen(callerid) + 1;</span>
<span class="lineNum">    7339 </span><span class="lineCov">         46 :                 if (callerid_fluff) {</span>
<span class="lineNum">    7340 </span><span class="lineNoCov">          0 :                         length += strlen(callerid) + 1 - callerid_fluff;</span>
<span class="lineNum">    7341 </span>            :                 }
<span class="lineNum">    7342 </span>            :         } else {
<span class="lineNum">    7343 </span><span class="lineCov">      71317 :                 length ++;      /* just the '\0' */</span>
<span class="lineNum">    7344 </span>            :         }
<span class="lineNum">    7345 </span><span class="lineCov">      71363 :         if (registrar_file) {</span>
<span class="lineNum">    7346 </span><span class="lineCov">      10228 :                 length += strlen(registrar_file) + 1;</span>
<span class="lineNum">    7347 </span>            :         }
<span class="lineNum">    7348 </span>            : 
<span class="lineNum">    7349 </span>            :         /* Be optimistic:  Build the extension structure first */
<span class="lineNum">    7350 </span><span class="lineCov">      71363 :         if (!(tmp = ast_calloc(1, length)))</span>
<span class="lineNum">    7351 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    7352 </span>            : 
<span class="lineNum">    7353 </span><span class="lineCov">      71363 :         if (ast_strlen_zero(label)) /* let's turn empty labels to a null ptr */</span>
<span class="lineNum">    7354 </span><span class="lineCov">      71054 :                 label = 0;</span>
<span class="lineNum">    7355 </span>            : 
<span class="lineNum">    7356 </span>            :         /* use p as dst in assignments, as the fields are const char * */
<span class="lineNum">    7357 </span><span class="lineCov">      71363 :         p = tmp-&gt;stuff;</span>
<span class="lineNum">    7358 </span><span class="lineCov">      71363 :         if (label) {</span>
<span class="lineNum">    7359 </span><span class="lineCov">        309 :                 tmp-&gt;label = p;</span>
<span class="lineNum">    7360 </span><span class="lineCov">        309 :                 strcpy(p, label);</span>
<span class="lineNum">    7361 </span><span class="lineCov">        309 :                 p += strlen(label) + 1;</span>
<span class="lineNum">    7362 </span>            :         }
<span class="lineNum">    7363 </span><span class="lineCov">      71363 :         tmp-&gt;name = p;</span>
<span class="lineNum">    7364 </span><span class="lineCov">      71363 :         p += ext_strncpy(p, extension, strlen(extension) + 1, 0);</span>
<span class="lineNum">    7365 </span><span class="lineCov">      71363 :         if (exten_fluff) {</span>
<span class="lineNum">    7366 </span><span class="lineCov">        247 :                 tmp-&gt;exten = p;</span>
<span class="lineNum">    7367 </span><span class="lineCov">        247 :                 p += ext_strncpy(p, extension, strlen(extension) + 1 - exten_fluff, 1);</span>
<span class="lineNum">    7368 </span>            :         } else {
<span class="lineNum">    7369 </span>            :                 /* no fluff, we don't need a copy. */
<span class="lineNum">    7370 </span><span class="lineCov">      71116 :                 tmp-&gt;exten = tmp-&gt;name;</span>
<span class="lineNum">    7371 </span>            :         }
<span class="lineNum">    7372 </span><span class="lineCov">      71363 :         tmp-&gt;priority = priority;</span>
<span class="lineNum">    7373 </span><span class="lineCov">      71363 :         tmp-&gt;cidmatch_display = tmp-&gt;cidmatch = p;        /* but use p for assignments below */</span>
<span class="lineNum">    7374 </span>            : 
<span class="lineNum">    7375 </span>            :         /* Blank callerid and NULL callerid are two SEPARATE things.  Do NOT confuse the two!!! */
<span class="lineNum">    7376 </span><span class="lineCov">      71363 :         if (callerid) {</span>
<span class="lineNum">    7377 </span><span class="lineCov">         46 :                 p += ext_strncpy(p, callerid, strlen(callerid) + 1, 0);</span>
<span class="lineNum">    7378 </span><span class="lineCov">         46 :                 if (callerid_fluff) {</span>
<span class="lineNum">    7379 </span><span class="lineNoCov">          0 :                         tmp-&gt;cidmatch = p;</span>
<span class="lineNum">    7380 </span><span class="lineNoCov">          0 :                         p += ext_strncpy(p, callerid, strlen(callerid) + 1 - callerid_fluff, 1);</span>
<span class="lineNum">    7381 </span>            :                 }
<span class="lineNum">    7382 </span><span class="lineCov">         46 :                 tmp-&gt;matchcid = AST_EXT_MATCHCID_ON;</span>
<span class="lineNum">    7383 </span>            :         } else {
<span class="lineNum">    7384 </span><span class="lineCov">      71317 :                 *p++ = '\0';</span>
<span class="lineNum">    7385 </span><span class="lineCov">      71317 :                 tmp-&gt;matchcid = AST_EXT_MATCHCID_OFF;</span>
<span class="lineNum">    7386 </span>            :         }
<span class="lineNum">    7387 </span>            : 
<span class="lineNum">    7388 </span><span class="lineCov">      71363 :         if (registrar_file) {</span>
<span class="lineNum">    7389 </span><span class="lineCov">      10228 :                 tmp-&gt;registrar_file = p;</span>
<span class="lineNum">    7390 </span><span class="lineCov">      10228 :                 strcpy(p, registrar_file);</span>
<span class="lineNum">    7391 </span><span class="lineCov">      10228 :                 p += strlen(registrar_file) + 1;</span>
<span class="lineNum">    7392 </span>            :         } else {
<span class="lineNum">    7393 </span><span class="lineCov">      61135 :                 tmp-&gt;registrar_file = NULL;</span>
<span class="lineNum">    7394 </span>            :         }
<span class="lineNum">    7395 </span>            : 
<span class="lineNum">    7396 </span><span class="lineCov">      71363 :         tmp-&gt;app = p;</span>
<span class="lineNum">    7397 </span><span class="lineCov">      71363 :         strcpy(p, application);</span>
<span class="lineNum">    7398 </span><span class="lineCov">      71363 :         tmp-&gt;parent = con;</span>
<span class="lineNum">    7399 </span><span class="lineCov">      71363 :         tmp-&gt;data = data;</span>
<span class="lineNum">    7400 </span><span class="lineCov">      71363 :         tmp-&gt;datad = datad;</span>
<span class="lineNum">    7401 </span><span class="lineCov">      71363 :         tmp-&gt;registrar = registrar;</span>
<span class="lineNum">    7402 </span><span class="lineCov">      71363 :         tmp-&gt;registrar_line = registrar_line;</span>
<span class="lineNum">    7403 </span>            : 
<span class="lineNum">    7404 </span><span class="lineCov">      71363 :         if (lock_context) {</span>
<span class="lineNum">    7405 </span><span class="lineCov">      47554 :                 ast_wrlock_context(con);</span>
<span class="lineNum">    7406 </span>            :         }
<span class="lineNum">    7407 </span>            : 
<span class="lineNum">    7408 </span><span class="lineCov">      71363 :         if (con-&gt;pattern_tree) { /* usually, on initial load, the pattern_tree isn't formed until the first find_exten; so if we are adding</span>
<span class="lineNum">    7409 </span>            :                                                                 an extension, and the trie exists, then we need to incrementally add this pattern to it. */
<span class="lineNum">    7410 </span><span class="lineCov">      22700 :                 ext_strncpy(dummy_name, tmp-&gt;exten, sizeof(dummy_name), 1);</span>
<span class="lineNum">    7411 </span><span class="lineCov">      22700 :                 dummy_exten.exten = dummy_name;</span>
<span class="lineNum">    7412 </span><span class="lineCov">      22700 :                 dummy_exten.matchcid = AST_EXT_MATCHCID_OFF;</span>
<span class="lineNum">    7413 </span><span class="lineCov">      22700 :                 dummy_exten.cidmatch = 0;</span>
<span class="lineNum">    7414 </span><span class="lineCov">      22700 :                 tmp2 = ast_hashtab_lookup(con-&gt;root_table, &amp;dummy_exten);</span>
<span class="lineNum">    7415 </span><span class="lineCov">      22700 :                 if (!tmp2) {</span>
<span class="lineNum">    7416 </span>            :                         /* hmmm, not in the trie; */
<span class="lineNum">    7417 </span><span class="lineCov">      22694 :                         add_exten_to_pattern_tree(con, tmp, 0);</span>
<span class="lineNum">    7418 </span><span class="lineCov">      22694 :                         ast_hashtab_insert_safe(con-&gt;root_table, tmp); /* for the sake of completeness */</span>
<span class="lineNum">    7419 </span>            :                 }
<span class="lineNum">    7420 </span>            :         }
<span class="lineNum">    7421 </span><span class="lineCov">      71363 :         res = 0; /* some compilers will think it is uninitialized otherwise */</span>
<span class="lineNum">    7422 </span><span class="lineCov">     325902 :         for (e = con-&gt;root; e; el = e, e = e-&gt;next) {   /* scan the extension list */</span>
<span class="lineNum">    7423 </span><span class="lineCov">     296768 :                 res = ext_cmp(e-&gt;exten, tmp-&gt;exten);</span>
<span class="lineNum">    7424 </span><span class="lineCov">     296768 :                 if (res == 0) { /* extension match, now look at cidmatch */</span>
<span class="lineNum">    7425 </span><span class="lineCov">      18764 :                         if (e-&gt;matchcid == AST_EXT_MATCHCID_OFF &amp;&amp; tmp-&gt;matchcid == AST_EXT_MATCHCID_OFF)</span>
<span class="lineNum">    7426 </span><span class="lineCov">      18696 :                                 res = 0;</span>
<span class="lineNum">    7427 </span><span class="lineCov">         68 :                         else if (tmp-&gt;matchcid == AST_EXT_MATCHCID_ON &amp;&amp; e-&gt;matchcid == AST_EXT_MATCHCID_OFF)</span>
<span class="lineNum">    7428 </span><span class="lineCov">          8 :                                 res = 1;</span>
<span class="lineNum">    7429 </span><span class="lineCov">         60 :                         else if (e-&gt;matchcid == AST_EXT_MATCHCID_ON &amp;&amp; tmp-&gt;matchcid == AST_EXT_MATCHCID_OFF)</span>
<span class="lineNum">    7430 </span><span class="lineCov">         14 :                                 res = -1;</span>
<span class="lineNum">    7431 </span>            :                         else
<span class="lineNum">    7432 </span><span class="lineCov">         46 :                                 res = ext_cmp(e-&gt;cidmatch, tmp-&gt;cidmatch);</span>
<span class="lineNum">    7433 </span>            :                 }
<span class="lineNum">    7434 </span><span class="lineCov">     296768 :                 if (res &gt;= 0)</span>
<span class="lineNum">    7435 </span><span class="lineCov">      42229 :                         break;</span>
<span class="lineNum">    7436 </span>            :         }
<span class="lineNum">    7437 </span><span class="lineCov">      71363 :         if (e &amp;&amp; res == 0) { /* exact match, insert in the priority chain */</span>
<span class="lineNum">    7438 </span><span class="lineCov">      18722 :                 res = add_priority(con, tmp, el, e, replace);</span>
<span class="lineNum">    7439 </span><span class="lineCov">      18722 :                 if (res &lt; 0) {</span>
<span class="lineNum">    7440 </span><span class="lineCov">         32 :                         if (con-&gt;pattern_tree) {</span>
<span class="lineNum">    7441 </span><span class="lineNoCov">          0 :                                 struct match_char *x = add_exten_to_pattern_tree(con, tmp, 1);</span>
<span class="lineNum">    7442 </span>            : 
<span class="lineNum">    7443 </span><span class="lineNoCov">          0 :                                 if (x-&gt;exten) {</span>
<span class="lineNum">    7444 </span><span class="lineNoCov">          0 :                                         x-&gt;deleted = 1;</span>
<span class="lineNum">    7445 </span><span class="lineNoCov">          0 :                                         x-&gt;exten = 0;</span>
<span class="lineNum">    7446 </span>            :                                 }
<span class="lineNum">    7447 </span>            : 
<span class="lineNum">    7448 </span><span class="lineNoCov">          0 :                                 ast_hashtab_remove_this_object(con-&gt;root_table, tmp);</span>
<span class="lineNum">    7449 </span>            :                         }
<span class="lineNum">    7450 </span>            : 
<span class="lineNum">    7451 </span><span class="lineCov">         32 :                         if (tmp-&gt;datad) {</span>
<span class="lineNum">    7452 </span><span class="lineCov">         32 :                                 tmp-&gt;datad(tmp-&gt;data);</span>
<span class="lineNum">    7453 </span>            :                                 /* if you free this, null it out */
<span class="lineNum">    7454 </span><span class="lineCov">         32 :                                 tmp-&gt;data = NULL;</span>
<span class="lineNum">    7455 </span>            :                         }
<span class="lineNum">    7456 </span>            : 
<span class="lineNum">    7457 </span><span class="lineCov">         32 :                         ast_free(tmp);</span>
<span class="lineNum">    7458 </span>            :                 }
<span class="lineNum">    7459 </span><span class="lineCov">      18722 :                 if (lock_context) {</span>
<span class="lineNum">    7460 </span><span class="lineCov">      18716 :                         ast_unlock_context(con);</span>
<span class="lineNum">    7461 </span>            :                 }
<span class="lineNum">    7462 </span><span class="lineCov">      18722 :                 if (res &lt; 0) {</span>
<span class="lineNum">    7463 </span><span class="lineCov">         32 :                         errno = EEXIST;</span>
<span class="lineNum">    7464 </span><span class="lineCov">         32 :                         return -1;</span>
<span class="lineNum">    7465 </span>            :                 }
<span class="lineNum">    7466 </span>            :         } else {
<span class="lineNum">    7467 </span>            :                 /*
<span class="lineNum">    7468 </span>            :                  * not an exact match, this is the first entry with this pattern,
<span class="lineNum">    7469 </span>            :                  * so insert in the main list right before 'e' (if any)
<span class="lineNum">    7470 </span>            :                  */
<span class="lineNum">    7471 </span><span class="lineCov">      52641 :                 tmp-&gt;next = e;</span>
<span class="lineNum">    7472 </span><span class="lineCov">      52641 :                 tmp-&gt;peer_table = ast_hashtab_create(13,</span>
<span class="lineNum">    7473 </span>            :                                                 hashtab_compare_exten_numbers,
<span class="lineNum">    7474 </span>            :                                                 ast_hashtab_resize_java,
<span class="lineNum">    7475 </span>            :                                                 ast_hashtab_newsize_java,
<span class="lineNum">    7476 </span>            :                                                 hashtab_hash_priority,
<span class="lineNum">    7477 </span>            :                                                 0);
<span class="lineNum">    7478 </span><span class="lineCov">      52641 :                 tmp-&gt;peer_label_table = ast_hashtab_create(7,</span>
<span class="lineNum">    7479 </span>            :                                                         hashtab_compare_exten_labels,
<span class="lineNum">    7480 </span>            :                                                         ast_hashtab_resize_java,
<span class="lineNum">    7481 </span>            :                                                         ast_hashtab_newsize_java,
<span class="lineNum">    7482 </span>            :                                                         hashtab_hash_labels,
<span class="lineNum">    7483 </span>            :                                                         0);
<span class="lineNum">    7484 </span>            : 
<span class="lineNum">    7485 </span><span class="lineCov">      52641 :                 if (el) {  /* there is another exten already in this context */</span>
<span class="lineNum">    7486 </span><span class="lineCov">      23931 :                         el-&gt;next = tmp;</span>
<span class="lineNum">    7487 </span>            :                 } else {  /* this is the first exten in this context */
<span class="lineNum">    7488 </span><span class="lineCov">      28710 :                         if (!con-&gt;root_table) {</span>
<span class="lineNum">    7489 </span><span class="lineCov">       5707 :                                 con-&gt;root_table = ast_hashtab_create(27,</span>
<span class="lineNum">    7490 </span>            :                                                                                                         hashtab_compare_extens,
<span class="lineNum">    7491 </span>            :                                                                                                         ast_hashtab_resize_java,
<span class="lineNum">    7492 </span>            :                                                                                                         ast_hashtab_newsize_java,
<span class="lineNum">    7493 </span>            :                                                                                                         hashtab_hash_extens,
<span class="lineNum">    7494 </span>            :                                                                                                         0);
<span class="lineNum">    7495 </span>            :                         }
<span class="lineNum">    7496 </span><span class="lineCov">      28710 :                         con-&gt;root = tmp;</span>
<span class="lineNum">    7497 </span>            :                 }
<span class="lineNum">    7498 </span><span class="lineCov">      52641 :                 if (label) {</span>
<span class="lineNum">    7499 </span><span class="lineNoCov">          0 :                         ast_hashtab_insert_safe(tmp-&gt;peer_label_table, tmp);</span>
<span class="lineNum">    7500 </span>            :                 }
<span class="lineNum">    7501 </span><span class="lineCov">      52641 :                 ast_hashtab_insert_safe(tmp-&gt;peer_table, tmp);</span>
<span class="lineNum">    7502 </span><span class="lineCov">      52641 :                 ast_hashtab_insert_safe(con-&gt;root_table, tmp);</span>
<span class="lineNum">    7503 </span>            : 
<span class="lineNum">    7504 </span><span class="lineCov">      52641 :                 if (lock_context) {</span>
<span class="lineNum">    7505 </span><span class="lineCov">      28838 :                         ast_unlock_context(con);</span>
<span class="lineNum">    7506 </span>            :                 }
<span class="lineNum">    7507 </span><span class="lineCov">      52641 :                 if (tmp-&gt;priority == PRIORITY_HINT) {</span>
<span class="lineNum">    7508 </span><span class="lineCov">        162 :                         ast_add_hint(tmp);</span>
<span class="lineNum">    7509 </span>            :                 }
<span class="lineNum">    7510 </span>            :         }
<span class="lineNum">    7511 </span><span class="lineCov">      71331 :         if (DEBUG_ATLEAST(1)) {</span>
<span class="lineNum">    7512 </span><span class="lineCov">      71228 :                 if (tmp-&gt;matchcid == AST_EXT_MATCHCID_ON) {</span>
<span class="lineNum">    7513 </span><span class="lineCov">         46 :                         ast_log(LOG_DEBUG, &quot;Added extension '%s' priority %d (CID match '%s') to %s (%p)\n&quot;,</span>
<span class="lineNum">    7514 </span><span class="lineCov">         46 :                                 tmp-&gt;name, tmp-&gt;priority, tmp-&gt;cidmatch_display, con-&gt;name, con);</span>
<span class="lineNum">    7515 </span>            :                 } else {
<span class="lineNum">    7516 </span><span class="lineCov">      71182 :                         ast_log(LOG_DEBUG, &quot;Added extension '%s' priority %d to %s (%p)\n&quot;,</span>
<span class="lineNum">    7517 </span><span class="lineCov">      71182 :                                 tmp-&gt;name, tmp-&gt;priority, con-&gt;name, con);</span>
<span class="lineNum">    7518 </span>            :                 }
<span class="lineNum">    7519 </span>            :         }
<span class="lineNum">    7520 </span>            : 
<span class="lineNum">    7521 </span><span class="lineCov">      71331 :         return 0;</span>
<span class="lineNum">    7522 </span>            : }
<span class="lineNum">    7523 </span>            : 
<span class="lineNum">    7524 </span>            : /*! \brief Structure which contains information about an outgoing dial */
<span class="lineNum">    7525 </span>            : struct pbx_outgoing {
<span class="lineNum">    7526 </span>            :         /*! \brief Dialing structure being used */
<span class="lineNum">    7527 </span>            :         struct ast_dial *dial;
<span class="lineNum">    7528 </span>            :         /*! \brief Condition for synchronous dialing */
<span class="lineNum">    7529 </span>            :         ast_cond_t cond;
<span class="lineNum">    7530 </span>            :         /*! \brief Application to execute */
<span class="lineNum">    7531 </span>            :         char app[AST_MAX_APP];
<span class="lineNum">    7532 </span>            :         /*! \brief Application data to pass to application */
<span class="lineNum">    7533 </span>            :         char *appdata;
<span class="lineNum">    7534 </span>            :         /*! \brief Dialplan context */
<span class="lineNum">    7535 </span>            :         char context[AST_MAX_CONTEXT];
<span class="lineNum">    7536 </span>            :         /*! \brief Dialplan extension */
<span class="lineNum">    7537 </span>            :         char exten[AST_MAX_EXTENSION];
<span class="lineNum">    7538 </span>            :         /*! \brief Dialplan priority */
<span class="lineNum">    7539 </span>            :         int priority;
<span class="lineNum">    7540 </span>            :         /*! \brief Result of the dial operation when dialed is set */
<span class="lineNum">    7541 </span>            :         int dial_res;
<span class="lineNum">    7542 </span>            :         /*! \brief Set when dialing is completed */
<span class="lineNum">    7543 </span>            :         unsigned int dialed:1;
<span class="lineNum">    7544 </span>            :         /*! \brief Set if we've spawned a thread to do our work */
<span class="lineNum">    7545 </span>            :         unsigned int in_separate_thread:1;
<span class="lineNum">    7546 </span>            : };
<a name="7547"><span class="lineNum">    7547 </span>            : </a>
<span class="lineNum">    7548 </span>            : /*! \brief Destructor for outgoing structure */
<span class="lineNum">    7549 </span><span class="lineCov">        888 : static void pbx_outgoing_destroy(void *obj)</span>
<span class="lineNum">    7550 </span>            : {
<span class="lineNum">    7551 </span><span class="lineCov">        888 :         struct pbx_outgoing *outgoing = obj;</span>
<span class="lineNum">    7552 </span>            : 
<span class="lineNum">    7553 </span><span class="lineCov">        888 :         if (outgoing-&gt;dial) {</span>
<span class="lineNum">    7554 </span><span class="lineCov">        888 :                 ast_dial_destroy(outgoing-&gt;dial);</span>
<span class="lineNum">    7555 </span>            :         }
<span class="lineNum">    7556 </span>            : 
<span class="lineNum">    7557 </span><span class="lineCov">        888 :         ast_cond_destroy(&amp;outgoing-&gt;cond);</span>
<span class="lineNum">    7558 </span>            : 
<span class="lineNum">    7559 </span><span class="lineCov">        888 :         ast_free(outgoing-&gt;appdata);</span>
<span class="lineNum">    7560 </span><span class="lineCov">        888 : }</span>
<a name="7561"><span class="lineNum">    7561 </span>            : </a>
<span class="lineNum">    7562 </span>            : /*! \brief Internal function which dials an outgoing leg and sends it to a provided extension or application */
<a name="7563"><span class="lineNum">    7563 </span><span class="lineCov">        887 : static void *pbx_outgoing_exec(void *data)</span></a>
<span class="lineNum">    7564 </span>            : {
<span class="lineNum">    7565 </span><span class="lineCov">       1774 :         RAII_VAR(struct pbx_outgoing *, outgoing, data, ao2_cleanup);</span>
<span class="lineNum">    7566 </span>            :         enum ast_dial_result res;
<span class="lineNum">    7567 </span>            : 
<span class="lineNum">    7568 </span><span class="lineCov">        887 :         res = ast_dial_run(outgoing-&gt;dial, NULL, 0);</span>
<span class="lineNum">    7569 </span>            : 
<span class="lineNum">    7570 </span><span class="lineCov">        887 :         if (outgoing-&gt;in_separate_thread) {</span>
<span class="lineNum">    7571 </span>            :                 /* Notify anyone interested that dialing is complete */
<span class="lineNum">    7572 </span><span class="lineCov">        860 :                 ao2_lock(outgoing);</span>
<span class="lineNum">    7573 </span><span class="lineCov">        860 :                 outgoing-&gt;dial_res = res;</span>
<span class="lineNum">    7574 </span><span class="lineCov">        860 :                 outgoing-&gt;dialed = 1;</span>
<span class="lineNum">    7575 </span><span class="lineCov">        860 :                 ast_cond_signal(&amp;outgoing-&gt;cond);</span>
<span class="lineNum">    7576 </span><span class="lineCov">        860 :                 ao2_unlock(outgoing);</span>
<span class="lineNum">    7577 </span>            :         } else {
<span class="lineNum">    7578 </span>            :                 /* We still need the dial result, but we don't need to lock */
<span class="lineNum">    7579 </span><span class="lineCov">         27 :                 outgoing-&gt;dial_res = res;</span>
<span class="lineNum">    7580 </span>            :         }
<span class="lineNum">    7581 </span>            : 
<span class="lineNum">    7582 </span>            :         /* If the outgoing leg was not answered we can immediately return and go no further */
<span class="lineNum">    7583 </span><span class="lineCov">        887 :         if (res != AST_DIAL_RESULT_ANSWERED) {</span>
<span class="lineNum">    7584 </span><span class="lineCov">        104 :                 return NULL;</span>
<span class="lineNum">    7585 </span>            :         }
<span class="lineNum">    7586 </span>            : 
<span class="lineNum">    7587 </span><span class="lineCov">        783 :         if (!ast_strlen_zero(outgoing-&gt;app)) {</span>
<span class="lineNum">    7588 </span><span class="lineCov">        194 :                 struct ast_app *app = pbx_findapp(outgoing-&gt;app);</span>
<span class="lineNum">    7589 </span>            : 
<span class="lineNum">    7590 </span><span class="lineCov">        194 :                 if (app) {</span>
<span class="lineNum">    7591 </span><span class="lineCov">        194 :                         ast_verb(4, &quot;Launching %s(%s) on %s\n&quot;, outgoing-&gt;app, S_OR(outgoing-&gt;appdata, &quot;&quot;),</span>
<span class="lineNum">    7592 </span>            :                                 ast_channel_name(ast_dial_answered(outgoing-&gt;dial)));
<span class="lineNum">    7593 </span><span class="lineCov">        194 :                         pbx_exec(ast_dial_answered(outgoing-&gt;dial), app, outgoing-&gt;appdata);</span>
<span class="lineNum">    7594 </span>            :                 } else {
<span class="lineNum">    7595 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;No such application '%s'\n&quot;, outgoing-&gt;app);</span>
<span class="lineNum">    7596 </span>            :                 }
<span class="lineNum">    7597 </span>            :         } else {
<span class="lineNum">    7598 </span><span class="lineCov">        589 :                 struct ast_channel *answered = ast_dial_answered(outgoing-&gt;dial);</span>
<span class="lineNum">    7599 </span>            : 
<span class="lineNum">    7600 </span><span class="lineCov">        589 :                 if (!ast_strlen_zero(outgoing-&gt;context)) {</span>
<span class="lineNum">    7601 </span><span class="lineCov">        589 :                         ast_channel_context_set(answered, outgoing-&gt;context);</span>
<span class="lineNum">    7602 </span>            :                 }
<span class="lineNum">    7603 </span>            : 
<span class="lineNum">    7604 </span><span class="lineCov">        589 :                 if (!ast_strlen_zero(outgoing-&gt;exten)) {</span>
<span class="lineNum">    7605 </span><span class="lineCov">        589 :                         ast_channel_exten_set(answered, outgoing-&gt;exten);</span>
<span class="lineNum">    7606 </span>            :                 }
<span class="lineNum">    7607 </span>            : 
<span class="lineNum">    7608 </span><span class="lineCov">        589 :                 if (outgoing-&gt;priority &gt; 0) {</span>
<span class="lineNum">    7609 </span><span class="lineCov">        589 :                         ast_channel_priority_set(answered, outgoing-&gt;priority);</span>
<span class="lineNum">    7610 </span>            :                 }
<span class="lineNum">    7611 </span>            : 
<span class="lineNum">    7612 </span><span class="lineCov">        589 :                 if (ast_pbx_run(answered)) {</span>
<span class="lineNum">    7613 </span><span class="lineNoCov">          0 :                         ast_log(LOG_ERROR, &quot;Failed to start PBX on %s\n&quot;, ast_channel_name(answered));</span>
<span class="lineNum">    7614 </span>            :                 } else {
<span class="lineNum">    7615 </span>            :                         /* PBX will have taken care of hanging up, so we steal the answered channel so dial doesn't do it */
<span class="lineNum">    7616 </span><span class="lineCov">        589 :                         ast_dial_answered_steal(outgoing-&gt;dial);</span>
<span class="lineNum">    7617 </span>            :                 }
<span class="lineNum">    7618 </span>            :         }
<span class="lineNum">    7619 </span>            : 
<span class="lineNum">    7620 </span><span class="lineCov">        783 :         return NULL;</span>
<span class="lineNum">    7621 </span>            : }
<a name="7622"><span class="lineNum">    7622 </span>            : </a>
<span class="lineNum">    7623 </span>            : /*! \brief Internal dialing state callback which causes early media to trigger an answer */
<span class="lineNum">    7624 </span><span class="lineNoCov">          0 : static void pbx_outgoing_state_callback(struct ast_dial *dial)</span>
<span class="lineNum">    7625 </span>            : {
<span class="lineNum">    7626 </span>            :         struct ast_channel *channel;
<span class="lineNum">    7627 </span>            : 
<span class="lineNum">    7628 </span><span class="lineNoCov">          0 :         if (ast_dial_state(dial) != AST_DIAL_RESULT_PROGRESS) {</span>
<span class="lineNum">    7629 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    7630 </span>            :         }
<span class="lineNum">    7631 </span>            : 
<span class="lineNum">    7632 </span><span class="lineNoCov">          0 :         if (!(channel = ast_dial_get_channel(dial, 0))) {</span>
<span class="lineNum">    7633 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    7634 </span>            :         }
<span class="lineNum">    7635 </span>            : 
<span class="lineNum">    7636 </span><span class="lineNoCov">          0 :         ast_verb(4, &quot;Treating progress as answer on '%s' due to early media option\n&quot;,</span>
<span class="lineNum">    7637 </span>            :                 ast_channel_name(channel));
<span class="lineNum">    7638 </span>            : 
<span class="lineNum">    7639 </span><span class="lineNoCov">          0 :         ast_queue_control(channel, AST_CONTROL_ANSWER);</span>
<span class="lineNum">    7640 </span>            : }
<span class="lineNum">    7641 </span>            : 
<span class="lineNum">    7642 </span>            : /*!
<span class="lineNum">    7643 </span>            :  * \brief Attempt to convert disconnect cause to old originate reason.
<span class="lineNum">    7644 </span>            :  *
<span class="lineNum">    7645 </span>            :  * \todo XXX The old originate reasons need to be trashed and replaced
<span class="lineNum">    7646 </span>            :  * with normal disconnect cause codes if the call was not answered.
<span class="lineNum">    7647 </span>            :  * The internal consumers of the reason values would also need to be
<a name="7648"><span class="lineNum">    7648 </span>            :  * updated: app_originate, call files, and AMI OriginateResponse.</a>
<span class="lineNum">    7649 </span>            :  */
<span class="lineNum">    7650 </span><span class="lineCov">        854 : static enum ast_control_frame_type pbx_dial_reason(enum ast_dial_result dial_result, int cause)</span>
<span class="lineNum">    7651 </span>            : {
<span class="lineNum">    7652 </span>            :         enum ast_control_frame_type pbx_reason;
<span class="lineNum">    7653 </span>            : 
<span class="lineNum">    7654 </span><span class="lineCov">        854 :         if (dial_result == AST_DIAL_RESULT_ANSWERED) {</span>
<span class="lineNum">    7655 </span>            :                 /* Remote end answered. */
<span class="lineNum">    7656 </span><span class="lineCov">        750 :                 pbx_reason = AST_CONTROL_ANSWER;</span>
<span class="lineNum">    7657 </span><span class="lineCov">        104 :         } else if (dial_result == AST_DIAL_RESULT_HANGUP) {</span>
<span class="lineNum">    7658 </span>            :                 /* Caller hungup */
<span class="lineNum">    7659 </span><span class="lineNoCov">          0 :                 pbx_reason = AST_CONTROL_HANGUP;</span>
<span class="lineNum">    7660 </span>            :         } else {
<span class="lineNum">    7661 </span><span class="lineCov">        104 :                 switch (cause) {</span>
<span class="lineNum">    7662 </span><span class="lineCov">          9 :                 case AST_CAUSE_USER_BUSY:</span>
<span class="lineNum">    7663 </span><span class="lineCov">          9 :                         pbx_reason = AST_CONTROL_BUSY;</span>
<span class="lineNum">    7664 </span><span class="lineCov">          9 :                         break;</span>
<span class="lineNum">    7665 </span><span class="lineCov">          6 :                 case AST_CAUSE_CALL_REJECTED:</span>
<span class="lineNum">    7666 </span>            :                 case AST_CAUSE_NETWORK_OUT_OF_ORDER:
<span class="lineNum">    7667 </span>            :                 case AST_CAUSE_DESTINATION_OUT_OF_ORDER:
<span class="lineNum">    7668 </span>            :                 case AST_CAUSE_NORMAL_TEMPORARY_FAILURE:
<span class="lineNum">    7669 </span>            :                 case AST_CAUSE_SWITCH_CONGESTION:
<span class="lineNum">    7670 </span>            :                 case AST_CAUSE_NORMAL_CIRCUIT_CONGESTION:
<span class="lineNum">    7671 </span><span class="lineCov">          6 :                         pbx_reason = AST_CONTROL_CONGESTION;</span>
<span class="lineNum">    7672 </span><span class="lineCov">          6 :                         break;</span>
<span class="lineNum">    7673 </span><span class="lineCov">          1 :                 case AST_CAUSE_ANSWERED_ELSEWHERE:</span>
<span class="lineNum">    7674 </span>            :                 case AST_CAUSE_NO_ANSWER:
<span class="lineNum">    7675 </span>            :                         /* Remote end was ringing (but isn't anymore) */
<span class="lineNum">    7676 </span><span class="lineCov">          1 :                         pbx_reason = AST_CONTROL_RINGING;</span>
<span class="lineNum">    7677 </span><span class="lineCov">          1 :                         break;</span>
<span class="lineNum">    7678 </span><span class="lineCov">         88 :                 case AST_CAUSE_UNALLOCATED:</span>
<span class="lineNum">    7679 </span>            :                 default:
<span class="lineNum">    7680 </span>            :                         /* Call Failure (not BUSY, and not NO_ANSWER, maybe Circuit busy or down?) */
<span class="lineNum">    7681 </span><span class="lineCov">         88 :                         pbx_reason = 0;</span>
<span class="lineNum">    7682 </span><span class="lineCov">         88 :                         break;</span>
<span class="lineNum">    7683 </span>            :                 }
<span class="lineNum">    7684 </span>            :         }
<span class="lineNum">    7685 </span>            : 
<span class="lineNum">    7686 </span><span class="lineCov">        854 :         return pbx_reason;</span>
<a name="7687"><span class="lineNum">    7687 </span>            : }</a>
<span class="lineNum">    7688 </span>            : 
<span class="lineNum">    7689 </span><span class="lineCov">        888 : static int pbx_outgoing_attempt(const char *type, struct ast_format_cap *cap,</span>
<span class="lineNum">    7690 </span>            :         const char *addr, int timeout, const char *context, const char *exten, int priority,
<span class="lineNum">    7691 </span>            :         const char *app, const char *appdata, int *reason, int synchronous,
<span class="lineNum">    7692 </span>            :         const char *cid_num, const char *cid_name, struct ast_variable *vars,
<span class="lineNum">    7693 </span>            :         const char *account, struct ast_channel **locked_channel, int early_media,
<a name="7694"><span class="lineNum">    7694 </span>            :         const struct ast_assigned_ids *assignedids, const char *predial_callee)</a>
<span class="lineNum">    7695 </span>            : {
<span class="lineNum">    7696 </span><span class="lineCov">       1776 :         RAII_VAR(struct pbx_outgoing *, outgoing, NULL, ao2_cleanup);</span>
<span class="lineNum">    7697 </span>            :         struct ast_channel *dialed;
<span class="lineNum">    7698 </span>            :         pthread_t thread;
<span class="lineNum">    7699 </span>            :         char tmp_cid_name[128];
<span class="lineNum">    7700 </span>            :         char tmp_cid_num[128];
<span class="lineNum">    7701 </span>            : 
<span class="lineNum">    7702 </span><span class="lineCov">        888 :         outgoing = ao2_alloc(sizeof(*outgoing), pbx_outgoing_destroy);</span>
<span class="lineNum">    7703 </span><span class="lineCov">        888 :         if (!outgoing) {</span>
<span class="lineNum">    7704 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    7705 </span>            :         }
<span class="lineNum">    7706 </span><span class="lineCov">        888 :         ast_cond_init(&amp;outgoing-&gt;cond, NULL);</span>
<span class="lineNum">    7707 </span>            : 
<span class="lineNum">    7708 </span><span class="lineCov">        888 :         if (!ast_strlen_zero(app)) {</span>
<span class="lineNum">    7709 </span><span class="lineCov">        251 :                 ast_copy_string(outgoing-&gt;app, app, sizeof(outgoing-&gt;app));</span>
<span class="lineNum">    7710 </span><span class="lineCov">        251 :                 outgoing-&gt;appdata = ast_strdup(appdata);</span>
<span class="lineNum">    7711 </span>            :         } else {
<span class="lineNum">    7712 </span><span class="lineCov">        637 :                 ast_copy_string(outgoing-&gt;context, context, sizeof(outgoing-&gt;context));</span>
<span class="lineNum">    7713 </span><span class="lineCov">        637 :                 ast_copy_string(outgoing-&gt;exten, exten, sizeof(outgoing-&gt;exten));</span>
<span class="lineNum">    7714 </span><span class="lineCov">        637 :                 outgoing-&gt;priority = priority;</span>
<span class="lineNum">    7715 </span>            :         }
<span class="lineNum">    7716 </span>            : 
<span class="lineNum">    7717 </span><span class="lineCov">        888 :         if (!(outgoing-&gt;dial = ast_dial_create())) {</span>
<span class="lineNum">    7718 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    7719 </span>            :         }
<span class="lineNum">    7720 </span>            : 
<span class="lineNum">    7721 </span><span class="lineCov">        888 :         if (ast_dial_append(outgoing-&gt;dial, type, addr, assignedids)) {</span>
<span class="lineNum">    7722 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    7723 </span>            :         }
<span class="lineNum">    7724 </span>            : 
<span class="lineNum">    7725 </span><span class="lineCov">        888 :         ast_dial_set_global_timeout(outgoing-&gt;dial, timeout);</span>
<span class="lineNum">    7726 </span>            : 
<span class="lineNum">    7727 </span><span class="lineCov">        888 :         if (!ast_strlen_zero(predial_callee)) {</span>
<span class="lineNum">    7728 </span>            :                 /* note casting to void * here to suppress compiler warning message (passing const to non-const function) */
<span class="lineNum">    7729 </span><span class="lineNoCov">          0 :                 ast_dial_option_global_enable(outgoing-&gt;dial, AST_DIAL_OPTION_PREDIAL, (void *)predial_callee);</span>
<span class="lineNum">    7730 </span>            :         }
<span class="lineNum">    7731 </span>            : 
<span class="lineNum">    7732 </span><span class="lineCov">        888 :         if (ast_dial_prerun(outgoing-&gt;dial, NULL, cap)) {</span>
<span class="lineNum">    7733 </span><span class="lineCov">          1 :                 if (synchronous &amp;&amp; reason) {</span>
<span class="lineNum">    7734 </span><span class="lineCov">          1 :                         *reason = pbx_dial_reason(AST_DIAL_RESULT_FAILED,</span>
<span class="lineNum">    7735 </span><span class="lineCov">          1 :                                 ast_dial_reason(outgoing-&gt;dial, 0));</span>
<span class="lineNum">    7736 </span>            :                 }
<span class="lineNum">    7737 </span><span class="lineCov">          1 :                 return -1;</span>
<span class="lineNum">    7738 </span>            :         }
<span class="lineNum">    7739 </span>            : 
<span class="lineNum">    7740 </span><span class="lineCov">        887 :         dialed = ast_dial_get_channel(outgoing-&gt;dial, 0);</span>
<span class="lineNum">    7741 </span><span class="lineCov">        887 :         if (!dialed) {</span>
<span class="lineNum">    7742 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    7743 </span>            :         }
<span class="lineNum">    7744 </span>            : 
<span class="lineNum">    7745 </span><span class="lineCov">        887 :         ast_channel_lock(dialed);</span>
<span class="lineNum">    7746 </span><span class="lineCov">        887 :         if (vars) {</span>
<span class="lineNum">    7747 </span><span class="lineCov">        349 :                 ast_set_variables(dialed, vars);</span>
<span class="lineNum">    7748 </span>            :         }
<span class="lineNum">    7749 </span><span class="lineCov">        887 :         if (!ast_strlen_zero(account)) {</span>
<span class="lineNum">    7750 </span><span class="lineCov">          2 :                 ast_channel_stage_snapshot(dialed);</span>
<span class="lineNum">    7751 </span><span class="lineCov">          2 :                 ast_channel_accountcode_set(dialed, account);</span>
<span class="lineNum">    7752 </span><span class="lineCov">          2 :                 ast_channel_peeraccount_set(dialed, account);</span>
<span class="lineNum">    7753 </span><span class="lineCov">          2 :                 ast_channel_stage_snapshot_done(dialed);</span>
<span class="lineNum">    7754 </span>            :         }
<span class="lineNum">    7755 </span><span class="lineCov">        887 :         ast_set_flag(ast_channel_flags(dialed), AST_FLAG_ORIGINATED);</span>
<span class="lineNum">    7756 </span>            : 
<span class="lineNum">    7757 </span><span class="lineCov">        887 :         if (!ast_strlen_zero(predial_callee)) {</span>
<span class="lineNum">    7758 </span><span class="lineNoCov">          0 :                 char *tmp = NULL;</span>
<span class="lineNum">    7759 </span>            :                 /*
<span class="lineNum">    7760 </span>            :                  * The predial sub routine may have set callerid so set this into the new channel
<span class="lineNum">    7761 </span>            :                  * Note... cid_num and cid_name parameters to this function will always be NULL if
<span class="lineNum">    7762 </span>            :                  * predial_callee is non-NULL so we are not overwriting anything here.
<span class="lineNum">    7763 </span>            :                  */
<span class="lineNum">    7764 </span><span class="lineNoCov">          0 :                 tmp = S_COR(ast_channel_caller(dialed)-&gt;id.number.valid, ast_channel_caller(dialed)-&gt;id.number.str, NULL);</span>
<span class="lineNum">    7765 </span><span class="lineNoCov">          0 :                 if (tmp) {</span>
<span class="lineNum">    7766 </span><span class="lineNoCov">          0 :                         ast_copy_string(tmp_cid_num, tmp, sizeof(tmp_cid_num));</span>
<span class="lineNum">    7767 </span><span class="lineNoCov">          0 :                         cid_num = tmp_cid_num;</span>
<span class="lineNum">    7768 </span>            :                 }
<span class="lineNum">    7769 </span><span class="lineNoCov">          0 :                 tmp = S_COR(ast_channel_caller(dialed)-&gt;id.name.valid, ast_channel_caller(dialed)-&gt;id.name.str, NULL);</span>
<span class="lineNum">    7770 </span><span class="lineNoCov">          0 :                 if (tmp) {</span>
<span class="lineNum">    7771 </span><span class="lineNoCov">          0 :                         ast_copy_string(tmp_cid_name, tmp, sizeof(tmp_cid_name));</span>
<span class="lineNum">    7772 </span><span class="lineNoCov">          0 :                         cid_name = tmp_cid_name;</span>
<span class="lineNum">    7773 </span>            :                 }
<span class="lineNum">    7774 </span>            :         }
<span class="lineNum">    7775 </span><span class="lineCov">        887 :         ast_channel_unlock(dialed);</span>
<span class="lineNum">    7776 </span>            : 
<span class="lineNum">    7777 </span><span class="lineCov">        887 :         if (!ast_strlen_zero(cid_num) || !ast_strlen_zero(cid_name)) {</span>
<span class="lineNum">    7778 </span>            :                 struct ast_party_connected_line connected;
<span class="lineNum">    7779 </span>            : 
<span class="lineNum">    7780 </span>            :                 /*
<span class="lineNum">    7781 </span>            :                  * It seems strange to set the CallerID on an outgoing call leg
<span class="lineNum">    7782 </span>            :                  * to whom we are calling, but this function's callers are doing
<span class="lineNum">    7783 </span>            :                  * various Originate methods.  This call leg goes to the local
<span class="lineNum">    7784 </span>            :                  * user.  Once the called party answers, the dialplan needs to
<span class="lineNum">    7785 </span>            :                  * be able to access the CallerID from the CALLERID function as
<span class="lineNum">    7786 </span>            :                  * if the called party had placed this call.
<span class="lineNum">    7787 </span>            :                  */
<span class="lineNum">    7788 </span><span class="lineCov">         26 :                 ast_set_callerid(dialed, cid_num, cid_name, cid_num);</span>
<span class="lineNum">    7789 </span>            : 
<span class="lineNum">    7790 </span><span class="lineCov">         26 :                 ast_party_connected_line_set_init(&amp;connected, ast_channel_connected(dialed));</span>
<span class="lineNum">    7791 </span><span class="lineCov">         26 :                 if (!ast_strlen_zero(cid_num)) {</span>
<span class="lineNum">    7792 </span><span class="lineCov">         13 :                         connected.id.number.valid = 1;</span>
<span class="lineNum">    7793 </span><span class="lineCov">         13 :                         connected.id.number.str = (char *) cid_num;</span>
<span class="lineNum">    7794 </span><span class="lineCov">         13 :                         connected.id.number.presentation = AST_PRES_ALLOWED_USER_NUMBER_NOT_SCREENED;</span>
<span class="lineNum">    7795 </span>            :                 }
<span class="lineNum">    7796 </span><span class="lineCov">         26 :                 if (!ast_strlen_zero(cid_name)) {</span>
<span class="lineNum">    7797 </span><span class="lineCov">         26 :                         connected.id.name.valid = 1;</span>
<span class="lineNum">    7798 </span><span class="lineCov">         26 :                         connected.id.name.str = (char *) cid_name;</span>
<span class="lineNum">    7799 </span><span class="lineCov">         26 :                         connected.id.name.presentation = AST_PRES_ALLOWED_USER_NUMBER_NOT_SCREENED;</span>
<span class="lineNum">    7800 </span>            :                 }
<span class="lineNum">    7801 </span><span class="lineCov">         26 :                 ast_channel_set_connected_line(dialed, &amp;connected, NULL);</span>
<span class="lineNum">    7802 </span>            :         }
<span class="lineNum">    7803 </span>            : 
<span class="lineNum">    7804 </span><span class="lineCov">        887 :         if (early_media) {</span>
<span class="lineNum">    7805 </span><span class="lineNoCov">          0 :                 ast_dial_set_state_callback(outgoing-&gt;dial, pbx_outgoing_state_callback);</span>
<span class="lineNum">    7806 </span>            :         }
<span class="lineNum">    7807 </span>            : 
<span class="lineNum">    7808 </span><span class="lineCov">        887 :         if (locked_channel) {</span>
<span class="lineNum">    7809 </span>            :                 /*
<span class="lineNum">    7810 </span>            :                  * Keep a dialed channel ref since the caller wants
<span class="lineNum">    7811 </span>            :                  * the channel returned.  We must get the ref before
<span class="lineNum">    7812 </span>            :                  * spawning off pbx_outgoing_exec().
<span class="lineNum">    7813 </span>            :                  */
<span class="lineNum">    7814 </span><span class="lineCov">        176 :                 ast_channel_ref(dialed);</span>
<span class="lineNum">    7815 </span><span class="lineCov">        176 :                 if (!synchronous) {</span>
<span class="lineNum">    7816 </span>            :                         /*
<span class="lineNum">    7817 </span>            :                          * Lock it now to hold off pbx_outgoing_exec() in case the
<span class="lineNum">    7818 </span>            :                          * calling function needs the channel state/snapshot before
<span class="lineNum">    7819 </span>            :                          * dialing actually happens.
<span class="lineNum">    7820 </span>            :                          */
<span class="lineNum">    7821 </span><span class="lineNoCov">          0 :                         ast_channel_lock(dialed);</span>
<span class="lineNum">    7822 </span>            :                 }
<span class="lineNum">    7823 </span>            :         }
<span class="lineNum">    7824 </span>            : 
<span class="lineNum">    7825 </span>            :         /* This extra reference is dereferenced by pbx_outgoing_exec */
<span class="lineNum">    7826 </span><span class="lineCov">        887 :         ao2_ref(outgoing, +1);</span>
<span class="lineNum">    7827 </span>            : 
<span class="lineNum">    7828 </span><span class="lineCov">        887 :         if (synchronous == AST_OUTGOING_WAIT_COMPLETE) {</span>
<span class="lineNum">    7829 </span>            :                 /*
<span class="lineNum">    7830 </span>            :                  * Because we are waiting until this is complete anyway, there is no
<span class="lineNum">    7831 </span>            :                  * sense in creating another thread that we will just need to wait
<span class="lineNum">    7832 </span>            :                  * for, so instead we commandeer the current thread.
<span class="lineNum">    7833 </span>            :                  */
<span class="lineNum">    7834 </span><span class="lineCov">         27 :                 pbx_outgoing_exec(outgoing);</span>
<span class="lineNum">    7835 </span>            :         } else {
<span class="lineNum">    7836 </span><span class="lineCov">        860 :                 outgoing-&gt;in_separate_thread = 1;</span>
<span class="lineNum">    7837 </span>            : 
<span class="lineNum">    7838 </span><span class="lineCov">        860 :                 if (ast_pthread_create_detached(&amp;thread, NULL, pbx_outgoing_exec, outgoing)) {</span>
<span class="lineNum">    7839 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Unable to spawn dialing thread for '%s/%s'\n&quot;, type, addr);</span>
<span class="lineNum">    7840 </span><span class="lineNoCov">          0 :                         ao2_ref(outgoing, -1);</span>
<span class="lineNum">    7841 </span><span class="lineNoCov">          0 :                         if (locked_channel) {</span>
<span class="lineNum">    7842 </span><span class="lineNoCov">          0 :                                 if (!synchronous) {</span>
<span class="lineNum">    7843 </span><span class="lineNoCov">          0 :                                         ast_channel_unlock(dialed);</span>
<span class="lineNum">    7844 </span>            :                                 }
<span class="lineNum">    7845 </span><span class="lineNoCov">          0 :                                 ast_channel_unref(dialed);</span>
<span class="lineNum">    7846 </span>            :                         }
<span class="lineNum">    7847 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    7848 </span>            :                 }
<span class="lineNum">    7849 </span>            : 
<span class="lineNum">    7850 </span><span class="lineCov">        860 :                 if (synchronous) {</span>
<span class="lineNum">    7851 </span><span class="lineCov">        826 :                         ao2_lock(outgoing);</span>
<span class="lineNum">    7852 </span>            :                         /* Wait for dialing to complete */
<span class="lineNum">    7853 </span><span class="lineCov">       1652 :                         while (!outgoing-&gt;dialed) {</span>
<span class="lineNum">    7854 </span><span class="lineCov">        826 :                                 ast_cond_wait(&amp;outgoing-&gt;cond, ao2_object_get_lockaddr(outgoing));</span>
<span class="lineNum">    7855 </span>            :                         }
<span class="lineNum">    7856 </span><span class="lineCov">        826 :                         ao2_unlock(outgoing);</span>
<span class="lineNum">    7857 </span>            :                 }
<span class="lineNum">    7858 </span>            :         }
<span class="lineNum">    7859 </span>            : 
<span class="lineNum">    7860 </span><span class="lineCov">        887 :         if (synchronous) {</span>
<span class="lineNum">    7861 </span>            :                 /* Determine the outcome of the dialing attempt up to it being answered. */
<span class="lineNum">    7862 </span><span class="lineCov">        853 :                 if (reason) {</span>
<span class="lineNum">    7863 </span><span class="lineCov">        853 :                         *reason = pbx_dial_reason(outgoing-&gt;dial_res,</span>
<span class="lineNum">    7864 </span><span class="lineCov">        853 :                                 ast_dial_reason(outgoing-&gt;dial, 0));</span>
<span class="lineNum">    7865 </span>            :                 }
<span class="lineNum">    7866 </span>            : 
<span class="lineNum">    7867 </span><span class="lineCov">        853 :                 if (outgoing-&gt;dial_res != AST_DIAL_RESULT_ANSWERED) {</span>
<span class="lineNum">    7868 </span>            :                         /* The dial operation failed. */
<span class="lineNum">    7869 </span><span class="lineCov">        103 :                         if (locked_channel) {</span>
<span class="lineNum">    7870 </span><span class="lineCov">         54 :                                 ast_channel_unref(dialed);</span>
<span class="lineNum">    7871 </span>            :                         }
<span class="lineNum">    7872 </span><span class="lineCov">        103 :                         return -1;</span>
<span class="lineNum">    7873 </span>            :                 }
<span class="lineNum">    7874 </span><span class="lineCov">        750 :                 if (locked_channel) {</span>
<span class="lineNum">    7875 </span><span class="lineCov">        122 :                         ast_channel_lock(dialed);</span>
<span class="lineNum">    7876 </span>            :                 }
<span class="lineNum">    7877 </span>            :         }
<span class="lineNum">    7878 </span>            : 
<span class="lineNum">    7879 </span><span class="lineCov">        784 :         if (locked_channel) {</span>
<span class="lineNum">    7880 </span><span class="lineCov">        122 :                 *locked_channel = dialed;</span>
<span class="lineNum">    7881 </span>            :         }
<span class="lineNum">    7882 </span><span class="lineCov">        784 :         return 0;</span>
<a name="7883"><span class="lineNum">    7883 </span>            : }</a>
<span class="lineNum">    7884 </span>            : 
<span class="lineNum">    7885 </span><span class="lineCov">        636 : int ast_pbx_outgoing_exten(const char *type, struct ast_format_cap *cap, const char *addr,</span>
<span class="lineNum">    7886 </span>            :         int timeout, const char *context, const char *exten, int priority, int *reason,
<span class="lineNum">    7887 </span>            :         int synchronous, const char *cid_num, const char *cid_name, struct ast_variable *vars,
<span class="lineNum">    7888 </span>            :         const char *account, struct ast_channel **locked_channel, int early_media,
<span class="lineNum">    7889 </span>            :         const struct ast_assigned_ids *assignedids)
<span class="lineNum">    7890 </span>            : {
<span class="lineNum">    7891 </span><span class="lineCov">        636 :         return ast_pbx_outgoing_exten_predial(type, cap, addr, timeout, context, exten, priority, reason,</span>
<span class="lineNum">    7892 </span>            :                 synchronous, cid_num, cid_name, vars, account, locked_channel, early_media, assignedids, NULL);
<a name="7893"><span class="lineNum">    7893 </span>            : }</a>
<span class="lineNum">    7894 </span>            : 
<span class="lineNum">    7895 </span><span class="lineCov">        637 : int ast_pbx_outgoing_exten_predial(const char *type, struct ast_format_cap *cap, const char *addr,</span>
<span class="lineNum">    7896 </span>            :         int timeout, const char *context, const char *exten, int priority, int *reason,
<span class="lineNum">    7897 </span>            :         int synchronous, const char *cid_num, const char *cid_name, struct ast_variable *vars,
<span class="lineNum">    7898 </span>            :         const char *account, struct ast_channel **locked_channel, int early_media,
<span class="lineNum">    7899 </span>            :         const struct ast_assigned_ids *assignedids, const char *predial_callee)
<span class="lineNum">    7900 </span>            : {
<span class="lineNum">    7901 </span>            :         int res;
<span class="lineNum">    7902 </span>            :         int my_reason;
<span class="lineNum">    7903 </span>            : 
<span class="lineNum">    7904 </span><span class="lineCov">        637 :         if (!reason) {</span>
<span class="lineNum">    7905 </span><span class="lineNoCov">          0 :                 reason = &amp;my_reason;</span>
<span class="lineNum">    7906 </span>            :         }
<span class="lineNum">    7907 </span><span class="lineCov">        637 :         *reason = 0;</span>
<span class="lineNum">    7908 </span><span class="lineCov">        637 :         if (locked_channel) {</span>
<span class="lineNum">    7909 </span><span class="lineCov">         93 :                 *locked_channel = NULL;</span>
<span class="lineNum">    7910 </span>            :         }
<span class="lineNum">    7911 </span>            : 
<span class="lineNum">    7912 </span><span class="lineCov">        637 :         res = pbx_outgoing_attempt(type, cap, addr, timeout, context, exten, priority,</span>
<span class="lineNum">    7913 </span>            :                 NULL, NULL, reason, synchronous, cid_num, cid_name, vars, account, locked_channel,
<span class="lineNum">    7914 </span>            :                 early_media, assignedids, predial_callee);
<span class="lineNum">    7915 </span>            : 
<span class="lineNum">    7916 </span><span class="lineCov">        637 :         if (res &lt; 0 /* Call failed to get connected for some reason. */</span>
<span class="lineNum">    7917 </span><span class="lineCov">         47 :                 &amp;&amp; 0 &lt; synchronous</span>
<span class="lineNum">    7918 </span><span class="lineCov">         47 :                 &amp;&amp; ast_exists_extension(NULL, context, &quot;failed&quot;, 1, NULL)) {</span>
<span class="lineNum">    7919 </span>            :                 struct ast_channel *failed;
<span class="lineNum">    7920 </span>            : 
<span class="lineNum">    7921 </span>            :                 /* We do not have to worry about a locked_channel if dialing failed. */
<span class="lineNum">    7922 </span><span class="lineNoCov">          0 :                 ast_assert(!locked_channel || !*locked_channel);</span>
<span class="lineNum">    7923 </span>            : 
<span class="lineNum">    7924 </span>            :                 /*!
<span class="lineNum">    7925 </span>            :                  * \todo XXX Not good.  The channel name is not unique if more than
<span class="lineNum">    7926 </span>            :                  * one originate fails at a time.
<span class="lineNum">    7927 </span>            :                  */
<span class="lineNum">    7928 </span><span class="lineNoCov">          0 :                 failed = ast_channel_alloc(0, AST_STATE_DOWN, cid_num, cid_name, account,</span>
<span class="lineNum">    7929 </span>            :                         &quot;failed&quot;, context, NULL, NULL, 0, &quot;OutgoingSpoolFailed&quot;);
<span class="lineNum">    7930 </span><span class="lineNoCov">          0 :                 if (failed) {</span>
<span class="lineNum">    7931 </span>            :                         char failed_reason[12];
<span class="lineNum">    7932 </span>            : 
<span class="lineNum">    7933 </span><span class="lineNoCov">          0 :                         ast_set_variables(failed, vars);</span>
<span class="lineNum">    7934 </span><span class="lineNoCov">          0 :                         snprintf(failed_reason, sizeof(failed_reason), &quot;%d&quot;, *reason);</span>
<span class="lineNum">    7935 </span><span class="lineNoCov">          0 :                         pbx_builtin_setvar_helper(failed, &quot;REASON&quot;, failed_reason);</span>
<span class="lineNum">    7936 </span><span class="lineNoCov">          0 :                         ast_channel_unlock(failed);</span>
<span class="lineNum">    7937 </span>            : 
<span class="lineNum">    7938 </span><span class="lineNoCov">          0 :                         if (ast_pbx_run(failed)) {</span>
<span class="lineNum">    7939 </span><span class="lineNoCov">          0 :                                 ast_log(LOG_ERROR, &quot;Unable to run PBX on '%s'\n&quot;,</span>
<span class="lineNum">    7940 </span>            :                                         ast_channel_name(failed));
<span class="lineNum">    7941 </span><span class="lineNoCov">          0 :                                 ast_hangup(failed);</span>
<span class="lineNum">    7942 </span>            :                         }
<span class="lineNum">    7943 </span>            :                 }
<span class="lineNum">    7944 </span>            :         }
<span class="lineNum">    7945 </span>            : 
<span class="lineNum">    7946 </span><span class="lineCov">        637 :         return res;</span>
<a name="7947"><span class="lineNum">    7947 </span>            : }</a>
<span class="lineNum">    7948 </span>            : 
<span class="lineNum">    7949 </span><span class="lineCov">        250 : int ast_pbx_outgoing_app(const char *type, struct ast_format_cap *cap, const char *addr,</span>
<span class="lineNum">    7950 </span>            :         int timeout, const char *app, const char *appdata, int *reason, int synchronous,
<span class="lineNum">    7951 </span>            :         const char *cid_num, const char *cid_name, struct ast_variable *vars,
<span class="lineNum">    7952 </span>            :         const char *account, struct ast_channel **locked_channel,
<span class="lineNum">    7953 </span>            :         const struct ast_assigned_ids *assignedids)
<span class="lineNum">    7954 </span>            : {
<span class="lineNum">    7955 </span><span class="lineCov">        250 :         return ast_pbx_outgoing_app_predial(type, cap, addr, timeout, app, appdata, reason, synchronous,</span>
<span class="lineNum">    7956 </span>            :                 cid_num, cid_name, vars, account, locked_channel, assignedids, NULL);
<a name="7957"><span class="lineNum">    7957 </span>            : }</a>
<span class="lineNum">    7958 </span>            : 
<span class="lineNum">    7959 </span><span class="lineCov">        251 : int ast_pbx_outgoing_app_predial(const char *type, struct ast_format_cap *cap, const char *addr,</span>
<span class="lineNum">    7960 </span>            :         int timeout, const char *app, const char *appdata, int *reason, int synchronous,
<span class="lineNum">    7961 </span>            :         const char *cid_num, const char *cid_name, struct ast_variable *vars,
<span class="lineNum">    7962 </span>            :         const char *account, struct ast_channel **locked_channel,
<span class="lineNum">    7963 </span>            :         const struct ast_assigned_ids *assignedids, const char *predial_callee)
<span class="lineNum">    7964 </span>            : {
<span class="lineNum">    7965 </span><span class="lineCov">        251 :         if (reason) {</span>
<span class="lineNum">    7966 </span><span class="lineCov">        251 :                 *reason = 0;</span>
<span class="lineNum">    7967 </span>            :         }
<span class="lineNum">    7968 </span><span class="lineCov">        251 :         if (locked_channel) {</span>
<span class="lineNum">    7969 </span><span class="lineCov">         83 :                 *locked_channel = NULL;</span>
<span class="lineNum">    7970 </span>            :         }
<span class="lineNum">    7971 </span><span class="lineCov">        251 :         if (ast_strlen_zero(app)) {</span>
<span class="lineNum">    7972 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    7973 </span>            :         }
<span class="lineNum">    7974 </span>            : 
<span class="lineNum">    7975 </span><span class="lineCov">        251 :         return pbx_outgoing_attempt(type, cap, addr, timeout, NULL, NULL, 0, app, appdata,</span>
<span class="lineNum">    7976 </span>            :                 reason, synchronous, cid_num, cid_name, vars, account, locked_channel, 0,
<span class="lineNum">    7977 </span>            :                 assignedids, predial_callee);
<span class="lineNum">    7978 </span>            : }
<span class="lineNum">    7979 </span>            : 
<span class="lineNum">    7980 </span>            : /* this is the guts of destroying a context --
<span class="lineNum">    7981 </span>            :    freeing up the structure, traversing and destroying the
<a name="7982"><span class="lineNum">    7982 </span>            :    extensions, switches, ignorepats, includes, etc. etc. */</a>
<span class="lineNum">    7983 </span>            : 
<span class="lineNum">    7984 </span><span class="lineCov">       4735 : static void __ast_internal_context_destroy( struct ast_context *con)</span>
<span class="lineNum">    7985 </span>            : {
<span class="lineNum">    7986 </span>            :         struct ast_exten *e, *el, *en;
<span class="lineNum">    7987 </span><span class="lineCov">       4735 :         struct ast_context *tmp = con;</span>
<span class="lineNum">    7988 </span>            : 
<span class="lineNum">    7989 </span>            :         /* Free includes */
<span class="lineNum">    7990 </span><span class="lineCov">       4735 :         AST_VECTOR_CALLBACK_VOID(&amp;tmp-&gt;includes, include_free);</span>
<span class="lineNum">    7991 </span><span class="lineCov">       4735 :         AST_VECTOR_FREE(&amp;tmp-&gt;includes);</span>
<span class="lineNum">    7992 </span>            : 
<span class="lineNum">    7993 </span>            :         /* Free ignorepats */
<span class="lineNum">    7994 </span><span class="lineCov">       4735 :         AST_VECTOR_CALLBACK_VOID(&amp;tmp-&gt;ignorepats, ignorepat_free);</span>
<span class="lineNum">    7995 </span><span class="lineCov">       4735 :         AST_VECTOR_FREE(&amp;tmp-&gt;ignorepats);</span>
<span class="lineNum">    7996 </span>            : 
<span class="lineNum">    7997 </span>            :         /* Free switches */
<span class="lineNum">    7998 </span><span class="lineCov">       4735 :         AST_VECTOR_CALLBACK_VOID(&amp;tmp-&gt;alts, sw_free);</span>
<span class="lineNum">    7999 </span><span class="lineCov">       4735 :         AST_VECTOR_FREE(&amp;tmp-&gt;alts);</span>
<span class="lineNum">    8000 </span>            : 
<span class="lineNum">    8001 </span><span class="lineCov">       4735 :         if (tmp-&gt;registrar)</span>
<span class="lineNum">    8002 </span><span class="lineCov">       4735 :                 ast_free(tmp-&gt;registrar);</span>
<span class="lineNum">    8003 </span>            : 
<span class="lineNum">    8004 </span>            :         /* destroy the hash tabs */
<span class="lineNum">    8005 </span><span class="lineCov">       4735 :         if (tmp-&gt;root_table) {</span>
<span class="lineNum">    8006 </span><span class="lineCov">       4551 :                 ast_hashtab_destroy(tmp-&gt;root_table, 0);</span>
<span class="lineNum">    8007 </span>            :         }
<span class="lineNum">    8008 </span>            :         /* and destroy the pattern tree */
<span class="lineNum">    8009 </span><span class="lineCov">       4735 :         if (tmp-&gt;pattern_tree)</span>
<span class="lineNum">    8010 </span><span class="lineCov">       2237 :                 destroy_pattern_tree(tmp-&gt;pattern_tree);</span>
<span class="lineNum">    8011 </span>            : 
<span class="lineNum">    8012 </span><span class="lineCov">      29661 :         for (e = tmp-&gt;root; e;) {</span>
<span class="lineNum">    8013 </span><span class="lineCov">      30552 :                 for (en = e-&gt;peer; en;) {</span>
<span class="lineNum">    8014 </span><span class="lineCov">       5626 :                         el = en;</span>
<span class="lineNum">    8015 </span><span class="lineCov">       5626 :                         en = en-&gt;peer;</span>
<span class="lineNum">    8016 </span><span class="lineCov">       5626 :                         destroy_exten(el);</span>
<span class="lineNum">    8017 </span>            :                 }
<span class="lineNum">    8018 </span><span class="lineCov">      24926 :                 el = e;</span>
<span class="lineNum">    8019 </span><span class="lineCov">      24926 :                 e = e-&gt;next;</span>
<span class="lineNum">    8020 </span><span class="lineCov">      24926 :                 destroy_exten(el);</span>
<span class="lineNum">    8021 </span>            :         }
<span class="lineNum">    8022 </span><span class="lineCov">       4735 :         tmp-&gt;root = NULL;</span>
<span class="lineNum">    8023 </span><span class="lineCov">       4735 :         ast_rwlock_destroy(&amp;tmp-&gt;lock);</span>
<span class="lineNum">    8024 </span><span class="lineCov">       4735 :         ast_mutex_destroy(&amp;tmp-&gt;macrolock);</span>
<span class="lineNum">    8025 </span><span class="lineCov">       4735 :         ast_free(tmp);</span>
<span class="lineNum">    8026 </span><span class="lineCov">       4735 : }</span>
<a name="8027"><span class="lineNum">    8027 </span>            : </a>
<span class="lineNum">    8028 </span>            : 
<span class="lineNum">    8029 </span><span class="lineCov">       4505 : void __ast_context_destroy(struct ast_context *list, struct ast_hashtab *contexttab, struct ast_context *con, const char *registrar)</span>
<span class="lineNum">    8030 </span>            : {
<span class="lineNum">    8031 </span><span class="lineCov">       4505 :         struct ast_context *tmp, *tmpl=NULL;</span>
<span class="lineNum">    8032 </span>            :         struct ast_exten *exten_item, *prio_item;
<span class="lineNum">    8033 </span>            : 
<span class="lineNum">    8034 </span><span class="lineCov">      12800 :         for (tmp = list; tmp; ) {</span>
<span class="lineNum">    8035 </span><span class="lineCov">       8295 :                 struct ast_context *next = NULL;        /* next starting point */</span>
<span class="lineNum">    8036 </span>            :                         /* The following code used to skip forward to the next
<span class="lineNum">    8037 </span>            :                            context with matching registrar, but this didn't
<span class="lineNum">    8038 </span>            :                            make sense; individual priorities registrar'd to
<span class="lineNum">    8039 </span>            :                            the matching registrar could occur in any context! */
<span class="lineNum">    8040 </span><span class="lineCov">       8295 :                 ast_debug(1, &quot;Investigate ctx %s %s\n&quot;, tmp-&gt;name, tmp-&gt;registrar);</span>
<span class="lineNum">    8041 </span><span class="lineCov">       8295 :                 if (con) {</span>
<span class="lineNum">    8042 </span><span class="lineNoCov">          0 :                         for (; tmp; tmpl = tmp, tmp = tmp-&gt;next) { /* skip to the matching context */</span>
<span class="lineNum">    8043 </span><span class="lineNoCov">          0 :                                 ast_debug(1, &quot;check ctx %s %s\n&quot;, tmp-&gt;name, tmp-&gt;registrar);</span>
<span class="lineNum">    8044 </span><span class="lineNoCov">          0 :                                 if ( !strcasecmp(tmp-&gt;name, con-&gt;name) ) {</span>
<span class="lineNum">    8045 </span><span class="lineNoCov">          0 :                                         break;  /* found it */</span>
<span class="lineNum">    8046 </span>            :                                 }
<span class="lineNum">    8047 </span>            :                         }
<span class="lineNum">    8048 </span>            :                 }
<span class="lineNum">    8049 </span>            : 
<span class="lineNum">    8050 </span><span class="lineCov">       8295 :                 if (!tmp)       /* not found, we are done */</span>
<span class="lineNum">    8051 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    8052 </span><span class="lineCov">       8295 :                 ast_wrlock_context(tmp);</span>
<span class="lineNum">    8053 </span>            : 
<span class="lineNum">    8054 </span><span class="lineCov">       8295 :                 if (registrar) {</span>
<span class="lineNum">    8055 </span>            :                         /* then search thru and remove any extens that match registrar. */
<span class="lineNum">    8056 </span>            :                         struct ast_hashtab_iter *exten_iter;
<span class="lineNum">    8057 </span>            :                         struct ast_hashtab_iter *prio_iter;
<span class="lineNum">    8058 </span>            :                         int idx;
<span class="lineNum">    8059 </span>            : 
<span class="lineNum">    8060 </span>            :                         /* remove any ignorepats whose registrar matches */
<span class="lineNum">    8061 </span><span class="lineCov">       8295 :                         for (idx = ast_context_ignorepats_count(tmp) - 1; idx &gt;= 0; idx--) {</span>
<span class="lineNum">    8062 </span><span class="lineNoCov">          0 :                                 struct ast_ignorepat *ip = AST_VECTOR_GET(&amp;tmp-&gt;ignorepats, idx);</span>
<span class="lineNum">    8063 </span>            : 
<span class="lineNum">    8064 </span><span class="lineNoCov">          0 :                                 if (!strcmp(ast_get_ignorepat_registrar(ip), registrar)) {</span>
<span class="lineNum">    8065 </span><span class="lineNoCov">          0 :                                         AST_VECTOR_REMOVE_ORDERED(&amp;tmp-&gt;ignorepats, idx);</span>
<span class="lineNum">    8066 </span><span class="lineNoCov">          0 :                                         ignorepat_free(ip);</span>
<span class="lineNum">    8067 </span>            :                                 }
<span class="lineNum">    8068 </span>            :                         }
<span class="lineNum">    8069 </span>            :                         /* remove any includes whose registrar matches */
<span class="lineNum">    8070 </span><span class="lineCov">       8299 :                         for (idx = ast_context_includes_count(tmp) - 1; idx &gt;= 0; idx--) {</span>
<span class="lineNum">    8071 </span><span class="lineCov">          4 :                                 struct ast_include *i = AST_VECTOR_GET(&amp;tmp-&gt;includes, idx);</span>
<span class="lineNum">    8072 </span>            : 
<span class="lineNum">    8073 </span><span class="lineCov">          4 :                                 if (!strcmp(ast_get_include_registrar(i), registrar)) {</span>
<span class="lineNum">    8074 </span><span class="lineCov">          4 :                                         AST_VECTOR_REMOVE_ORDERED(&amp;tmp-&gt;includes, idx);</span>
<span class="lineNum">    8075 </span><span class="lineCov">          4 :                                         include_free(i);</span>
<span class="lineNum">    8076 </span>            :                                 }
<span class="lineNum">    8077 </span>            :                         }
<span class="lineNum">    8078 </span>            :                         /* remove any switches whose registrar matches */
<span class="lineNum">    8079 </span><span class="lineCov">       8296 :                         for (idx = ast_context_switches_count(tmp) - 1; idx &gt;= 0; idx--) {</span>
<span class="lineNum">    8080 </span><span class="lineCov">          1 :                                 struct ast_sw *sw = AST_VECTOR_GET(&amp;tmp-&gt;alts, idx);</span>
<span class="lineNum">    8081 </span>            : 
<span class="lineNum">    8082 </span><span class="lineCov">          1 :                                 if (!strcmp(ast_get_switch_registrar(sw), registrar)) {</span>
<span class="lineNum">    8083 </span><span class="lineCov">          1 :                                         AST_VECTOR_REMOVE_ORDERED(&amp;tmp-&gt;alts, idx);</span>
<span class="lineNum">    8084 </span><span class="lineCov">          1 :                                         sw_free(sw);</span>
<span class="lineNum">    8085 </span>            :                                 }
<span class="lineNum">    8086 </span>            :                         }
<span class="lineNum">    8087 </span>            : 
<span class="lineNum">    8088 </span><span class="lineCov">       8295 :                         if (tmp-&gt;root_table) { /* it is entirely possible that the context is EMPTY */</span>
<span class="lineNum">    8089 </span><span class="lineCov">       8097 :                                 exten_iter = ast_hashtab_start_traversal(tmp-&gt;root_table);</span>
<span class="lineNum">    8090 </span><span class="lineCov">      86163 :                                 while ((exten_item=ast_hashtab_next(exten_iter))) {</span>
<span class="lineNum">    8091 </span><span class="lineCov">      78066 :                                         int end_traversal = 1;</span>
<span class="lineNum">    8092 </span>            : 
<span class="lineNum">    8093 </span>            :                                         /*
<span class="lineNum">    8094 </span>            :                                          * If the extension could not be removed from the root_table due to
<span class="lineNum">    8095 </span>            :                                          * a loaded PBX app, it can exist here but have its peer_table be
<span class="lineNum">    8096 </span>            :                                          * destroyed due to a previous pass through this function.
<span class="lineNum">    8097 </span>            :                                          */
<span class="lineNum">    8098 </span><span class="lineCov">      78066 :                                         if (!exten_item-&gt;peer_table) {</span>
<span class="lineNum">    8099 </span><span class="lineCov">          9 :                                                 continue;</span>
<span class="lineNum">    8100 </span>            :                                         }
<span class="lineNum">    8101 </span>            : 
<span class="lineNum">    8102 </span><span class="lineCov">      78057 :                                         prio_iter = ast_hashtab_start_traversal(exten_item-&gt;peer_table);</span>
<span class="lineNum">    8103 </span><span class="lineCov">     174856 :                                         while ((prio_item=ast_hashtab_next(prio_iter))) {</span>
<span class="lineNum">    8104 </span>            :                                                 char extension[AST_MAX_EXTENSION];
<span class="lineNum">    8105 </span>            :                                                 char cidmatch[AST_MAX_EXTENSION];
<span class="lineNum">    8106 </span><span class="lineCov">      96799 :                                                 if (!prio_item-&gt;registrar || strcmp(prio_item-&gt;registrar, registrar) != 0) {</span>
<span class="lineNum">    8107 </span><span class="lineCov">      56090 :                                                         continue;</span>
<span class="lineNum">    8108 </span>            :                                                 }
<span class="lineNum">    8109 </span><span class="lineCov">      40709 :                                                 ast_verb(3, &quot;Remove %s/%s/%d, registrar=%s; con=%s(%p); con-&gt;root=%p\n&quot;,</span>
<span class="lineNum">    8110 </span>            :                                                                  tmp-&gt;name, prio_item-&gt;name, prio_item-&gt;priority, registrar, con? con-&gt;name : &quot;&lt;nil&gt;&quot;, con, con? con-&gt;root_table: NULL);
<span class="lineNum">    8111 </span><span class="lineCov">      40709 :                                                 ast_copy_string(extension, prio_item-&gt;exten, sizeof(extension));</span>
<span class="lineNum">    8112 </span><span class="lineCov">      40709 :                                                 if (prio_item-&gt;cidmatch) {</span>
<span class="lineNum">    8113 </span><span class="lineCov">      40709 :                                                         ast_copy_string(cidmatch, prio_item-&gt;cidmatch, sizeof(cidmatch));</span>
<span class="lineNum">    8114 </span>            :                                                 }
<span class="lineNum">    8115 </span><span class="lineCov">      40709 :                                                 end_traversal &amp;= ast_context_remove_extension_callerid2(tmp, extension, prio_item-&gt;priority, cidmatch, prio_item-&gt;matchcid, NULL, 1);</span>
<span class="lineNum">    8116 </span>            :                                         }
<span class="lineNum">    8117 </span>            :                                         /* Explanation:
<span class="lineNum">    8118 </span>            :                                          * ast_context_remove_extension_callerid2 will destroy the extension that it comes across. This
<span class="lineNum">    8119 </span>            :                                          * destruction includes destroying the exten's peer_table, which we are currently traversing. If
<span class="lineNum">    8120 </span>            :                                          * ast_context_remove_extension_callerid2 ever should return '0' then this means we have destroyed
<span class="lineNum">    8121 </span>            :                                          * the hashtable which we are traversing, and thus calling ast_hashtab_end_traversal will result
<span class="lineNum">    8122 </span>            :                                          * in reading invalid memory. Thus, if we detect that we destroyed the hashtable, then we will simply
<span class="lineNum">    8123 </span>            :                                          * free the iterator
<span class="lineNum">    8124 </span>            :                                          */
<span class="lineNum">    8125 </span><span class="lineCov">      78057 :                                         if (end_traversal) {</span>
<span class="lineNum">    8126 </span><span class="lineCov">      50399 :                                                 ast_hashtab_end_traversal(prio_iter);</span>
<span class="lineNum">    8127 </span>            :                                         } else {
<span class="lineNum">    8128 </span><span class="lineCov">      27658 :                                                 ast_free(prio_iter);</span>
<span class="lineNum">    8129 </span>            :                                         }
<span class="lineNum">    8130 </span>            :                                 }
<span class="lineNum">    8131 </span><span class="lineCov">       8097 :                                 ast_hashtab_end_traversal(exten_iter);</span>
<span class="lineNum">    8132 </span>            :                         }
<span class="lineNum">    8133 </span>            : 
<span class="lineNum">    8134 </span>            :                         /* delete the context if it's registrar matches, is empty, has refcount of 1, */
<span class="lineNum">    8135 </span>            :                         /* it's not empty, if it has includes, ignorepats, or switches that are registered from
<span class="lineNum">    8136 </span>            :                            another registrar. It's not empty if there are any extensions */
<span class="lineNum">    8137 </span><span class="lineCov">       8295 :                         if (strcmp(tmp-&gt;registrar, registrar) == 0 &amp;&amp; tmp-&gt;refcount &lt; 2 &amp;&amp; !tmp-&gt;root &amp;&amp; !ast_context_ignorepats_count(tmp) &amp;&amp; !ast_context_includes_count(tmp) &amp;&amp; !ast_context_switches_count(tmp)) {</span>
<span class="lineNum">    8138 </span><span class="lineCov">       2481 :                                 ast_debug(1, &quot;delete ctx %s %s\n&quot;, tmp-&gt;name, tmp-&gt;registrar);</span>
<span class="lineNum">    8139 </span><span class="lineCov">       2481 :                                 ast_hashtab_remove_this_object(contexttab, tmp);</span>
<span class="lineNum">    8140 </span>            : 
<span class="lineNum">    8141 </span><span class="lineCov">       2481 :                                 next = tmp-&gt;next;</span>
<span class="lineNum">    8142 </span><span class="lineCov">       2481 :                                 if (tmpl)</span>
<span class="lineNum">    8143 </span><span class="lineCov">       2462 :                                         tmpl-&gt;next = next;</span>
<span class="lineNum">    8144 </span>            :                                 else
<span class="lineNum">    8145 </span><span class="lineCov">         19 :                                         contexts = next;</span>
<span class="lineNum">    8146 </span>            :                                 /* Okay, now we're safe to let it go -- in a sense, we were
<span class="lineNum">    8147 </span>            :                                    ready to let it go as soon as we locked it. */
<span class="lineNum">    8148 </span><span class="lineCov">       2481 :                                 ast_unlock_context(tmp);</span>
<span class="lineNum">    8149 </span><span class="lineCov">       2481 :                                 __ast_internal_context_destroy(tmp);</span>
<span class="lineNum">    8150 </span>            :                         } else {
<span class="lineNum">    8151 </span><span class="lineCov">       5814 :                                 ast_debug(1,&quot;Couldn't delete ctx %s/%s; refc=%d; tmp.root=%p\n&quot;, tmp-&gt;name, tmp-&gt;registrar,</span>
<span class="lineNum">    8152 </span>            :                                                   tmp-&gt;refcount, tmp-&gt;root);
<span class="lineNum">    8153 </span><span class="lineCov">       5814 :                                 ast_unlock_context(tmp);</span>
<span class="lineNum">    8154 </span><span class="lineCov">       5814 :                                 next = tmp-&gt;next;</span>
<span class="lineNum">    8155 </span><span class="lineCov">       5814 :                                 tmpl = tmp;</span>
<span class="lineNum">    8156 </span>            :                         }
<span class="lineNum">    8157 </span><span class="lineNoCov">          0 :                 } else if (con) {</span>
<span class="lineNum">    8158 </span><span class="lineNoCov">          0 :                         ast_verb(3, &quot;Deleting context %s registrar=%s\n&quot;, tmp-&gt;name, tmp-&gt;registrar);</span>
<span class="lineNum">    8159 </span><span class="lineNoCov">          0 :                         ast_debug(1, &quot;delete ctx %s %s\n&quot;, tmp-&gt;name, tmp-&gt;registrar);</span>
<span class="lineNum">    8160 </span><span class="lineNoCov">          0 :                         ast_hashtab_remove_this_object(contexttab, tmp);</span>
<span class="lineNum">    8161 </span>            : 
<span class="lineNum">    8162 </span><span class="lineNoCov">          0 :                         next = tmp-&gt;next;</span>
<span class="lineNum">    8163 </span><span class="lineNoCov">          0 :                         if (tmpl)</span>
<span class="lineNum">    8164 </span><span class="lineNoCov">          0 :                                 tmpl-&gt;next = next;</span>
<span class="lineNum">    8165 </span>            :                         else
<span class="lineNum">    8166 </span><span class="lineNoCov">          0 :                                 contexts = next;</span>
<span class="lineNum">    8167 </span>            :                         /* Okay, now we're safe to let it go -- in a sense, we were
<span class="lineNum">    8168 </span>            :                            ready to let it go as soon as we locked it. */
<span class="lineNum">    8169 </span><span class="lineNoCov">          0 :                         ast_unlock_context(tmp);</span>
<span class="lineNum">    8170 </span><span class="lineNoCov">          0 :                         __ast_internal_context_destroy(tmp);</span>
<span class="lineNum">    8171 </span>            :                 }
<span class="lineNum">    8172 </span>            : 
<span class="lineNum">    8173 </span>            :                 /* if we have a specific match, we are done, otherwise continue */
<span class="lineNum">    8174 </span><span class="lineCov">       8295 :                 tmp = con ? NULL : next;</span>
<span class="lineNum">    8175 </span>            :         }
<a name="8176"><span class="lineNum">    8176 </span><span class="lineCov">       4505 : }</span></a>
<span class="lineNum">    8177 </span>            : 
<span class="lineNum">    8178 </span><span class="lineCov">       1682 : int ast_context_destroy_by_name(const char *context, const char *registrar)</span>
<span class="lineNum">    8179 </span>            : {
<span class="lineNum">    8180 </span>            :         struct ast_context *con;
<span class="lineNum">    8181 </span><span class="lineCov">       1682 :         int ret = -1;</span>
<span class="lineNum">    8182 </span>            : 
<span class="lineNum">    8183 </span><span class="lineCov">       1682 :         ast_wrlock_contexts();</span>
<span class="lineNum">    8184 </span><span class="lineCov">       1682 :         con = ast_context_find(context);</span>
<span class="lineNum">    8185 </span><span class="lineCov">       1682 :         if (con) {</span>
<span class="lineNum">    8186 </span><span class="lineNoCov">          0 :                 ast_context_destroy(con, registrar);</span>
<span class="lineNum">    8187 </span><span class="lineNoCov">          0 :                 ret = 0;</span>
<span class="lineNum">    8188 </span>            :         }
<span class="lineNum">    8189 </span><span class="lineCov">       1682 :         ast_unlock_contexts();</span>
<span class="lineNum">    8190 </span>            : 
<span class="lineNum">    8191 </span><span class="lineCov">       1682 :         return ret;</span>
<a name="8192"><span class="lineNum">    8192 </span>            : }</a>
<span class="lineNum">    8193 </span>            : 
<span class="lineNum">    8194 </span><span class="lineCov">       4505 : void ast_context_destroy(struct ast_context *con, const char *registrar)</span>
<span class="lineNum">    8195 </span>            : {
<span class="lineNum">    8196 </span><span class="lineCov">       4505 :         ast_wrlock_contexts();</span>
<span class="lineNum">    8197 </span><span class="lineCov">       4505 :         __ast_context_destroy(contexts, contexts_table, con,registrar);</span>
<span class="lineNum">    8198 </span><span class="lineCov">       4505 :         ast_unlock_contexts();</span>
<a name="8199"><span class="lineNum">    8199 </span><span class="lineCov">       4505 : }</span></a>
<span class="lineNum">    8200 </span>            : 
<span class="lineNum">    8201 </span><span class="lineCov">        105 : void wait_for_hangup(struct ast_channel *chan, const void *data)</span>
<span class="lineNum">    8202 </span>            : {
<span class="lineNum">    8203 </span>            :         int res;
<span class="lineNum">    8204 </span>            :         struct ast_frame *f;
<span class="lineNum">    8205 </span>            :         double waitsec;
<span class="lineNum">    8206 </span>            :         int waittime;
<span class="lineNum">    8207 </span>            : 
<span class="lineNum">    8208 </span><span class="lineCov">        105 :         if (ast_strlen_zero(data) || (sscanf(data, &quot;%30lg&quot;, &amp;waitsec) != 1) || (waitsec &lt; 0))</span>
<span class="lineNum">    8209 </span><span class="lineCov">         64 :                 waitsec = -1;</span>
<span class="lineNum">    8210 </span><span class="lineCov">        105 :         if (waitsec &gt; -1) {</span>
<span class="lineNum">    8211 </span><span class="lineCov">         41 :                 waittime = waitsec * 1000.0;</span>
<span class="lineNum">    8212 </span><span class="lineCov">         41 :                 ast_safe_sleep(chan, waittime);</span>
<span class="lineNum">    8213 </span>            :         } else do {
<span class="lineNum">    8214 </span><span class="lineCov">         80 :                 res = ast_waitfor(chan, -1);</span>
<span class="lineNum">    8215 </span><span class="lineCov">         80 :                 if (res &lt; 0)</span>
<span class="lineNum">    8216 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    8217 </span><span class="lineCov">         80 :                 f = ast_read(chan);</span>
<span class="lineNum">    8218 </span><span class="lineCov">         80 :                 if (f)</span>
<span class="lineNum">    8219 </span><span class="lineCov">         16 :                         ast_frfree(f);</span>
<span class="lineNum">    8220 </span><span class="lineCov">         80 :         } while(f);</span>
<span class="lineNum">    8221 </span>            : }
<span class="lineNum">    8222 </span>            : 
<span class="lineNum">    8223 </span>            : /*!
<a name="8224"><span class="lineNum">    8224 </span>            :  * \ingroup functions</a>
<span class="lineNum">    8225 </span>            :  */
<span class="lineNum">    8226 </span><span class="lineNoCov">          0 : static int testtime_write(struct ast_channel *chan, const char *cmd, char *var, const char *value)</span>
<span class="lineNum">    8227 </span>            : {
<span class="lineNum">    8228 </span>            :         struct ast_tm tm;
<span class="lineNum">    8229 </span>            :         struct timeval tv;
<span class="lineNum">    8230 </span>            :         char *remainder, result[30], timezone[80];
<span class="lineNum">    8231 </span>            : 
<span class="lineNum">    8232 </span>            :         /* Turn off testing? */
<span class="lineNum">    8233 </span><span class="lineNoCov">          0 :         if (!pbx_checkcondition(value)) {</span>
<span class="lineNum">    8234 </span><span class="lineNoCov">          0 :                 pbx_builtin_setvar_helper(chan, &quot;TESTTIME&quot;, NULL);</span>
<span class="lineNum">    8235 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    8236 </span>            :         }
<span class="lineNum">    8237 </span>            : 
<span class="lineNum">    8238 </span>            :         /* Parse specified time */
<span class="lineNum">    8239 </span><span class="lineNoCov">          0 :         if (!(remainder = ast_strptime(value, &quot;%Y/%m/%d %H:%M:%S&quot;, &amp;tm))) {</span>
<span class="lineNum">    8240 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    8241 </span>            :         }
<span class="lineNum">    8242 </span><span class="lineNoCov">          0 :         sscanf(remainder, &quot;%79s&quot;, timezone);</span>
<span class="lineNum">    8243 </span><span class="lineNoCov">          0 :         tv = ast_mktime(&amp;tm, S_OR(timezone, NULL));</span>
<span class="lineNum">    8244 </span>            : 
<span class="lineNum">    8245 </span><span class="lineNoCov">          0 :         snprintf(result, sizeof(result), &quot;%ld&quot;, (long) tv.tv_sec);</span>
<span class="lineNum">    8246 </span><span class="lineNoCov">          0 :         pbx_builtin_setvar_helper(chan, &quot;__TESTTIME&quot;, result);</span>
<span class="lineNum">    8247 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    8248 </span>            : }
<span class="lineNum">    8249 </span>            : 
<span class="lineNum">    8250 </span>            : static struct ast_custom_function testtime_function = {
<span class="lineNum">    8251 </span>            :         .name = &quot;TESTTIME&quot;,
<span class="lineNum">    8252 </span>            :         .write = testtime_write,
<a name="8253"><span class="lineNum">    8253 </span>            : };</a>
<span class="lineNum">    8254 </span>            : 
<span class="lineNum">    8255 </span><span class="lineCov">       1688 : int pbx_checkcondition(const char *condition)</span>
<span class="lineNum">    8256 </span>            : {
<span class="lineNum">    8257 </span>            :         int res;
<span class="lineNum">    8258 </span><span class="lineCov">       1688 :         if (ast_strlen_zero(condition)) {                /* NULL or empty strings are false */</span>
<span class="lineNum">    8259 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    8260 </span><span class="lineCov">       1688 :         } else if (sscanf(condition, &quot;%30d&quot;, &amp;res) == 1) { /* Numbers are evaluated for truth */</span>
<span class="lineNum">    8261 </span><span class="lineCov">       1683 :                 return res;</span>
<span class="lineNum">    8262 </span>            :         } else {                                         /* Strings are true */
<span class="lineNum">    8263 </span><span class="lineCov">          5 :                 return 1;</span>
<span class="lineNum">    8264 </span>            :         }
<a name="8265"><span class="lineNum">    8265 </span>            : }</a>
<span class="lineNum">    8266 </span>            : 
<span class="lineNum">    8267 </span><span class="lineCov">       2172 : static void presence_state_cb(void *unused, struct stasis_subscription *sub, struct stasis_message *msg)</span>
<span class="lineNum">    8268 </span>            : {
<span class="lineNum">    8269 </span>            :         struct ast_presence_state_message *presence_state;
<span class="lineNum">    8270 </span><span class="lineCov">       2172 :         struct ast_str *hint_app = NULL;</span>
<span class="lineNum">    8271 </span>            :         struct ast_hintdevice *device;
<span class="lineNum">    8272 </span>            :         struct ast_hintdevice *cmpdevice;
<span class="lineNum">    8273 </span>            :         struct ao2_iterator *dev_iter;
<span class="lineNum">    8274 </span>            : 
<span class="lineNum">    8275 </span><span class="lineCov">       2172 :         if (stasis_message_type(msg) != ast_presence_state_message_type()) {</span>
<span class="lineNum">    8276 </span><span class="lineCov">       2157 :                 return;</span>
<span class="lineNum">    8277 </span>            :         }
<span class="lineNum">    8278 </span>            : 
<span class="lineNum">    8279 </span><span class="lineCov">         29 :         presence_state = stasis_message_data(msg);</span>
<span class="lineNum">    8280 </span>            : 
<span class="lineNum">    8281 </span><span class="lineCov">         29 :         if (ao2_container_count(hintdevices) == 0) {</span>
<span class="lineNum">    8282 </span>            :                 /* There are no hints monitoring devices. */
<span class="lineNum">    8283 </span><span class="lineCov">         14 :                 return;</span>
<span class="lineNum">    8284 </span>            :         }
<span class="lineNum">    8285 </span>            : 
<span class="lineNum">    8286 </span><span class="lineCov">         15 :         hint_app = ast_str_create(1024);</span>
<span class="lineNum">    8287 </span><span class="lineCov">         15 :         if (!hint_app) {</span>
<span class="lineNum">    8288 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    8289 </span>            :         }
<span class="lineNum">    8290 </span>            : 
<span class="lineNum">    8291 </span><span class="lineCov">         15 :         cmpdevice = ast_alloca(sizeof(*cmpdevice) + strlen(presence_state-&gt;provider));</span>
<span class="lineNum">    8292 </span><span class="lineCov">         15 :         strcpy(cmpdevice-&gt;hintdevice, presence_state-&gt;provider);</span>
<span class="lineNum">    8293 </span>            : 
<span class="lineNum">    8294 </span><span class="lineCov">         15 :         ast_mutex_lock(&amp;context_merge_lock);/* Hold off ast_merge_contexts_and_delete */</span>
<span class="lineNum">    8295 </span><span class="lineCov">         15 :         dev_iter = ao2_t_callback(hintdevices,</span>
<span class="lineNum">    8296 </span>            :                 OBJ_POINTER | OBJ_MULTIPLE,
<span class="lineNum">    8297 </span>            :                 hintdevice_cmp_multiple,
<span class="lineNum">    8298 </span>            :                 cmpdevice,
<span class="lineNum">    8299 </span>            :                 &quot;find devices in container&quot;);
<span class="lineNum">    8300 </span><span class="lineCov">         15 :         if (!dev_iter) {</span>
<span class="lineNum">    8301 </span><span class="lineNoCov">          0 :                 ast_mutex_unlock(&amp;context_merge_lock);</span>
<span class="lineNum">    8302 </span><span class="lineNoCov">          0 :                 ast_free(hint_app);</span>
<span class="lineNum">    8303 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    8304 </span>            :         }
<span class="lineNum">    8305 </span>            : 
<span class="lineNum">    8306 </span><span class="lineCov">         30 :         for (; (device = ao2_iterator_next(dev_iter)); ao2_t_ref(device, -1, &quot;Next device&quot;)) {</span>
<span class="lineNum">    8307 </span><span class="lineCov">         15 :                 if (device-&gt;hint) {</span>
<span class="lineNum">    8308 </span><span class="lineCov">         15 :                         presence_state_notify_callbacks(device-&gt;hint, &amp;hint_app, presence_state);</span>
<span class="lineNum">    8309 </span>            :                 }
<span class="lineNum">    8310 </span>            :         }
<span class="lineNum">    8311 </span><span class="lineCov">         15 :         ao2_iterator_destroy(dev_iter);</span>
<span class="lineNum">    8312 </span><span class="lineCov">         15 :         ast_mutex_unlock(&amp;context_merge_lock);</span>
<span class="lineNum">    8313 </span>            : 
<span class="lineNum">    8314 </span><span class="lineCov">         15 :         ast_free(hint_app);</span>
<a name="8315"><span class="lineNum">    8315 </span>            : }</a>
<span class="lineNum">    8316 </span>            : 
<span class="lineNum">    8317 </span><span class="lineCov">          1 : static int action_extensionstatelist(struct mansession *s, const struct message *m)</span>
<span class="lineNum">    8318 </span>            : {
<span class="lineNum">    8319 </span><span class="lineCov">          1 :         const char *action_id = astman_get_header(m, &quot;ActionID&quot;);</span>
<span class="lineNum">    8320 </span>            :         struct ast_hint *hint;
<span class="lineNum">    8321 </span>            :         struct ao2_iterator it_hints;
<span class="lineNum">    8322 </span><span class="lineCov">          1 :         int hint_count = 0;</span>
<span class="lineNum">    8323 </span>            : 
<span class="lineNum">    8324 </span><span class="lineCov">          1 :         if (!hints) {</span>
<span class="lineNum">    8325 </span><span class="lineNoCov">          0 :                 astman_send_error(s, m, &quot;No dialplan hints are available&quot;);</span>
<span class="lineNum">    8326 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    8327 </span>            :         }
<span class="lineNum">    8328 </span>            : 
<span class="lineNum">    8329 </span><span class="lineCov">          1 :         astman_send_listack(s, m, &quot;Extension Statuses will follow&quot;, &quot;start&quot;);</span>
<span class="lineNum">    8330 </span>            : 
<span class="lineNum">    8331 </span><span class="lineCov">          1 :         ao2_lock(hints);</span>
<span class="lineNum">    8332 </span><span class="lineCov">          1 :         it_hints = ao2_iterator_init(hints, 0);</span>
<span class="lineNum">    8333 </span><span class="lineCov">          4 :         for (; (hint = ao2_iterator_next(&amp;it_hints)); ao2_ref(hint, -1)) {</span>
<span class="lineNum">    8334 </span>            : 
<span class="lineNum">    8335 </span><span class="lineCov">          3 :                 ao2_lock(hint);</span>
<span class="lineNum">    8336 </span>            : 
<span class="lineNum">    8337 </span>            :                 /* Ignore pattern matching hints; they are stored in the
<span class="lineNum">    8338 </span>            :                  * hints container but aren't real from the perspective of
<span class="lineNum">    8339 </span>            :                  * an AMI user
<span class="lineNum">    8340 </span>            :                  */
<span class="lineNum">    8341 </span><span class="lineCov">          3 :                 if (hint-&gt;exten-&gt;exten[0] == '_') {</span>
<span class="lineNum">    8342 </span><span class="lineCov">          1 :                         ao2_unlock(hint);</span>
<span class="lineNum">    8343 </span><span class="lineCov">          1 :                         continue;</span>
<span class="lineNum">    8344 </span>            :                 }
<span class="lineNum">    8345 </span>            : 
<span class="lineNum">    8346 </span><span class="lineCov">          2 :                 ++hint_count;</span>
<span class="lineNum">    8347 </span>            : 
<span class="lineNum">    8348 </span><span class="lineCov">          2 :                 astman_append(s, &quot;Event: ExtensionStatus\r\n&quot;);</span>
<span class="lineNum">    8349 </span><span class="lineCov">          2 :                 if (!ast_strlen_zero(action_id)) {</span>
<span class="lineNum">    8350 </span><span class="lineCov">          2 :                         astman_append(s, &quot;ActionID: %s\r\n&quot;, action_id);</span>
<span class="lineNum">    8351 </span>            :                 }
<span class="lineNum">    8352 </span><span class="lineCov">          2 :                 astman_append(s,</span>
<span class="lineNum">    8353 </span>            :                    &quot;Exten: %s\r\n&quot;
<span class="lineNum">    8354 </span>            :                    &quot;Context: %s\r\n&quot;
<span class="lineNum">    8355 </span>            :                    &quot;Hint: %s\r\n&quot;
<span class="lineNum">    8356 </span>            :                    &quot;Status: %d\r\n&quot;
<span class="lineNum">    8357 </span>            :                    &quot;StatusText: %s\r\n\r\n&quot;,
<span class="lineNum">    8358 </span><span class="lineCov">          2 :                    hint-&gt;exten-&gt;exten,</span>
<span class="lineNum">    8359 </span><span class="lineCov">          2 :                    hint-&gt;exten-&gt;parent-&gt;name,</span>
<span class="lineNum">    8360 </span><span class="lineCov">          2 :                    hint-&gt;exten-&gt;app,</span>
<span class="lineNum">    8361 </span>            :                    hint-&gt;laststate,
<span class="lineNum">    8362 </span>            :                    ast_extension_state2str(hint-&gt;laststate));
<span class="lineNum">    8363 </span><span class="lineCov">          2 :                 ao2_unlock(hint);</span>
<span class="lineNum">    8364 </span>            :         }
<span class="lineNum">    8365 </span>            : 
<span class="lineNum">    8366 </span><span class="lineCov">          1 :         ao2_iterator_destroy(&amp;it_hints);</span>
<span class="lineNum">    8367 </span><span class="lineCov">          1 :         ao2_unlock(hints);</span>
<span class="lineNum">    8368 </span>            : 
<span class="lineNum">    8369 </span><span class="lineCov">          1 :         astman_send_list_complete_start(s, m, &quot;ExtensionStateListComplete&quot;, hint_count);</span>
<span class="lineNum">    8370 </span><span class="lineCov">          1 :         astman_send_list_complete_end(s);</span>
<span class="lineNum">    8371 </span>            : 
<span class="lineNum">    8372 </span><span class="lineCov">          1 :         return 0;</span>
<span class="lineNum">    8373 </span>            : }
<span class="lineNum">    8374 </span>            : 
<span class="lineNum">    8375 </span>            : 
<span class="lineNum">    8376 </span>            : /*!
<span class="lineNum">    8377 </span>            :  * \internal
<span class="lineNum">    8378 </span>            :  * \brief Clean up resources on Asterisk shutdown.
<span class="lineNum">    8379 </span>            :  *
<a name="8380"><span class="lineNum">    8380 </span>            :  * \note Cleans up resources allocated in load_pbx</a>
<span class="lineNum">    8381 </span>            :  */
<span class="lineNum">    8382 </span><span class="lineCov">       1015 : static void unload_pbx(void)</span>
<span class="lineNum">    8383 </span>            : {
<span class="lineNum">    8384 </span><span class="lineCov">       1015 :         presence_state_sub = stasis_unsubscribe_and_join(presence_state_sub);</span>
<span class="lineNum">    8385 </span><span class="lineCov">       1015 :         device_state_sub = stasis_unsubscribe_and_join(device_state_sub);</span>
<span class="lineNum">    8386 </span>            : 
<span class="lineNum">    8387 </span><span class="lineCov">       1015 :         ast_manager_unregister(&quot;ShowDialPlan&quot;);</span>
<span class="lineNum">    8388 </span><span class="lineCov">       1015 :         ast_manager_unregister(&quot;ExtensionStateList&quot;);</span>
<span class="lineNum">    8389 </span><span class="lineCov">       1015 :         ast_cli_unregister_multiple(pbx_cli, ARRAY_LEN(pbx_cli));</span>
<span class="lineNum">    8390 </span><span class="lineCov">       1015 :         ast_custom_function_unregister(&amp;exception_function);</span>
<span class="lineNum">    8391 </span><span class="lineCov">       1015 :         ast_custom_function_unregister(&amp;testtime_function);</span>
<a name="8392"><span class="lineNum">    8392 </span><span class="lineCov">       1015 : }</span></a>
<span class="lineNum">    8393 </span>            : 
<span class="lineNum">    8394 </span><span class="lineCov">       1124 : int load_pbx(void)</span>
<span class="lineNum">    8395 </span>            : {
<span class="lineNum">    8396 </span><span class="lineCov">       1124 :         int res = 0;</span>
<span class="lineNum">    8397 </span>            : 
<span class="lineNum">    8398 </span><span class="lineCov">       1124 :         ast_register_cleanup(unload_pbx);</span>
<span class="lineNum">    8399 </span>            : 
<span class="lineNum">    8400 </span>            :         /* Initialize the PBX */
<span class="lineNum">    8401 </span><span class="lineCov">       1124 :         ast_verb(1, &quot;Asterisk PBX Core Initializing\n&quot;);</span>
<span class="lineNum">    8402 </span>            : 
<span class="lineNum">    8403 </span><span class="lineCov">       1124 :         ast_verb(2, &quot;Registering builtin functions:\n&quot;);</span>
<span class="lineNum">    8404 </span><span class="lineCov">       1124 :         ast_cli_register_multiple(pbx_cli, ARRAY_LEN(pbx_cli));</span>
<span class="lineNum">    8405 </span><span class="lineCov">       1124 :         __ast_custom_function_register(&amp;exception_function, NULL);</span>
<span class="lineNum">    8406 </span><span class="lineCov">       1124 :         __ast_custom_function_register(&amp;testtime_function, NULL);</span>
<span class="lineNum">    8407 </span>            : 
<span class="lineNum">    8408 </span>            :         /* Register manager application */
<span class="lineNum">    8409 </span><span class="lineCov">       1124 :         res |= ast_manager_register_xml_core(&quot;ShowDialPlan&quot;, EVENT_FLAG_CONFIG | EVENT_FLAG_REPORTING, manager_show_dialplan);</span>
<span class="lineNum">    8410 </span><span class="lineCov">       1124 :         res |= ast_manager_register_xml_core(&quot;ExtensionStateList&quot;, EVENT_FLAG_CALL | EVENT_FLAG_REPORTING, action_extensionstatelist);</span>
<span class="lineNum">    8411 </span>            : 
<span class="lineNum">    8412 </span><span class="lineCov">       1124 :         if (res) {</span>
<span class="lineNum">    8413 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    8414 </span>            :         }
<span class="lineNum">    8415 </span>            : 
<span class="lineNum">    8416 </span><span class="lineCov">       1124 :         if (!(device_state_sub = stasis_subscribe(ast_device_state_topic_all(), device_state_cb, NULL))) {</span>
<span class="lineNum">    8417 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    8418 </span>            :         }
<span class="lineNum">    8419 </span>            : 
<span class="lineNum">    8420 </span><span class="lineCov">       1124 :         if (!(presence_state_sub = stasis_subscribe(ast_presence_state_topic_all(), presence_state_cb, NULL))) {</span>
<span class="lineNum">    8421 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    8422 </span>            :         }
<span class="lineNum">    8423 </span>            : 
<span class="lineNum">    8424 </span><span class="lineCov">       1124 :         return 0;</span>
<span class="lineNum">    8425 </span>            : }
<span class="lineNum">    8426 </span>            : 
<span class="lineNum">    8427 </span>            : /*
<a name="8428"><span class="lineNum">    8428 </span>            :  * Lock context list functions ...</a>
<span class="lineNum">    8429 </span>            :  */
<span class="lineNum">    8430 </span><span class="lineCov">       9593 : int ast_wrlock_contexts(void)</span>
<span class="lineNum">    8431 </span>            : {
<span class="lineNum">    8432 </span><span class="lineCov">       9593 :         return ast_mutex_lock(&amp;conlock);</span>
<a name="8433"><span class="lineNum">    8433 </span>            : }</a>
<span class="lineNum">    8434 </span>            : 
<span class="lineNum">    8435 </span><span class="lineCov">     313408 : int ast_rdlock_contexts(void)</span>
<span class="lineNum">    8436 </span>            : {
<span class="lineNum">    8437 </span><span class="lineCov">     313408 :         return ast_mutex_lock(&amp;conlock);</span>
<a name="8438"><span class="lineNum">    8438 </span>            : }</a>
<span class="lineNum">    8439 </span>            : 
<span class="lineNum">    8440 </span><span class="lineCov">     323001 : int ast_unlock_contexts(void)</span>
<span class="lineNum">    8441 </span>            : {
<span class="lineNum">    8442 </span><span class="lineCov">     323001 :         return ast_mutex_unlock(&amp;conlock);</span>
<span class="lineNum">    8443 </span>            : }
<span class="lineNum">    8444 </span>            : 
<span class="lineNum">    8445 </span>            : /*
<a name="8446"><span class="lineNum">    8446 </span>            :  * Lock context ...</a>
<span class="lineNum">    8447 </span>            :  */
<span class="lineNum">    8448 </span><span class="lineCov">      57008 : int ast_wrlock_context(struct ast_context *con)</span>
<span class="lineNum">    8449 </span>            : {
<span class="lineNum">    8450 </span><span class="lineCov">      57008 :         return ast_rwlock_wrlock(&amp;con-&gt;lock);</span>
<a name="8451"><span class="lineNum">    8451 </span>            : }</a>
<span class="lineNum">    8452 </span>            : 
<span class="lineNum">    8453 </span><span class="lineCov">         16 : int ast_rdlock_context(struct ast_context *con)</span>
<span class="lineNum">    8454 </span>            : {
<span class="lineNum">    8455 </span><span class="lineCov">         16 :         return ast_rwlock_rdlock(&amp;con-&gt;lock);</span>
<a name="8456"><span class="lineNum">    8456 </span>            : }</a>
<span class="lineNum">    8457 </span>            : 
<span class="lineNum">    8458 </span><span class="lineCov">      57024 : int ast_unlock_context(struct ast_context *con)</span>
<span class="lineNum">    8459 </span>            : {
<span class="lineNum">    8460 </span><span class="lineCov">      57024 :         return ast_rwlock_unlock(&amp;con-&gt;lock);</span>
<span class="lineNum">    8461 </span>            : }
<span class="lineNum">    8462 </span>            : 
<span class="lineNum">    8463 </span>            : /*
<a name="8464"><span class="lineNum">    8464 </span>            :  * Name functions ...</a>
<span class="lineNum">    8465 </span>            :  */
<span class="lineNum">    8466 </span><span class="lineCov">       5025 : const char *ast_get_context_name(struct ast_context *con)</span>
<span class="lineNum">    8467 </span>            : {
<span class="lineNum">    8468 </span><span class="lineCov">       5025 :         return con ? con-&gt;name : NULL;</span>
<a name="8469"><span class="lineNum">    8469 </span>            : }</a>
<span class="lineNum">    8470 </span>            : 
<span class="lineNum">    8471 </span><span class="lineCov">        479 : struct ast_context *ast_get_extension_context(struct ast_exten *exten)</span>
<span class="lineNum">    8472 </span>            : {
<span class="lineNum">    8473 </span><span class="lineCov">        479 :         return exten ? exten-&gt;parent : NULL;</span>
<a name="8474"><span class="lineNum">    8474 </span>            : }</a>
<span class="lineNum">    8475 </span>            : 
<span class="lineNum">    8476 </span><span class="lineCov">        837 : const char *ast_get_extension_name(struct ast_exten *exten)</span>
<span class="lineNum">    8477 </span>            : {
<span class="lineNum">    8478 </span><span class="lineCov">        837 :         return exten ? exten-&gt;name : NULL;</span>
<a name="8479"><span class="lineNum">    8479 </span>            : }</a>
<span class="lineNum">    8480 </span>            : 
<span class="lineNum">    8481 </span><span class="lineCov">          5 : const char *ast_get_extension_label(struct ast_exten *exten)</span>
<span class="lineNum">    8482 </span>            : {
<span class="lineNum">    8483 </span><span class="lineCov">          5 :         return exten ? exten-&gt;label : NULL;</span>
<a name="8484"><span class="lineNum">    8484 </span>            : }</a>
<span class="lineNum">    8485 </span>            : 
<span class="lineNum">    8486 </span><span class="lineCov">         61 : int ast_get_extension_priority(struct ast_exten *exten)</span>
<span class="lineNum">    8487 </span>            : {
<span class="lineNum">    8488 </span><span class="lineCov">         61 :         return exten ? exten-&gt;priority : -1;</span>
<span class="lineNum">    8489 </span>            : }
<span class="lineNum">    8490 </span>            : 
<span class="lineNum">    8491 </span>            : /*
<a name="8492"><span class="lineNum">    8492 </span>            :  * Registrar info functions ...</a>
<span class="lineNum">    8493 </span>            :  */
<span class="lineNum">    8494 </span><span class="lineCov">          4 : const char *ast_get_context_registrar(struct ast_context *c)</span>
<span class="lineNum">    8495 </span>            : {
<span class="lineNum">    8496 </span><span class="lineCov">          4 :         return c ? c-&gt;registrar : NULL;</span>
<a name="8497"><span class="lineNum">    8497 </span>            : }</a>
<span class="lineNum">    8498 </span>            : 
<span class="lineNum">    8499 </span><span class="lineCov">         36 : const char *ast_get_extension_registrar(struct ast_exten *e)</span>
<span class="lineNum">    8500 </span>            : {
<span class="lineNum">    8501 </span><span class="lineCov">         36 :         return e ? e-&gt;registrar : NULL;</span>
<a name="8502"><span class="lineNum">    8502 </span>            : }</a>
<span class="lineNum">    8503 </span>            : 
<span class="lineNum">    8504 </span><span class="lineCov">          8 : const char *ast_get_extension_registrar_file(struct ast_exten *e)</span>
<span class="lineNum">    8505 </span>            : {
<span class="lineNum">    8506 </span><span class="lineCov">          8 :         return e ? e-&gt;registrar_file : NULL;</span>
<a name="8507"><span class="lineNum">    8507 </span>            : }</a>
<span class="lineNum">    8508 </span>            : 
<span class="lineNum">    8509 </span><span class="lineCov">          4 : int ast_get_extension_registrar_line(struct ast_exten *e)</span>
<span class="lineNum">    8510 </span>            : {
<span class="lineNum">    8511 </span><span class="lineCov">          4 :         return e ? e-&gt;registrar_line : 0;</span>
<a name="8512"><span class="lineNum">    8512 </span>            : }</a>
<span class="lineNum">    8513 </span>            : 
<span class="lineNum">    8514 </span><span class="lineCov">          9 : int ast_get_extension_matchcid(struct ast_exten *e)</span>
<span class="lineNum">    8515 </span>            : {
<span class="lineNum">    8516 </span><span class="lineCov">          9 :         return e ? e-&gt;matchcid : 0;</span>
<a name="8517"><span class="lineNum">    8517 </span>            : }</a>
<span class="lineNum">    8518 </span>            : 
<span class="lineNum">    8519 </span><span class="lineNoCov">          0 : const char *ast_get_extension_cidmatch(struct ast_exten *e)</span>
<span class="lineNum">    8520 </span>            : {
<span class="lineNum">    8521 </span><span class="lineNoCov">          0 :         return e ? e-&gt;cidmatch_display : NULL;</span>
<a name="8522"><span class="lineNum">    8522 </span>            : }</a>
<span class="lineNum">    8523 </span>            : 
<span class="lineNum">    8524 </span><span class="lineCov">       1285 : const char *ast_get_extension_app(struct ast_exten *e)</span>
<span class="lineNum">    8525 </span>            : {
<span class="lineNum">    8526 </span><span class="lineCov">       1285 :         return e ? e-&gt;app : NULL;</span>
<a name="8527"><span class="lineNum">    8527 </span>            : }</a>
<span class="lineNum">    8528 </span>            : 
<span class="lineNum">    8529 </span><span class="lineCov">         23 : void *ast_get_extension_app_data(struct ast_exten *e)</span>
<span class="lineNum">    8530 </span>            : {
<span class="lineNum">    8531 </span><span class="lineCov">         23 :         return e ? e-&gt;data : NULL;</span>
<span class="lineNum">    8532 </span>            : }
<span class="lineNum">    8533 </span>            : 
<span class="lineNum">    8534 </span>            : /*
<a name="8535"><span class="lineNum">    8535 </span>            :  * Walking functions ...</a>
<span class="lineNum">    8536 </span>            :  */
<span class="lineNum">    8537 </span><span class="lineCov">     362922 : struct ast_context *ast_walk_contexts(struct ast_context *con)</span>
<span class="lineNum">    8538 </span>            : {
<span class="lineNum">    8539 </span><span class="lineCov">     362922 :         return con ? con-&gt;next : contexts;</span>
<a name="8540"><span class="lineNum">    8540 </span>            : }</a>
<span class="lineNum">    8541 </span>            : 
<span class="lineNum">    8542 </span><span class="lineCov">    2344877 : struct ast_exten *ast_walk_context_extensions(struct ast_context *con,</span>
<span class="lineNum">    8543 </span>            :         struct ast_exten *exten)
<span class="lineNum">    8544 </span>            : {
<span class="lineNum">    8545 </span><span class="lineCov">    2344877 :         if (!exten)</span>
<span class="lineNum">    8546 </span><span class="lineCov">     275885 :                 return con ? con-&gt;root : NULL;</span>
<span class="lineNum">    8547 </span>            :         else
<span class="lineNum">    8548 </span><span class="lineCov">    2068992 :                 return exten-&gt;next;</span>
<a name="8549"><span class="lineNum">    8549 </span>            : }</a>
<span class="lineNum">    8550 </span>            : 
<span class="lineNum">    8551 </span><span class="lineNoCov">          0 : const struct ast_sw *ast_walk_context_switches(const struct ast_context *con,</span>
<span class="lineNum">    8552 </span>            :         const struct ast_sw *sw)
<span class="lineNum">    8553 </span>            : {
<span class="lineNum">    8554 </span><span class="lineNoCov">          0 :         if (sw) {</span>
<span class="lineNum">    8555 </span>            :                 int idx;
<span class="lineNum">    8556 </span><span class="lineNoCov">          0 :                 int next = 0;</span>
<span class="lineNum">    8557 </span>            : 
<span class="lineNum">    8558 </span><span class="lineNoCov">          0 :                 for (idx = 0; idx &lt; ast_context_switches_count(con); idx++) {</span>
<span class="lineNum">    8559 </span><span class="lineNoCov">          0 :                         const struct ast_sw *s = ast_context_switches_get(con, idx);</span>
<span class="lineNum">    8560 </span>            : 
<span class="lineNum">    8561 </span><span class="lineNoCov">          0 :                         if (next) {</span>
<span class="lineNum">    8562 </span><span class="lineNoCov">          0 :                                 return s;</span>
<span class="lineNum">    8563 </span>            :                         }
<span class="lineNum">    8564 </span>            : 
<span class="lineNum">    8565 </span><span class="lineNoCov">          0 :                         if (sw == s) {</span>
<span class="lineNum">    8566 </span><span class="lineNoCov">          0 :                                 next = 1;</span>
<span class="lineNum">    8567 </span>            :                         }
<span class="lineNum">    8568 </span>            :                 }
<span class="lineNum">    8569 </span>            : 
<span class="lineNum">    8570 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    8571 </span>            :         }
<span class="lineNum">    8572 </span>            : 
<span class="lineNum">    8573 </span><span class="lineNoCov">          0 :         if (!ast_context_switches_count(con)) {</span>
<span class="lineNum">    8574 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    8575 </span>            :         }
<span class="lineNum">    8576 </span>            : 
<span class="lineNum">    8577 </span><span class="lineNoCov">          0 :         return ast_context_switches_get(con, 0);</span>
<a name="8578"><span class="lineNum">    8578 </span>            : }</a>
<span class="lineNum">    8579 </span>            : 
<span class="lineNum">    8580 </span><span class="lineCov">      41400 : int ast_context_switches_count(const struct ast_context *con)</span>
<span class="lineNum">    8581 </span>            : {
<span class="lineNum">    8582 </span><span class="lineCov">      41400 :         return AST_VECTOR_SIZE(&amp;con-&gt;alts);</span>
<a name="8583"><span class="lineNum">    8583 </span>            : }</a>
<span class="lineNum">    8584 </span>            : 
<span class="lineNum">    8585 </span><span class="lineCov">         13 : const struct ast_sw *ast_context_switches_get(const struct ast_context *con, int idx)</span>
<span class="lineNum">    8586 </span>            : {
<span class="lineNum">    8587 </span><span class="lineCov">         13 :         return AST_VECTOR_GET(&amp;con-&gt;alts, idx);</span>
<a name="8588"><span class="lineNum">    8588 </span>            : }</a>
<span class="lineNum">    8589 </span>            : 
<span class="lineNum">    8590 </span><span class="lineCov">    3959490 : struct ast_exten *ast_walk_extension_priorities(struct ast_exten *exten,</span>
<span class="lineNum">    8591 </span>            :         struct ast_exten *priority)
<span class="lineNum">    8592 </span>            : {
<span class="lineNum">    8593 </span><span class="lineCov">    3959490 :         return priority ? priority-&gt;peer : exten;</span>
<a name="8594"><span class="lineNum">    8594 </span>            : }</a>
<span class="lineNum">    8595 </span>            : 
<span class="lineNum">    8596 </span><span class="lineNoCov">          0 : const struct ast_include *ast_walk_context_includes(const struct ast_context *con,</span>
<span class="lineNum">    8597 </span>            :         const struct ast_include *inc)
<span class="lineNum">    8598 </span>            : {
<span class="lineNum">    8599 </span><span class="lineNoCov">          0 :         if (inc) {</span>
<span class="lineNum">    8600 </span>            :                 int idx;
<span class="lineNum">    8601 </span><span class="lineNoCov">          0 :                 int next = 0;</span>
<span class="lineNum">    8602 </span>            : 
<span class="lineNum">    8603 </span><span class="lineNoCov">          0 :                 for (idx = 0; idx &lt; ast_context_includes_count(con); idx++) {</span>
<span class="lineNum">    8604 </span><span class="lineNoCov">          0 :                         const struct ast_include *include = AST_VECTOR_GET(&amp;con-&gt;includes, idx);</span>
<span class="lineNum">    8605 </span>            : 
<span class="lineNum">    8606 </span><span class="lineNoCov">          0 :                         if (next) {</span>
<span class="lineNum">    8607 </span><span class="lineNoCov">          0 :                                 return include;</span>
<span class="lineNum">    8608 </span>            :                         }
<span class="lineNum">    8609 </span>            : 
<span class="lineNum">    8610 </span><span class="lineNoCov">          0 :                         if (inc == include) {</span>
<span class="lineNum">    8611 </span><span class="lineNoCov">          0 :                                 next = 1;</span>
<span class="lineNum">    8612 </span>            :                         }
<span class="lineNum">    8613 </span>            :                 }
<span class="lineNum">    8614 </span>            : 
<span class="lineNum">    8615 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    8616 </span>            :         }
<span class="lineNum">    8617 </span>            : 
<span class="lineNum">    8618 </span><span class="lineNoCov">          0 :         if (!ast_context_includes_count(con)) {</span>
<span class="lineNum">    8619 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    8620 </span>            :         }
<span class="lineNum">    8621 </span>            : 
<span class="lineNum">    8622 </span><span class="lineNoCov">          0 :         return ast_context_includes_get(con, 0);</span>
<a name="8623"><span class="lineNum">    8623 </span>            : }</a>
<span class="lineNum">    8624 </span>            : 
<span class="lineNum">    8625 </span><span class="lineCov">      45099 : int ast_context_includes_count(const struct ast_context *con)</span>
<span class="lineNum">    8626 </span>            : {
<span class="lineNum">    8627 </span><span class="lineCov">      45099 :         return AST_VECTOR_SIZE(&amp;con-&gt;includes);</span>
<a name="8628"><span class="lineNum">    8628 </span>            : }</a>
<span class="lineNum">    8629 </span>            : 
<span class="lineNum">    8630 </span><span class="lineCov">        103 : const struct ast_include *ast_context_includes_get(const struct ast_context *con, int idx)</span>
<span class="lineNum">    8631 </span>            : {
<span class="lineNum">    8632 </span><span class="lineCov">        103 :         return AST_VECTOR_GET(&amp;con-&gt;includes, idx);</span>
<a name="8633"><span class="lineNum">    8633 </span>            : }</a>
<span class="lineNum">    8634 </span>            : 
<span class="lineNum">    8635 </span><span class="lineNoCov">          0 : const struct ast_ignorepat *ast_walk_context_ignorepats(const struct ast_context *con,</span>
<span class="lineNum">    8636 </span>            :         const struct ast_ignorepat *ip)
<span class="lineNum">    8637 </span>            : {
<span class="lineNum">    8638 </span><span class="lineNoCov">          0 :         if (!con) {</span>
<span class="lineNum">    8639 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    8640 </span>            :         }
<span class="lineNum">    8641 </span>            : 
<span class="lineNum">    8642 </span><span class="lineNoCov">          0 :         if (ip) {</span>
<span class="lineNum">    8643 </span>            :                 int idx;
<span class="lineNum">    8644 </span><span class="lineNoCov">          0 :                 int next = 0;</span>
<span class="lineNum">    8645 </span>            : 
<span class="lineNum">    8646 </span><span class="lineNoCov">          0 :                 for (idx = 0; idx &lt; ast_context_ignorepats_count(con); idx++) {</span>
<span class="lineNum">    8647 </span><span class="lineNoCov">          0 :                         const struct ast_ignorepat *i = ast_context_ignorepats_get(con, idx);</span>
<span class="lineNum">    8648 </span>            : 
<span class="lineNum">    8649 </span><span class="lineNoCov">          0 :                         if (next) {</span>
<span class="lineNum">    8650 </span><span class="lineNoCov">          0 :                                 return i;</span>
<span class="lineNum">    8651 </span>            :                         }
<span class="lineNum">    8652 </span>            : 
<span class="lineNum">    8653 </span><span class="lineNoCov">          0 :                         if (ip == i) {</span>
<span class="lineNum">    8654 </span><span class="lineNoCov">          0 :                                 next = 1;</span>
<span class="lineNum">    8655 </span>            :                         }
<span class="lineNum">    8656 </span>            :                 }
<span class="lineNum">    8657 </span>            : 
<span class="lineNum">    8658 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    8659 </span>            :         }
<span class="lineNum">    8660 </span>            : 
<span class="lineNum">    8661 </span><span class="lineNoCov">          0 :         if (!ast_context_ignorepats_count(con)) {</span>
<span class="lineNum">    8662 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    8663 </span>            :         }
<span class="lineNum">    8664 </span>            : 
<span class="lineNum">    8665 </span><span class="lineNoCov">          0 :         return ast_context_ignorepats_get(con, 0);</span>
<a name="8666"><span class="lineNum">    8666 </span>            : }</a>
<span class="lineNum">    8667 </span>            : 
<span class="lineNum">    8668 </span><span class="lineCov">      13164 : int ast_context_ignorepats_count(const struct ast_context *con)</span>
<span class="lineNum">    8669 </span>            : {
<span class="lineNum">    8670 </span><span class="lineCov">      13164 :         return AST_VECTOR_SIZE(&amp;con-&gt;ignorepats);</span>
<a name="8671"><span class="lineNum">    8671 </span>            : }</a>
<span class="lineNum">    8672 </span>            : 
<span class="lineNum">    8673 </span><span class="lineNoCov">          0 : const struct ast_ignorepat *ast_context_ignorepats_get(const struct ast_context *con, int idx)</span>
<span class="lineNum">    8674 </span>            : {
<span class="lineNum">    8675 </span><span class="lineNoCov">          0 :         return AST_VECTOR_GET(&amp;con-&gt;ignorepats, idx);</span>
<a name="8676"><span class="lineNum">    8676 </span>            : }</a>
<span class="lineNum">    8677 </span>            : 
<span class="lineNum">    8678 </span><span class="lineCov">       3630 : int ast_context_verify_includes(struct ast_context *con)</span>
<span class="lineNum">    8679 </span>            : {
<span class="lineNum">    8680 </span>            :         int idx;
<span class="lineNum">    8681 </span><span class="lineCov">       3630 :         int res = 0;</span>
<span class="lineNum">    8682 </span>            : 
<span class="lineNum">    8683 </span><span class="lineCov">       3633 :         for (idx = 0; idx &lt; ast_context_includes_count(con); idx++) {</span>
<span class="lineNum">    8684 </span><span class="lineCov">          3 :                 const struct ast_include *inc = ast_context_includes_get(con, idx);</span>
<span class="lineNum">    8685 </span>            : 
<span class="lineNum">    8686 </span><span class="lineCov">          3 :                 if (ast_context_find(include_rname(inc))) {</span>
<span class="lineNum">    8687 </span><span class="lineCov">          3 :                         continue;</span>
<span class="lineNum">    8688 </span>            :                 }
<span class="lineNum">    8689 </span>            : 
<span class="lineNum">    8690 </span><span class="lineNoCov">          0 :                 res = -1;</span>
<span class="lineNum">    8691 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Context '%s' tries to include nonexistent context '%s'\n&quot;,</span>
<span class="lineNum">    8692 </span>            :                         ast_get_context_name(con), include_rname(inc));
<span class="lineNum">    8693 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    8694 </span>            :         }
<span class="lineNum">    8695 </span>            : 
<span class="lineNum">    8696 </span><span class="lineCov">       3630 :         return res;</span>
<span class="lineNum">    8697 </span>            : }
<a name="8698"><span class="lineNum">    8698 </span>            : </a>
<span class="lineNum">    8699 </span>            : 
<span class="lineNum">    8700 </span><span class="lineCov">        132 : static int __ast_goto_if_exists(struct ast_channel *chan, const char *context, const char *exten, int priority, int async)</span>
<span class="lineNum">    8701 </span>            : {
<span class="lineNum">    8702 </span>            :         int (*goto_func)(struct ast_channel *chan, const char *context, const char *exten, int priority);
<span class="lineNum">    8703 </span>            : 
<span class="lineNum">    8704 </span><span class="lineCov">        132 :         if (!chan)</span>
<span class="lineNum">    8705 </span><span class="lineNoCov">          0 :                 return -2;</span>
<span class="lineNum">    8706 </span>            : 
<span class="lineNum">    8707 </span><span class="lineCov">        132 :         if (context == NULL)</span>
<span class="lineNum">    8708 </span><span class="lineNoCov">          0 :                 context = ast_channel_context(chan);</span>
<span class="lineNum">    8709 </span><span class="lineCov">        132 :         if (exten == NULL)</span>
<span class="lineNum">    8710 </span><span class="lineNoCov">          0 :                 exten = ast_channel_exten(chan);</span>
<span class="lineNum">    8711 </span>            : 
<span class="lineNum">    8712 </span><span class="lineCov">        132 :         goto_func = (async) ? ast_async_goto : ast_explicit_goto;</span>
<span class="lineNum">    8713 </span><span class="lineCov">        132 :         if (ast_exists_extension(chan, context, exten, priority,</span>
<span class="lineNum">    8714 </span><span class="lineCov">        132 :                 S_COR(ast_channel_caller(chan)-&gt;id.number.valid, ast_channel_caller(chan)-&gt;id.number.str, NULL)))</span>
<span class="lineNum">    8715 </span><span class="lineCov">         55 :                 return goto_func(chan, context, exten, priority);</span>
<span class="lineNum">    8716 </span>            :         else {
<span class="lineNum">    8717 </span><span class="lineCov">         77 :                 return AST_PBX_GOTO_FAILED;</span>
<span class="lineNum">    8718 </span>            :         }
<a name="8719"><span class="lineNum">    8719 </span>            : }</a>
<span class="lineNum">    8720 </span>            : 
<span class="lineNum">    8721 </span><span class="lineCov">        132 : int ast_goto_if_exists(struct ast_channel *chan, const char* context, const char *exten, int priority)</span>
<span class="lineNum">    8722 </span>            : {
<span class="lineNum">    8723 </span><span class="lineCov">        132 :         return __ast_goto_if_exists(chan, context, exten, priority, 0);</span>
<a name="8724"><span class="lineNum">    8724 </span>            : }</a>
<span class="lineNum">    8725 </span>            : 
<span class="lineNum">    8726 </span><span class="lineNoCov">          0 : int ast_async_goto_if_exists(struct ast_channel *chan, const char * context, const char *exten, int priority)</span>
<span class="lineNum">    8727 </span>            : {
<span class="lineNum">    8728 </span><span class="lineNoCov">          0 :         return __ast_goto_if_exists(chan, context, exten, priority, 1);</span>
<a name="8729"><span class="lineNum">    8729 </span>            : }</a>
<span class="lineNum">    8730 </span>            : 
<span class="lineNum">    8731 </span><span class="lineCov">       1616 : static int pbx_parseable_goto(struct ast_channel *chan, const char *goto_string, int async)</span>
<span class="lineNum">    8732 </span>            : {
<span class="lineNum">    8733 </span>            :         char *exten, *pri, *context;
<span class="lineNum">    8734 </span>            :         char *stringp;
<span class="lineNum">    8735 </span>            :         int ipri;
<span class="lineNum">    8736 </span><span class="lineCov">       1616 :         int mode = 0;</span>
<span class="lineNum">    8737 </span>            : 
<span class="lineNum">    8738 </span><span class="lineCov">       1616 :         if (ast_strlen_zero(goto_string)) {</span>
<span class="lineNum">    8739 </span><span class="lineNoCov">          0 :                 ast_log(LOG_WARNING, &quot;Goto requires an argument ([[context,]extension,]priority)\n&quot;);</span>
<span class="lineNum">    8740 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    8741 </span>            :         }
<span class="lineNum">    8742 </span><span class="lineCov">       1616 :         stringp = ast_strdupa(goto_string);</span>
<span class="lineNum">    8743 </span><span class="lineCov">       1616 :         context = strsep(&amp;stringp, &quot;,&quot;);  /* guaranteed non-null */</span>
<span class="lineNum">    8744 </span><span class="lineCov">       1616 :         exten = strsep(&amp;stringp, &quot;,&quot;);</span>
<span class="lineNum">    8745 </span><span class="lineCov">       1616 :         pri = strsep(&amp;stringp, &quot;,&quot;);</span>
<span class="lineNum">    8746 </span><span class="lineCov">       1616 :         if (!exten) {   /* Only a priority in this one */</span>
<span class="lineNum">    8747 </span><span class="lineCov">        666 :                 pri = context;</span>
<span class="lineNum">    8748 </span><span class="lineCov">        666 :                 exten = NULL;</span>
<span class="lineNum">    8749 </span><span class="lineCov">        666 :                 context = NULL;</span>
<span class="lineNum">    8750 </span><span class="lineCov">        950 :         } else if (!pri) {      /* Only an extension and priority in this one */</span>
<span class="lineNum">    8751 </span><span class="lineCov">         77 :                 pri = exten;</span>
<span class="lineNum">    8752 </span><span class="lineCov">         77 :                 exten = context;</span>
<span class="lineNum">    8753 </span><span class="lineCov">         77 :                 context = NULL;</span>
<span class="lineNum">    8754 </span>            :         }
<span class="lineNum">    8755 </span><span class="lineCov">       1616 :         if (*pri == '+') {</span>
<span class="lineNum">    8756 </span><span class="lineNoCov">          0 :                 mode = 1;</span>
<span class="lineNum">    8757 </span><span class="lineNoCov">          0 :                 pri++;</span>
<span class="lineNum">    8758 </span><span class="lineCov">       1616 :         } else if (*pri == '-') {</span>
<span class="lineNum">    8759 </span><span class="lineNoCov">          0 :                 mode = -1;</span>
<span class="lineNum">    8760 </span><span class="lineNoCov">          0 :                 pri++;</span>
<span class="lineNum">    8761 </span>            :         }
<span class="lineNum">    8762 </span><span class="lineCov">       1616 :         if (sscanf(pri, &quot;%30d&quot;, &amp;ipri) != 1) {</span>
<span class="lineNum">    8763 </span><span class="lineCov">        758 :                 ipri = ast_findlabel_extension(chan, context ? context : ast_channel_context(chan),</span>
<span class="lineNum">    8764 </span><span class="lineCov">        563 :                         exten ? exten : ast_channel_exten(chan), pri,</span>
<span class="lineNum">    8765 </span><span class="lineCov">        758 :                         S_COR(ast_channel_caller(chan)-&gt;id.number.valid, ast_channel_caller(chan)-&gt;id.number.str, NULL));</span>
<span class="lineNum">    8766 </span><span class="lineCov">        758 :                 if (ipri &lt; 1) {</span>
<span class="lineNum">    8767 </span><span class="lineNoCov">          0 :                         ast_log(LOG_WARNING, &quot;Priority '%s' must be a number &gt; 0, or valid label\n&quot;, pri);</span>
<span class="lineNum">    8768 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    8769 </span>            :                 } else
<span class="lineNum">    8770 </span><span class="lineCov">        758 :                         mode = 0;</span>
<span class="lineNum">    8771 </span>            :         }
<span class="lineNum">    8772 </span>            :         /* At this point we have a priority and maybe an extension and a context */
<span class="lineNum">    8773 </span>            : 
<span class="lineNum">    8774 </span><span class="lineCov">       1616 :         if (mode)</span>
<span class="lineNum">    8775 </span><span class="lineNoCov">          0 :                 ipri = ast_channel_priority(chan) + (ipri * mode);</span>
<span class="lineNum">    8776 </span>            : 
<span class="lineNum">    8777 </span><span class="lineCov">       1616 :         if (async)</span>
<span class="lineNum">    8778 </span><span class="lineCov">          1 :                 ast_async_goto(chan, context, exten, ipri);</span>
<span class="lineNum">    8779 </span>            :         else
<span class="lineNum">    8780 </span><span class="lineCov">       1615 :                 ast_explicit_goto(chan, context, exten, ipri);</span>
<span class="lineNum">    8781 </span>            : 
<span class="lineNum">    8782 </span><span class="lineCov">       1616 :         return 0;</span>
<span class="lineNum">    8783 </span>            : 
<a name="8784"><span class="lineNum">    8784 </span>            : }</a>
<span class="lineNum">    8785 </span>            : 
<span class="lineNum">    8786 </span><span class="lineCov">       1615 : int ast_parseable_goto(struct ast_channel *chan, const char *goto_string)</span>
<span class="lineNum">    8787 </span>            : {
<span class="lineNum">    8788 </span><span class="lineCov">       1615 :         return pbx_parseable_goto(chan, goto_string, 0);</span>
<a name="8789"><span class="lineNum">    8789 </span>            : }</a>
<span class="lineNum">    8790 </span>            : 
<span class="lineNum">    8791 </span><span class="lineCov">          1 : int ast_async_parseable_goto(struct ast_channel *chan, const char *goto_string)</span>
<span class="lineNum">    8792 </span>            : {
<span class="lineNum">    8793 </span><span class="lineCov">          1 :         return pbx_parseable_goto(chan, goto_string, 1);</span>
<a name="8794"><span class="lineNum">    8794 </span>            : }</a>
<span class="lineNum">    8795 </span>            : 
<span class="lineNum">    8796 </span><span class="lineCov">        163 : static int hint_hash(const void *obj, const int flags)</span>
<span class="lineNum">    8797 </span>            : {
<span class="lineNum">    8798 </span><span class="lineCov">        163 :         const struct ast_hint *hint = obj;</span>
<span class="lineNum">    8799 </span>            :         const char *exten_name;
<span class="lineNum">    8800 </span>            :         int res;
<span class="lineNum">    8801 </span>            : 
<span class="lineNum">    8802 </span><span class="lineCov">        163 :         exten_name = ast_get_extension_name(hint-&gt;exten);</span>
<span class="lineNum">    8803 </span><span class="lineCov">        163 :         if (ast_strlen_zero(exten_name)) {</span>
<span class="lineNum">    8804 </span>            :                 /*
<span class="lineNum">    8805 </span>            :                  * If the exten or extension name isn't set, return 0 so that
<span class="lineNum">    8806 </span>            :                  * the ao2_find() search will start in the first bucket.
<span class="lineNum">    8807 </span>            :                  */
<span class="lineNum">    8808 </span><span class="lineNoCov">          0 :                 res = 0;</span>
<span class="lineNum">    8809 </span>            :         } else {
<span class="lineNum">    8810 </span><span class="lineCov">        163 :                 res = ast_str_case_hash(exten_name);</span>
<span class="lineNum">    8811 </span>            :         }
<span class="lineNum">    8812 </span>            : 
<span class="lineNum">    8813 </span><span class="lineCov">        163 :         return res;</span>
<a name="8814"><span class="lineNum">    8814 </span>            : }</a>
<span class="lineNum">    8815 </span>            : 
<span class="lineNum">    8816 </span><span class="lineCov">        986 : static int hint_cmp(void *obj, void *arg, int flags)</span>
<span class="lineNum">    8817 </span>            : {
<span class="lineNum">    8818 </span><span class="lineCov">        986 :         const struct ast_hint *hint = obj;</span>
<span class="lineNum">    8819 </span><span class="lineCov">        986 :         const struct ast_exten *exten = arg;</span>
<span class="lineNum">    8820 </span>            : 
<span class="lineNum">    8821 </span><span class="lineCov">        986 :         return (hint-&gt;exten == exten) ? CMP_MATCH | CMP_STOP : 0;</span>
<a name="8822"><span class="lineNum">    8822 </span>            : }</a>
<span class="lineNum">    8823 </span>            : 
<span class="lineNum">    8824 </span><span class="lineCov">        863 : static int statecbs_cmp(void *obj, void *arg, int flags)</span>
<span class="lineNum">    8825 </span>            : {
<span class="lineNum">    8826 </span><span class="lineCov">        863 :         const struct ast_state_cb *state_cb = obj;</span>
<span class="lineNum">    8827 </span><span class="lineCov">        863 :         ast_state_cb_type change_cb = arg;</span>
<span class="lineNum">    8828 </span>            : 
<span class="lineNum">    8829 </span><span class="lineCov">        863 :         return (state_cb-&gt;change_cb == change_cb) ? CMP_MATCH | CMP_STOP : 0;</span>
<span class="lineNum">    8830 </span>            : }
<span class="lineNum">    8831 </span>            : 
<span class="lineNum">    8832 </span>            : /*!
<span class="lineNum">    8833 </span>            :  * \internal
<a name="8834"><span class="lineNum">    8834 </span>            :  * \brief Clean up resources on Asterisk shutdown</a>
<span class="lineNum">    8835 </span>            :  */
<span class="lineNum">    8836 </span><span class="lineCov">       1015 : static void pbx_shutdown(void)</span>
<span class="lineNum">    8837 </span>            : {
<span class="lineNum">    8838 </span><span class="lineCov">       1015 :         STASIS_MESSAGE_TYPE_CLEANUP(hint_change_message_type);</span>
<span class="lineNum">    8839 </span>            : 
<span class="lineNum">    8840 </span><span class="lineCov">       1015 :         if (hints) {</span>
<span class="lineNum">    8841 </span><span class="lineCov">       1015 :                 ao2_container_unregister(&quot;hints&quot;);</span>
<span class="lineNum">    8842 </span><span class="lineCov">       1015 :                 ao2_ref(hints, -1);</span>
<span class="lineNum">    8843 </span><span class="lineCov">       1015 :                 hints = NULL;</span>
<span class="lineNum">    8844 </span>            :         }
<span class="lineNum">    8845 </span><span class="lineCov">       1015 :         if (hintdevices) {</span>
<span class="lineNum">    8846 </span><span class="lineCov">       1015 :                 ao2_container_unregister(&quot;hintdevices&quot;);</span>
<span class="lineNum">    8847 </span><span class="lineCov">       1015 :                 ao2_ref(hintdevices, -1);</span>
<span class="lineNum">    8848 </span><span class="lineCov">       1015 :                 hintdevices = NULL;</span>
<span class="lineNum">    8849 </span>            :         }
<span class="lineNum">    8850 </span><span class="lineCov">       1015 :         if (autohints) {</span>
<span class="lineNum">    8851 </span><span class="lineCov">       1015 :                 ao2_container_unregister(&quot;autohints&quot;);</span>
<span class="lineNum">    8852 </span><span class="lineCov">       1015 :                 ao2_ref(autohints, -1);</span>
<span class="lineNum">    8853 </span><span class="lineCov">       1015 :                 autohints = NULL;</span>
<span class="lineNum">    8854 </span>            :         }
<span class="lineNum">    8855 </span><span class="lineCov">       1015 :         if (statecbs) {</span>
<span class="lineNum">    8856 </span><span class="lineCov">       1015 :                 ao2_container_unregister(&quot;statecbs&quot;);</span>
<span class="lineNum">    8857 </span><span class="lineCov">       1015 :                 ao2_ref(statecbs, -1);</span>
<span class="lineNum">    8858 </span><span class="lineCov">       1015 :                 statecbs = NULL;</span>
<span class="lineNum">    8859 </span>            :         }
<span class="lineNum">    8860 </span><span class="lineCov">       1015 :         if (contexts_table) {</span>
<span class="lineNum">    8861 </span><span class="lineCov">       1015 :                 ast_hashtab_destroy(contexts_table, NULL);</span>
<span class="lineNum">    8862 </span>            :         }
<a name="8863"><span class="lineNum">    8863 </span><span class="lineCov">       1015 : }</span></a>
<span class="lineNum">    8864 </span>            : 
<span class="lineNum">    8865 </span><span class="lineNoCov">          0 : static void print_hints_key(void *v_obj, void *where, ao2_prnt_fn *prnt)</span>
<span class="lineNum">    8866 </span>            : {
<span class="lineNum">    8867 </span><span class="lineNoCov">          0 :         struct ast_hint *hint = v_obj;</span>
<span class="lineNum">    8868 </span>            : 
<span class="lineNum">    8869 </span><span class="lineNoCov">          0 :         if (!hint) {</span>
<span class="lineNum">    8870 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    8871 </span>            :         }
<span class="lineNum">    8872 </span><span class="lineNoCov">          0 :         prnt(where, &quot;%s@%s&quot;, ast_get_extension_name(hint-&gt;exten),</span>
<span class="lineNum">    8873 </span>            :                 ast_get_context_name(ast_get_extension_context(hint-&gt;exten)));
<a name="8874"><span class="lineNum">    8874 </span>            : }</a>
<span class="lineNum">    8875 </span>            : 
<span class="lineNum">    8876 </span><span class="lineNoCov">          0 : static void print_hintdevices_key(void *v_obj, void *where, ao2_prnt_fn *prnt)</span>
<span class="lineNum">    8877 </span>            : {
<span class="lineNum">    8878 </span><span class="lineNoCov">          0 :         struct ast_hintdevice *hintdevice = v_obj;</span>
<span class="lineNum">    8879 </span>            : 
<span class="lineNum">    8880 </span><span class="lineNoCov">          0 :         if (!hintdevice) {</span>
<span class="lineNum">    8881 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    8882 </span>            :         }
<span class="lineNum">    8883 </span><span class="lineNoCov">          0 :         prnt(where, &quot;%s =&gt; %s@%s&quot;, hintdevice-&gt;hintdevice,</span>
<span class="lineNum">    8884 </span><span class="lineNoCov">          0 :                 ast_get_extension_name(hintdevice-&gt;hint-&gt;exten),</span>
<span class="lineNum">    8885 </span><span class="lineNoCov">          0 :                 ast_get_context_name(ast_get_extension_context(hintdevice-&gt;hint-&gt;exten)));</span>
<a name="8886"><span class="lineNum">    8886 </span>            : }</a>
<span class="lineNum">    8887 </span>            : 
<span class="lineNum">    8888 </span><span class="lineNoCov">          0 : static void print_autohint_key(void *v_obj, void *where, ao2_prnt_fn *prnt)</span>
<span class="lineNum">    8889 </span>            : {
<span class="lineNum">    8890 </span><span class="lineNoCov">          0 :         struct ast_autohint *autohint = v_obj;</span>
<span class="lineNum">    8891 </span>            : 
<span class="lineNum">    8892 </span><span class="lineNoCov">          0 :         if (!autohint) {</span>
<span class="lineNum">    8893 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    8894 </span>            :         }
<span class="lineNum">    8895 </span><span class="lineNoCov">          0 :         prnt(where, &quot;%s&quot;, autohint-&gt;context);</span>
<a name="8896"><span class="lineNum">    8896 </span>            : }</a>
<span class="lineNum">    8897 </span>            : 
<span class="lineNum">    8898 </span><span class="lineNoCov">          0 : static void print_statecbs_key(void *v_obj, void *where, ao2_prnt_fn *prnt)</span>
<span class="lineNum">    8899 </span>            : {
<span class="lineNum">    8900 </span><span class="lineNoCov">          0 :         struct ast_state_cb *state_cb = v_obj;</span>
<span class="lineNum">    8901 </span>            : 
<span class="lineNum">    8902 </span><span class="lineNoCov">          0 :         if (!state_cb) {</span>
<span class="lineNum">    8903 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    8904 </span>            :         }
<span class="lineNum">    8905 </span><span class="lineNoCov">          0 :         prnt(where, &quot;%d&quot;, state_cb-&gt;id);</span>
<a name="8906"><span class="lineNum">    8906 </span>            : }</a>
<span class="lineNum">    8907 </span>            : 
<span class="lineNum">    8908 </span><span class="lineCov">       1124 : int ast_pbx_init(void)</span>
<span class="lineNum">    8909 </span>            : {
<span class="lineNum">    8910 </span><span class="lineCov">       1124 :         hints = ao2_container_alloc(HASH_EXTENHINT_SIZE, hint_hash, hint_cmp);</span>
<span class="lineNum">    8911 </span><span class="lineCov">       1124 :         if (hints) {</span>
<span class="lineNum">    8912 </span><span class="lineCov">       1124 :                 ao2_container_register(&quot;hints&quot;, hints, print_hints_key);</span>
<span class="lineNum">    8913 </span>            :         }
<span class="lineNum">    8914 </span><span class="lineCov">       1124 :         hintdevices = ao2_container_alloc(HASH_EXTENHINT_SIZE, hintdevice_hash_cb, hintdevice_cmp_multiple);</span>
<span class="lineNum">    8915 </span><span class="lineCov">       1124 :         if (hintdevices) {</span>
<span class="lineNum">    8916 </span><span class="lineCov">       1124 :                 ao2_container_register(&quot;hintdevices&quot;, hintdevices, print_hintdevices_key);</span>
<span class="lineNum">    8917 </span>            :         }
<span class="lineNum">    8918 </span>            :         /* This is protected by the context_and_merge lock */
<span class="lineNum">    8919 </span><span class="lineCov">       1124 :         autohints = ao2_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, HASH_EXTENHINT_SIZE,</span>
<span class="lineNum">    8920 </span>            :                 autohint_hash_cb, autohint_cmp);
<span class="lineNum">    8921 </span><span class="lineCov">       1124 :         if (autohints) {</span>
<span class="lineNum">    8922 </span><span class="lineCov">       1124 :                 ao2_container_register(&quot;autohints&quot;, autohints, print_autohint_key);</span>
<span class="lineNum">    8923 </span>            :         }
<span class="lineNum">    8924 </span><span class="lineCov">       1124 :         statecbs = ao2_container_alloc(1, NULL, statecbs_cmp);</span>
<span class="lineNum">    8925 </span><span class="lineCov">       1124 :         if (statecbs) {</span>
<span class="lineNum">    8926 </span><span class="lineCov">       1124 :                 ao2_container_register(&quot;statecbs&quot;, statecbs, print_statecbs_key);</span>
<span class="lineNum">    8927 </span>            :         }
<span class="lineNum">    8928 </span>            : 
<span class="lineNum">    8929 </span><span class="lineCov">       1124 :         ast_register_cleanup(pbx_shutdown);</span>
<span class="lineNum">    8930 </span>            : 
<span class="lineNum">    8931 </span><span class="lineCov">       1124 :         if (STASIS_MESSAGE_TYPE_INIT(hint_change_message_type) != 0) {</span>
<span class="lineNum">    8932 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    8933 </span>            :         }
<span class="lineNum">    8934 </span>            : 
<span class="lineNum">    8935 </span><span class="lineCov">       1124 :         return (hints &amp;&amp; hintdevices &amp;&amp; autohints &amp;&amp; statecbs) ? 0 : -1;</span>
<span class="lineNum">    8936 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
